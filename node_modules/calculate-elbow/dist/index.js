//#region lib/calculateElbowBends.ts
/**
* IMPORTANT:
* `calculateElbow` always calls this helper with a normalised coordinate system
* where
*   • `p1.x` ≤ `p2.x` (and when `x` is equal then `p1.y` ≤ `p2.y`)
*   • `p1.facingDirection` ∈ {"x+", "y+"} or is `undefined` (`none`)
*
* This means any branch that depends on `p1` facing `"x-"` or `"y-"` or on
* `p1.x > p2.x` can never be taken at runtime.  The new
* `NormalisedStartPoint` type encodes this guarantee so TypeScript will flag
* any call-site that violates it.
*/
const calculateElbowBends = (p1, p2, overshootAmount) => {
	const result = [{
		x: p1.x,
		y: p1.y
	}];
	const midX = (p1.x + p2.x) / 2;
	const midY = (p1.y + p2.y) / 2;
	const p2Target = {
		x: p2.x,
		y: p2.y
	};
	switch (p2.facingDirection) {
		case "x+":
			p2Target.x += overshootAmount;
			break;
		case "x-":
			p2Target.x -= overshootAmount;
			break;
		case "y+":
			p2Target.y += overshootAmount;
			break;
		case "y-":
			p2Target.y -= overshootAmount;
			break;
	}
	const startDir = p1.facingDirection ?? "none";
	const endDir = p2.facingDirection ?? "none";
	const push = (pt) => {
		const last = result[result.length - 1];
		if (last.x !== pt.x || last.y !== pt.y) result.push(pt);
	};
	const yAligned = Math.abs(p1.y - p2.y) <= Math.max(1e-6, overshootAmount * .1);
	const xAligned = Math.abs(p1.x - p2.x) <= Math.max(1e-6, overshootAmount * .1);
	if (startDir === "none" && endDir === "none") {
		push({
			x: midX,
			y: p1.y
		});
		push({
			x: midX,
			y: p2.y
		});
	} else if (startDir === "x+" && endDir === "y+") if (p1.x > p2.x && p1.y < p2.y) {
		push({
			x: p1.x + overshootAmount,
			y: p1.y
		});
		push({
			x: p1.x + overshootAmount,
			y: p2.y + overshootAmount
		});
		push({
			x: p2.x,
			y: p2.y + overshootAmount
		});
	} else if (!xAligned && !yAligned && p1.x < p2.x && p1.y > p2.y) push({
		x: p2.x,
		y: p1.y
	});
	else if (xAligned) {
		push({
			x: p1.x + overshootAmount,
			y: p1.y
		});
		push({
			x: p1.x + overshootAmount,
			y: p2.y + overshootAmount
		});
		push({
			x: p2.x,
			y: p2.y + overshootAmount
		});
	} else if (p1.x < p2.x) {
		push({
			x: midX,
			y: p1.y
		});
		push({
			x: midX,
			y: p2Target.y
		});
		push({
			x: p2.x,
			y: p2Target.y
		});
	} else if (p1.y <= p2.y + overshootAmount) {
		push({
			x: p1.x + overshootAmount,
			y: p1.y
		});
		push({
			x: p1.x + overshootAmount,
			y: p1.y + overshootAmount
		});
		push({
			x: p2.x,
			y: p1.y + overshootAmount
		});
		push({
			x: p2.x,
			y: p2.y
		});
	} else {
		push({
			x: p1.x + overshootAmount,
			y: p1.y
		});
		push({
			x: p1.x + overshootAmount,
			y: (p1.y + p2.y) / 2
		});
		push({
			x: p2.x,
			y: (p1.y + p2.y) / 2
		});
	}
	else if (startDir === "x+" && endDir === "x+" && !yAligned) {
		const commonX = Math.max(p1.x + overshootAmount, p2Target.x);
		push({
			x: commonX,
			y: p1.y
		});
		push({
			x: commonX,
			y: p2.y
		});
	} else if (startDir === "x+" && endDir === "x+" && yAligned) {
		push({
			x: p1.x + overshootAmount,
			y: p1.y
		});
		push({
			x: p1.x + overshootAmount,
			y: p1.y + overshootAmount
		});
		push({
			x: p2.x + overshootAmount,
			y: p1.y + overshootAmount
		});
		push({
			x: p2.x + overshootAmount,
			y: p2.y
		});
	} else if (startDir === "x+" && endDir === "y-") if (xAligned && p1.y <= p2.y) {
		push({
			x: p1.x + overshootAmount,
			y: p1.y
		});
		push({
			x: p1.x + overshootAmount,
			y: midY
		});
		push({
			x: p2.x,
			y: midY
		});
	} else if (xAligned && p1.y > p2.y) {
		push({
			x: p1.x + overshootAmount,
			y: p1.y
		});
		push({
			x: p1.x + overshootAmount,
			y: p2.y - overshootAmount
		});
		push({
			x: p2.x,
			y: p2.y - overshootAmount
		});
	} else if (p1.x < p2.x && p1.y < p2.y) push({
		x: p2.x,
		y: p1.y
	});
	else if (p1.x > p2.x && p1.y < p2.y) {
		const p1OvershootX = p1.x + overshootAmount;
		push({
			x: p1OvershootX,
			y: p1.y
		});
		push({
			x: p1OvershootX,
			y: midY
		});
		push({
			x: p2.x,
			y: midY
		});
	} else if (p1.x > p2.x && p1.y > p2.y) {
		const p1OvershootX = p1.x + overshootAmount;
		push({
			x: p1OvershootX,
			y: p1.y
		});
		push({
			x: p1OvershootX,
			y: p2Target.y
		});
		push({
			x: p2.x,
			y: p2Target.y
		});
	} else if (p1.y === p2.y) {
		push({
			x: p1.x + overshootAmount,
			y: p1.y
		});
		push({
			x: p1.x + overshootAmount,
			y: p1.y - overshootAmount
		});
		push({
			x: p2.x,
			y: p1.y - overshootAmount
		});
	} else {
		push({
			x: midX,
			y: p1.y
		});
		push({
			x: midX,
			y: p2Target.y
		});
		push({
			x: p2.x,
			y: p2Target.y
		});
	}
	else if (startDir === "x+" && endDir === "x-" && p1.x + overshootAmount >= p2.x - overshootAmount && !yAligned) {
		const p1OvershootX = p1.x + overshootAmount;
		push({
			x: p1OvershootX,
			y: p1.y
		});
		push({
			x: p1OvershootX,
			y: midY
		});
		push({
			x: p2Target.x,
			y: midY
		});
		push({
			x: p2Target.x,
			y: p2Target.y
		});
	} else if (startDir === "x+" && endDir === "x-" && yAligned && p2.x > p1.x) {} else if (startDir === "x+" && endDir === "x-" && yAligned) {
		push({
			x: p1.x + overshootAmount,
			y: p1.y
		});
		push({
			x: p1.x + overshootAmount,
			y: p1.y + overshootAmount
		});
		push({
			x: p2.x - overshootAmount,
			y: p1.y + overshootAmount
		});
		push({
			x: p2.x - overshootAmount,
			y: p1.y
		});
	} else {
		if (startDir === "x+") push({
			x: p1.x + overshootAmount,
			y: p1.y
		});
		push({
			x: midX,
			y: result[result.length - 1].y
		});
		push({
			x: midX,
			y: p2Target.y
		});
		push({
			x: p2Target.x,
			y: p2Target.y
		});
	}
	push({
		x: p2.x,
		y: p2.y
	});
	return result;
};

//#endregion
//#region lib/index.ts
const calculateElbow = (point1, point2, options = {}) => {
	let p1 = point1;
	let p2 = point2;
	let orderFlipped = false;
	if (p1.x > p2.x || p1.x === p2.x && p1.y > p2.y) {
		orderFlipped = true;
		[p1, p2] = [p2, p1];
	}
	const mirrorX = p1.facingDirection === "x-";
	const mirrorY = p1.facingDirection === "y-";
	const mirrorPoint = (pt) => {
		const x = mirrorX ? p1.x - (pt.x - p1.x) : pt.x;
		const y = mirrorY ? p1.y - (pt.y - p1.y) : pt.y;
		let facing = pt.facingDirection;
		if (mirrorX) {
			if (facing === "x+") facing = "x-";
			else if (facing === "x-") facing = "x+";
		}
		if (mirrorY) {
			if (facing === "y+") facing = "y-";
			else if (facing === "y-") facing = "y+";
		}
		return {
			x,
			y,
			facingDirection: facing
		};
	};
	const rotateCW = (pt, centre) => {
		const dx = pt.x - centre.x;
		const dy = pt.y - centre.y;
		const x = centre.x + dy;
		const y = centre.y - dx;
		let facing = pt.facingDirection;
		switch (facing) {
			case "x+":
				facing = "y-";
				break;
			case "y-":
				facing = "x-";
				break;
			case "x-":
				facing = "y+";
				break;
			case "y+":
				facing = "x+";
				break;
		}
		return {
			x,
			y,
			facingDirection: facing
		};
	};
	const rotateCCW = (pt, centre) => {
		const dx = pt.x - centre.x;
		const dy = pt.y - centre.y;
		return {
			x: centre.x - dy,
			y: centre.y + dx
		};
	};
	const mp1 = mirrorX || mirrorY ? mirrorPoint(p1) : p1;
	const mp2 = mirrorX || mirrorY ? mirrorPoint(p2) : p2;
	let rp1 = mp1;
	let rp2 = mp2;
	let rotated = false;
	if (mp1.facingDirection === "y+") {
		rotated = true;
		rp1 = {
			...mp1,
			facingDirection: "x+"
		};
		rp2 = rotateCW(mp2, mp1);
	}
	const overshootAmount = options?.overshoot ?? .1 * Math.max(Math.abs(rp1.x - rp2.x), Math.abs(rp1.y - rp2.y));
	let result = calculateElbowBends(rp1, rp2, overshootAmount);
	if (rotated) result = result.map((pt) => rotateCCW(pt, rp1));
	if (mirrorX || mirrorY) result = result.map(({ x, y }) => ({
		x: mirrorX ? p1.x - (x - p1.x) : x,
		y: mirrorY ? p1.y - (y - p1.y) : y
	}));
	return orderFlipped ? result.reverse() : result;
};

//#endregion
export { calculateElbow };