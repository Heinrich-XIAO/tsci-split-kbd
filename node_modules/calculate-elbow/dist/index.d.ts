//#region lib/calculateElbowBends.d.ts
interface ElbowPoint {
  x: number;
  y: number;
  facingDirection?: "x+" | "x-" | "y+" | "y-";
}
/**
 * The first point is always passed in *normalised* form where it can only face
 * the positive X-axis, positive Y-axis or have no facing at all.  We capture
 * that restriction in a dedicated type so the compiler can keep us honest.
 */

declare global {
  var __DEBUG_CALCULATE_ELBOW_CASE: number;
}
/**
 * IMPORTANT:
 * `calculateElbow` always calls this helper with a normalised coordinate system
 * where
 *   • `p1.x` ≤ `p2.x` (and when `x` is equal then `p1.y` ≤ `p2.y`)
 *   • `p1.facingDirection` ∈ {"x+", "y+"} or is `undefined` (`none`)
 *
 * This means any branch that depends on `p1` facing `"x-"` or `"y-"` or on
 * `p1.x > p2.x` can never be taken at runtime.  The new
 * `NormalisedStartPoint` type encodes this guarantee so TypeScript will flag
 * any call-site that violates it.
 */
//#endregion
//#region lib/index.d.ts
declare const calculateElbow: (point1: ElbowPoint, point2: ElbowPoint, options?: {
  /**
   * Amount to overshoot the line if the facingDirection requires that we go
   * beyond "out" before turning
   */
  overshoot?: number;
}) => Array<{
  x: number;
  y: number;
}>;
//#endregion
export { type ElbowPoint, calculateElbow };