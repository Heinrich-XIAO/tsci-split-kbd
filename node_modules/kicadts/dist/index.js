// lib/sexpr/parseToPrimitiveSExpr.ts
function tokenize(input) {
  const tokens = [];
  let i = 0;
  const isWhitespace = (ch) => /\s/.test(ch);
  const isSymbolInitial = (ch) => /[^\s()"]/u.test(ch);
  const peek = () => i < input.length ? input[i] : void 0;
  const advance = () => {
    if (i >= input.length) {
      throw new SyntaxError("Unexpected end of input");
    }
    return input[i++];
  };
  while (i < input.length) {
    const ch = peek();
    if (ch === void 0) {
      break;
    }
    const current = ch;
    if (isWhitespace(current)) {
      i++;
      continue;
    }
    if (current === ";") {
      while (i < input.length && input[i] !== "\n") i++;
      continue;
    }
    if (current === "(") {
      tokens.push({ type: "lparen" });
      i++;
      continue;
    }
    if (current === ")") {
      tokens.push({ type: "rparen" });
      i++;
      continue;
    }
    if (current === '"') {
      i++;
      let out = "";
      while (i < input.length) {
        const c = advance();
        if (c === '"') break;
        if (c === "\\") {
          if (i >= input.length)
            throw new SyntaxError("Unterminated escape in string");
          const e = advance();
          switch (e) {
            case "n":
              out += "\n";
              break;
            case "r":
              out += "\r";
              break;
            case "t":
              out += "	";
              break;
            case '"':
              out += '"';
              break;
            case "\\":
              out += "\\";
              break;
            default:
              out += e;
              break;
          }
        } else {
          out += c;
        }
      }
      if (input[i - 1] !== '"')
        throw new SyntaxError("Unterminated string literal");
      tokens.push({ type: "string", value: out });
      continue;
    }
    if (isSymbolInitial(current) || current === "-" || current === "+" || current === ".") {
      let start = i;
      while (i < input.length) {
        const nextChar = input[i];
        if (isWhitespace(nextChar) || nextChar === "(" || nextChar === ")" || nextChar === '"') {
          break;
        }
        i++;
      }
      const raw = input.slice(start, i);
      if (raw === "#t") {
        tokens.push({ type: "boolean", value: true });
        continue;
      }
      if (raw === "#f") {
        tokens.push({ type: "boolean", value: false });
        continue;
      }
      if (raw === "nil") {
        tokens.push({ type: "nil" });
        continue;
      }
      if (/^[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?$/u.test(raw)) {
        tokens.push({ type: "number", value: Number(raw) });
      } else {
        tokens.push({ type: "symbol", value: raw });
      }
      continue;
    }
    throw new SyntaxError(`Unexpected character: ${JSON.stringify(ch)} at ${i}`);
  }
  return tokens;
}
function parseToPrimitiveSExpr(input) {
  const toks = tokenize(input);
  let idx = 0;
  const peekToken = () => idx < toks.length ? toks[idx] : void 0;
  const advanceToken = () => {
    if (idx >= toks.length) {
      throw new SyntaxError("Unexpected end of input");
    }
    return toks[idx++];
  };
  function readForm() {
    const t = advanceToken();
    switch (t.type) {
      case "lparen": {
        const list = [];
        while (true) {
          const next = peekToken();
          if (!next) {
            throw new SyntaxError("Unmatched '('");
          }
          if (next.type === "rparen") break;
          list.push(readForm());
        }
        advanceToken();
        return list;
      }
      case "rparen":
        throw new SyntaxError("Unmatched ')'");
      case "number":
        return t.value;
      case "string":
        return t.value;
      case "boolean":
        return t.value;
      case "nil":
        return null;
      case "symbol":
        return t.value;
    }
  }
  const forms = [];
  while (peekToken()) forms.push(readForm());
  return forms;
}
function printSExpr(x) {
  if (x === null) return "nil";
  if (typeof x === "boolean") return x ? "#t" : "#f";
  if (typeof x === "number") return Number.isFinite(x) ? String(x) : "nan";
  if (typeof x === "string") {
    if (/^[^\s()"]+$/u.test(x) && x !== "nil" && x !== "#t" && x !== "#f")
      return x;
    return `"${x.replace(
      /["\\\n\r\t]/g,
      (m) => m === '"' ? '\\"' : m === "\\" ? "\\\\" : m === "\n" ? "\\n" : m === "\r" ? "\\r" : "\\t"
    )}"`;
  }
  if (Array.isArray(x)) {
    return `(${x.map(printSExpr).join(" ")})`;
  }
  throw new Error(`Unsupported S-expression value: ${JSON.stringify(x)}`);
}

// lib/sexpr/base-classes/SxClass.ts
var DEFAULT_PARENT_TOKEN = "__default__";
var SxClass = class _SxClass {
  static token;
  /**
   * Token strings are sometimes re-used (e.g. a "type" token) but the class
   * varies based on the parent token
   */
  static parentToken;
  isSxClass = true;
  getChildren() {
    return Object.keys(this).filter((k) => k.startsWith("_sx")).map((k) => this[k]).filter((v) => v && typeof v === "object" && v.isSxClass);
  }
  getStringIndented() {
    return this.getString().split("\n").map((line) => `  ${line}`).join("\n");
  }
  getString() {
    const children = this.getChildren();
    if (children.length === 0) {
      return `(${this.token})`;
    }
    const lines = [`(${this.token}`];
    for (const p of children) {
      lines.push(p.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
  get [Symbol.toStringTag]() {
    return this.getString();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.getString();
  }
  // =========================== STATIC METHODS ===========================
  static classes = {};
  /**
   * Should be called after class definition to register the class for parsing
   */
  static register(newClass) {
    if (!newClass.token) {
      throw new Error("Class must have a static override token");
    }
    const parentKey = newClass.parentToken ?? DEFAULT_PARENT_TOKEN;
    const existing = _SxClass.classes[newClass.token] ?? {};
    existing[parentKey] = newClass;
    _SxClass.classes[newClass.token] = existing;
  }
  /**
   * Parse an S-expression string into registered SxClass instances
   */
  static parse(sexpr) {
    const primitiveSexpr = parseToPrimitiveSExpr(sexpr);
    return _SxClass.parsePrimitiveSexpr(primitiveSexpr);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    throw new Error(
      `"${this.name}" class has not implemented fromSexprPrimitives`
    );
  }
  static parsePrimitiveSexpr(primitiveSexpr, options = {}) {
    const parentToken = options.parentToken;
    if (Array.isArray(primitiveSexpr) && primitiveSexpr.length >= 1 && typeof primitiveSexpr[0] === "string") {
      const classToken = primitiveSexpr[0];
      const classGroup = _SxClass.classes[classToken];
      if (!classGroup) {
        throw new Error(
          `Class "${classToken}" not registered via SxClass.register`
        );
      }
      const parentKey = parentToken ?? DEFAULT_PARENT_TOKEN;
      const ClassDef = classGroup[parentKey] ?? classGroup[DEFAULT_PARENT_TOKEN];
      if (!ClassDef) {
        throw new Error(
          `Class "${classToken}" not registered for parent "${parentToken ?? "<root>"}"`
        );
      }
      const args = primitiveSexpr.slice(1);
      if (!("fromSexprPrimitives" in ClassDef)) {
        throw new Error(
          `Class "${classToken}" does not have a fromSexprPrimitives method`
        );
      }
      const classInstance = ClassDef.fromSexprPrimitives(args);
      return classInstance;
    }
    if (Array.isArray(primitiveSexpr)) {
      return primitiveSexpr.map(
        (item) => _SxClass.parsePrimitiveSexpr(item, options)
      );
    }
    if (typeof primitiveSexpr === "number" || typeof primitiveSexpr === "string" || typeof primitiveSexpr === "boolean" || primitiveSexpr === null) {
      return primitiveSexpr;
    }
    throw new Error(
      `Couldn't parse primitive S-expression: ${JSON.stringify(primitiveSexpr)}`
    );
  }
  // =========================== STATIC UTILITIES  ===========================
  static parsePrimitivesToClassProperties(primitiveSexprs, parentToken) {
    const propertyMap = {};
    const arrayPropertyMap = {};
    for (const primitiveSexpr of primitiveSexprs) {
      const sxClass = _SxClass.parsePrimitiveSexpr(primitiveSexpr, {
        parentToken
      });
      if (!sxClass.isSxClass) continue;
      propertyMap[sxClass.token] = sxClass;
      arrayPropertyMap[sxClass.token] ??= [];
      arrayPropertyMap[sxClass.token].push(sxClass);
    }
    return { propertyMap, arrayPropertyMap };
  }
};

// lib/sexpr/base-classes/SxPrimitiveNumber.ts
var SxPrimitiveNumber = class extends SxClass {
  value;
  constructor(v) {
    super();
    this.value = v;
  }
  set(value) {
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    return new this(primitiveSexprs[0]);
  }
  getString() {
    return `(${this.token} ${this.value})`;
  }
};

// lib/sexpr/classes/Width.ts
var Width = class extends SxPrimitiveNumber {
  static token = "width";
  token = "width";
};
SxClass.register(Width);

// lib/sexpr/classes/StrokeType.ts
var StrokeType = class _StrokeType extends SxClass {
  static token = "type";
  static parentToken = "stroke";
  token = "type";
  type;
  constructor(type) {
    super();
    this.type = type;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    return new _StrokeType(primitiveSexprs[0]);
  }
  getString() {
    return `(type ${this.type})`;
  }
};
SxClass.register(StrokeType);

// lib/sexpr/classes/Color.ts
var Color = class _Color extends SxClass {
  static token = "color";
  token = "color";
  color;
  constructor(args) {
    super();
    this.color = { r: args[0], g: args[1], b: args[2], a: args[3] };
  }
  static fromSexprPrimitives(primitiveSexprs) {
    return new _Color(
      primitiveSexprs
    );
  }
  getString() {
    return `(color ${this.color.r} ${this.color.g} ${this.color.b} ${this.color.a})`;
  }
};
SxClass.register(Color);

// lib/sexpr/classes/Stroke.ts
var Stroke = class _Stroke extends SxClass {
  static token = "stroke";
  token = "stroke";
  _sxWidth;
  _sxType;
  _sxColor;
  static fromSexprPrimitives(primitiveSexprs) {
    const stroke = new _Stroke();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    stroke._sxWidth = propertyMap.width;
    stroke._sxType = propertyMap.type;
    stroke._sxColor = propertyMap.color;
    return stroke;
  }
  get width() {
    return this._sxWidth?.value;
  }
  get type() {
    return this._sxType?.type;
  }
  get color() {
    return this._sxColor?.color;
  }
  set width(width) {
    this._sxWidth = new Width(width);
  }
  set type(type) {
    this._sxType = new StrokeType(type);
  }
  set color(color) {
    this._sxColor = new Color([color.r, color.g, color.b, color.a]);
  }
};
SxClass.register(Stroke);

// lib/sexpr/classes/Unit.ts
var unitValues = ["inches", "mils", "millimeters", "automatic"];
var Unit = class _Unit extends SxClass {
  static token = "unit";
  token = "unit";
  value;
  constructor(value) {
    super();
    if (typeof value === "number") {
      this.value = unitValues[value];
    } else {
      this.value = value;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [numericValue] = primitiveSexprs;
    return new _Unit(numericValue);
  }
};
SxClass.register(Unit);

// lib/sexpr/base-classes/SxPrimitiveBoolean.ts
var SxPrimitiveBoolean = class extends SxClass {
  value;
  constructor(v) {
    super();
    this.value = v;
  }
  set(value) {
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawVal] = primitiveSexprs;
    let booleanVal;
    if (typeof rawVal === "boolean") {
      booleanVal = rawVal;
    } else if (typeof rawVal === "string") {
      booleanVal = rawVal === "true" || rawVal === "yes";
    } else {
      booleanVal = false;
    }
    return new this(booleanVal);
  }
  getString() {
    return `(${this.token} ${this.value ? "yes" : "no"})`;
  }
};

// lib/sexpr/classes/InBom.ts
var InBom = class extends SxPrimitiveBoolean {
  static token = "in_bom";
  token = "in_bom";
};
SxClass.register(InBom);

// lib/sexpr/classes/OnBoard.ts
var OnBoard = class extends SxPrimitiveBoolean {
  static token = "on_board";
  token = "on_board";
};
SxClass.register(OnBoard);

// lib/sexpr/utils/toNumberValue.ts
var toNumberValue = (value) => {
  if (value === void 0) return void 0;
  if (typeof value === "number") return value;
  if (typeof value === "string") {
    const parsed = Number(value);
    return Number.isNaN(parsed) ? void 0 : parsed;
  }
  return void 0;
};

// lib/sexpr/classes/Xy.ts
var Xy = class _Xy extends SxClass {
  static token = "xy";
  token = "xy";
  x;
  y;
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX) ?? 0;
    const y = toNumberValue(rawY) ?? 0;
    return new _Xy(x, y);
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(xy ${this.x} ${this.y})`;
  }
};
SxClass.register(Xy);

// lib/sexpr/classes/Pts.ts
var Pts = class _Pts extends SxClass {
  static token = "pts";
  token = "pts";
  points;
  constructor(points = []) {
    super();
    this.points = points;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const points = [];
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `Unexpected primitive inside pts: ${printSExpr(primitive)}`
        );
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (parsed instanceof Xy) {
        points.push(parsed);
        continue;
      }
      if (parsed instanceof PtsArc) {
        points.push(parsed);
        continue;
      }
      if (parsed instanceof SxClass) {
        throw new Error(
          `Unsupported child "${parsed.token}" inside pts expression`
        );
      }
      throw new Error(
        `Unable to parse child inside pts: ${printSExpr(primitive)}`
      );
    }
    return new _Pts(points);
  }
  getChildren() {
    return [...this.points];
  }
  getString() {
    const lines = ["(pts"];
    for (const point of this.points) {
      const pointString = point.getString();
      const segments = pointString.split("\n");
      for (const segment of segments) {
        lines.push(`  ${segment}`);
      }
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(Pts);
var PtsArc = class _PtsArc extends SxClass {
  static token = "arc";
  static parentToken = "pts";
  token = "arc";
  _sxStart;
  _sxMid;
  _sxEnd;
  constructor(params = {}) {
    super();
    if (params.start !== void 0) this.start = params.start;
    if (params.mid !== void 0) this.mid = params.mid;
    if (params.end !== void 0) this.end = params.end;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const arc = new _PtsArc();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    arc._sxStart = propertyMap.start;
    arc._sxMid = propertyMap.mid;
    arc._sxEnd = propertyMap.end;
    return arc;
  }
  get start() {
    return this._sxStart;
  }
  set start(value) {
    if (value === void 0) {
      this._sxStart = void 0;
      return;
    }
    if (value instanceof PtsArcStart) {
      this._sxStart = value;
      return;
    }
    this._sxStart = new PtsArcStart(value.x, value.y);
  }
  get mid() {
    return this._sxMid;
  }
  set mid(value) {
    if (value === void 0) {
      this._sxMid = void 0;
      return;
    }
    if (value instanceof PtsArcMid) {
      this._sxMid = value;
      return;
    }
    this._sxMid = new PtsArcMid(value.x, value.y);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    if (value === void 0) {
      this._sxEnd = void 0;
      return;
    }
    if (value instanceof PtsArcEnd) {
      this._sxEnd = value;
      return;
    }
    this._sxEnd = new PtsArcEnd(value.x, value.y);
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxMid) children.push(this._sxMid);
    if (this._sxEnd) children.push(this._sxEnd);
    return children;
  }
  getString() {
    const lines = ["(arc"];
    if (this._sxStart) lines.push(this._sxStart.getStringIndented());
    if (this._sxMid) lines.push(this._sxMid.getStringIndented());
    if (this._sxEnd) lines.push(this._sxEnd.getStringIndented());
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(PtsArc);
var PtsArcStart = class _PtsArcStart extends SxClass {
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static token = "start";
  static parentToken = "arc";
  token = "start";
  static fromSexprPrimitives(primitiveSexprs) {
    const x = toNumberValue(primitiveSexprs[0]) ?? 0;
    const y = toNumberValue(primitiveSexprs[1]) ?? 0;
    return new _PtsArcStart(x, y);
  }
  getString() {
    return `(start ${this.x} ${this.y})`;
  }
};
SxClass.register(PtsArcStart);
var PtsArcMid = class _PtsArcMid extends SxClass {
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static token = "mid";
  static parentToken = "arc";
  token = "mid";
  static fromSexprPrimitives(primitiveSexprs) {
    const x = toNumberValue(primitiveSexprs[0]) ?? 0;
    const y = toNumberValue(primitiveSexprs[1]) ?? 0;
    return new _PtsArcMid(x, y);
  }
  getString() {
    return `(mid ${this.x} ${this.y})`;
  }
};
SxClass.register(PtsArcMid);
var PtsArcEnd = class _PtsArcEnd extends SxClass {
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static token = "end";
  static parentToken = "arc";
  token = "end";
  static fromSexprPrimitives(primitiveSexprs) {
    const x = toNumberValue(primitiveSexprs[0]) ?? 0;
    const y = toNumberValue(primitiveSexprs[1]) ?? 0;
    return new _PtsArcEnd(x, y);
  }
  getString() {
    return `(end ${this.x} ${this.y})`;
  }
};
SxClass.register(PtsArcEnd);

// lib/sexpr/classes/At.ts
var At = class _At extends SxClass {
  static token = "at";
  token = "at";
  constructor(args, opts = {}) {
    super();
    this.x = args[0];
    this.y = args[1];
    this.angle = args[2];
    if (this.angle && opts.isTextSymbol) {
      this.angle *= 10;
    }
  }
  x;
  y;
  angle;
  static from(input, opts = {}) {
    if (input instanceof _At) {
      return input;
    }
    if (Array.isArray(input)) {
      return new _At(input, opts);
    }
    return new _At([input.x, input.y, input.angle], opts);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [x, y, angle] = primitiveSexprs;
    return new _At([x, y, angle]);
  }
  getString() {
    const parts = [this.x, this.y];
    if (this.angle !== void 0) {
      parts.push(this.angle);
    }
    return `(at ${parts.join(" ")})`;
  }
};
SxClass.register(At);

// lib/sexpr/utils/quoteSExprString.ts
var needsQuoting = (value) => {
  if (value.length === 0) return true;
  return /[\s()"\\]/.test(value);
};
var quoteSExprString = (value) => {
  return `"${value.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t")}"`;
};
var quoteIfNeeded = (value) => {
  return needsQuoting(value) ? quoteSExprString(value) : value;
};

// lib/sexpr/base-classes/SxPrimitiveString.ts
var SxPrimitiveString = class extends SxClass {
  value;
  constructor(v) {
    super();
    this.value = v;
  }
  set(value) {
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    return new this(primitiveSexprs[0]);
  }
  getString() {
    return `(${this.token} ${quoteIfNeeded(this.value)})`;
  }
};

// lib/sexpr/utils/toStringValue.ts
var toStringValue = (value) => {
  if (value === void 0) return void 0;
  if (typeof value === "string") return value;
  if (typeof value === "number" || typeof value === "boolean")
    return String(value);
  return void 0;
};

// lib/sexpr/classes/TextEffects.ts
var TextEffects = class _TextEffects extends SxClass {
  static token = "effects";
  token = "effects";
  _sxFont;
  _sxJustify;
  _hiddenText = false;
  constructor(params = {}) {
    super();
    if (params.font !== void 0) this.font = params.font;
    if (params.justify !== void 0) this.justify = params.justify;
    if (params.hiddenText !== void 0) this.hiddenText = params.hiddenText;
  }
  get font() {
    if (!this._sxFont) {
      this._sxFont = new TextEffectsFont();
    }
    return this._sxFont;
  }
  set font(value) {
    this._sxFont = value;
  }
  get justify() {
    return this._sxJustify;
  }
  set justify(value) {
    this._sxJustify = value;
  }
  get hiddenText() {
    return this._hiddenText;
  }
  set hiddenText(value) {
    this._hiddenText = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const effects = new _TextEffects();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    effects._sxFont = propertyMap.font;
    effects._sxJustify = propertyMap.justify;
    const hideNode = propertyMap.hide;
    if (hideNode) {
      effects._hiddenText = hideNode.value;
    }
    for (const primitive of primitiveSexprs) {
      if (typeof primitive === "string") {
        if (primitive === "hide") {
          effects._hiddenText = true;
          continue;
        }
        throw new Error(`Unknown text effects token: ${primitive}`);
      }
      if (Array.isArray(primitive)) {
        continue;
      }
      throw new Error(
        `Unsupported text effects primitive: ${JSON.stringify(primitive)}`
      );
    }
    return effects;
  }
  getChildren() {
    const children = [];
    if (this._sxFont) children.push(this._sxFont);
    if (this._sxJustify) children.push(this._sxJustify);
    if (this._hiddenText) children.push(new TextEffectsHide(true));
    return children;
  }
  getString() {
    const lines = ["(effects"];
    if (this._sxFont) {
      lines.push(this._sxFont.getStringIndented());
    }
    if (this._sxJustify) {
      lines.push(this._sxJustify.getStringIndented());
    }
    if (this._hiddenText) {
      lines.push(new TextEffectsHide(true).getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(TextEffects);
var TextEffectsFont = class _TextEffectsFont extends SxClass {
  static token = "font";
  static parentToken = "effects";
  token = "font";
  _sxFace;
  _sxSize;
  _sxThickness;
  _sxLineSpacing;
  _sxBold;
  _sxItalic;
  get face() {
    return this._sxFace?.value;
  }
  set face(value) {
    this._sxFace = value === void 0 ? void 0 : new TextEffectsFontFace(value);
  }
  get size() {
    if (!this._sxSize) return void 0;
    return { height: this._sxSize.height, width: this._sxSize.width };
  }
  set size(value) {
    if (value === void 0) {
      this._sxSize = void 0;
      return;
    }
    if (value instanceof TextEffectsFontSize) {
      this._sxSize = value;
      return;
    }
    this._sxSize = new TextEffectsFontSize(value.height, value.width);
  }
  get thickness() {
    return this._sxThickness?.value;
  }
  set thickness(value) {
    this._sxThickness = value === void 0 ? void 0 : new TextEffectsFontThickness(value);
  }
  get lineSpacing() {
    return this._sxLineSpacing?.value;
  }
  set lineSpacing(value) {
    this._sxLineSpacing = value === void 0 ? void 0 : new TextEffectsFontLineSpacing(value);
  }
  get bold() {
    return this._sxBold?.value ?? false;
  }
  set bold(value) {
    this._sxBold = value ? new TextEffectsFontBold(value) : void 0;
  }
  get italic() {
    return this._sxItalic?.value ?? false;
  }
  set italic(value) {
    this._sxItalic = value ? new TextEffectsFontItalic(value) : void 0;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const font = new _TextEffectsFont();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    font._sxFace = propertyMap.face;
    font._sxSize = propertyMap.size;
    font._sxThickness = propertyMap.thickness;
    font._sxLineSpacing = propertyMap.line_spacing;
    font._sxBold = propertyMap.bold;
    font._sxItalic = propertyMap.italic;
    for (const primitive of primitiveSexprs) {
      if (typeof primitive === "string") {
        if (primitive === "bold") {
          font._sxBold = new TextEffectsFontBold(true);
          continue;
        }
        if (primitive === "italic") {
          font._sxItalic = new TextEffectsFontItalic(true);
          continue;
        }
        throw new Error(`Unknown font token: ${primitive}`);
      }
      if (Array.isArray(primitive)) {
        continue;
      }
      throw new Error(
        `Unsupported font primitive: ${JSON.stringify(primitive)}`
      );
    }
    return font;
  }
  getChildren() {
    const children = [];
    if (this._sxFace) children.push(this._sxFace);
    if (this._sxSize) children.push(this._sxSize);
    if (this._sxThickness) children.push(this._sxThickness);
    if (this._sxBold) children.push(this._sxBold);
    if (this._sxItalic) children.push(this._sxItalic);
    if (this._sxLineSpacing) children.push(this._sxLineSpacing);
    return children;
  }
  getString() {
    const lines = ["(font"];
    if (this._sxFace) {
      lines.push(this._sxFace.getStringIndented());
    }
    if (this._sxSize) {
      lines.push(this._sxSize.getStringIndented());
    }
    if (this._sxThickness) {
      lines.push(this._sxThickness.getStringIndented());
    }
    if (this._sxBold) {
      lines.push(this._sxBold.getStringIndented());
    }
    if (this._sxItalic) {
      lines.push(this._sxItalic.getStringIndented());
    }
    if (this._sxLineSpacing) {
      lines.push(this._sxLineSpacing.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(TextEffectsFont);
var TextEffectsFontFace = class extends SxPrimitiveString {
  static token = "face";
  static parentToken = "font";
  token = "face";
  getString() {
    return `(face ${quoteSExprString(this.value)})`;
  }
};
SxClass.register(TextEffectsFontFace);
var TextEffectsFontSize = class _TextEffectsFontSize extends SxClass {
  static token = "size";
  static parentToken = "font";
  token = "size";
  _height = 0;
  _width = 0;
  constructor(height = 0, width = 0) {
    super();
    this._height = height;
    this._width = width;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const height = toNumberValue(primitiveSexprs[0]) ?? 0;
    const width = toNumberValue(primitiveSexprs[1]) ?? 0;
    return new _TextEffectsFontSize(height, width);
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
  getString() {
    return `(size ${this._height} ${this._width})`;
  }
};
SxClass.register(TextEffectsFontSize);
var TextEffectsFontThickness = class extends SxPrimitiveNumber {
  static token = "thickness";
  static parentToken = "font";
  token = "thickness";
};
SxClass.register(TextEffectsFontThickness);
var TextEffectsFontBold = class extends SxPrimitiveBoolean {
  static token = "bold";
  static parentToken = "font";
  token = "bold";
  constructor(value) {
    super(value ?? true);
  }
  getString() {
    return this.value ? "bold" : "";
  }
};
SxClass.register(TextEffectsFontBold);
var TextEffectsFontItalic = class extends SxPrimitiveBoolean {
  static token = "italic";
  static parentToken = "font";
  token = "italic";
  constructor(value) {
    super(value ?? true);
  }
  getString() {
    return this.value ? "italic" : "";
  }
};
SxClass.register(TextEffectsFontItalic);
var TextEffectsHide = class extends SxPrimitiveBoolean {
  static token = "hide";
  static parentToken = "effects";
  token = "hide";
  constructor(value) {
    super(value ?? true);
  }
  getString() {
    return this.value ? "(hide yes)" : "(hide no)";
  }
};
SxClass.register(TextEffectsHide);
var TextEffectsFontLineSpacing = class extends SxPrimitiveNumber {
  static token = "line_spacing";
  static parentToken = "font";
  token = "line_spacing";
};
SxClass.register(TextEffectsFontLineSpacing);
var TextEffectsJustify = class _TextEffectsJustify extends SxClass {
  static token = "justify";
  static parentToken = "effects";
  token = "justify";
  _horizontal;
  _vertical;
  _mirror = false;
  constructor(options = {}) {
    super();
    this._horizontal = options.horizontal;
    this._vertical = options.vertical;
    this._mirror = options.mirror ?? false;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const justify = new _TextEffectsJustify();
    for (const primitive of primitiveSexprs) {
      const value = toStringValue(primitive);
      if (value === void 0) {
        throw new Error(
          `Unsupported justify primitive: ${JSON.stringify(primitive)}`
        );
      }
      if (value === "left" || value === "right") {
        justify._horizontal = value;
        continue;
      }
      if (value === "top" || value === "bottom") {
        justify._vertical = value;
        continue;
      }
      if (value === "mirror") {
        justify._mirror = true;
        continue;
      }
      throw new Error(`Unknown justify token: ${value}`);
    }
    return justify;
  }
  get horizontal() {
    return this._horizontal;
  }
  set horizontal(value) {
    this._horizontal = value;
  }
  get vertical() {
    return this._vertical;
  }
  set vertical(value) {
    this._vertical = value;
  }
  get mirror() {
    return this._mirror;
  }
  set mirror(value) {
    this._mirror = value;
  }
  getString() {
    const parts = ["(justify"];
    if (this._horizontal) {
      parts.push(` ${this._horizontal}`);
    }
    if (this._vertical) {
      parts.push(` ${this._vertical}`);
    }
    if (this._mirror) {
      parts.push(" mirror");
    }
    parts.push(")");
    return parts.join("");
  }
};
SxClass.register(TextEffectsJustify);

// lib/sexpr/classes/Uuid.ts
var Uuid = class extends SxPrimitiveString {
  static token = "uuid";
  token = "uuid";
};
SxClass.register(Uuid);

// lib/sexpr/classes/TitleBlock.ts
function primitiveToString(value) {
  if (value === void 0) return "";
  const str = toStringValue(value);
  if (str !== void 0) return str;
  return printSExpr(value);
}
var TitleBlock = class _TitleBlock extends SxClass {
  static token = "title_block";
  token = "title_block";
  _sxTitle;
  _sxDate;
  _sxRev;
  _sxCompany;
  comments = [];
  constructor(params = {}) {
    super();
    if (params.title !== void 0) this.title = params.title;
    if (params.date !== void 0) this.date = params.date;
    if (params.rev !== void 0) this.rev = params.rev;
    if (params.company !== void 0) this.company = params.company;
    if (params.comments !== void 0) this.comments = params.comments;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const titleBlock = new _TitleBlock();
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `Unexpected primitive inside title_block: ${printSExpr(primitive)}`
        );
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (!(parsed instanceof SxClass)) {
        throw new Error(
          `Unable to parse child node inside title_block: ${printSExpr(primitive)}`
        );
      }
      if (parsed instanceof TitleBlockTitle) {
        titleBlock._sxTitle = parsed;
        continue;
      }
      if (parsed instanceof TitleBlockDate) {
        titleBlock._sxDate = parsed;
        continue;
      }
      if (parsed instanceof TitleBlockRevision) {
        titleBlock._sxRev = parsed;
        continue;
      }
      if (parsed instanceof TitleBlockCompany) {
        titleBlock._sxCompany = parsed;
        continue;
      }
      if (parsed instanceof TitleBlockComment) {
        titleBlock.comments.push(parsed);
        continue;
      }
      throw new Error(
        `Unsupported child "${parsed.token}" inside title_block expression`
      );
    }
    return titleBlock;
  }
  get title() {
    return this._sxTitle?.value;
  }
  set title(value) {
    this._sxTitle = value === void 0 ? void 0 : new TitleBlockTitle(value);
  }
  get date() {
    return this._sxDate?.value;
  }
  set date(value) {
    this._sxDate = value === void 0 ? void 0 : new TitleBlockDate(value);
  }
  get rev() {
    return this._sxRev?.value;
  }
  set rev(value) {
    this._sxRev = value === void 0 ? void 0 : new TitleBlockRevision(value);
  }
  get company() {
    return this._sxCompany?.value;
  }
  set company(value) {
    this._sxCompany = value === void 0 ? void 0 : new TitleBlockCompany(value);
  }
  getComment(index) {
    return this.comments.find((comment) => comment.index === index)?.value;
  }
  setComment(index, value) {
    const existing = this.comments.find((comment) => comment.index === index);
    if (existing) {
      existing.value = value;
      return;
    }
    this.comments.push(new TitleBlockComment(index, value));
  }
  removeComment(index) {
    this.comments = this.comments.filter((comment) => comment.index !== index);
  }
  getChildren() {
    const children = [];
    if (this._sxTitle) children.push(this._sxTitle);
    if (this._sxDate) children.push(this._sxDate);
    if (this._sxRev) children.push(this._sxRev);
    if (this._sxCompany) children.push(this._sxCompany);
    const sortedComments = [...this.comments].sort((a, b) => a.index - b.index);
    children.push(...sortedComments);
    return children;
  }
  getString() {
    const lines = ["(title_block"];
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(TitleBlock);
var TitleBlockStringValue = class extends SxClass {
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  getChildren() {
    return [];
  }
};
var TitleBlockTitle = class _TitleBlockTitle extends TitleBlockStringValue {
  static token = "title";
  static parentToken = "title_block";
  token = "title";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawValue] = primitiveSexprs;
    return new _TitleBlockTitle(primitiveToString(rawValue));
  }
  getString() {
    return `(title ${quoteSExprString(this.value)})`;
  }
};
SxClass.register(TitleBlockTitle);
var TitleBlockDate = class _TitleBlockDate extends TitleBlockStringValue {
  static token = "date";
  static parentToken = "title_block";
  token = "date";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawValue] = primitiveSexprs;
    return new _TitleBlockDate(primitiveToString(rawValue));
  }
  getString() {
    return `(date ${quoteSExprString(this.value)})`;
  }
};
SxClass.register(TitleBlockDate);
var TitleBlockRevision = class _TitleBlockRevision extends TitleBlockStringValue {
  static token = "rev";
  static parentToken = "title_block";
  token = "rev";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawValue] = primitiveSexprs;
    return new _TitleBlockRevision(primitiveToString(rawValue));
  }
  getString() {
    return `(rev ${quoteSExprString(this.value)})`;
  }
};
SxClass.register(TitleBlockRevision);
var TitleBlockCompany = class _TitleBlockCompany extends TitleBlockStringValue {
  static token = "company";
  static parentToken = "title_block";
  token = "company";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawValue] = primitiveSexprs;
    return new _TitleBlockCompany(primitiveToString(rawValue));
  }
  getString() {
    return `(company ${quoteSExprString(this.value)})`;
  }
};
SxClass.register(TitleBlockCompany);
var TitleBlockComment = class _TitleBlockComment extends SxClass {
  static token = "comment";
  static parentToken = "title_block";
  token = "comment";
  index;
  value;
  _sxAt;
  _sxEffects;
  _sxUuid;
  constructor(index, value) {
    super();
    this.index = index;
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawIndex, rawValue, ...rest] = primitiveSexprs;
    const index = toNumberValue(rawIndex);
    if (index === void 0) {
      throw new Error("title_block comment requires a numeric index");
    }
    const value = primitiveToString(rawValue);
    const comment = new _TitleBlockComment(index, value);
    for (const primitive of rest) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `Unexpected primitive inside title_block comment: ${printSExpr(primitive)}`
        );
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (!(parsed instanceof SxClass)) {
        throw new Error(
          `Unable to parse child node inside title_block comment: ${printSExpr(primitive)}`
        );
      }
      if (parsed instanceof At) {
        comment._sxAt = parsed;
        continue;
      }
      if (parsed instanceof TextEffects) {
        comment._sxEffects = parsed;
        continue;
      }
      if (parsed instanceof Uuid) {
        comment._sxUuid = parsed;
        continue;
      }
      throw new Error(
        `Unsupported child "${parsed.token}" inside title_block comment`
      );
    }
    return comment;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value;
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    this._sxUuid = value;
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxEffects) children.push(this._sxEffects);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
  getString() {
    const children = this.getChildren();
    if (children.length === 0) {
      return `(comment ${this.index} ${quoteSExprString(this.value)})`;
    }
    const lines = [`(comment ${this.index} ${quoteSExprString(this.value)}`];
    for (const child of children) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(TitleBlockComment);

// lib/sexpr/classes/Paper.ts
var Paper = class _Paper extends SxClass {
  static token = "paper";
  token = "paper";
  _size;
  _width;
  _height;
  _portrait = false;
  static fromSexprPrimitives(primitiveSexprs) {
    const paper = new _Paper();
    const numericArgs = [];
    for (const primitive of primitiveSexprs) {
      if (typeof primitive === "number") {
        numericArgs.push(primitive);
        continue;
      }
      if (typeof primitive === "string") {
        if (primitive === "portrait") {
          paper._portrait = true;
          continue;
        }
        if (paper._size === void 0 && numericArgs.length === 0) {
          paper._size = primitive;
        }
      }
    }
    if (numericArgs.length >= 2) {
      paper._width = numericArgs[0];
      paper._height = numericArgs[1];
    } else if (numericArgs.length === 1) {
      paper._width = numericArgs[0];
    }
    return paper;
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
    if (value !== void 0) {
      this._width = void 0;
      this._height = void 0;
    }
  }
  get customSize() {
    if (typeof this._width === "number" && typeof this._height === "number") {
      return { width: this._width, height: this._height };
    }
    return void 0;
  }
  set customSize(size) {
    if (!size) {
      this._width = void 0;
      this._height = void 0;
      return;
    }
    this._width = size.width;
    this._height = size.height;
    this._size = void 0;
  }
  get isPortrait() {
    return this._portrait;
  }
  set isPortrait(value) {
    this._portrait = value;
  }
  getString() {
    const lines = ["(paper"];
    if (this._size) {
      lines.push(`  ${this._size}`);
    } else if (typeof this._width === "number" && typeof this._height === "number") {
      lines.push(`  ${this._width} ${this._height}`);
    }
    if (this._portrait) {
      lines.push("  portrait");
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(Paper);

// lib/sexpr/classes/Layer.ts
var Layer = class _Layer extends SxClass {
  static token = "layer";
  token = "layer";
  _names = [];
  constructor(names = []) {
    super();
    this.names = names.map((name) => String(name));
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const names = primitiveSexprs.map(
      (primitive) => typeof primitive === "string" || typeof primitive === "number" ? String(primitive) : printSExpr(primitive)
    );
    return new _Layer(names);
  }
  get names() {
    return [...this._names];
  }
  set names(values) {
    this._names = values.map((value) => String(value));
  }
  addName(name) {
    this._names.push(String(name));
  }
  getString() {
    const rendered = this._names.map((name) => {
      if (/^[^\s()"]+$/u.test(name) && !["nil", "#t", "#f"].includes(name)) {
        return name;
      }
      return quoteSExprString(name);
    }).join(" ");
    return `(layer ${rendered})`;
  }
};
SxClass.register(Layer);

// lib/sexpr/classes/Image.ts
var SUPPORTED_SINGLE_TOKENS = /* @__PURE__ */ new Set([
  "at",
  "xy",
  "scale",
  "layer",
  "uuid",
  "data"
]);
var SUPPORTED_MULTI_TOKENS = /* @__PURE__ */ new Set();
var Image = class _Image extends SxClass {
  static token = "image";
  token = "image";
  _sxPosition;
  _sxScale;
  _sxLayer;
  _sxUuid;
  _sxData;
  constructor(params = {}) {
    super();
    if (params.position !== void 0) this.position = params.position;
    if (params.scale !== void 0) this.scale = params.scale;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.data !== void 0) this.data = params.data;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const image = new _Image();
    const structuredPrimitives = [];
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `image encountered invalid child expression: ${JSON.stringify(primitive)}`
        );
      }
      structuredPrimitives.push(primitive);
    }
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(structuredPrimitives, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS.has(token)) {
        throw new Error(`image encountered unsupported child token "${token}"`);
      }
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS.has(token)) {
        throw new Error(`image encountered unsupported child token "${token}"`);
      }
      if (!SUPPORTED_MULTI_TOKENS.has(token) && entries.length > 1) {
        throw new Error(
          `image does not support repeated child token "${token}"`
        );
      }
    }
    const atInstance = propertyMap.at;
    const xyInstance = propertyMap.xy;
    if (atInstance && xyInstance) {
      throw new Error("image cannot include both at and xy child tokens");
    }
    image._sxPosition = atInstance ?? xyInstance;
    image._sxScale = propertyMap.scale;
    image._sxLayer = propertyMap.layer;
    image._sxUuid = propertyMap.uuid;
    image._sxData = propertyMap.data;
    return image;
  }
  get position() {
    return this._sxPosition;
  }
  set position(value) {
    if (value === void 0) {
      this._sxPosition = void 0;
      return;
    }
    if (value instanceof Xy) {
      this._sxPosition = value;
      return;
    }
    this._sxPosition = At.from(value);
  }
  get scale() {
    return this._sxScale;
  }
  set scale(value) {
    if (value === void 0) {
      this._sxScale = void 0;
      return;
    }
    this._sxScale = value instanceof ImageScale ? value : new ImageScale(value);
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
    } else {
      const names = Array.isArray(value) ? value : [value];
      this._sxLayer = new Layer(names);
    }
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get data() {
    return this._sxData;
  }
  set data(value) {
    if (value === void 0) {
      this._sxData = void 0;
      return;
    }
    if (value instanceof ImageData) {
      this._sxData = value;
    } else if (Array.isArray(value)) {
      this._sxData = ImageData.fromStrings(value);
    } else {
      this._sxData = ImageData.fromStrings([value]);
    }
  }
  getChildren() {
    const children = [];
    if (this._sxPosition) children.push(this._sxPosition);
    if (this._sxScale) children.push(this._sxScale);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxData) children.push(this._sxData);
    return children;
  }
};
SxClass.register(Image);
var ImageScale = class _ImageScale extends SxClass {
  static token = "scale";
  static parentToken = "image";
  token = "scale";
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [raw] = primitiveSexprs;
    const numeric = toNumberValue(raw);
    return new _ImageScale(numeric ?? 1);
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(scale ${this.value})`;
  }
};
SxClass.register(ImageScale);
var ImageData = class _ImageData extends SxClass {
  static token = "data";
  static parentToken = "image";
  token = "data";
  _chunks;
  constructor(chunks = []) {
    super();
    this._chunks = chunks;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const chunks = primitiveSexprs.map(
      (primitive) => primitiveToChunk(primitive)
    );
    return new _ImageData(chunks);
  }
  static fromStrings(values) {
    return new _ImageData(values);
  }
  get chunks() {
    return [...this._chunks];
  }
  set chunks(values) {
    this._chunks = [...values];
  }
  get value() {
    return this._chunks.join("");
  }
  set value(data) {
    this._chunks = [data];
  }
  getChildren() {
    return [];
  }
  getString() {
    if (this._chunks.length === 0) {
      return "(data)";
    }
    const rendered = this._chunks.map((chunk) => quoteSExprString(chunk)).join(" ");
    return `(data ${rendered})`;
  }
};
SxClass.register(ImageData);
function primitiveToChunk(value) {
  const stringValue = toStringValue(value);
  if (stringValue !== void 0) {
    return stringValue;
  }
  return printSExpr(value);
}

// lib/sexpr/classes/RenderCache.ts
var RenderCache = class _RenderCache extends SxClass {
  static token = "render_cache";
  token = "render_cache";
  _text;
  _angle;
  _offsetX;
  _offsetY;
  _elements = [];
  constructor(text = "") {
    super();
    this._text = text;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length === 0) {
      throw new Error("render_cache requires a text argument");
    }
    const [rawText, ...rest] = primitiveSexprs;
    const text = toStringValue(rawText);
    if (text === void 0) {
      throw new Error(
        `render_cache text must be a string value, received ${JSON.stringify(rawText)}`
      );
    }
    const renderCache = new _RenderCache(text);
    const numericParams = [];
    for (const primitive of rest) {
      if (Array.isArray(primitive)) {
        const parsed = SxClass.parsePrimitiveSexpr(primitive, {
          parentToken: this.token
        });
        if (!(parsed instanceof SxClass)) {
          throw new Error(
            `render_cache child did not resolve to an SxClass: ${JSON.stringify(primitive)}`
          );
        }
        if (!(parsed instanceof RenderCachePolygon)) {
          throw new Error(
            `render_cache encountered unsupported child token "${parsed.token}"`
          );
        }
        renderCache._elements.push(parsed);
        continue;
      }
      const numeric = toNumberValue(primitive);
      if (numeric === void 0) {
        throw new Error(
          `render_cache encountered non-numeric parameter ${JSON.stringify(primitive)}`
        );
      }
      numericParams.push(numeric);
    }
    if (numericParams.length > 0) {
      renderCache._angle = numericParams[0];
    }
    if (numericParams.length > 1) {
      renderCache._offsetX = numericParams[1];
    }
    if (numericParams.length > 2) {
      renderCache._offsetY = numericParams[2];
    }
    if (numericParams.length > 3) {
      throw new Error("render_cache supports at most three numeric parameters");
    }
    return renderCache;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get angle() {
    return this._angle;
  }
  set angle(value) {
    this._angle = value;
  }
  get offsetX() {
    return this._offsetX;
  }
  set offsetX(value) {
    this._offsetX = value;
  }
  get offsetY() {
    return this._offsetY;
  }
  set offsetY(value) {
    this._offsetY = value;
  }
  get elements() {
    return [...this._elements];
  }
  set elements(elements) {
    this._elements = [...elements];
  }
  addElement(element) {
    this._elements.push(element);
  }
  getChildren() {
    return [...this._elements];
  }
  getString() {
    const headerParts = [quoteSExprString(this._text)];
    if (this._angle !== void 0) {
      headerParts.push(String(this._angle));
    }
    if (this._offsetX !== void 0) {
      headerParts.push(String(this._offsetX));
    }
    if (this._offsetY !== void 0) {
      headerParts.push(String(this._offsetY));
    }
    if (this._elements.length === 0) {
      return `(render_cache ${headerParts.join(" ")})`;
    }
    const lines = [`(render_cache ${headerParts.join(" ")}`];
    for (const element of this._elements) {
      lines.push(element.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(RenderCache);
var RenderCachePolygon = class _RenderCachePolygon extends SxClass {
  static token = "polygon";
  static parentToken = "render_cache";
  token = "polygon";
  _contours = [];
  static fromSexprPrimitives(primitiveSexprs) {
    const polygon = new _RenderCachePolygon();
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `render_cache polygon encountered invalid child: ${JSON.stringify(primitive)}`
        );
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (!(parsed instanceof SxClass)) {
        throw new Error(
          `render_cache polygon child did not resolve to an SxClass: ${JSON.stringify(primitive)}`
        );
      }
      if (!(parsed instanceof Pts)) {
        throw new Error(
          `render_cache polygon encountered unsupported token "${parsed.token}"`
        );
      }
      polygon._contours.push(parsed);
    }
    if (polygon._contours.length === 0) {
      throw new Error("render_cache polygon requires at least one pts child");
    }
    return polygon;
  }
  get contours() {
    return [...this._contours];
  }
  set contours(value) {
    this._contours = [...value];
  }
  getChildren() {
    return [...this._contours];
  }
};
SxClass.register(RenderCachePolygon);

// lib/sexpr/classes/Tstamp.ts
var Tstamp = class extends SxPrimitiveString {
  static token = "tstamp";
  token = "tstamp";
};
SxClass.register(Tstamp);

// lib/sexpr/classes/KicadSchGenerator.ts
var isSymbolToken = (value) => /^[A-Za-z0-9._-]+$/.test(value);
var KicadSchGenerator = class _KicadSchGenerator extends SxPrimitiveString {
  static token = "generator";
  static parentToken = "kicad_sch";
  token = "generator";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawValue] = primitiveSexprs;
    const parsedValue = toStringValue(rawValue);
    if (parsedValue === void 0) {
      throw new Error("generator expects a string argument");
    }
    return new _KicadSchGenerator(parsedValue);
  }
  getString() {
    const serialized = isSymbolToken(this.value) ? this.value : quoteSExprString(this.value);
    return `(generator ${serialized})`;
  }
};
SxClass.register(KicadSchGenerator);

// lib/sexpr/classes/KicadSchVersion.ts
var KicadSchVersion = class _KicadSchVersion extends SxPrimitiveNumber {
  static token = "version";
  static parentToken = "kicad_sch";
  token = "version";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawValue] = primitiveSexprs;
    const parsedValue = toNumberValue(rawValue);
    if (parsedValue === void 0) {
      throw new Error("version expects a numeric argument");
    }
    return new _KicadSchVersion(parsedValue);
  }
};
SxClass.register(KicadSchVersion);

// lib/sexpr/classes/KicadSchGeneratorVersion.ts
var KicadSchGeneratorVersion = class _KicadSchGeneratorVersion extends SxPrimitiveString {
  static token = "generator_version";
  static parentToken = "kicad_sch";
  token = "generator_version";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawValue] = primitiveSexprs;
    const parsedValue = toStringValue(rawValue);
    if (parsedValue === void 0) {
      throw new Error("generator_version expects a string argument");
    }
    return new _KicadSchGeneratorVersion(parsedValue);
  }
  getString() {
    const serialized = /^[^\s()\"]+$/.test(this.value) ? this.value : quoteSExprString(this.value);
    return `(generator_version ${serialized})`;
  }
};
SxClass.register(KicadSchGeneratorVersion);

// lib/sexpr/utils/indentLines.ts
var indentLines = (value, indent = "  ") => {
  return value.split("\n").map((line) => `${indent}${line}`);
};

// lib/sexpr/classes/Dnp.ts
var Dnp = class extends SxPrimitiveBoolean {
  static token = "dnp";
  token = "dnp";
};
SxClass.register(Dnp);

// lib/sexpr/classes/EmbeddedFonts.ts
var EmbeddedFonts = class _EmbeddedFonts extends SxClass {
  static token = "embedded_fonts";
  token = "embedded_fonts";
  _enabled = false;
  constructor(enabled = false) {
    super();
    this._enabled = enabled;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length === 0) {
      return new _EmbeddedFonts(false);
    }
    if (primitiveSexprs.length > 1) {
      throw new Error("embedded_fonts accepts at most a single value");
    }
    const [raw] = primitiveSexprs;
    if (raw === void 0) {
      return new _EmbeddedFonts(false);
    }
    if (typeof raw === "boolean") {
      return new _EmbeddedFonts(raw);
    }
    if (typeof raw === "string") {
      const normalized = raw.toLowerCase();
      if (normalized === "yes") {
        return new _EmbeddedFonts(true);
      }
      if (normalized === "no") {
        return new _EmbeddedFonts(false);
      }
      throw new Error(`embedded_fonts expects "yes" or "no", received "${raw}"`);
    }
    throw new Error(
      `embedded_fonts encountered unsupported value ${JSON.stringify(raw)}`
    );
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(embedded_fonts ${this._enabled ? "yes" : "no"})`;
  }
};
SxClass.register(EmbeddedFonts);

// lib/sexpr/classes/ExcludeFromSim.ts
var ExcludeFromSim = class extends SxPrimitiveBoolean {
  static token = "exclude_from_sim";
  token = "exclude_from_sim";
};
SxClass.register(ExcludeFromSim);

// lib/sexpr/classes/FieldsAutoplaced.ts
var FieldsAutoplaced = class extends SxPrimitiveBoolean {
  static token = "fields_autoplaced";
  token = "fields_autoplaced";
};
SxClass.register(FieldsAutoplaced);

// lib/sexpr/classes/Polyline.ts
var SUPPORTED_TOKENS_KICAD_SCH = /* @__PURE__ */ new Set(["pts", "stroke", "uuid"]);
var SUPPORTED_TOKENS_SYMBOL = /* @__PURE__ */ new Set(["pts", "stroke", "fill"]);
var Polyline = class _Polyline extends SxClass {
  static token = "polyline";
  token = "polyline";
  _sxPts;
  _sxStroke;
  _sxUuid;
  _sxFill;
  constructor(params = {}) {
    super();
    if (params.points !== void 0) {
      this.points = params.points;
    }
    if (params.stroke !== void 0) {
      this.stroke = params.stroke;
    }
    if (params.uuid !== void 0) {
      this.uuid = params.uuid;
    }
    if (params.fill !== void 0) {
      this.fill = params.fill;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const polyline = new _Polyline();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    const supportedTokens = this.parentToken === "symbol" ? SUPPORTED_TOKENS_SYMBOL : SUPPORTED_TOKENS_KICAD_SCH;
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!supportedTokens.has(token)) {
        throw new Error(
          `Unsupported child tokens inside polyline expression: ${token}`
        );
      }
      if (entries.length > 1) {
        throw new Error(
          `polyline does not support repeated child tokens: ${token}`
        );
      }
    }
    const unsupportedTokens = Object.keys(propertyMap).filter(
      (token) => !supportedTokens.has(token)
    );
    if (unsupportedTokens.length > 0) {
      throw new Error(
        `Unsupported child tokens inside polyline expression: ${unsupportedTokens.join(", ")}`
      );
    }
    polyline._sxPts = arrayPropertyMap.pts?.[0] ?? propertyMap.pts;
    polyline._sxStroke = propertyMap.stroke;
    polyline._sxUuid = propertyMap.uuid;
    polyline._sxFill = propertyMap.fill;
    return polyline;
  }
  get points() {
    return this._sxPts;
  }
  set points(value) {
    this._sxPts = value;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get fill() {
    return this._sxFill;
  }
  set fill(value) {
    this._sxFill = value;
  }
  getChildren() {
    const children = [];
    if (this._sxPts) children.push(this._sxPts);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxFill) children.push(this._sxFill);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
};
SxClass.register(Polyline);
var SchematicPolyline = class extends Polyline {
  static parentToken = "kicad_sch";
};
SxClass.register(SchematicPolyline);
var SymbolPolyline = class extends Polyline {
  static parentToken = "symbol";
};
SxClass.register(SymbolPolyline);

// lib/sexpr/classes/Symbol.ts
var SymbolUnit = class _SymbolUnit extends SxPrimitiveNumber {
  static token = "unit";
  static parentToken = "symbol";
  token = "unit";
  static from(value) {
    if (value instanceof _SymbolUnit) {
      return value;
    }
    return new _SymbolUnit(value);
  }
};
SxClass.register(SymbolUnit);
var SymbolLibId = class _SymbolLibId extends SxClass {
  static token = "lib_id";
  static parentToken = "symbol";
  token = "lib_id";
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive] = primitiveSexprs;
    const value = toStringValue(valuePrimitive);
    if (value === void 0) {
      throw new Error("lib_id expects a string value");
    }
    return new _SymbolLibId(value);
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(lib_id ${quoteSExprString(this.value)})`;
  }
};
SxClass.register(SymbolLibId);
var SymbolDuplicatePinNumbersAreJumpers = class extends SxPrimitiveBoolean {
  static token = "duplicate_pin_numbers_are_jumpers";
  static parentToken = "symbol";
  token = "duplicate_pin_numbers_are_jumpers";
};
SxClass.register(SymbolDuplicatePinNumbersAreJumpers);
var Mirror = class _Mirror extends SxClass {
  static token = "mirror";
  static parentToken = "symbol";
  token = "mirror";
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive] = primitiveSexprs;
    const value = toStringValue(valuePrimitive);
    if (value === void 0) {
      throw new Error("mirror expects a string value (x or y)");
    }
    return new _Mirror(value);
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(mirror ${this.value})`;
  }
};
SxClass.register(Mirror);
var SymbolPinNumbers = class _SymbolPinNumbers extends SxClass {
  static token = "pin_numbers";
  static parentToken = "symbol";
  token = "pin_numbers";
  _sxHide;
  static fromSexprPrimitives(primitiveSexprs) {
    const pinNumbers = new _SymbolPinNumbers();
    const primitiveStrings = [];
    const primitiveNodes = [];
    for (const primitive of primitiveSexprs) {
      if (typeof primitive === "string") {
        primitiveStrings.push(primitive);
        continue;
      }
      primitiveNodes.push(primitive);
    }
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveNodes,
      this.token
    );
    pinNumbers._sxHide = propertyMap.hide;
    for (const flag of primitiveStrings) {
      if (flag === "hide") {
        pinNumbers._sxHide = new SymbolPinNumbersHide(true, { inline: true });
        continue;
      }
      throw new Error(
        `symbol pin_numbers encountered unsupported flag "${flag}"`
      );
    }
    return pinNumbers;
  }
  get hide() {
    return this._sxHide?.value ?? false;
  }
  set hide(value) {
    this._sxHide = new SymbolPinNumbersHide(value);
  }
  getChildren() {
    return this._sxHide ? [this._sxHide] : [];
  }
};
SxClass.register(SymbolPinNumbers);
var SymbolPinNumbersHide = class extends SxPrimitiveBoolean {
  static token = "hide";
  static parentToken = "pin_numbers";
  token = "hide";
  inline = false;
  constructor(value, options = {}) {
    super(value ?? true);
    this.inline = options.inline ?? false;
  }
  getString() {
    if (this.inline) {
      return this.value ? "hide" : "(hide no)";
    }
    return super.getString();
  }
};
SxClass.register(SymbolPinNumbersHide);
var SymbolPinNames = class _SymbolPinNames extends SxClass {
  static token = "pin_names";
  static parentToken = "symbol";
  token = "pin_names";
  _sxOffset;
  _sxHide;
  static fromSexprPrimitives(primitiveSexprs) {
    const pinNames = new _SymbolPinNames();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    pinNames._sxOffset = propertyMap.offset;
    pinNames._sxHide = propertyMap.hide;
    return pinNames;
  }
  get offset() {
    return this._sxOffset?.value;
  }
  set offset(value) {
    if (value === void 0) {
      this._sxOffset = void 0;
      return;
    }
    this._sxOffset = new SymbolPinNamesOffset(value);
  }
  get hide() {
    return this._sxHide?.value ?? false;
  }
  set hide(value) {
    this._sxHide = new SymbolPinNamesHide(value);
  }
  getChildren() {
    const children = [];
    if (this._sxOffset) children.push(this._sxOffset);
    if (this._sxHide) children.push(this._sxHide);
    return children;
  }
};
SxClass.register(SymbolPinNames);
var SymbolPinNamesOffset = class _SymbolPinNamesOffset extends SxClass {
  static token = "offset";
  static parentToken = "pin_names";
  token = "offset";
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive] = primitiveSexprs;
    const value = toNumberValue(valuePrimitive);
    if (value === void 0) {
      throw new Error("pin_names offset expects a numeric value");
    }
    return new _SymbolPinNamesOffset(value);
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(offset ${this.value})`;
  }
};
SxClass.register(SymbolPinNamesOffset);
var SymbolPinNamesHide = class extends SxPrimitiveBoolean {
  static token = "hide";
  static parentToken = "pin_names";
  token = "hide";
};
SxClass.register(SymbolPinNamesHide);
var SymbolPointBase = class extends SxClass {
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error(`${this.name} expects two numeric arguments`);
    }
    const Ctor = this;
    return new Ctor(x, y);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  toObject() {
    return { x: this._x, y: this._y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(${this.token} ${this._x} ${this._y})`;
  }
};
var SymbolRectangleStart = class extends SymbolPointBase {
  static token = "start";
  static parentToken = "rectangle";
  token = "start";
};
SxClass.register(SymbolRectangleStart);
var SymbolRectangleEnd = class extends SymbolPointBase {
  static token = "end";
  static parentToken = "rectangle";
  token = "end";
};
SxClass.register(SymbolRectangleEnd);
var SymbolArcStart = class extends SymbolPointBase {
  static token = "start";
  static parentToken = "arc";
  token = "start";
};
SxClass.register(SymbolArcStart);
var SymbolArcMid = class extends SymbolPointBase {
  static token = "mid";
  static parentToken = "arc";
  token = "mid";
};
SxClass.register(SymbolArcMid);
var SymbolArcEnd = class extends SymbolPointBase {
  static token = "end";
  static parentToken = "arc";
  token = "end";
};
SxClass.register(SymbolArcEnd);
var SymbolCircleCenter = class extends SymbolPointBase {
  static token = "center";
  static parentToken = "circle";
  token = "center";
};
SxClass.register(SymbolCircleCenter);
var SymbolCircleRadius = class extends SxPrimitiveNumber {
  static token = "radius";
  static parentToken = "circle";
  token = "radius";
};
SxClass.register(SymbolCircleRadius);
var SymbolFillBase = class extends SxClass {
  _sxType;
  static fromSexprPrimitives(primitiveSexprs) {
    const fill = new this();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      "fill"
    );
    fill._sxType = propertyMap.type;
    return fill;
  }
  get type() {
    return this._sxType?.value;
  }
  set type(value) {
    if (value === void 0) {
      this._sxType = void 0;
      return;
    }
    this._sxType = new SymbolFillType(value);
  }
  getChildren() {
    return this._sxType ? [this._sxType] : [];
  }
};
var SymbolPolylineFill = class extends SymbolFillBase {
  static token = "fill";
  static parentToken = "polyline";
  token = "fill";
};
SxClass.register(SymbolPolylineFill);
var SymbolRectangleFill = class extends SymbolFillBase {
  static token = "fill";
  static parentToken = "rectangle";
  token = "fill";
};
SxClass.register(SymbolRectangleFill);
var SymbolCircleFill = class extends SymbolFillBase {
  static token = "fill";
  static parentToken = "circle";
  token = "fill";
};
SxClass.register(SymbolCircleFill);
var SymbolArcFill = class extends SymbolFillBase {
  static token = "fill";
  static parentToken = "arc";
  token = "fill";
};
SxClass.register(SymbolArcFill);
var SymbolFillType = class _SymbolFillType extends SxClass {
  static token = "type";
  static parentToken = "fill";
  token = "type";
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive] = primitiveSexprs;
    const value = toStringValue(valuePrimitive);
    if (value === void 0) {
      throw new Error("fill type expects a string value");
    }
    return new _SymbolFillType(value);
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(type ${this.value})`;
  }
};
SxClass.register(SymbolFillType);
var SymbolRectangle = class _SymbolRectangle extends SxClass {
  static token = "rectangle";
  static parentToken = "symbol";
  token = "rectangle";
  _sxStart;
  _sxEnd;
  _sxStroke;
  _sxFill;
  static fromSexprPrimitives(primitiveSexprs) {
    const rectangle = new _SymbolRectangle();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    rectangle._sxStart = propertyMap.start;
    rectangle._sxEnd = propertyMap.end;
    rectangle._sxStroke = propertyMap.stroke;
    rectangle._sxFill = propertyMap.fill;
    return rectangle;
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxFill) children.push(this._sxFill);
    return children;
  }
};
SxClass.register(SymbolRectangle);
var SymbolCircle = class _SymbolCircle extends SxClass {
  static token = "circle";
  static parentToken = "symbol";
  token = "circle";
  _sxCenter;
  _sxRadius;
  _sxStroke;
  _sxFill;
  static fromSexprPrimitives(primitiveSexprs) {
    const circle = new _SymbolCircle();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    circle._sxCenter = propertyMap.center;
    circle._sxRadius = propertyMap.radius;
    circle._sxStroke = propertyMap.stroke;
    circle._sxFill = propertyMap.fill;
    return circle;
  }
  getChildren() {
    const children = [];
    if (this._sxCenter) children.push(this._sxCenter);
    if (this._sxRadius) children.push(this._sxRadius);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxFill) children.push(this._sxFill);
    return children;
  }
};
SxClass.register(SymbolCircle);
var SymbolArc = class _SymbolArc extends SxClass {
  static token = "arc";
  static parentToken = "symbol";
  token = "arc";
  _sxStart;
  _sxMid;
  _sxEnd;
  _sxStroke;
  _sxFill;
  static fromSexprPrimitives(primitiveSexprs) {
    const arc = new _SymbolArc();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    arc._sxStart = propertyMap.start;
    arc._sxMid = propertyMap.mid;
    arc._sxEnd = propertyMap.end;
    arc._sxStroke = propertyMap.stroke;
    arc._sxFill = propertyMap.fill;
    return arc;
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxMid) children.push(this._sxMid);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxFill) children.push(this._sxFill);
    return children;
  }
};
SxClass.register(SymbolArc);
var SymbolText = class _SymbolText extends SxClass {
  static token = "text";
  static parentToken = "symbol";
  token = "text";
  _value = "";
  _sxAt;
  _sxEffects;
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive, ...rest] = primitiveSexprs;
    const value = toStringValue(valuePrimitive);
    if (value === void 0) {
      throw new Error("text expects a string value");
    }
    const text = new _SymbolText();
    text._value = value;
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      rest,
      this.token
    );
    text._sxAt = propertyMap.at;
    text._sxEffects = propertyMap.effects;
    return text;
  }
  get value() {
    return this._value;
  }
  set value(newValue) {
    this._value = newValue;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxEffects) children.push(this._sxEffects);
    return children;
  }
  getString() {
    const lines = [`(text ${quoteSExprString(this._value)}`];
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SymbolText);
var SymbolPower = class _SymbolPower extends SxClass {
  static token = "power";
  static parentToken = "symbol";
  token = "power";
  static fromSexprPrimitives() {
    return new _SymbolPower();
  }
  getChildren() {
    return [];
  }
  getString() {
    return "(power)";
  }
};
SxClass.register(SymbolPower);
var SchematicSymbol = class _SchematicSymbol extends SxClass {
  static token = "symbol";
  token = "symbol";
  _sxLibId;
  _sxAt;
  _sxMirror;
  _sxUnit;
  _sxPinNumbers;
  _sxPinNames;
  _sxExcludeFromSim;
  _sxInBom;
  _sxOnBoard;
  _sxDnp;
  _sxUuid;
  _sxDuplicatePinNumbersAreJumpers;
  _sxFieldsAutoplaced;
  properties = [];
  pins = [];
  subSymbols = [];
  polylines = [];
  rectangles = [];
  circles = [];
  arcs = [];
  texts = [];
  _sxPower;
  _sxEmbeddedFonts;
  _sxInstances;
  _inlineLibId;
  constructor(params = {}) {
    super();
    if (params.libraryId !== void 0) this.libraryId = params.libraryId;
    if (params.at !== void 0) this.at = params.at;
    if (params.mirror !== void 0) this.mirror = params.mirror;
    if (params.unit !== void 0)
      this.unit = typeof params.unit === "number" ? params.unit : params.unit.value;
    if (params.pinNumbers !== void 0) this.pinNumbers = params.pinNumbers;
    if (params.pinNames !== void 0) this.pinNames = params.pinNames;
    if (params.excludeFromSim !== void 0)
      this.excludeFromSim = params.excludeFromSim;
    if (params.inBom !== void 0) this.inBom = params.inBom;
    if (params.onBoard !== void 0) this.onBoard = params.onBoard;
    if (params.dnp !== void 0) this.dnp = params.dnp;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.duplicatePinNumbersAreJumpers !== void 0)
      this.duplicatePinNumbersAreJumpers = params.duplicatePinNumbersAreJumpers;
    if (params.fieldsAutoplaced !== void 0)
      this.fieldsAutoplaced = params.fieldsAutoplaced;
    if (params.properties !== void 0) this.properties = params.properties;
    if (params.pins !== void 0) this.pins = params.pins;
    if (params.subSymbols !== void 0) this.subSymbols = params.subSymbols;
    if (params.polylines !== void 0) this.polylines = params.polylines;
    if (params.rectangles !== void 0) this.rectangles = params.rectangles;
    if (params.circles !== void 0) this.circles = params.circles;
    if (params.arcs !== void 0) this.arcs = params.arcs;
    if (params.texts !== void 0) this.texts = params.texts;
    if (params.embeddedFonts !== void 0)
      this._sxEmbeddedFonts = params.embeddedFonts;
    if (params.instances !== void 0) this.instances = params.instances;
  }
  get libraryId() {
    return this._sxLibId?.value ?? this._inlineLibId;
  }
  set libraryId(value) {
    if (value && typeof value === "object") {
      this._sxLibId = value;
      this._inlineLibId = void 0;
      return;
    }
    if (value === void 0 || value === "") {
      this._inlineLibId = void 0;
      if (this._sxLibId) {
        this._sxLibId = void 0;
      }
      return;
    }
    this._inlineLibId = value;
    this._sxLibId = void 0;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get mirror() {
    return this._sxMirror?.value;
  }
  set mirror(value) {
    if (value === void 0) {
      this._sxMirror = void 0;
      return;
    }
    this._sxMirror = value instanceof Mirror ? value : new Mirror(value);
  }
  get unit() {
    return this._sxUnit?.value;
  }
  set unit(value) {
    this._sxUnit = value === void 0 ? void 0 : SymbolUnit.from(value);
  }
  get pinNumbers() {
    return this._sxPinNumbers;
  }
  set pinNumbers(value) {
    this._sxPinNumbers = value;
  }
  get pinNames() {
    return this._sxPinNames;
  }
  set pinNames(value) {
    this._sxPinNames = value;
  }
  get inBom() {
    return this._sxInBom?.value;
  }
  set inBom(value) {
    this._sxInBom = value === void 0 ? void 0 : new InBom(value);
  }
  get excludeFromSim() {
    return this._sxExcludeFromSim?.value ?? false;
  }
  set excludeFromSim(value) {
    this._sxExcludeFromSim = new ExcludeFromSim(value);
  }
  get onBoard() {
    return this._sxOnBoard?.value;
  }
  set onBoard(value) {
    this._sxOnBoard = value === void 0 ? void 0 : new OnBoard(value);
  }
  get dnp() {
    return this._sxDnp?.value ?? false;
  }
  set dnp(value) {
    this._sxDnp = new Dnp(value);
  }
  get fieldsAutoplaced() {
    return this._sxFieldsAutoplaced?.value ?? false;
  }
  set fieldsAutoplaced(value) {
    this._sxFieldsAutoplaced = new FieldsAutoplaced(value);
  }
  get uuid() {
    return this._sxUuid?.value;
  }
  set uuid(value) {
    this._sxUuid = value === void 0 ? void 0 : new Uuid(value);
  }
  get duplicatePinNumbersAreJumpers() {
    return this._sxDuplicatePinNumbersAreJumpers?.value ?? false;
  }
  set duplicatePinNumbersAreJumpers(value) {
    if (value === void 0) {
      this._sxDuplicatePinNumbersAreJumpers = void 0;
      return;
    }
    this._sxDuplicatePinNumbersAreJumpers = new SymbolDuplicatePinNumbersAreJumpers(value);
  }
  get instances() {
    return this._sxInstances;
  }
  set instances(value) {
    this._sxInstances = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const symbol = new _SchematicSymbol();
    let remaining = primitiveSexprs;
    let inlineId;
    if (remaining.length > 0) {
      const first = remaining[0];
      inlineId = toStringValue(first);
      if (inlineId !== void 0) {
        symbol._inlineLibId = inlineId;
        remaining = remaining.slice(1);
      }
    }
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(remaining, this.token);
    const libIdClass = propertyMap.lib_id;
    if (libIdClass) {
      symbol._sxLibId = libIdClass;
    } else if (inlineId !== void 0) {
      symbol._inlineLibId = inlineId;
    }
    symbol._sxAt = propertyMap.at;
    symbol._sxMirror = propertyMap.mirror;
    symbol._sxUnit = propertyMap.unit;
    symbol._sxPinNumbers = propertyMap.pin_numbers;
    symbol._sxPinNames = propertyMap.pin_names;
    symbol._sxExcludeFromSim = propertyMap.exclude_from_sim;
    symbol._sxInBom = propertyMap.in_bom;
    symbol._sxOnBoard = propertyMap.on_board;
    symbol._sxDnp = propertyMap.dnp;
    symbol._sxUuid = propertyMap.uuid;
    symbol._sxDuplicatePinNumbersAreJumpers = propertyMap.duplicate_pin_numbers_are_jumpers;
    symbol._sxFieldsAutoplaced = propertyMap.fields_autoplaced;
    symbol._sxPower = propertyMap.power;
    symbol._sxEmbeddedFonts = propertyMap.embedded_fonts;
    symbol.properties = arrayPropertyMap.property ?? [];
    symbol.pins = arrayPropertyMap.pin ?? [];
    symbol.subSymbols = arrayPropertyMap.symbol ?? [];
    symbol.polylines = arrayPropertyMap.polyline ?? [];
    symbol.rectangles = arrayPropertyMap.rectangle ?? [];
    symbol.circles = arrayPropertyMap.circle ?? [];
    symbol.arcs = arrayPropertyMap.arc ?? [];
    symbol.texts = arrayPropertyMap.text ?? [];
    symbol._sxInstances = propertyMap.instances;
    return symbol;
  }
  getChildren() {
    const children = [];
    if (this._sxLibId) children.push(this._sxLibId);
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxMirror) children.push(this._sxMirror);
    if (this._sxUnit) children.push(this._sxUnit);
    if (this._sxPinNumbers) children.push(this._sxPinNumbers);
    if (this._sxPinNames) children.push(this._sxPinNames);
    if (this._sxExcludeFromSim) children.push(this._sxExcludeFromSim);
    if (this._sxInBom) children.push(this._sxInBom);
    if (this._sxOnBoard) children.push(this._sxOnBoard);
    if (this._sxDnp) children.push(this._sxDnp);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxDuplicatePinNumbersAreJumpers) {
      children.push(this._sxDuplicatePinNumbersAreJumpers);
    }
    if (this._sxFieldsAutoplaced) children.push(this._sxFieldsAutoplaced);
    children.push(...this.properties);
    children.push(...this.pins);
    children.push(...this.subSymbols);
    children.push(...this.polylines);
    children.push(...this.rectangles);
    children.push(...this.circles);
    children.push(...this.arcs);
    children.push(...this.texts);
    if (this._sxPower) children.push(this._sxPower);
    if (this._sxEmbeddedFonts) children.push(this._sxEmbeddedFonts);
    if (this._sxInstances) children.push(this._sxInstances);
    return children;
  }
  getString() {
    const inlineLibId = this._sxLibId ? void 0 : this.libraryId;
    const lines = inlineLibId !== void 0 && inlineLibId !== "" ? [`(symbol ${quoteSExprString(inlineLibId)}`] : ["(symbol"];
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SchematicSymbol);
var SymbolPropertyId = class _SymbolPropertyId extends SxPrimitiveNumber {
  static token = "id";
  static parentToken = "property";
  token = "id";
  static from(value) {
    if (value instanceof _SymbolPropertyId) {
      return value;
    }
    return new _SymbolPropertyId(value);
  }
};
SxClass.register(SymbolPropertyId);
var SymbolProperty = class _SymbolProperty extends SxClass {
  static token = "property";
  static parentToken = "symbol";
  token = "property";
  key;
  value;
  _sxId;
  _sxAt;
  _sxEffects;
  constructor(params) {
    super();
    this.key = params.key;
    this.value = params.value;
    this._sxId = params.id !== void 0 ? SymbolPropertyId.from(params.id) : void 0;
    this._sxAt = params.at !== void 0 ? At.from(params.at) : void 0;
    this._sxEffects = params.effects;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [inputKey, inputValue, ...rest] = primitiveSexprs;
    const key = toStringValue(inputKey) ?? "";
    const value = toStringValue(inputValue) ?? "";
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      rest,
      this.token
    );
    return new _SymbolProperty({
      key,
      value,
      id: propertyMap.id,
      at: propertyMap.at,
      effects: propertyMap.effects
    });
  }
  get id() {
    return this._sxId?.value;
  }
  set id(value) {
    this._sxId = value === void 0 ? void 0 : SymbolPropertyId.from(value);
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  getChildren() {
    const children = [];
    if (this._sxId) children.push(this._sxId);
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxEffects) children.push(this._sxEffects);
    return children;
  }
  getString() {
    const lines = [
      `(property ${quoteSExprString(this.key)} ${quoteSExprString(this.value)}`
    ];
    if (this._sxId) {
      lines.push(...indentLines(this._sxId.getString()));
    }
    if (this._sxAt) {
      lines.push(...indentLines(this._sxAt.getString()));
    }
    if (this._sxEffects) {
      lines.push(...indentLines(this._sxEffects.getString()));
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SymbolProperty);
var electricalTypeSet = /* @__PURE__ */ new Set([
  "input",
  "output",
  "bidirectional",
  "tri_state",
  "passive",
  "free",
  "unspecified",
  "power_in",
  "power_out",
  "open_collector",
  "open_emitter",
  "no_connect"
]);
var graphicStyleSet = /* @__PURE__ */ new Set([
  "line",
  "inverted",
  "clock",
  "inverted_clock",
  "input_low",
  "clock_low",
  "output_low",
  "edge_clock_high",
  "non_logic"
]);
var SymbolPinLength = class extends SxPrimitiveNumber {
  static token = "length";
  static parentToken = "pin";
  token = "length";
};
SxClass.register(SymbolPinLength);
var SymbolPinName = class _SymbolPinName extends SxClass {
  static token = "name";
  static parentToken = "pin";
  token = "name";
  value;
  _sxEffects;
  constructor(params) {
    super();
    this.value = params.value;
    this._sxEffects = params.effects;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive, ...rest] = primitiveSexprs;
    const value = toStringValue(valuePrimitive) ?? "";
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      rest,
      this.token
    );
    return new _SymbolPinName({
      value,
      effects: propertyMap.effects
    });
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  getChildren() {
    return this._sxEffects ? [this._sxEffects] : [];
  }
  getString() {
    const lines = [`(name ${quoteSExprString(this.value)}`];
    if (this._sxEffects) {
      lines.push(...indentLines(this._sxEffects.getString()));
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SymbolPinName);
var SymbolPinNumber = class _SymbolPinNumber extends SxClass {
  static token = "number";
  static parentToken = "pin";
  token = "number";
  value;
  _sxEffects;
  constructor(params) {
    super();
    this.value = params.value;
    this._sxEffects = params.effects;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive, ...rest] = primitiveSexprs;
    const value = toStringValue(valuePrimitive) ?? "";
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      rest,
      this.token
    );
    return new _SymbolPinNumber({
      value,
      effects: propertyMap.effects
    });
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  getChildren() {
    return this._sxEffects ? [this._sxEffects] : [];
  }
  getString() {
    const lines = [`(number ${quoteSExprString(this.value)}`];
    if (this._sxEffects) {
      lines.push(...indentLines(this._sxEffects.getString()));
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SymbolPinNumber);
var SymbolPin = class _SymbolPin extends SxClass {
  static token = "pin";
  static parentToken = "symbol";
  token = "pin";
  pinElectricalType;
  pinGraphicStyle;
  _sxAt;
  _sxLength;
  _sxName;
  _sxNumber;
  _sxUuid;
  inlineNumber;
  _sxHide;
  static fromSexprPrimitives(args) {
    const symbolPin = new _SymbolPin();
    let index = 0;
    const first = args[0];
    const firstString = toStringValue(first);
    if (firstString && electricalTypeSet.has(firstString)) {
      symbolPin.pinElectricalType = firstString;
      index = 1;
      const second = args[1];
      const secondString = toStringValue(second);
      if (secondString && graphicStyleSet.has(secondString)) {
        symbolPin.pinGraphicStyle = secondString;
        index = 2;
      }
    } else if (firstString !== void 0 && !Array.isArray(first)) {
      symbolPin.inlineNumber = firstString;
      index = 1;
    }
    const remaining = args.slice(index);
    const primitiveStrings = [];
    const primitiveNodes = [];
    for (const primitive of remaining) {
      if (typeof primitive === "string") {
        primitiveStrings.push(primitive);
        continue;
      }
      primitiveNodes.push(primitive);
    }
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveNodes,
      this.token
    );
    symbolPin._sxAt = propertyMap.at;
    symbolPin._sxLength = propertyMap.length;
    symbolPin._sxName = propertyMap.name;
    symbolPin._sxNumber = propertyMap.number;
    symbolPin._sxUuid = propertyMap.uuid;
    symbolPin._sxHide = propertyMap.hide;
    for (const flag of primitiveStrings) {
      if (flag === "hide") {
        symbolPin._sxHide = new SymbolPinHide(true, { inline: true });
        continue;
      }
      throw new Error(`symbol pin encountered unsupported flag "${flag}"`);
    }
    return symbolPin;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get length() {
    return this._sxLength?.value;
  }
  set length(value) {
    this._sxLength = value === void 0 ? void 0 : new SymbolPinLength(value);
  }
  get name() {
    return this._sxName?.value;
  }
  set name(value) {
    if (value === void 0) {
      this._sxName = void 0;
      return;
    }
    this._sxName = new SymbolPinName({ value });
  }
  get numberString() {
    return this._sxNumber?.value ?? this.inlineNumber;
  }
  set numberString(value) {
    if (value === void 0) {
      this._sxNumber = void 0;
      this.inlineNumber = void 0;
      return;
    }
    this.inlineNumber = value;
    this._sxNumber = void 0;
  }
  get uuid() {
    return this._sxUuid?.value;
  }
  set uuid(value) {
    this._sxUuid = value === void 0 ? void 0 : new Uuid(value);
  }
  get hidden() {
    return this._sxHide?.value ?? false;
  }
  set hidden(value) {
    this._sxHide = value ? new SymbolPinHide(value) : void 0;
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxLength) children.push(this._sxLength);
    if (this._sxName) children.push(this._sxName);
    if (this._sxNumber) children.push(this._sxNumber);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxHide) children.push(this._sxHide);
    return children;
  }
  getString() {
    if (this.pinElectricalType) {
      const headerParts = ["(pin", this.pinElectricalType];
      if (this.pinGraphicStyle) {
        headerParts.push(this.pinGraphicStyle);
      }
      const lines2 = [headerParts.join(" ")];
      for (const child of this.getChildren()) {
        lines2.push(...indentLines(child.getString()));
      }
      lines2.push(")");
      return lines2.join("\n");
    }
    const number = this.numberString ?? "";
    const lines = [`(pin ${quoteSExprString(number)}`];
    if (this._sxUuid) {
      lines.push(...indentLines(this._sxUuid.getString()));
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SymbolPin);
var SymbolInstances = class _SymbolInstances extends SxClass {
  static token = "instances";
  static parentToken = "symbol";
  token = "instances";
  projects = [];
  static fromSexprPrimitives(primitiveSexprs) {
    const symbolInstances = new _SymbolInstances();
    const { arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    symbolInstances.projects = arrayPropertyMap.project ?? [];
    return symbolInstances;
  }
  getChildren() {
    return [...this.projects];
  }
  getString() {
    const lines = ["(instances"];
    for (const project of this.projects) {
      lines.push(project.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SymbolInstances);
var SymbolPinHide = class extends SxPrimitiveBoolean {
  static token = "hide";
  static parentToken = "pin";
  token = "hide";
  inline = false;
  constructor(value, options = {}) {
    super(value ?? true);
    this.inline = options.inline ?? false;
  }
  getString() {
    if (this.inline) {
      return this.value ? "hide" : "(hide no)";
    }
    return this.value ? "(hide yes)" : "(hide no)";
  }
};
SxClass.register(SymbolPinHide);
var SymbolInstancesProject = class _SymbolInstancesProject extends SxClass {
  static token = "project";
  static parentToken = "instances";
  token = "project";
  name;
  paths = [];
  constructor(name) {
    super();
    this.name = name;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [namePrimitive, ...rest] = primitiveSexprs;
    const name = toStringValue(namePrimitive) ?? "";
    const project = new _SymbolInstancesProject(name);
    const { arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(
      rest,
      this.token
    );
    project.paths = arrayPropertyMap.path ?? [];
    return project;
  }
  getChildren() {
    return [...this.paths];
  }
  getString() {
    const lines = [`(project ${quoteSExprString(this.name)}`];
    for (const path of this.paths) {
      lines.push(path.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SymbolInstancesProject);
var SymbolInstancePath = class _SymbolInstancePath extends SxClass {
  static token = "path";
  static parentToken = "project";
  token = "path";
  value;
  _sxReference;
  _sxUnit;
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [pathPrimitive, ...rest] = primitiveSexprs;
    const value = toStringValue(pathPrimitive) ?? "";
    const path = new _SymbolInstancePath(value);
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      rest,
      this.token
    );
    path._sxReference = propertyMap.reference;
    path._sxUnit = propertyMap.unit;
    return path;
  }
  get reference() {
    return this._sxReference?.value;
  }
  set reference(value) {
    this._sxReference = value === void 0 ? void 0 : new SymbolInstanceReference(value);
  }
  get unit() {
    return this._sxUnit?.value;
  }
  set unit(value) {
    this._sxUnit = value === void 0 ? void 0 : new SymbolInstanceUnit(value);
  }
  getChildren() {
    const children = [];
    if (this._sxReference) children.push(this._sxReference);
    if (this._sxUnit) children.push(this._sxUnit);
    return children;
  }
  getString() {
    const lines = [`(path ${quoteSExprString(this.value)}`];
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SymbolInstancePath);
var SymbolInstanceReference = class _SymbolInstanceReference extends SxClass {
  static token = "reference";
  static parentToken = "path";
  token = "reference";
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive] = primitiveSexprs;
    return new _SymbolInstanceReference(toStringValue(valuePrimitive) ?? "");
  }
  getString() {
    return `(reference ${quoteSExprString(this.value)})`;
  }
};
SxClass.register(SymbolInstanceReference);
var SymbolInstanceUnit = class extends SxPrimitiveNumber {
  static token = "unit";
  static parentToken = "path";
  token = "unit";
};
SxClass.register(SymbolInstanceUnit);

// lib/sexpr/classes/LibSymbols.ts
var SUPPORTED_ARRAY_TOKENS = /* @__PURE__ */ new Set(["symbol"]);
var LibSymbols = class _LibSymbols extends SxClass {
  static token = "lib_symbols";
  static parentToken = "kicad_sch";
  token = "lib_symbols";
  _symbols = [];
  static fromSexprPrimitives(primitiveSexprs) {
    const libSymbols = new _LibSymbols();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    const unsupportedSingularTokens = Object.keys(propertyMap).filter(
      (token) => !SUPPORTED_ARRAY_TOKENS.has(token)
    );
    if (unsupportedSingularTokens.length > 0) {
      throw new Error(
        `Unsupported child tokens inside lib_symbols expression: ${unsupportedSingularTokens.join(", ")}`
      );
    }
    const unsupportedArrayTokens = Object.keys(arrayPropertyMap).filter(
      (token) => !SUPPORTED_ARRAY_TOKENS.has(token)
    );
    if (unsupportedArrayTokens.length > 0) {
      throw new Error(
        `Unsupported repeated child tokens inside lib_symbols expression: ${unsupportedArrayTokens.join(", ")}`
      );
    }
    const symbols = arrayPropertyMap.symbol ?? [];
    if (!symbols.length && propertyMap.symbol) {
      symbols.push(propertyMap.symbol);
    }
    libSymbols._symbols = symbols;
    return libSymbols;
  }
  get symbols() {
    return [...this._symbols];
  }
  set symbols(value) {
    this._symbols = [...value];
  }
  getChildren() {
    return [...this._symbols];
  }
};
SxClass.register(LibSymbols);

// lib/sexpr/classes/Wire.ts
var SUPPORTED_TOKENS = /* @__PURE__ */ new Set(["pts", "stroke", "uuid"]);
var Wire = class _Wire extends SxClass {
  static token = "wire";
  static parentToken = "kicad_sch";
  token = "wire";
  _sxPts;
  _sxStroke;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.points !== void 0) {
      this.points = params.points;
    }
    if (params.stroke !== void 0) {
      this.stroke = params.stroke;
    }
    if (params.uuid !== void 0) {
      this.uuid = params.uuid;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const wire = new _Wire();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS.has(token)) {
        throw new Error(
          `Unsupported child tokens inside wire expression: ${token}`
        );
      }
      if (entries.length > 1) {
        throw new Error(`wire does not support repeated child tokens: ${token}`);
      }
    }
    const unsupportedTokens = Object.keys(propertyMap).filter(
      (token) => !SUPPORTED_TOKENS.has(token)
    );
    if (unsupportedTokens.length > 0) {
      throw new Error(
        `Unsupported child tokens inside wire expression: ${unsupportedTokens.join(", ")}`
      );
    }
    wire._sxPts = arrayPropertyMap.pts?.[0] ?? propertyMap.pts;
    wire._sxStroke = propertyMap.stroke;
    wire._sxUuid = propertyMap.uuid;
    return wire;
  }
  get points() {
    return this._sxPts;
  }
  set points(value) {
    this._sxPts = value;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  getChildren() {
    const children = [];
    if (this._sxPts) children.push(this._sxPts);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
};
SxClass.register(Wire);

// lib/sexpr/classes/Bus.ts
var SUPPORTED_TOKENS2 = /* @__PURE__ */ new Set(["pts", "stroke", "uuid"]);
var Bus = class _Bus extends SxClass {
  static token = "bus";
  static parentToken = "kicad_sch";
  token = "bus";
  _sxPts;
  _sxStroke;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.points !== void 0) {
      this.points = params.points;
    }
    if (params.stroke !== void 0) {
      this.stroke = params.stroke;
    }
    if (params.uuid !== void 0) {
      this.uuid = params.uuid;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const bus = new _Bus();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    if (Object.keys(arrayPropertyMap).length > 0) {
      const tokens = Object.keys(arrayPropertyMap).join(", ");
      throw new Error(`bus does not support repeated child tokens: ${tokens}`);
    }
    const unsupportedTokens = Object.keys(propertyMap).filter(
      (token) => !SUPPORTED_TOKENS2.has(token)
    );
    if (unsupportedTokens.length > 0) {
      throw new Error(
        `Unsupported child tokens inside bus expression: ${unsupportedTokens.join(", ")}`
      );
    }
    bus._sxPts = propertyMap.pts;
    bus._sxStroke = propertyMap.stroke;
    bus._sxUuid = propertyMap.uuid;
    return bus;
  }
  get points() {
    return this._sxPts;
  }
  set points(value) {
    this._sxPts = value;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  getChildren() {
    const children = [];
    if (this._sxPts) children.push(this._sxPts);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
};
SxClass.register(Bus);

// lib/sexpr/classes/Junction.ts
var Junction = class _Junction extends SxClass {
  static token = "junction";
  static parentToken = "kicad_sch";
  token = "junction";
  _sxAt;
  _sxDiameter;
  _sxColor;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.at !== void 0) {
      this.at = params.at;
    }
    if (params.diameter !== void 0) {
      if (params.diameter instanceof JunctionDiameter) {
        this._sxDiameter = params.diameter;
      } else {
        this.diameter = params.diameter;
      }
    }
    if (params.color !== void 0) {
      this.color = params.color;
    }
    if (params.uuid !== void 0) {
      this.uuid = params.uuid;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const junction = new _Junction();
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `junction encountered invalid child expression: ${JSON.stringify(primitive)}`
        );
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (!(parsed instanceof SxClass)) {
        throw new Error(
          `junction child did not resolve to an SxClass: ${JSON.stringify(primitive)}`
        );
      }
      if (parsed instanceof At) {
        if (junction._sxAt) {
          throw new Error("junction encountered duplicate at tokens");
        }
        junction._sxAt = parsed;
        continue;
      }
      if (parsed instanceof JunctionDiameter) {
        if (junction._sxDiameter) {
          throw new Error("junction encountered duplicate diameter tokens");
        }
        junction._sxDiameter = parsed;
        continue;
      }
      if (parsed instanceof Color) {
        if (junction._sxColor) {
          throw new Error("junction encountered duplicate color tokens");
        }
        junction._sxColor = parsed;
        continue;
      }
      if (parsed instanceof Uuid) {
        if (junction._sxUuid) {
          throw new Error("junction encountered duplicate uuid tokens");
        }
        junction._sxUuid = parsed;
        continue;
      }
      throw new Error(
        `Unsupported child tokens inside junction expression: ${parsed.token}`
      );
    }
    return junction;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get diameter() {
    return this._sxDiameter?.value;
  }
  set diameter(value) {
    this._sxDiameter = value === void 0 ? void 0 : new JunctionDiameter(value);
  }
  get color() {
    return this._sxColor;
  }
  set color(value) {
    this._sxColor = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxDiameter) children.push(this._sxDiameter);
    if (this._sxColor) children.push(this._sxColor);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
};
SxClass.register(Junction);
var JunctionDiameter = class extends SxPrimitiveNumber {
  static token = "diameter";
  static parentToken = "junction";
  token = "diameter";
};
SxClass.register(JunctionDiameter);

// lib/sexpr/classes/NoConnect.ts
var SUPPORTED_TOKENS3 = /* @__PURE__ */ new Set(["at", "uuid"]);
var NoConnect = class _NoConnect extends SxClass {
  static token = "no_connect";
  static parentToken = "kicad_sch";
  token = "no_connect";
  _sxAt;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.at !== void 0) {
      this.at = params.at;
    }
    if (params.uuid !== void 0) {
      this.uuid = params.uuid;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const noConnect = new _NoConnect();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    for (const token of Object.keys(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS3.has(token)) {
        continue;
      }
      if (arrayPropertyMap[token].length > 1) {
        throw new Error(
          `no_connect does not support repeated child tokens: ${token}`
        );
      }
    }
    const unsupportedTokens = Object.keys(propertyMap).filter(
      (token) => !SUPPORTED_TOKENS3.has(token)
    );
    if (unsupportedTokens.length > 0) {
      throw new Error(
        `Unsupported child tokens inside no_connect expression: ${unsupportedTokens.join(", ")}`
      );
    }
    noConnect._sxAt = propertyMap.at;
    noConnect._sxUuid = propertyMap.uuid;
    return noConnect;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
};
SxClass.register(NoConnect);

// lib/sexpr/classes/BusEntry.ts
var SUPPORTED_TOKENS4 = /* @__PURE__ */ new Set(["at", "size", "stroke", "uuid"]);
var BusEntry = class _BusEntry extends SxClass {
  static token = "bus_entry";
  static parentToken = "kicad_sch";
  token = "bus_entry";
  _sxAt;
  _sxSize;
  _sxStroke;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.at !== void 0) {
      this.at = params.at;
    }
    if (params.size !== void 0) {
      this.size = params.size;
    }
    if (params.stroke !== void 0) {
      this.stroke = params.stroke;
    }
    if (params.uuid !== void 0) {
      this.uuid = params.uuid;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const entry = new _BusEntry();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    if (Object.keys(arrayPropertyMap).length > 0) {
      const tokens = Object.keys(arrayPropertyMap).join(", ");
      throw new Error(
        `bus_entry does not support repeated child tokens: ${tokens}`
      );
    }
    const unsupportedTokens = Object.keys(propertyMap).filter(
      (token) => !SUPPORTED_TOKENS4.has(token)
    );
    if (unsupportedTokens.length > 0) {
      throw new Error(
        `Unsupported child tokens inside bus_entry expression: ${unsupportedTokens.join(", ")}`
      );
    }
    entry._sxAt = propertyMap.at;
    entry._sxSize = propertyMap.size;
    entry._sxStroke = propertyMap.stroke;
    entry._sxUuid = propertyMap.uuid;
    return entry;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get size() {
    return this._sxSize?.toObject();
  }
  set size(value) {
    if (value === void 0) {
      this._sxSize = void 0;
      return;
    }
    if (value instanceof BusEntrySize) {
      this._sxSize = value;
      return;
    }
    this._sxSize = new BusEntrySize(value.x, value.y);
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxSize) children.push(this._sxSize);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
};
SxClass.register(BusEntry);
var BusEntrySize = class _BusEntrySize extends SxClass {
  static token = "size";
  static parentToken = "bus_entry";
  token = "size";
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    if (typeof rawX !== "number" || typeof rawY !== "number") {
      throw new Error("bus_entry size expects two numeric arguments");
    }
    return new _BusEntrySize(rawX, rawY);
  }
  toObject() {
    return { x: this._x, y: this._y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(size ${this._x} ${this._y})`;
  }
};
SxClass.register(BusEntrySize);

// lib/sexpr/classes/Label.ts
var SUPPORTED_TOKENS5 = /* @__PURE__ */ new Set(["at", "effects", "uuid", "fields_autoplaced"]);
var Label = class _Label extends SxClass {
  static token = "label";
  static parentToken = "kicad_sch";
  token = "label";
  _value = "";
  _sxAt;
  _sxEffects;
  _sxUuid;
  _sxFieldsAutoplaced;
  constructor(params = {}) {
    super();
    if (params.value !== void 0) {
      this.value = params.value;
    }
    if (params.at !== void 0) {
      this.at = params.at;
    }
    if (params.effects !== void 0) {
      this.effects = params.effects;
    }
    if (params.uuid !== void 0) {
      this.uuid = params.uuid;
    }
    if (params.fieldsAutoplaced !== void 0) {
      if (params.fieldsAutoplaced instanceof FieldsAutoplaced) {
        this._sxFieldsAutoplaced = params.fieldsAutoplaced;
      } else {
        this.fieldsAutoplaced = params.fieldsAutoplaced;
      }
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [textPrimitive, ...rest] = primitiveSexprs;
    const value = toStringValue(textPrimitive);
    if (value === void 0) {
      throw new Error("label expects a string value");
    }
    const label = new _Label();
    label._value = value;
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(rest, this.token);
    const unsupportedTokens = Object.keys(propertyMap).filter(
      (token) => !SUPPORTED_TOKENS5.has(token)
    );
    if (unsupportedTokens.length > 0) {
      throw new Error(
        `Unsupported child tokens inside label expression: ${unsupportedTokens.join(", ")}`
      );
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS5.has(token)) {
        throw new Error(
          `Unsupported child tokens inside label expression: ${token}`
        );
      }
      if (entries.length > 1) {
        throw new Error(
          `label does not support repeated child tokens: ${token}`
        );
      }
    }
    label._sxAt = arrayPropertyMap.at?.[0] ?? propertyMap.at;
    label._sxEffects = arrayPropertyMap.effects?.[0] ?? propertyMap.effects;
    label._sxUuid = arrayPropertyMap.uuid?.[0] ?? propertyMap.uuid;
    label._sxFieldsAutoplaced = arrayPropertyMap.fields_autoplaced?.[0] ?? propertyMap.fields_autoplaced;
    return label;
  }
  get value() {
    return this._value;
  }
  set value(newValue) {
    this._value = newValue;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get fieldsAutoplaced() {
    return this._sxFieldsAutoplaced?.value ?? false;
  }
  set fieldsAutoplaced(value) {
    this._sxFieldsAutoplaced = new FieldsAutoplaced(value);
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxEffects) children.push(this._sxEffects);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxFieldsAutoplaced) children.push(this._sxFieldsAutoplaced);
    return children;
  }
  getString() {
    const lines = [`(label ${quoteSExprString(this._value)}`];
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(Label);

// lib/sexpr/classes/PropertyHide.ts
var PropertyHide = class extends SxPrimitiveBoolean {
  static token = "hide";
  static parentToken = "property";
  token = "hide";
};
SxClass.register(PropertyHide);

// lib/sexpr/classes/PropertyUnlocked.ts
var PropertyUnlocked = class extends SxPrimitiveBoolean {
  static token = "unlocked";
  static parentToken = "property";
  token = "unlocked";
};
SxClass.register(PropertyUnlocked);

// lib/sexpr/classes/Property.ts
var SUPPORTED_SINGLE_CHILDREN = /* @__PURE__ */ new Set([
  "at",
  "xy",
  "layer",
  "uuid",
  "effects",
  "unlocked",
  "hide"
]);
var ensureSingleChild = (arrayPropertyMap, token) => {
  const entries = arrayPropertyMap[token];
  if (entries && entries.length > 1) {
    throw new Error(`property does not support repeated "${token}" children`);
  }
};
var primitiveToString2 = (value) => {
  if (value === void 0) {
    return void 0;
  }
  const asString = toStringValue(value);
  if (asString !== void 0) {
    return asString;
  }
  return printSExpr(value);
};
var Property = class _Property extends SxClass {
  static token = "property";
  token = "property";
  _key = "";
  _value = "";
  _sxAt;
  _sxXy;
  _sxLayer;
  _sxUuid;
  _sxEffects;
  _sxUnlocked;
  _sxHide;
  constructor(keyOrParams = {}, value = "") {
    super();
    if (typeof keyOrParams === "string") {
      this._key = keyOrParams;
      this._value = value;
    } else {
      const params = keyOrParams;
      if (params.key !== void 0) {
        this._key = params.key;
      }
      if (params.value !== void 0) {
        this._value = params.value;
      }
      if (params.position !== void 0) {
        this.position = params.position;
      }
      if (params.layer !== void 0) {
        this.layer = params.layer;
      }
      if (params.uuid !== void 0) {
        this.uuid = params.uuid;
      }
      if (params.effects !== void 0) {
        this.effects = params.effects;
      }
      if (params.unlocked !== void 0) {
        if (params.unlocked instanceof PropertyUnlocked) {
          this._sxUnlocked = params.unlocked;
        } else {
          this.unlocked = params.unlocked;
        }
      }
      if (params.hidden !== void 0) {
        if (params.hidden instanceof PropertyHide) {
          this._sxHide = params.hidden;
        } else {
          this.hidden = params.hidden;
        }
      }
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length < 2) {
      throw new Error("property requires key and value arguments");
    }
    const [rawKey, rawValue, ...rest] = primitiveSexprs;
    const key = primitiveToString2(rawKey);
    const value = primitiveToString2(rawValue);
    if (key === void 0) {
      throw new Error("property key must be a printable value");
    }
    if (value === void 0) {
      throw new Error("property value must be a printable value");
    }
    for (const primitive of rest) {
      if (!Array.isArray(primitive)) {
        throw new Error(
          `property encountered unexpected primitive child: ${JSON.stringify(primitive)}`
        );
      }
      if (primitive.length === 0 || typeof primitive[0] !== "string") {
        throw new Error(
          `property encountered invalid child expression: ${JSON.stringify(primitive)}`
        );
      }
    }
    const property = new _Property(key, value);
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(rest, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_SINGLE_CHILDREN.has(token)) {
        throw new Error(
          `property encountered unsupported child token "${token}"`
        );
      }
    }
    for (const token of Object.keys(arrayPropertyMap)) {
      if (!SUPPORTED_SINGLE_CHILDREN.has(token)) {
        throw new Error(
          `property encountered unsupported child token "${token}"`
        );
      }
      ensureSingleChild(arrayPropertyMap, token);
    }
    const at = propertyMap.at;
    const xy = propertyMap.xy;
    if (at && xy) {
      throw new Error("property can't include both at and xy children");
    }
    property._sxAt = at;
    property._sxXy = xy;
    property._sxLayer = propertyMap.layer;
    property._sxUuid = propertyMap.uuid;
    property._sxEffects = propertyMap.effects;
    property._sxUnlocked = propertyMap.unlocked;
    property._sxHide = propertyMap.hide;
    return property;
  }
  get key() {
    return this._key;
  }
  set key(value) {
    this._key = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  get position() {
    return this._sxAt ?? this._sxXy;
  }
  set position(value) {
    if (value === void 0) {
      this._sxAt = void 0;
      this._sxXy = void 0;
      return;
    }
    if (value instanceof Xy) {
      this._sxXy = value;
      this._sxAt = void 0;
      return;
    }
    this._sxAt = At.from(value);
    this._sxXy = void 0;
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  get unlocked() {
    return this._sxUnlocked?.value ?? false;
  }
  set unlocked(value) {
    this._sxUnlocked = new PropertyUnlocked(value);
  }
  get hidden() {
    return this._sxHide?.value ?? false;
  }
  set hidden(value) {
    this._sxHide = new PropertyHide(value);
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxXy) children.push(this._sxXy);
    if (this._sxUnlocked) children.push(this._sxUnlocked);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxHide) children.push(this._sxHide);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxEffects) children.push(this._sxEffects);
    return children;
  }
  getString() {
    const lines = [
      `(property ${quoteSExprString(this._key)} ${quoteSExprString(this._value)}`
    ];
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(Property);

// lib/sexpr/classes/GlobalLabel.ts
var SUPPORTED_TOKENS6 = /* @__PURE__ */ new Set([
  "shape",
  "at",
  "effects",
  "uuid",
  "fields_autoplaced",
  "property"
]);
var GlobalLabel = class _GlobalLabel extends SxClass {
  static token = "global_label";
  static parentToken = "kicad_sch";
  token = "global_label";
  _value = "";
  _shape = "input";
  _sxAt;
  _sxEffects;
  _sxUuid;
  _sxFieldsAutoplaced;
  _properties = [];
  constructor(params = {}) {
    super();
    if (params.value !== void 0) {
      this.value = params.value;
    }
    if (params.shape !== void 0) {
      this.shape = params.shape;
    }
    if (params.at !== void 0) {
      this.at = params.at;
    }
    if (params.effects !== void 0) {
      this.effects = params.effects;
    }
    if (params.uuid !== void 0) {
      this.uuid = params.uuid;
    }
    if (params.fieldsAutoplaced !== void 0) {
      if (params.fieldsAutoplaced instanceof FieldsAutoplaced) {
        this._sxFieldsAutoplaced = params.fieldsAutoplaced;
      } else {
        this.fieldsAutoplaced = params.fieldsAutoplaced;
      }
    }
    if (params.properties !== void 0) {
      this.properties = params.properties;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [textPrimitive, ...rest] = primitiveSexprs;
    const value = toStringValue(textPrimitive);
    if (value === void 0) {
      throw new Error("global_label expects a string value");
    }
    const globalLabel = new _GlobalLabel();
    globalLabel._value = value;
    let shapeIndex = -1;
    for (let i = 0; i < rest.length; i++) {
      const item = rest[i];
      if (Array.isArray(item) && item[0] === "shape" && item.length === 2) {
        shapeIndex = i;
        const shapeValue = toStringValue(item[1]);
        if (shapeValue) {
          globalLabel._shape = shapeValue;
        }
        break;
      }
    }
    const restWithoutShape = shapeIndex >= 0 ? rest.filter((_, i) => i !== shapeIndex) : rest;
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(restWithoutShape, this.token);
    const unsupportedTokens = Object.keys(propertyMap).filter(
      (token) => !SUPPORTED_TOKENS6.has(token)
    );
    if (unsupportedTokens.length > 0) {
      throw new Error(
        `Unsupported child tokens inside global_label expression: ${unsupportedTokens.join(", ")}`
      );
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS6.has(token)) {
        throw new Error(
          `Unsupported child tokens inside global_label expression: ${token}`
        );
      }
      if (token !== "property" && entries.length > 1) {
        throw new Error(
          `global_label does not support repeated child tokens: ${token}`
        );
      }
    }
    globalLabel._sxAt = arrayPropertyMap.at?.[0] ?? propertyMap.at;
    globalLabel._sxEffects = arrayPropertyMap.effects?.[0] ?? propertyMap.effects;
    globalLabel._sxUuid = arrayPropertyMap.uuid?.[0] ?? propertyMap.uuid;
    globalLabel._sxFieldsAutoplaced = arrayPropertyMap.fields_autoplaced?.[0] ?? propertyMap.fields_autoplaced;
    globalLabel._properties = arrayPropertyMap.property ?? [];
    return globalLabel;
  }
  get value() {
    return this._value;
  }
  set value(newValue) {
    this._value = newValue;
  }
  get shape() {
    return this._shape;
  }
  set shape(value) {
    this._shape = value;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get fieldsAutoplaced() {
    return this._sxFieldsAutoplaced?.value ?? false;
  }
  set fieldsAutoplaced(value) {
    this._sxFieldsAutoplaced = new FieldsAutoplaced(value);
  }
  get properties() {
    return [...this._properties];
  }
  set properties(value) {
    this._properties = [...value];
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxEffects) children.push(this._sxEffects);
    if (this._sxUuid) children.push(this._sxUuid);
    children.push(...this._properties);
    if (this._sxFieldsAutoplaced) children.push(this._sxFieldsAutoplaced);
    return children;
  }
  getString() {
    const lines = [`(global_label ${quoteSExprString(this._value)}`];
    lines.push(`  (shape ${this._shape})`);
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(GlobalLabel);

// lib/sexpr/classes/SchematicText.ts
var SUPPORTED_TOKENS7 = /* @__PURE__ */ new Set(["exclude_from_sim", "at", "effects", "uuid"]);
var SchematicText = class _SchematicText extends SxClass {
  static token = "text";
  static parentToken = "kicad_sch";
  token = "text";
  _value = "";
  _sxExcludeFromSim;
  _sxAt;
  _sxEffects;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.value !== void 0) {
      this.value = params.value;
    }
    if (params.excludeFromSim !== void 0) {
      this.excludeFromSim = typeof params.excludeFromSim === "boolean" ? params.excludeFromSim : params.excludeFromSim.value;
    }
    if (params.at !== void 0) {
      this.at = params.at;
    }
    if (params.effects !== void 0) {
      this.effects = params.effects;
    }
    if (params.uuid !== void 0) {
      this.uuid = params.uuid;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [textPrimitive, ...rest] = primitiveSexprs;
    const value = toStringValue(textPrimitive);
    if (value === void 0) {
      throw new Error("text expects a string value");
    }
    const text = new _SchematicText();
    text._value = value;
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(rest, this.token);
    const unsupportedTokens = Object.keys(propertyMap).filter(
      (token) => !SUPPORTED_TOKENS7.has(token)
    );
    if (unsupportedTokens.length > 0) {
      throw new Error(
        `Unsupported child tokens inside text expression: ${unsupportedTokens.join(", ")}`
      );
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS7.has(token)) {
        throw new Error(
          `Unsupported child tokens inside text expression: ${token}`
        );
      }
      if (entries.length > 1) {
        throw new Error(`text does not support repeated child tokens: ${token}`);
      }
    }
    text._sxExcludeFromSim = arrayPropertyMap.exclude_from_sim?.[0] ?? propertyMap.exclude_from_sim;
    text._sxAt = arrayPropertyMap.at?.[0] ?? propertyMap.at;
    text._sxEffects = arrayPropertyMap.effects?.[0] ?? propertyMap.effects;
    text._sxUuid = arrayPropertyMap.uuid?.[0] ?? propertyMap.uuid;
    return text;
  }
  get value() {
    return this._value;
  }
  set value(newValue) {
    this._value = newValue;
  }
  get excludeFromSim() {
    return this._sxExcludeFromSim?.value ?? false;
  }
  set excludeFromSim(value) {
    this._sxExcludeFromSim = value ? new ExcludeFromSim(true) : void 0;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  getChildren() {
    const children = [];
    if (this._sxExcludeFromSim) children.push(this._sxExcludeFromSim);
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxEffects) children.push(this._sxEffects);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
  getString() {
    const lines = [`(text ${quoteSExprString(this._value)}`];
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SchematicText);

// lib/sexpr/classes/SheetInstancesRoot.ts
var SUPPORTED_ARRAY_TOKENS2 = /* @__PURE__ */ new Set(["page"]);
var SheetInstancesRoot = class _SheetInstancesRoot extends SxClass {
  static token = "sheet_instances";
  token = "sheet_instances";
  _paths = [];
  static fromSexprPrimitives(primitiveSexprs) {
    const sheetInstances = new _SheetInstancesRoot();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    const unsupportedSingularTokens = Object.keys(propertyMap).filter(
      (token) => token !== "path"
    );
    if (unsupportedSingularTokens.length > 0) {
      throw new Error(
        `Unsupported singular child tokens inside sheet_instances expression: ${unsupportedSingularTokens.join(", ")}`
      );
    }
    const unsupportedArrayTokens = Object.keys(arrayPropertyMap).filter(
      (token) => token !== "path"
    );
    if (unsupportedArrayTokens.length > 0) {
      throw new Error(
        `Unsupported repeated child tokens inside sheet_instances expression: ${unsupportedArrayTokens.join(", ")}`
      );
    }
    const paths = arrayPropertyMap.path ?? [];
    if (!paths.length && propertyMap.path) {
      paths.push(propertyMap.path);
    }
    sheetInstances._paths = paths;
    return sheetInstances;
  }
  get paths() {
    return [...this._paths];
  }
  set paths(value) {
    this._paths = [...value];
  }
  getChildren() {
    return [...this._paths];
  }
};
SxClass.register(SheetInstancesRoot);
var SheetInstancesRootPath = class _SheetInstancesRootPath extends SxClass {
  static token = "path";
  static parentToken = "sheet_instances";
  token = "path";
  _value = "";
  _pages = [];
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive, ...rest] = primitiveSexprs;
    const value = toStringValue(valuePrimitive);
    if (value === void 0) {
      throw new Error("sheet_instances path requires a string identifier");
    }
    const path = new _SheetInstancesRootPath();
    path._value = value;
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(rest, "sheet_instances_path");
    const unsupportedSingularTokens = Object.keys(propertyMap).filter(
      (token) => !SUPPORTED_ARRAY_TOKENS2.has(token)
    );
    if (unsupportedSingularTokens.length > 0) {
      throw new Error(
        `Unsupported singular child tokens inside sheet_instances path expression: ${unsupportedSingularTokens.join(", ")}`
      );
    }
    const unsupportedArrayTokens = Object.keys(arrayPropertyMap).filter(
      (token) => !SUPPORTED_ARRAY_TOKENS2.has(token)
    );
    if (unsupportedArrayTokens.length > 0) {
      throw new Error(
        `Unsupported repeated child tokens inside sheet_instances path expression: ${unsupportedArrayTokens.join(", ")}`
      );
    }
    const pages = arrayPropertyMap.page ?? [];
    if (!pages.length && propertyMap.page) {
      pages.push(propertyMap.page);
    }
    path._pages = pages;
    return path;
  }
  get value() {
    return this._value;
  }
  set value(newValue) {
    this._value = newValue;
  }
  get pages() {
    return [...this._pages];
  }
  set pages(value) {
    this._pages = [...value];
  }
  getChildren() {
    return [...this._pages];
  }
  getString() {
    const lines = [`(path ${quoteSExprString(this._value)}`];
    for (const page of this._pages) {
      lines.push(page.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SheetInstancesRootPath);
var SheetInstancesRootPage = class _SheetInstancesRootPage extends SxPrimitiveString {
  static token = "page";
  static parentToken = "sheet_instances_path";
  token = "page";
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive] = primitiveSexprs;
    const value = toStringValue(valuePrimitive);
    if (value === void 0) {
      throw new Error("sheet_instances page expects a string value");
    }
    return new _SheetInstancesRootPage(value);
  }
  getString() {
    return `(page ${quoteSExprString(this.value)})`;
  }
};
SxClass.register(SheetInstancesRootPage);

// lib/sexpr/classes/SheetInstances.ts
var SUPPORTED_CHILD_TOKENS = /* @__PURE__ */ new Set(["project", "path"]);
var parseSheetInstancesChildren = (primitiveSexprs) => {
  const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, "sheet_instances");
  const unsupportedSingularTokens = Object.keys(propertyMap).filter(
    (token) => !SUPPORTED_CHILD_TOKENS.has(token)
  );
  if (unsupportedSingularTokens.length > 0) {
    throw new Error(
      `sheet_instances encountered unsupported child token${unsupportedSingularTokens.length > 1 ? "s" : ""} ${unsupportedSingularTokens.map((token) => `"${token}"`).join(", ")}`
    );
  }
  const unsupportedArrayTokens = Object.keys(arrayPropertyMap).filter(
    (token) => !SUPPORTED_CHILD_TOKENS.has(token)
  );
  if (unsupportedArrayTokens.length > 0) {
    throw new Error(
      `sheet_instances encountered unsupported repeated child token${unsupportedArrayTokens.length > 1 ? "s" : ""} ${unsupportedArrayTokens.map((token) => `"${token}"`).join(", ")}`
    );
  }
  const projects = arrayPropertyMap.project ?? [];
  if (!projects.length && propertyMap.project) {
    projects.push(propertyMap.project);
  }
  const paths = arrayPropertyMap.path ?? [];
  if (!paths.length && propertyMap.path) {
    paths.push(propertyMap.path);
  }
  return { projects, paths };
};
var SheetInstances = class _SheetInstances extends SxClass {
  static token = "sheet_instances";
  static parentToken = "kicad_sch";
  token = "sheet_instances";
  _projects = [];
  _paths = [];
  static fromSexprPrimitives(primitiveSexprs) {
    const instances = new _SheetInstances();
    const { projects, paths } = parseSheetInstancesChildren(primitiveSexprs);
    instances.projects = projects;
    instances.paths = paths;
    return instances;
  }
  get projects() {
    return [...this._projects];
  }
  set projects(value) {
    this._projects = [...value];
  }
  get paths() {
    return [...this._paths];
  }
  set paths(value) {
    this._paths = [...value];
  }
  getChildren() {
    return [...this._projects, ...this._paths];
  }
  getString() {
    const children = this.getChildren();
    if (children.length === 0) {
      return `(${this.token})`;
    }
    const lines = [`(${this.token}`];
    for (const child of children) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SheetInstances);
var SheetInstancesForSheet = class _SheetInstancesForSheet extends SheetInstances {
  static token = "instances";
  static parentToken = "sheet";
  token = "instances";
  static fromSexprPrimitives(primitiveSexprs) {
    const instances = new _SheetInstancesForSheet();
    const { projects, paths } = parseSheetInstancesChildren(primitiveSexprs);
    instances.projects = projects;
    instances.paths = paths;
    return instances;
  }
};
SxClass.register(SheetInstancesForSheet);
var SheetInstancesProject = class _SheetInstancesProject extends SxClass {
  static token = "project";
  static parentToken = "sheet_instances";
  token = "project";
  name;
  paths = [];
  constructor(name) {
    super();
    this.name = name;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [namePrimitive, ...rest] = primitiveSexprs;
    const name = toStringValue(namePrimitive);
    if (name === void 0) {
      throw new Error("sheet project instances require a project name");
    }
    const project = new _SheetInstancesProject(name);
    const { arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(
      rest,
      "sheet_project"
    );
    project.paths = arrayPropertyMap.path ?? [];
    return project;
  }
  getChildren() {
    return [...this.paths];
  }
  getString() {
    const lines = [`(project ${quoteSExprString(this.name)}`];
    for (const path of this.paths) {
      lines.push(path.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SheetInstancesProject);
var SheetInstancePath = class _SheetInstancePath extends SxClass {
  static token = "path";
  static parentToken = "sheet_project";
  token = "path";
  value;
  pages = [];
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [pathPrimitive, ...rest] = primitiveSexprs;
    const value = toStringValue(pathPrimitive);
    if (value === void 0) {
      throw new Error("sheet instance path value must be a string");
    }
    const path = new _SheetInstancePath(value);
    const { arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(
      rest,
      "sheet_path"
    );
    path.pages = arrayPropertyMap.page ?? [];
    return path;
  }
  getChildren() {
    return [...this.pages];
  }
  getString() {
    const lines = [`(path ${quoteSExprString(this.value)}`];
    for (const page of this.pages) {
      lines.push(page.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(SheetInstancePath);
var SheetInstancePage = class _SheetInstancePage extends SxClass {
  static token = "page";
  static parentToken = "sheet_path";
  token = "page";
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive] = primitiveSexprs;
    const value = toStringValue(valuePrimitive);
    if (value === void 0) {
      throw new Error("sheet instance page value must be a string");
    }
    return new _SheetInstancePage(value);
  }
  getString() {
    return `(page ${quoteSExprString(this.value)})`;
  }
};
SxClass.register(SheetInstancePage);

// lib/sexpr/classes/SheetPin.ts
var electricalTypes = /* @__PURE__ */ new Set([
  "input",
  "output",
  "bidirectional",
  "tri_state",
  "passive"
]);
var SheetPin = class _SheetPin extends SxClass {
  static token = "pin";
  static parentToken = "sheet";
  token = "pin";
  name = "";
  electricalType = "input";
  _sxAt;
  _sxEffects;
  _sxUuid;
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length < 2) {
      throw new Error("sheet pin requires a name and electrical type");
    }
    const [rawName, rawType, ...rest] = primitiveSexprs;
    const name = toStringValue(rawName);
    if (name === void 0) {
      throw new Error("sheet pin name must be a string");
    }
    const electricalType = toStringValue(rawType);
    if (!electricalType || !electricalTypes.has(electricalType)) {
      throw new Error(
        `sheet pin electrical type must be one of: ${Array.from(electricalTypes).join(", ")}`
      );
    }
    const pin = new _SheetPin();
    pin.name = name;
    pin.electricalType = electricalType;
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      rest,
      this.token
    );
    pin._sxAt = propertyMap.at;
    pin._sxEffects = propertyMap.effects;
    pin._sxUuid = propertyMap.uuid;
    return pin;
  }
  get position() {
    return this._sxAt;
  }
  set position(value) {
    this._sxAt = value;
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxEffects) children.push(this._sxEffects);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
  getString() {
    const header = `(pin ${quoteSExprString(this.name)} ${this.electricalType}`;
    const bodyLines = this.getChildren().flatMap(
      (child) => indentLines(child.getString())
    );
    if (bodyLines.length === 0) {
      return `${header})`;
    }
    return [header, ...bodyLines, ")"].join("\n");
  }
};
SxClass.register(SheetPin);

// lib/sexpr/classes/SheetFill.ts
var SheetFill = class _SheetFill extends SxClass {
  static token = "fill";
  static parentToken = "sheet";
  token = "fill";
  _sxColor;
  static fromSexprPrimitives(primitiveSexprs) {
    const fill = new _SheetFill();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    fill._sxColor = propertyMap.color;
    return fill;
  }
  get color() {
    return this._sxColor;
  }
  set color(value) {
    this._sxColor = value;
  }
  getChildren() {
    return this._sxColor ? [this._sxColor] : [];
  }
};
SxClass.register(SheetFill);

// lib/sexpr/classes/SheetSize.ts
var SheetSize = class _SheetSize extends SxClass {
  static token = "size";
  static parentToken = "sheet";
  token = "size";
  width;
  height;
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const width = toNumberValue(primitiveSexprs[0]);
    const height = toNumberValue(primitiveSexprs[1]);
    if (width === void 0 || height === void 0) {
      throw new Error("sheet size requires numeric width and height");
    }
    return new _SheetSize(width, height);
  }
  toObject() {
    return { width: this.width, height: this.height };
  }
  getString() {
    return `(size ${this.width} ${this.height})`;
  }
};
SxClass.register(SheetSize);

// lib/sexpr/classes/SheetProperty.ts
var SheetProperty = class _SheetProperty extends SxClass {
  static token = "property";
  static parentToken = "sheet";
  token = "property";
  key;
  value;
  _sxId;
  _sxAt;
  _sxEffects;
  constructor(params) {
    super();
    this.key = params.key;
    this.value = params.value;
    this.id = params.id;
    this.at = params.at;
    this.effects = params.effects;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawKey, rawValue, ...rest] = primitiveSexprs;
    const key = toStringValue(rawKey);
    const value = toStringValue(rawValue);
    if (key === void 0 || value === void 0) {
      throw new Error("sheet property requires string key and value");
    }
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      rest,
      this.token
    );
    return new _SheetProperty({
      key,
      value,
      id: propertyMap.id,
      at: propertyMap.at,
      effects: propertyMap.effects
    });
  }
  get id() {
    return this._sxId?.value;
  }
  set id(value) {
    if (value === void 0) {
      this._sxId = void 0;
      return;
    }
    this._sxId = value instanceof SymbolPropertyId ? value : new SymbolPropertyId(value);
  }
  get idClass() {
    return this._sxId;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value;
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  getChildren() {
    const children = [];
    if (this._sxId) children.push(this._sxId);
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxEffects) children.push(this._sxEffects);
    return children;
  }
  getString() {
    const header = `(property ${quoteSExprString(this.key)} ${quoteSExprString(this.value)}`;
    const bodyLines = this.getChildren().flatMap(
      (child) => indentLines(child.getString())
    );
    if (bodyLines.length === 0) {
      return `${header})`;
    }
    return [header, ...bodyLines, ")"].join("\n");
  }
};
SxClass.register(SheetProperty);

// lib/sexpr/classes/Sheet.ts
var Sheet = class _Sheet extends SxClass {
  static token = "sheet";
  token = "sheet";
  _sxAt;
  _sxSize;
  _sxExcludeFromSim;
  _sxInBom;
  _sxOnBoard;
  _sxDnp;
  _sxFieldsAutoplaced;
  _sxStroke;
  _sxFill;
  _sxUuid;
  _properties = [];
  _pins = [];
  _sxInstances;
  constructor(params = {}) {
    super();
    if (params.position !== void 0) {
      this.position = params.position;
    }
    if (params.size !== void 0) {
      this.size = params.size;
    }
    if (params.excludeFromSim !== void 0) {
      this.excludeFromSim = typeof params.excludeFromSim === "boolean" ? params.excludeFromSim : params.excludeFromSim.value;
    }
    if (params.inBom !== void 0) {
      this.inBom = typeof params.inBom === "boolean" ? params.inBom : params.inBom.value;
    }
    if (params.onBoard !== void 0) {
      this.onBoard = typeof params.onBoard === "boolean" ? params.onBoard : params.onBoard.value;
    }
    if (params.dnp !== void 0) {
      this.dnp = typeof params.dnp === "boolean" ? params.dnp : params.dnp.value;
    }
    if (params.fieldsAutoplaced !== void 0) {
      this.fieldsAutoplaced = typeof params.fieldsAutoplaced === "boolean" ? params.fieldsAutoplaced : params.fieldsAutoplaced.value;
    }
    if (params.stroke !== void 0) {
      this.stroke = params.stroke;
    }
    if (params.fill !== void 0) {
      this.fill = params.fill;
    }
    if (params.uuid !== void 0) {
      this.uuid = params.uuid;
    }
    if (params.properties !== void 0) {
      this.properties = params.properties;
    }
    if (params.pins !== void 0) {
      this.pins = params.pins;
    }
    if (params.instances !== void 0) {
      this.instances = params.instances;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const sheet = new _Sheet();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    sheet._sxAt = propertyMap.at;
    sheet._sxSize = propertyMap.size;
    sheet._sxExcludeFromSim = propertyMap.exclude_from_sim;
    sheet._sxInBom = propertyMap.in_bom;
    sheet._sxOnBoard = propertyMap.on_board;
    sheet._sxDnp = propertyMap.dnp;
    sheet._sxFieldsAutoplaced = propertyMap.fields_autoplaced;
    sheet._sxStroke = propertyMap.stroke;
    sheet._sxFill = propertyMap.fill;
    sheet._sxUuid = propertyMap.uuid;
    sheet._properties = arrayPropertyMap.property ?? [];
    sheet._pins = arrayPropertyMap.pin ?? [];
    sheet._sxInstances = propertyMap.instances;
    return sheet;
  }
  get position() {
    return this._sxAt;
  }
  set position(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get size() {
    return this._sxSize?.toObject();
  }
  set size(value) {
    if (value === void 0) {
      this._sxSize = void 0;
      return;
    }
    if (value instanceof SheetSize) {
      this._sxSize = value;
      return;
    }
    this._sxSize = new SheetSize(value.width, value.height);
  }
  get excludeFromSim() {
    return this._sxExcludeFromSim?.value ?? false;
  }
  set excludeFromSim(value) {
    this._sxExcludeFromSim = new ExcludeFromSim(value);
  }
  get inBom() {
    return this._sxInBom?.value ?? false;
  }
  set inBom(value) {
    this._sxInBom = new InBom(value);
  }
  get onBoard() {
    return this._sxOnBoard?.value ?? false;
  }
  set onBoard(value) {
    this._sxOnBoard = new OnBoard(value);
  }
  get dnp() {
    return this._sxDnp?.value ?? false;
  }
  set dnp(value) {
    this._sxDnp = new Dnp(value);
  }
  get fieldsAutoplaced() {
    return this._sxFieldsAutoplaced?.value ?? false;
  }
  set fieldsAutoplaced(value) {
    this._sxFieldsAutoplaced = new FieldsAutoplaced(value);
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get fill() {
    return this._sxFill;
  }
  set fill(value) {
    this._sxFill = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get properties() {
    return this._properties;
  }
  set properties(value) {
    this._properties = value;
  }
  get pins() {
    return this._pins;
  }
  set pins(value) {
    this._pins = value;
  }
  get instances() {
    return this._sxInstances;
  }
  set instances(value) {
    this._sxInstances = value;
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxSize) children.push(this._sxSize);
    if (this._sxExcludeFromSim) children.push(this._sxExcludeFromSim);
    if (this._sxInBom) children.push(this._sxInBom);
    if (this._sxOnBoard) children.push(this._sxOnBoard);
    if (this._sxDnp) children.push(this._sxDnp);
    if (this._sxFieldsAutoplaced) children.push(this._sxFieldsAutoplaced);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxFill) children.push(this._sxFill);
    if (this._sxUuid) children.push(this._sxUuid);
    children.push(...this._properties);
    children.push(...this._pins);
    if (this._sxInstances) children.push(this._sxInstances);
    return children;
  }
};
SxClass.register(Sheet);

// lib/sexpr/classes/KicadSch.ts
var SINGLE_CHILD_TOKENS = /* @__PURE__ */ new Set([
  "version",
  "generator",
  "generator_version",
  "uuid",
  "paper",
  "title_block",
  "lib_symbols",
  "embedded_fonts"
]);
var MULTI_CHILD_TOKENS = /* @__PURE__ */ new Set([
  "property",
  "image",
  "sheet",
  "symbol",
  "text",
  "label",
  "global_label",
  "junction",
  "wire",
  "no_connect",
  "sheet_instances",
  "polyline"
]);
var SUPPORTED_CHILD_TOKENS2 = /* @__PURE__ */ new Set([
  ...SINGLE_CHILD_TOKENS,
  ...MULTI_CHILD_TOKENS
]);
var KicadSch = class _KicadSch extends SxClass {
  static token = "kicad_sch";
  token = "kicad_sch";
  _sxVersion;
  _sxGenerator;
  _sxGeneratorVersion;
  _sxUuid;
  _sxPaper;
  _sxTitleBlock;
  _sxLibSymbols;
  _sheetInstances = [];
  _sxEmbeddedFonts;
  _properties = [];
  _images = [];
  _sheets = [];
  _symbols = [];
  _texts = [];
  _labels = [];
  _globalLabels = [];
  _wires = [];
  _junctions = [];
  _noConnects = [];
  _polylines = [];
  constructor(params = {}) {
    super();
    if (params.version instanceof KicadSchVersion) {
      this._sxVersion = params.version;
    } else if (params.version !== void 0) {
      this.version = params.version;
    }
    if (params.generator instanceof KicadSchGenerator) {
      this._sxGenerator = params.generator;
    } else if (params.generator !== void 0) {
      this.generator = params.generator;
    }
    if (params.generatorVersion instanceof KicadSchGeneratorVersion) {
      this._sxGeneratorVersion = params.generatorVersion;
    } else if (params.generatorVersion !== void 0) {
      this.generatorVersion = params.generatorVersion;
    }
    if (params.uuid !== void 0) {
      this.uuid = params.uuid;
    }
    if (params.paper !== void 0) {
      this.paper = params.paper;
    }
    if (params.titleBlock !== void 0) {
      this.titleBlock = params.titleBlock;
    }
    if (params.libSymbols !== void 0) {
      this.libSymbols = params.libSymbols;
    }
    if (params.sheetInstances !== void 0) {
      this.sheetInstances = params.sheetInstances;
    }
    if (params.embeddedFonts !== void 0) {
      this.embeddedFonts = params.embeddedFonts;
    }
    if (params.properties !== void 0) {
      this.properties = params.properties;
    }
    if (params.images !== void 0) {
      this.images = params.images;
    }
    if (params.sheets !== void 0) {
      this.sheets = params.sheets;
    }
    if (params.symbols !== void 0) {
      this.symbols = params.symbols;
    }
    if (params.texts !== void 0) {
      this.texts = params.texts;
    }
    if (params.labels !== void 0) {
      this.labels = params.labels;
    }
    if (params.globalLabels !== void 0) {
      this.globalLabels = params.globalLabels;
    }
    if (params.wires !== void 0) {
      this.wires = params.wires;
    }
    if (params.junctions !== void 0) {
      this.junctions = params.junctions;
    }
    if (params.noConnects !== void 0) {
      this.noConnects = params.noConnects;
    }
    if (params.polylines !== void 0) {
      this.polylines = params.polylines;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive)) {
        throw new Error(
          `kicad_sch encountered unexpected primitive child: ${JSON.stringify(primitive)}`
        );
      }
      if (primitive.length === 0 || typeof primitive[0] !== "string") {
        throw new Error(
          `kicad_sch encountered invalid child expression: ${JSON.stringify(primitive)}`
        );
      }
    }
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_CHILD_TOKENS2.has(token)) {
        throw new Error(
          `kicad_sch encountered unsupported child token "${token}"`
        );
      }
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_CHILD_TOKENS2.has(token)) {
        throw new Error(
          `kicad_sch encountered unsupported child token "${token}"`
        );
      }
      if (!MULTI_CHILD_TOKENS.has(token) && entries.length > 1) {
        throw new Error(
          `kicad_sch does not support repeated child token "${token}"`
        );
      }
    }
    return new _KicadSch({
      version: propertyMap.version,
      generator: propertyMap.generator,
      generatorVersion: propertyMap.generator_version,
      uuid: propertyMap.uuid,
      paper: propertyMap.paper,
      titleBlock: propertyMap.title_block,
      libSymbols: propertyMap.lib_symbols,
      sheetInstances: arrayPropertyMap.sheet_instances,
      embeddedFonts: propertyMap.embedded_fonts,
      properties: arrayPropertyMap.property ?? [],
      images: arrayPropertyMap.image ?? [],
      sheets: arrayPropertyMap.sheet ?? [],
      symbols: arrayPropertyMap.symbol ?? [],
      texts: arrayPropertyMap.text ?? [],
      labels: arrayPropertyMap.label ?? [],
      globalLabels: arrayPropertyMap.global_label ?? [],
      junctions: arrayPropertyMap.junction ?? [],
      wires: arrayPropertyMap.wire ?? [],
      noConnects: arrayPropertyMap.no_connect ?? [],
      polylines: arrayPropertyMap.polyline ?? []
    });
  }
  get version() {
    return this._sxVersion?.value;
  }
  set version(value) {
    this._sxVersion = value === void 0 ? void 0 : new KicadSchVersion(value);
  }
  get generator() {
    return this._sxGenerator?.value;
  }
  set generator(value) {
    this._sxGenerator = value === void 0 ? void 0 : new KicadSchGenerator(value);
  }
  get generatorVersion() {
    return this._sxGeneratorVersion?.value;
  }
  set generatorVersion(value) {
    this._sxGeneratorVersion = value === void 0 ? void 0 : new KicadSchGeneratorVersion(value);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get paper() {
    return this._sxPaper;
  }
  set paper(value) {
    this._sxPaper = value;
  }
  get titleBlock() {
    return this._sxTitleBlock;
  }
  set titleBlock(value) {
    this._sxTitleBlock = value;
  }
  get libSymbols() {
    return this._sxLibSymbols;
  }
  set libSymbols(value) {
    this._sxLibSymbols = value;
  }
  get sheetInstances() {
    return [...this._sheetInstances];
  }
  set sheetInstances(value) {
    if (value === void 0) {
      this._sheetInstances = [];
      return;
    }
    this._sheetInstances = Array.isArray(value) ? [...value] : [value];
  }
  get embeddedFonts() {
    return this._sxEmbeddedFonts;
  }
  set embeddedFonts(value) {
    this._sxEmbeddedFonts = value;
  }
  get properties() {
    return [...this._properties];
  }
  set properties(value) {
    this._properties = [...value];
  }
  get images() {
    return [...this._images];
  }
  set images(value) {
    this._images = [...value];
  }
  get sheets() {
    return [...this._sheets];
  }
  set sheets(value) {
    this._sheets = [...value];
  }
  get symbols() {
    return [...this._symbols];
  }
  set symbols(value) {
    this._symbols = [...value];
  }
  get texts() {
    return [...this._texts];
  }
  set texts(value) {
    this._texts = [...value];
  }
  get labels() {
    return [...this._labels];
  }
  set labels(value) {
    this._labels = [...value];
  }
  get globalLabels() {
    return [...this._globalLabels];
  }
  set globalLabels(value) {
    this._globalLabels = [...value];
  }
  get junctions() {
    return [...this._junctions];
  }
  set junctions(value) {
    this._junctions = [...value];
  }
  get wires() {
    return [...this._wires];
  }
  set wires(value) {
    this._wires = [...value];
  }
  get noConnects() {
    return [...this._noConnects];
  }
  set noConnects(value) {
    this._noConnects = [...value];
  }
  get polylines() {
    return [...this._polylines];
  }
  set polylines(value) {
    this._polylines = [...value];
  }
  getChildren() {
    const children = [];
    if (this._sxVersion) children.push(this._sxVersion);
    if (this._sxGenerator) children.push(this._sxGenerator);
    if (this._sxGeneratorVersion) children.push(this._sxGeneratorVersion);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxPaper) children.push(this._sxPaper);
    if (this._sxTitleBlock) children.push(this._sxTitleBlock);
    if (this._sxLibSymbols) children.push(this._sxLibSymbols);
    children.push(...this._sheetInstances);
    if (this._sxEmbeddedFonts) children.push(this._sxEmbeddedFonts);
    children.push(...this._properties);
    children.push(...this._images);
    children.push(...this._sheets);
    children.push(...this._symbols);
    children.push(...this._texts);
    children.push(...this._labels);
    children.push(...this._globalLabels);
    children.push(...this._junctions);
    children.push(...this._wires);
    children.push(...this._noConnects);
    children.push(...this._polylines);
    return children;
  }
};
SxClass.register(KicadSch);

// lib/sexpr/classes/FootprintAttr.ts
var FLAG_TOKENS = /* @__PURE__ */ new Set([
  "board_only",
  "exclude_from_pos_files",
  "exclude_from_bom",
  "allow_soldermask_bridges"
]);
var FootprintAttr = class _FootprintAttr extends SxClass {
  static token = "attr";
  static parentToken = "footprint";
  token = "attr";
  _type;
  _boardOnly = false;
  _excludeFromPosFiles = false;
  _excludeFromBom = false;
  _allowSoldermaskBridges = false;
  static fromSexprPrimitives(primitiveSexprs) {
    const attr = new _FootprintAttr();
    for (const primitive of primitiveSexprs) {
      if (typeof primitive !== "string") {
        throw new Error(
          `attr encountered unsupported child: ${JSON.stringify(primitive)}`
        );
      }
      if (FLAG_TOKENS.has(primitive)) {
        attr.applyFlag(primitive);
        continue;
      }
      if (attr._type === void 0) {
        attr._type = primitive;
        continue;
      }
      throw new Error(
        `attr encountered duplicate or unknown token "${primitive}"`
      );
    }
    return attr;
  }
  applyFlag(flag) {
    switch (flag) {
      case "board_only":
        this._boardOnly = true;
        break;
      case "exclude_from_pos_files":
        this._excludeFromPosFiles = true;
        break;
      case "exclude_from_bom":
        this._excludeFromBom = true;
        break;
      case "allow_soldermask_bridges":
        this._allowSoldermaskBridges = true;
        break;
    }
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  get boardOnly() {
    return this._boardOnly;
  }
  set boardOnly(value) {
    this._boardOnly = value;
  }
  get excludeFromPosFiles() {
    return this._excludeFromPosFiles;
  }
  set excludeFromPosFiles(value) {
    this._excludeFromPosFiles = value;
  }
  get excludeFromBom() {
    return this._excludeFromBom;
  }
  set excludeFromBom(value) {
    this._excludeFromBom = value;
  }
  get allowSoldermaskBridges() {
    return this._allowSoldermaskBridges;
  }
  set allowSoldermaskBridges(value) {
    this._allowSoldermaskBridges = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    const tokens = ["attr"];
    if (this._type) tokens.push(this._type);
    if (this._boardOnly) tokens.push("board_only");
    if (this._excludeFromPosFiles) tokens.push("exclude_from_pos_files");
    if (this._excludeFromBom) tokens.push("exclude_from_bom");
    if (this._allowSoldermaskBridges) tokens.push("allow_soldermask_bridges");
    return `(${tokens.join(" ")})`;
  }
};
SxClass.register(FootprintAttr);

// lib/sexpr/classes/FootprintAutoplaceCost180.ts
var FootprintAutoplaceCost180 = class extends SxPrimitiveNumber {
  static token = "autoplace_cost180";
  static parentToken = "footprint";
  token = "autoplace_cost180";
};
SxClass.register(FootprintAutoplaceCost180);

// lib/sexpr/classes/FootprintAutoplaceCost90.ts
var FootprintAutoplaceCost90 = class extends SxPrimitiveNumber {
  static token = "autoplace_cost90";
  static parentToken = "footprint";
  token = "autoplace_cost90";
};
SxClass.register(FootprintAutoplaceCost90);

// lib/sexpr/classes/FootprintClearance.ts
var FootprintClearance = class extends SxPrimitiveNumber {
  static token = "clearance";
  static parentToken = "footprint";
  token = "clearance";
};
SxClass.register(FootprintClearance);

// lib/sexpr/classes/FootprintDescr.ts
var FootprintDescr = class _FootprintDescr extends SxClass {
  static token = "descr";
  static parentToken = "footprint";
  token = "descr";
  _value;
  constructor(value) {
    super();
    this._value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const value = toStringValue(primitiveSexprs[0]);
    if (value === void 0) {
      throw new Error("descr expects a string value");
    }
    return new _FootprintDescr(value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(descr ${quoteSExprString(this._value)})`;
  }
};
SxClass.register(FootprintDescr);

// lib/sexpr/classes/FootprintNetTiePadGroups.ts
var FootprintNetTiePadGroups = class _FootprintNetTiePadGroups extends SxClass {
  static token = "net_tie_pad_groups";
  static parentToken = "footprint";
  token = "net_tie_pad_groups";
  _groups = [];
  constructor(groups) {
    super();
    this.groups = groups;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const groups = primitiveSexprs.map((primitive) => {
      const value = toStringValue(primitive);
      if (value === void 0) {
        throw new Error(
          `net_tie_pad_groups expects string group entries, received ${JSON.stringify(primitive)}`
        );
      }
      return value;
    });
    return new _FootprintNetTiePadGroups(groups);
  }
  get groups() {
    return [...this._groups];
  }
  set groups(values) {
    this._groups = values.map((value) => String(value));
  }
  getChildren() {
    return [];
  }
  getString() {
    const rendered = this._groups.map((group) => quoteSExprString(group)).join(" ");
    return `(net_tie_pad_groups ${rendered})`;
  }
};
SxClass.register(FootprintNetTiePadGroups);

// lib/sexpr/classes/FootprintPath.ts
var FootprintPath = class _FootprintPath extends SxClass {
  static token = "path";
  static parentToken = "footprint";
  token = "path";
  _value;
  constructor(value) {
    super();
    this._value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const value = toStringValue(primitiveSexprs[0]);
    if (value === void 0) {
      throw new Error("path expects a string value");
    }
    return new _FootprintPath(value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(path ${quoteSExprString(this._value)})`;
  }
};
SxClass.register(FootprintPath);

// lib/sexpr/classes/FootprintPrivateLayers.ts
var FootprintPrivateLayers = class _FootprintPrivateLayers extends SxClass {
  static token = "private_layers";
  static parentToken = "footprint";
  token = "private_layers";
  _layers = [];
  constructor(layers) {
    super();
    this.layers = layers;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const layers = primitiveSexprs.map((primitive) => {
      const value = toStringValue(primitive);
      if (value === void 0) {
        throw new Error(
          `private_layers expects string layer names, received ${JSON.stringify(primitive)}`
        );
      }
      return value;
    });
    return new _FootprintPrivateLayers(layers);
  }
  get layers() {
    return [...this._layers];
  }
  set layers(values) {
    this._layers = values.map((value) => String(value));
  }
  getChildren() {
    return [];
  }
  getString() {
    const rendered = this._layers.map(
      (layer) => /^[^\s()"]+$/u.test(layer) && !["nil", "#t", "#f"].includes(layer) ? layer : quoteSExprString(layer)
    ).join(" ");
    return `(private_layers ${rendered})`;
  }
};
SxClass.register(FootprintPrivateLayers);

// lib/sexpr/classes/FootprintSolderMaskMargin.ts
var FootprintSolderMaskMargin = class extends SxPrimitiveNumber {
  static token = "solder_mask_margin";
  static parentToken = "footprint";
  token = "solder_mask_margin";
};
SxClass.register(FootprintSolderMaskMargin);

// lib/sexpr/classes/FootprintSolderPasteMargin.ts
var FootprintSolderPasteMargin = class extends SxPrimitiveNumber {
  static token = "solder_paste_margin";
  static parentToken = "footprint";
  token = "solder_paste_margin";
};
SxClass.register(FootprintSolderPasteMargin);

// lib/sexpr/classes/FootprintSolderPasteRatio.ts
var FootprintSolderPasteRatio = class extends SxPrimitiveNumber {
  static token = "solder_paste_ratio";
  static parentToken = "footprint";
  token = "solder_paste_ratio";
};
SxClass.register(FootprintSolderPasteRatio);

// lib/sexpr/classes/FootprintTags.ts
var FootprintTags = class _FootprintTags extends SxClass {
  static token = "tags";
  static parentToken = "footprint";
  token = "tags";
  _value;
  constructor(value) {
    super();
    this._value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const value = toStringValue(primitiveSexprs[0]);
    if (value === void 0) {
      throw new Error("tags expects a string value");
    }
    return new _FootprintTags(value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(tags ${quoteSExprString(this._value)})`;
  }
};
SxClass.register(FootprintTags);

// lib/sexpr/classes/FootprintTedit.ts
var FootprintTedit = class _FootprintTedit extends SxPrimitiveString {
  static token = "tedit";
  static parentToken = "footprint";
  token = "tedit";
  static fromSexprPrimitives(primitiveSexprs) {
    const value = toStringValue(primitiveSexprs[0]);
    if (value === void 0) {
      throw new Error("tedit expects a string value");
    }
    return new _FootprintTedit(value);
  }
};
SxClass.register(FootprintTedit);

// lib/sexpr/classes/FootprintThermalGap.ts
var FootprintThermalGap = class extends SxPrimitiveNumber {
  static token = "thermal_gap";
  static parentToken = "footprint";
  token = "thermal_gap";
};
SxClass.register(FootprintThermalGap);

// lib/sexpr/classes/FootprintThermalWidth.ts
var FootprintThermalWidth = class extends SxPrimitiveNumber {
  static token = "thermal_width";
  static parentToken = "footprint";
  token = "thermal_width";
};
SxClass.register(FootprintThermalWidth);

// lib/sexpr/classes/FootprintZoneConnect.ts
var FootprintZoneConnect = class extends SxPrimitiveNumber {
  static token = "zone_connect";
  static parentToken = "footprint";
  token = "zone_connect";
};
SxClass.register(FootprintZoneConnect);

// lib/sexpr/classes/PadChamfer.ts
var PadChamfer = class _PadChamfer extends SxClass {
  static token = "chamfer";
  static parentToken = "pad";
  token = "chamfer";
  _corners = [];
  constructor(corners) {
    super();
    this.corners = corners;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const corners = primitiveSexprs.map((primitive) => {
      const corner = toStringValue(primitive);
      if (corner === void 0) {
        return printSExpr(primitive);
      }
      return corner;
    });
    return new _PadChamfer(corners);
  }
  get corners() {
    return [...this._corners];
  }
  set corners(values) {
    this._corners = values.map((value) => String(value));
  }
  getChildren() {
    return [];
  }
  getString() {
    if (this._corners.length === 0) {
      return "(chamfer)";
    }
    return `(chamfer ${this._corners.join(" ")})`;
  }
};
SxClass.register(PadChamfer);

// lib/sexpr/classes/PadChamferRatio.ts
var PadChamferRatio = class extends SxPrimitiveNumber {
  static token = "chamfer_ratio";
  static parentToken = "pad";
  token = "chamfer_ratio";
};
SxClass.register(PadChamferRatio);

// lib/sexpr/classes/PadClearance.ts
var PadClearance = class extends SxPrimitiveNumber {
  static token = "clearance";
  static parentToken = "pad";
  token = "clearance";
};
SxClass.register(PadClearance);

// lib/sexpr/classes/PadDieLength.ts
var PadDieLength = class extends SxPrimitiveNumber {
  static token = "die_length";
  static parentToken = "pad";
  token = "die_length";
};
SxClass.register(PadDieLength);

// lib/sexpr/classes/PadDrillOffset.ts
var PadDrillOffset = class _PadDrillOffset extends SxClass {
  static token = "offset";
  static parentToken = "drill";
  token = "offset";
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const x = toNumberValue(primitiveSexprs[0]);
    const y = toNumberValue(primitiveSexprs[1]);
    if (x === void 0 || y === void 0) {
      throw new Error("drill offset requires x and y numeric values");
    }
    return new _PadDrillOffset(x, y);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(offset ${this._x} ${this._y})`;
  }
};
SxClass.register(PadDrillOffset);

// lib/sexpr/classes/PadDrill.ts
var PadDrill = class _PadDrill extends SxClass {
  static token = "drill";
  static parentToken = "pad";
  token = "drill";
  _oval = false;
  _diameter;
  _width;
  _sxOffset;
  constructor({
    oval = false,
    diameter,
    width,
    offset
  }) {
    super();
    this._oval = oval;
    this._diameter = diameter;
    this._width = width;
    if (offset instanceof PadDrillOffset) {
      this._sxOffset = offset;
    } else if (offset) {
      this._sxOffset = new PadDrillOffset(offset.x, offset.y);
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const remaining = [...primitiveSexprs];
    let oval = false;
    if (remaining[0] === "oval") {
      oval = true;
      remaining.shift();
    }
    const diameter = toNumberValue(remaining.shift());
    if (diameter === void 0) {
      throw new Error("drill requires a diameter value");
    }
    let width;
    const potentialWidth = toNumberValue(remaining[0]);
    if (potentialWidth !== void 0) {
      width = potentialWidth;
      remaining.shift();
    }
    const drill = new _PadDrill({ oval, diameter, width });
    for (const primitive of remaining) {
      if (!Array.isArray(primitive)) {
        throw new Error(
          `drill encountered unexpected primitive child: ${JSON.stringify(primitive)}`
        );
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (!(parsed instanceof PadDrillOffset)) {
        throw new Error(
          `drill encountered unsupported child token: ${printSExpr(primitive)}`
        );
      }
      if (drill._sxOffset) {
        throw new Error("drill does not support multiple offset children");
      }
      drill._sxOffset = parsed;
    }
    return drill;
  }
  get oval() {
    return this._oval;
  }
  set oval(value) {
    this._oval = value;
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
  get offset() {
    return this._sxOffset;
  }
  set offset(value) {
    if (value === void 0) {
      this._sxOffset = void 0;
      return;
    }
    this._sxOffset = value instanceof PadDrillOffset ? value : new PadDrillOffset(value.x, value.y);
  }
  getChildren() {
    return this._sxOffset ? [this._sxOffset] : [];
  }
  getString() {
    const tokens = [];
    if (this._oval) tokens.push("oval");
    tokens.push(String(this._diameter));
    if (this._width !== void 0) tokens.push(String(this._width));
    if (!this._sxOffset) {
      return `(drill ${tokens.join(" ")})`;
    }
    const lines = [`(drill ${tokens.join(" ")}`];
    lines.push(this._sxOffset.getStringIndented());
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(PadDrill);

// lib/sexpr/classes/PadLayers.ts
var PadLayers = class _PadLayers extends SxClass {
  static token = "layers";
  static parentToken = "pad";
  token = "layers";
  _layers = [];
  constructor(layers) {
    super();
    this.layers = layers;
  }
  static from(input) {
    if (input instanceof _PadLayers) {
      return input;
    }
    return new _PadLayers(input);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const layers = primitiveSexprs.map((primitive) => {
      const value = toStringValue(primitive);
      if (value === void 0) {
        return printSExpr(primitive);
      }
      return value;
    });
    return new _PadLayers(layers);
  }
  get layers() {
    return [...this._layers];
  }
  set layers(values) {
    this._layers = values.map((value) => String(value));
  }
  getChildren() {
    return [];
  }
  getString() {
    if (this._layers.length === 0) {
      return "(layers)";
    }
    const rendered = this._layers.map((layer) => {
      if (/^[^\s()"]+$/u.test(layer) && !["nil", "#t", "#f"].includes(layer)) {
        return layer;
      }
      return quoteSExprString(layer);
    }).join(" ");
    return `(layers ${rendered})`;
  }
};
SxClass.register(PadLayers);

// lib/sexpr/classes/PadNet.ts
var PadNet = class _PadNet extends SxClass {
  static token = "net";
  static parentToken = "pad";
  token = "net";
  _id;
  _name;
  constructor(id, name) {
    super();
    this._id = id;
    this._name = name;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const id = toNumberValue(primitiveSexprs[0]);
    const name = toStringValue(primitiveSexprs[1]);
    if (id === void 0 || name === void 0) {
      throw new Error("pad net requires numeric id and string name");
    }
    return new _PadNet(id, name);
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(net ${this._id} ${quoteSExprString(this._name)})`;
  }
};
SxClass.register(PadNet);

// lib/sexpr/classes/PadOptions.ts
var CLEARANCE_TYPES = ["outline", "convexhull"];
var ANCHOR_SHAPES = ["rect", "circle"];
var PadOptions = class _PadOptions extends SxClass {
  static token = "options";
  static parentToken = "pad";
  token = "options";
  _sxClearance;
  _sxAnchor;
  static fromSexprPrimitives(primitiveSexprs) {
    const options = new _PadOptions();
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `pad options encountered invalid child expression: ${JSON.stringify(primitive)}`
        );
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (!(parsed instanceof SxClass)) {
        throw new Error(
          `pad options child did not resolve to an SxClass: ${JSON.stringify(primitive)}`
        );
      }
      if (parsed instanceof PadOptionsClearance) {
        if (options._sxClearance) {
          throw new Error("pad options encountered duplicate clearance tokens");
        }
        options._sxClearance = parsed;
        continue;
      }
      if (parsed instanceof PadOptionsAnchor) {
        if (options._sxAnchor) {
          throw new Error("pad options encountered duplicate anchor tokens");
        }
        options._sxAnchor = parsed;
        continue;
      }
      throw new Error(
        `pad options encountered unsupported token "${parsed.token}"`
      );
    }
    return options;
  }
  get clearance() {
    return this._sxClearance?.type;
  }
  set clearance(value) {
    this._sxClearance = value ? new PadOptionsClearance(value) : void 0;
  }
  get anchor() {
    return this._sxAnchor?.shape;
  }
  set anchor(value) {
    this._sxAnchor = value ? new PadOptionsAnchor(value) : void 0;
  }
  getChildren() {
    const children = [];
    if (this._sxClearance) children.push(this._sxClearance);
    if (this._sxAnchor) children.push(this._sxAnchor);
    return children;
  }
};
SxClass.register(PadOptions);
var PadOptionsClearance = class _PadOptionsClearance extends SxClass {
  static token = "clearance";
  static parentToken = "options";
  token = "clearance";
  _type;
  constructor(type) {
    super();
    this._type = type;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [raw] = primitiveSexprs;
    const stringValue = toStringValue(raw);
    if (stringValue === void 0) {
      throw new Error("pad options clearance requires a string value");
    }
    if (!CLEARANCE_TYPES.includes(stringValue)) {
      throw new Error(
        `pad options clearance must be one of ${CLEARANCE_TYPES.join(", ")}`
      );
    }
    return new _PadOptionsClearance(stringValue);
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(clearance ${this._type})`;
  }
};
SxClass.register(PadOptionsClearance);
var PadOptionsAnchor = class _PadOptionsAnchor extends SxClass {
  static token = "anchor";
  static parentToken = "options";
  token = "anchor";
  _shape;
  constructor(shape) {
    super();
    this._shape = shape;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [raw] = primitiveSexprs;
    const stringValue = toStringValue(raw);
    if (stringValue === void 0) {
      throw new Error("pad options anchor requires a string value");
    }
    if (!ANCHOR_SHAPES.includes(stringValue)) {
      throw new Error(
        `pad options anchor must be one of ${ANCHOR_SHAPES.join(", ")}`
      );
    }
    return new _PadOptionsAnchor(stringValue);
  }
  get shape() {
    return this._shape;
  }
  set shape(value) {
    this._shape = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(anchor ${this._shape})`;
  }
};
SxClass.register(PadOptionsAnchor);

// lib/sexpr/classes/PadPinFunction.ts
var PadPinFunction = class extends SxPrimitiveString {
  static token = "pinfunction";
  static parentToken = "pad";
  token = "pinfunction";
};
SxClass.register(PadPinFunction);

// lib/sexpr/classes/PadPinType.ts
var PadPinType = class extends SxPrimitiveString {
  static token = "pintype";
  static parentToken = "pad";
  token = "pintype";
};
SxClass.register(PadPinType);

// lib/sexpr/classes/GrLineEnd.ts
var GrLineEnd = class _GrLineEnd extends SxClass {
  static token = "end";
  static parentToken = "gr_line";
  token = "end";
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error("gr_line end expects two numeric arguments");
    }
    return new _GrLineEnd(x, y);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  toObject() {
    return { x: this._x, y: this._y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(end ${this._x} ${this._y})`;
  }
};
SxClass.register(GrLineEnd);

// lib/sexpr/classes/GrLineStart.ts
var GrLineStart = class _GrLineStart extends SxClass {
  static token = "start";
  static parentToken = "gr_line";
  token = "start";
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error("gr_line start expects two numeric arguments");
    }
    return new _GrLineStart(x, y);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  toObject() {
    return { x: this._x, y: this._y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(start ${this._x} ${this._y})`;
  }
};
SxClass.register(GrLineStart);

// lib/sexpr/classes/PadPrimitiveGrLine.ts
var SUPPORTED_TOKENS8 = /* @__PURE__ */ new Set(["start", "end", "width"]);
var PadPrimitiveGrLine = class _PadPrimitiveGrLine extends SxClass {
  static token = "gr_line";
  static parentToken = "primitives";
  token = "gr_line";
  _sxStart;
  _sxEnd;
  _sxWidth;
  static fromSexprPrimitives(primitiveSexprs) {
    const line = new _PadPrimitiveGrLine();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_TOKENS8.has(token)) {
        throw new Error(
          `pad primitive gr_line encountered unsupported child token "${token}"`
        );
      }
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS8.has(token)) {
        throw new Error(
          `pad primitive gr_line encountered unsupported child token "${token}"`
        );
      }
      if (entries.length > 1) {
        throw new Error(
          `pad primitive gr_line does not support repeated "${token}" tokens`
        );
      }
    }
    line._sxStart = propertyMap.start;
    line._sxEnd = propertyMap.end;
    line._sxWidth = propertyMap.width;
    if (!line._sxStart) {
      throw new Error("pad primitive gr_line requires a start child token");
    }
    if (!line._sxEnd) {
      throw new Error("pad primitive gr_line requires an end child token");
    }
    return line;
  }
  get start() {
    return this._sxStart;
  }
  set start(value) {
    if (value === void 0) {
      this._sxStart = void 0;
      return;
    }
    if (value instanceof GrLineStart) {
      this._sxStart = value;
      return;
    }
    this._sxStart = new GrLineStart(value.x, value.y);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    if (value === void 0) {
      this._sxEnd = void 0;
      return;
    }
    if (value instanceof GrLineEnd) {
      this._sxEnd = value;
      return;
    }
    this._sxEnd = new GrLineEnd(value.x, value.y);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    this._sxWidth = value instanceof Width ? value : new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxWidth) children.push(this._sxWidth);
    return children;
  }
  getString() {
    const lines = ["(gr_line"];
    if (this._sxStart) lines.push(this._sxStart.getStringIndented());
    if (this._sxEnd) lines.push(this._sxEnd.getStringIndented());
    if (this._sxWidth) lines.push(this._sxWidth.getStringIndented());
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(PadPrimitiveGrLine);

// lib/sexpr/classes/PadPrimitiveGrArc.ts
var SUPPORTED_TOKENS9 = /* @__PURE__ */ new Set(["start", "mid", "end", "width"]);
var PadPrimitiveGrArc = class _PadPrimitiveGrArc extends SxClass {
  static token = "gr_arc";
  static parentToken = "primitives";
  token = "gr_arc";
  _sxStart;
  _sxMid;
  _sxEnd;
  _sxWidth;
  constructor(params = {}) {
    super();
    if (params.start !== void 0) this.start = params.start;
    if (params.mid !== void 0) this.mid = params.mid;
    if (params.end !== void 0) this.end = params.end;
    if (params.width !== void 0) this.width = params.width;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const arc = new _PadPrimitiveGrArc();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_TOKENS9.has(token)) {
        throw new Error(
          `pad primitive gr_arc encountered unsupported child token "${token}"`
        );
      }
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS9.has(token)) {
        throw new Error(
          `pad primitive gr_arc encountered unsupported child token "${token}"`
        );
      }
      if (entries.length > 1) {
        throw new Error(
          `pad primitive gr_arc does not support repeated "${token}" tokens`
        );
      }
    }
    arc._sxStart = propertyMap.start;
    arc._sxMid = propertyMap.mid;
    arc._sxEnd = propertyMap.end;
    arc._sxWidth = propertyMap.width;
    if (!arc._sxStart) {
      throw new Error("pad primitive gr_arc requires a start child token");
    }
    if (!arc._sxMid) {
      throw new Error("pad primitive gr_arc requires a mid child token");
    }
    if (!arc._sxEnd) {
      throw new Error("pad primitive gr_arc requires an end child token");
    }
    return arc;
  }
  get start() {
    return this._sxStart;
  }
  set start(value) {
    this._sxStart = normalizeArcPoint(value, PadPrimitiveGrArcStart);
  }
  get mid() {
    return this._sxMid;
  }
  set mid(value) {
    this._sxMid = normalizeArcPoint(value, PadPrimitiveGrArcMid);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    this._sxEnd = normalizeArcPoint(value, PadPrimitiveGrArcEnd);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    this._sxWidth = value instanceof Width ? value : new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxMid) children.push(this._sxMid);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxWidth) children.push(this._sxWidth);
    return children;
  }
  getString() {
    const lines = ["(gr_arc"];
    if (this._sxStart) lines.push(this._sxStart.getStringIndented());
    if (this._sxMid) lines.push(this._sxMid.getStringIndented());
    if (this._sxEnd) lines.push(this._sxEnd.getStringIndented());
    if (this._sxWidth) lines.push(this._sxWidth.getStringIndented());
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(PadPrimitiveGrArc);
var normalizeArcPoint = (value, Constructor) => {
  if (value === void 0) {
    return void 0;
  }
  if (value instanceof Constructor) {
    return value;
  }
  return new Constructor(value.x, value.y);
};
var PadPrimitiveGrArcPoint = class extends SxClass {
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(${this.token} ${this._x} ${this._y})`;
  }
};
var PadPrimitiveGrArcStart = class _PadPrimitiveGrArcStart extends PadPrimitiveGrArcPoint {
  static token = "start";
  static parentToken = "gr_arc";
  token = "start";
  constructor(x, y) {
    super(x, y);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error(
        "pad primitive gr_arc start expects two numeric arguments"
      );
    }
    return new _PadPrimitiveGrArcStart(x, y);
  }
};
SxClass.register(PadPrimitiveGrArcStart);
var PadPrimitiveGrArcMid = class _PadPrimitiveGrArcMid extends PadPrimitiveGrArcPoint {
  static token = "mid";
  static parentToken = "gr_arc";
  token = "mid";
  constructor(x, y) {
    super(x, y);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error("pad primitive gr_arc mid expects two numeric arguments");
    }
    return new _PadPrimitiveGrArcMid(x, y);
  }
};
SxClass.register(PadPrimitiveGrArcMid);
var PadPrimitiveGrArcEnd = class _PadPrimitiveGrArcEnd extends PadPrimitiveGrArcPoint {
  static token = "end";
  static parentToken = "gr_arc";
  token = "end";
  constructor(x, y) {
    super(x, y);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error("pad primitive gr_arc end expects two numeric arguments");
    }
    return new _PadPrimitiveGrArcEnd(x, y);
  }
};
SxClass.register(PadPrimitiveGrArcEnd);

// lib/sexpr/classes/PadPrimitiveGrCircle.ts
var SUPPORTED_TOKENS10 = /* @__PURE__ */ new Set(["center", "end", "width", "fill"]);
var PadPrimitiveGrCircle = class _PadPrimitiveGrCircle extends SxClass {
  static token = "gr_circle";
  static parentToken = "primitives";
  token = "gr_circle";
  _sxCenter;
  _sxEnd;
  _sxWidth;
  _sxFill;
  constructor(params = {}) {
    super();
    if (params.center !== void 0) this.center = params.center;
    if (params.end !== void 0) this.end = params.end;
    if (params.width !== void 0) this.width = params.width;
    if (params.fill !== void 0) this.fill = params.fill;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const circle = new _PadPrimitiveGrCircle();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_TOKENS10.has(token)) {
        throw new Error(
          `pad primitive gr_circle encountered unsupported child token "${token}"`
        );
      }
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS10.has(token)) {
        throw new Error(
          `pad primitive gr_circle encountered unsupported child token "${token}"`
        );
      }
      if (entries.length > 1) {
        throw new Error(
          `pad primitive gr_circle does not support repeated "${token}" tokens`
        );
      }
    }
    circle._sxCenter = propertyMap.center;
    circle._sxEnd = propertyMap.end;
    circle._sxWidth = propertyMap.width;
    circle._sxFill = propertyMap.fill;
    if (!circle._sxCenter) {
      throw new Error("pad primitive gr_circle requires a center child token");
    }
    if (!circle._sxEnd) {
      throw new Error("pad primitive gr_circle requires an end child token");
    }
    return circle;
  }
  get center() {
    return this._sxCenter;
  }
  set center(value) {
    this._sxCenter = normalizeCirclePoint(value, PadPrimitiveGrCircleCenter);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    this._sxEnd = normalizeCirclePoint(value, PadPrimitiveGrCircleEnd);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    this._sxWidth = value instanceof Width ? value : new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  get fill() {
    return this._sxFill?.filled;
  }
  set fill(value) {
    if (value === void 0) {
      this._sxFill = void 0;
      return;
    }
    this._sxFill = value instanceof PadPrimitiveGrCircleFill ? value : new PadPrimitiveGrCircleFill(value);
  }
  get fillClass() {
    return this._sxFill;
  }
  getChildren() {
    const children = [];
    if (this._sxCenter) children.push(this._sxCenter);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxFill) children.push(this._sxFill);
    return children;
  }
  getString() {
    const lines = ["(gr_circle"];
    if (this._sxCenter) lines.push(this._sxCenter.getStringIndented());
    if (this._sxEnd) lines.push(this._sxEnd.getStringIndented());
    if (this._sxWidth) lines.push(this._sxWidth.getStringIndented());
    if (this._sxFill) lines.push(this._sxFill.getStringIndented());
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(PadPrimitiveGrCircle);
var normalizeCirclePoint = (value, Constructor) => {
  if (value === void 0) {
    return void 0;
  }
  if (value instanceof Constructor) {
    return value;
  }
  return new Constructor(value.x, value.y);
};
var PadPrimitiveGrCirclePoint = class extends SxClass {
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(${this.token} ${this._x} ${this._y})`;
  }
};
var PadPrimitiveGrCircleCenter = class _PadPrimitiveGrCircleCenter extends PadPrimitiveGrCirclePoint {
  static token = "center";
  static parentToken = "gr_circle";
  token = "center";
  constructor(x, y) {
    super(x, y);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error(
        "pad primitive gr_circle center expects two numeric arguments"
      );
    }
    return new _PadPrimitiveGrCircleCenter(x, y);
  }
};
SxClass.register(PadPrimitiveGrCircleCenter);
var PadPrimitiveGrCircleEnd = class _PadPrimitiveGrCircleEnd extends PadPrimitiveGrCirclePoint {
  static token = "end";
  static parentToken = "gr_circle";
  token = "end";
  constructor(x, y) {
    super(x, y);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error(
        "pad primitive gr_circle end expects two numeric arguments"
      );
    }
    return new _PadPrimitiveGrCircleEnd(x, y);
  }
};
SxClass.register(PadPrimitiveGrCircleEnd);
var truthyFillStrings = /* @__PURE__ */ new Set(["yes", "true"]);
var falsyFillStrings = /* @__PURE__ */ new Set(["no", "false", "none"]);
var PadPrimitiveGrCircleFill = class _PadPrimitiveGrCircleFill extends SxClass {
  static token = "fill";
  static parentToken = "gr_circle";
  token = "fill";
  value;
  constructor(value) {
    super();
    if (value === void 0 || value === false) {
      this.value = "no";
    } else if (value === true) {
      this.value = "yes";
    } else {
      this.value = value;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [raw] = primitiveSexprs;
    if (raw === void 0) {
      return new _PadPrimitiveGrCircleFill("no");
    }
    if (typeof raw === "boolean") {
      return new _PadPrimitiveGrCircleFill(raw);
    }
    if (typeof raw === "string") {
      const normalized = raw.toLowerCase();
      if (truthyFillStrings.has(normalized) || falsyFillStrings.has(normalized)) {
        return new _PadPrimitiveGrCircleFill(raw);
      }
    }
    throw new Error(
      `pad primitive gr_circle fill expects yes/no/none or boolean, received ${JSON.stringify(raw)}`
    );
  }
  get filled() {
    return truthyFillStrings.has(this.value.toLowerCase());
  }
  set filled(value) {
    this.value = value ? "yes" : "no";
  }
  getString() {
    return `(fill ${this.value})`;
  }
};
SxClass.register(PadPrimitiveGrCircleFill);

// lib/sexpr/classes/PadPrimitives.ts
var PadPrimitives = class _PadPrimitives extends SxClass {
  static token = "primitives";
  static parentToken = "pad";
  token = "primitives";
  _graphics = [];
  _sxWidth;
  _sxFill;
  static fromSexprPrimitives(primitiveSexprs) {
    const primitives = new _PadPrimitives();
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `pad primitives encountered invalid child expression: ${JSON.stringify(primitive)}`
        );
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (!(parsed instanceof SxClass)) {
        throw new Error(
          `pad primitives child did not resolve to an SxClass: ${JSON.stringify(primitive)}`
        );
      }
      if (parsed instanceof Width) {
        if (primitives._sxWidth) {
          throw new Error("pad primitives encountered duplicate width tokens");
        }
        primitives._sxWidth = parsed;
        continue;
      }
      if (parsed instanceof PadPrimitivesFill) {
        if (primitives._sxFill) {
          throw new Error("pad primitives encountered duplicate fill tokens");
        }
        primitives._sxFill = parsed;
        continue;
      }
      if (parsed instanceof PadPrimitiveGrPoly) {
        primitives._graphics.push(parsed);
        continue;
      }
      if (parsed instanceof PadPrimitiveGrLine) {
        primitives._graphics.push(parsed);
        continue;
      }
      if (parsed instanceof PadPrimitiveGrArc) {
        primitives._graphics.push(parsed);
        continue;
      }
      if (parsed instanceof PadPrimitiveGrCircle) {
        primitives._graphics.push(parsed);
        continue;
      }
      throw new Error(
        `pad primitives encountered unsupported token "${parsed.token}"`
      );
    }
    return primitives;
  }
  get graphics() {
    return [...this._graphics];
  }
  set graphics(value) {
    this._graphics = [...value];
  }
  addGraphic(graphic) {
    this._graphics.push(graphic);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    this._sxWidth = value === void 0 ? void 0 : new Width(value);
  }
  get fill() {
    return this._sxFill?.value;
  }
  set fill(value) {
    this._sxFill = value === void 0 ? void 0 : new PadPrimitivesFill({ value });
  }
  getChildren() {
    const children = [];
    children.push(...this._graphics);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxFill) children.push(this._sxFill);
    return children;
  }
};
SxClass.register(PadPrimitives);
var PadPrimitivesFill = class _PadPrimitivesFill extends SxPrimitiveBoolean {
  static token = "fill";
  static parentToken = "primitives";
  token = "fill";
  constructor(options = {}) {
    super(options.value ?? false);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [raw] = primitiveSexprs;
    const normalized = typeof raw === "string" ? raw.toLowerCase() : raw;
    if (normalized === void 0) {
      return new _PadPrimitivesFill({ value: false });
    }
    if (normalized === "yes") {
      return new _PadPrimitivesFill({ value: true });
    }
    if (normalized === "no") {
      return new _PadPrimitivesFill({ value: false });
    }
    if (typeof normalized === "boolean") {
      return new _PadPrimitivesFill({ value: normalized });
    }
    throw new Error(
      `pad primitives fill expects yes/no or boolean, received ${JSON.stringify(raw)}`
    );
  }
};
SxClass.register(PadPrimitivesFill);
var PadPrimitiveGrPoly = class _PadPrimitiveGrPoly extends SxClass {
  static token = "gr_poly";
  static parentToken = "primitives";
  token = "gr_poly";
  _contours = [];
  _sxWidth;
  _sxFill;
  static fromSexprPrimitives(primitiveSexprs) {
    const polygon = new _PadPrimitiveGrPoly();
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `gr_poly primitive encountered invalid child: ${JSON.stringify(primitive)}`
        );
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (!(parsed instanceof SxClass)) {
        throw new Error(
          `gr_poly primitive child did not resolve to an SxClass: ${JSON.stringify(primitive)}`
        );
      }
      if (parsed instanceof Pts) {
        polygon._contours.push(parsed);
        continue;
      }
      if (parsed instanceof Width) {
        if (polygon._sxWidth) {
          throw new Error("gr_poly encountered duplicate width tokens");
        }
        polygon._sxWidth = parsed;
        continue;
      }
      if (parsed instanceof PadPrimitiveFill) {
        if (polygon._sxFill) {
          throw new Error("gr_poly encountered duplicate fill tokens");
        }
        polygon._sxFill = parsed;
        continue;
      }
      if (parsed.token === "fill") {
        if (polygon._sxFill) {
          throw new Error("gr_poly encountered duplicate fill tokens");
        }
        const fillValue = "value" in parsed ? parsed.value : "filled" in parsed ? parsed.filled : false;
        polygon._sxFill = new PadPrimitiveFill({ value: fillValue });
        continue;
      }
      throw new Error(`gr_poly encountered unsupported token "${parsed.token}"`);
    }
    if (polygon._contours.length === 0) {
      throw new Error("gr_poly requires at least one pts child");
    }
    return polygon;
  }
  get contours() {
    return [...this._contours];
  }
  set contours(value) {
    this._contours = [...value];
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    this._sxWidth = value === void 0 ? void 0 : new Width(value);
  }
  get filled() {
    return this._sxFill?.value;
  }
  set filled(value) {
    this._sxFill = value === void 0 ? void 0 : new PadPrimitiveFill({ value });
  }
  getChildren() {
    const children = [];
    children.push(...this._contours);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxFill) children.push(this._sxFill);
    return children;
  }
};
SxClass.register(PadPrimitiveGrPoly);
var PadPrimitiveFill = class _PadPrimitiveFill extends SxPrimitiveBoolean {
  static token = "fill";
  static parentToken = "gr_poly";
  token = "fill";
  constructor(options = {}) {
    super(options.value ?? false);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [raw] = primitiveSexprs;
    if (raw === void 0) {
      return new _PadPrimitiveFill({ value: false });
    }
    if (typeof raw === "boolean") {
      return new _PadPrimitiveFill({ value: raw });
    }
    if (typeof raw === "string") {
      return new _PadPrimitiveFill({ value: raw.toLowerCase() === "yes" });
    }
    throw new Error(
      `gr_poly fill expects yes/no or boolean, received ${JSON.stringify(raw)}`
    );
  }
  getString() {
    return `(fill ${this.value ? "yes" : "no"})`;
  }
};
SxClass.register(PadPrimitiveFill);

// lib/sexpr/classes/PadRoundrectRratio.ts
var PadRoundrectRratio = class extends SxPrimitiveNumber {
  static token = "roundrect_rratio";
  static parentToken = "pad";
  token = "roundrect_rratio";
};
SxClass.register(PadRoundrectRratio);

// lib/sexpr/classes/PadSize.ts
var PadSize = class _PadSize extends SxClass {
  static token = "size";
  static parentToken = "pad";
  token = "size";
  _width;
  _height;
  constructor(width, height) {
    super();
    this._width = width;
    this._height = height;
  }
  static from(input) {
    if (input instanceof _PadSize) {
      return input;
    }
    if (Array.isArray(input)) {
      return new _PadSize(input[0], input[1]);
    }
    return new _PadSize(input.width, input.height);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const width = toNumberValue(primitiveSexprs[0]);
    const height = toNumberValue(primitiveSexprs[1]);
    if (width === void 0 || height === void 0) {
      throw new Error("size requires width and height numeric values");
    }
    return new _PadSize(width, height);
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(size ${this._width} ${this._height})`;
  }
};
SxClass.register(PadSize);

// lib/sexpr/classes/PadSolderMaskMargin.ts
var PadSolderMaskMargin = class extends SxPrimitiveNumber {
  static token = "solder_mask_margin";
  static parentToken = "pad";
  token = "solder_mask_margin";
};
SxClass.register(PadSolderMaskMargin);

// lib/sexpr/classes/PadSolderPasteMargin.ts
var PadSolderPasteMargin = class extends SxPrimitiveNumber {
  static token = "solder_paste_margin";
  static parentToken = "pad";
  token = "solder_paste_margin";
};
SxClass.register(PadSolderPasteMargin);

// lib/sexpr/classes/PadSolderPasteMarginRatio.ts
var PadSolderPasteMarginRatio = class extends SxPrimitiveNumber {
  static token = "solder_paste_margin_ratio";
  static parentToken = "pad";
  token = "solder_paste_margin_ratio";
};
SxClass.register(PadSolderPasteMarginRatio);

// lib/sexpr/classes/PadThermalGap.ts
var PadThermalGap = class extends SxPrimitiveNumber {
  static token = "thermal_gap";
  static parentToken = "pad";
  token = "thermal_gap";
};
SxClass.register(PadThermalGap);

// lib/sexpr/classes/PadThermalWidth.ts
var PadThermalWidth = class extends SxPrimitiveNumber {
  static token = "thermal_width";
  static parentToken = "pad";
  token = "thermal_width";
};
SxClass.register(PadThermalWidth);

// lib/sexpr/classes/PadThermalBridgeAngle.ts
var PadThermalBridgeAngle = class extends SxPrimitiveNumber {
  static token = "thermal_bridge_angle";
  static parentToken = "pad";
  token = "thermal_bridge_angle";
};
SxClass.register(PadThermalBridgeAngle);

// lib/sexpr/classes/PadZoneConnect.ts
var PadZoneConnect = class extends SxPrimitiveNumber {
  static token = "zone_connect";
  static parentToken = "pad";
  token = "zone_connect";
};
SxClass.register(PadZoneConnect);

// lib/sexpr/utils/parseYesNo.ts
var parseYesNo = (value) => {
  const str = toStringValue(value);
  if (!str) return void 0;
  if (str === "yes" || str === "true") return true;
  if (str === "no" || str === "false") return false;
  return void 0;
};

// lib/sexpr/classes/PadTeardrops.ts
var NUMERIC_TOKENS = /* @__PURE__ */ new Map([
  ["best_length_ratio", "bestLengthRatio"],
  ["max_length", "maxLength"],
  ["best_width_ratio", "bestWidthRatio"],
  ["max_width", "maxWidth"],
  ["filter_ratio", "filterRatio"]
]);
var BOOLEAN_TOKENS = /* @__PURE__ */ new Map([
  ["curved_edges", "curvedEdges"],
  ["enabled", "enabled"],
  ["allow_two_segments", "allowTwoSegments"],
  ["prefer_zone_connections", "preferZoneConnections"]
]);
var PadTeardrops = class _PadTeardrops extends SxClass {
  static token = "teardrops";
  static parentToken = "pad";
  token = "teardrops";
  _bestLengthRatio;
  _maxLength;
  _bestWidthRatio;
  _maxWidth;
  _filterRatio;
  _curvedEdges;
  _enabled;
  _allowTwoSegments;
  _preferZoneConnections;
  static fromSexprPrimitives(primitiveSexprs) {
    const teardrops = new _PadTeardrops();
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `teardrops encountered invalid child expression: ${JSON.stringify(primitive)}`
        );
      }
      const [rawToken, rawValue] = primitive;
      if (typeof rawToken !== "string") {
        throw new Error(
          `teardrops encountered non-string token: ${JSON.stringify(rawToken)}`
        );
      }
      if (NUMERIC_TOKENS.has(rawToken)) {
        const property = NUMERIC_TOKENS.get(rawToken);
        const numeric = toNumberValue(rawValue);
        if (numeric === void 0) {
          throw new Error(
            `teardrops ${rawToken} expects a numeric value, received ${JSON.stringify(rawValue)}`
          );
        }
        teardrops[property] = numeric;
        continue;
      }
      if (BOOLEAN_TOKENS.has(rawToken)) {
        const property = BOOLEAN_TOKENS.get(rawToken);
        const booleanValue = parseYesNo(rawValue);
        if (booleanValue === void 0) {
          throw new Error(
            `teardrops ${rawToken} expects yes/no, received ${JSON.stringify(rawValue)}`
          );
        }
        teardrops[property] = booleanValue;
        continue;
      }
      throw new Error(`teardrops encountered unsupported token "${rawToken}"`);
    }
    return teardrops;
  }
  get bestLengthRatio() {
    return this._bestLengthRatio;
  }
  set bestLengthRatio(value) {
    this._bestLengthRatio = value;
  }
  get maxLength() {
    return this._maxLength;
  }
  set maxLength(value) {
    this._maxLength = value;
  }
  get bestWidthRatio() {
    return this._bestWidthRatio;
  }
  set bestWidthRatio(value) {
    this._bestWidthRatio = value;
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(value) {
    this._maxWidth = value;
  }
  get filterRatio() {
    return this._filterRatio;
  }
  set filterRatio(value) {
    this._filterRatio = value;
  }
  get curvedEdges() {
    return this._curvedEdges;
  }
  set curvedEdges(value) {
    this._curvedEdges = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get allowTwoSegments() {
    return this._allowTwoSegments;
  }
  set allowTwoSegments(value) {
    this._allowTwoSegments = value;
  }
  get preferZoneConnections() {
    return this._preferZoneConnections;
  }
  set preferZoneConnections(value) {
    this._preferZoneConnections = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    const lines = ["(teardrops"];
    if (this._bestLengthRatio !== void 0) {
      lines.push(`  (best_length_ratio ${this._bestLengthRatio})`);
    }
    if (this._maxLength !== void 0) {
      lines.push(`  (max_length ${this._maxLength})`);
    }
    if (this._bestWidthRatio !== void 0) {
      lines.push(`  (best_width_ratio ${this._bestWidthRatio})`);
    }
    if (this._maxWidth !== void 0) {
      lines.push(`  (max_width ${this._maxWidth})`);
    }
    if (this._curvedEdges !== void 0) {
      lines.push(`  (curved_edges ${this._curvedEdges ? "yes" : "no"})`);
    }
    if (this._filterRatio !== void 0) {
      lines.push(`  (filter_ratio ${this._filterRatio})`);
    }
    if (this._enabled !== void 0) {
      lines.push(`  (enabled ${this._enabled ? "yes" : "no"})`);
    }
    if (this._allowTwoSegments !== void 0) {
      lines.push(
        `  (allow_two_segments ${this._allowTwoSegments ? "yes" : "no"})`
      );
    }
    if (this._preferZoneConnections !== void 0) {
      lines.push(
        `  (prefer_zone_connections ${this._preferZoneConnections ? "yes" : "no"})`
      );
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(PadTeardrops);

// lib/sexpr/classes/PadRectDelta.ts
var PadRectDelta = class _PadRectDelta extends SxClass {
  static token = "rect_delta";
  static parentToken = "pad";
  token = "rect_delta";
  _x;
  _y;
  constructor(x = 0, y = 0) {
    super();
    this._x = x;
    this._y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error("pad rect_delta expects two numeric arguments");
    }
    return new _PadRectDelta(x, y);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(rect_delta ${this._x} ${this._y})`;
  }
};
SxClass.register(PadRectDelta);

// lib/sexpr/classes/FootprintPad.ts
var SINGLE_TOKENS = /* @__PURE__ */ new Set([
  "at",
  "size",
  "drill",
  "layers",
  "width",
  "stroke",
  "rect_delta",
  "roundrect_rratio",
  "chamfer_ratio",
  "chamfer",
  "net",
  "tstamp",
  "uuid",
  "pinfunction",
  "pintype",
  "die_length",
  "solder_mask_margin",
  "solder_paste_margin",
  "solder_paste_margin_ratio",
  "clearance",
  "zone_connect",
  "thermal_width",
  "thermal_gap",
  "thermal_bridge_angle",
  "options",
  "primitives",
  "remove_unused_layers",
  "keep_end_layers",
  "teardrops"
]);
var MULTI_TOKENS = /* @__PURE__ */ new Set(["property"]);
var SUPPORTED_TOKENS11 = /* @__PURE__ */ new Set([...SINGLE_TOKENS, ...MULTI_TOKENS]);
var ensureSingle = (arrayPropertyMap, token) => {
  const entries = arrayPropertyMap[token];
  if (entries && entries.length > 1) {
    throw new Error(`pad does not support repeated "${token}" children`);
  }
};
var FootprintPad = class _FootprintPad extends SxClass {
  static token = "pad";
  token = "pad";
  _number = "";
  _padType = "";
  _shape = "";
  _locked = false;
  _sxRemoveUnusedLayers;
  _sxKeepEndLayers;
  _sxAt;
  _sxSize;
  _sxDrill;
  _sxLayers;
  _sxWidth;
  _sxStroke;
  _properties = [];
  _sxRoundrectRatio;
  _sxChamferRatio;
  _sxChamfer;
  _sxRectDelta;
  _sxNet;
  _sxTstamp;
  _sxUuid;
  _sxPinFunction;
  _sxPinType;
  _sxDieLength;
  _sxSolderMaskMargin;
  _sxSolderPasteMargin;
  _sxSolderPasteMarginRatio;
  _sxClearance;
  _sxZoneConnect;
  _sxThermalWidth;
  _sxThermalGap;
  _sxThermalBridgeAngle;
  _sxOptions;
  _sxPrimitives;
  _sxTeardrops;
  constructor(params, padType, shape) {
    super();
    if (typeof params === "string") {
      this._number = params;
      this._padType = padType || "";
      this._shape = shape || "";
      return;
    }
    const p = params || {};
    if (p.number !== void 0) this.number = p.number;
    if (p.padType !== void 0) this.padType = p.padType;
    if (p.shape !== void 0) this.shape = p.shape;
    if (p.locked !== void 0) this.locked = p.locked;
    if (p.removeUnusedLayers !== void 0)
      this.removeUnusedLayer = p.removeUnusedLayers;
    if (p.keepEndLayers !== void 0) this.keepEndLayers = p.keepEndLayers;
    if (p.at !== void 0) this.at = p.at;
    if (p.size !== void 0) this.size = p.size;
    if (p.drill !== void 0) this.drill = p.drill;
    if (p.layers !== void 0) this.layers = p.layers;
    if (p.width !== void 0) this.width = p.width;
    if (p.stroke !== void 0) this.stroke = p.stroke;
    if (p.properties !== void 0) this.properties = p.properties;
    if (p.roundrectRatio !== void 0) this.roundrectRatio = p.roundrectRatio;
    if (p.chamferRatio !== void 0) this.chamferRatio = p.chamferRatio;
    if (p.chamfer !== void 0) this.chamfer = p.chamfer;
    if (p.rectDelta !== void 0) this.rectDelta = p.rectDelta;
    if (p.net !== void 0) this.net = p.net;
    if (p.tstamp !== void 0) this.tstamp = p.tstamp;
    if (p.uuid !== void 0) this.uuid = p.uuid;
    if (p.pinFunction !== void 0) this.pinfunction = p.pinFunction;
    if (p.pinType !== void 0) this.pintype = p.pinType;
    if (p.dieLength !== void 0) this.dieLength = p.dieLength;
    if (p.solderMaskMargin !== void 0)
      this.solderMaskMargin = p.solderMaskMargin;
    if (p.solderPasteMargin !== void 0)
      this.solderPasteMargin = p.solderPasteMargin;
    if (p.solderPasteMarginRatio !== void 0)
      this.solderPasteMarginRatio = p.solderPasteMarginRatio;
    if (p.clearance !== void 0) this.clearance = p.clearance;
    if (p.zoneConnect !== void 0) this.zoneConnect = p.zoneConnect;
    if (p.thermalWidth !== void 0) this.thermalWidth = p.thermalWidth;
    if (p.thermalGap !== void 0) this.thermalGap = p.thermalGap;
    if (p.thermalBridgeAngle !== void 0)
      this.thermalBridgeAngle = p.thermalBridgeAngle;
    if (p.options !== void 0) this.options = p.options;
    if (p.primitives !== void 0) this.primitives = p.primitives;
    if (p.teardrops !== void 0) this.teardrops = p.teardrops;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length < 3) {
      throw new Error("pad requires number, type, and shape arguments");
    }
    const [rawNumber, rawType, rawShape, ...rest] = primitiveSexprs;
    const number = toStringValue(rawNumber);
    const padType = toStringValue(rawType);
    const shape = toStringValue(rawShape);
    if (number === void 0 || padType === void 0 || shape === void 0) {
      throw new Error("pad header tokens must be strings");
    }
    const pad = new _FootprintPad(number, padType, shape);
    const primitiveStrings = [];
    const primitiveNodes = [];
    for (const primitive of rest) {
      if (typeof primitive === "string") {
        primitiveStrings.push(primitive);
      } else if (Array.isArray(primitive)) {
        primitiveNodes.push(primitive);
      } else {
        throw new Error(
          `pad encountered unexpected primitive child: ${JSON.stringify(primitive)}`
        );
      }
    }
    for (const flag of primitiveStrings) {
      switch (flag) {
        case "locked":
          pad._locked = true;
          break;
        case "remove_unused_layer":
          pad._sxRemoveUnusedLayers = new PadRemoveUnusedLayers({
            value: true,
            bareToken: "remove_unused_layer"
          });
          break;
        case "keep_end_layers":
          pad._sxKeepEndLayers = new PadKeepEndLayers({
            value: true,
            bare: true
          });
          break;
        default:
          throw new Error(`pad encountered unsupported flag "${flag}"`);
      }
    }
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveNodes, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_TOKENS11.has(token)) {
        throw new Error(`pad encountered unsupported child token "${token}"`);
      }
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS11.has(token)) {
        throw new Error(`pad encountered unsupported child token "${token}"`);
      }
      if (!MULTI_TOKENS.has(token) && entries.length > 1) {
        throw new Error(`pad does not support repeated child "${token}"`);
      }
    }
    ensureSingle(arrayPropertyMap, "at");
    ensureSingle(arrayPropertyMap, "size");
    ensureSingle(arrayPropertyMap, "drill");
    ensureSingle(arrayPropertyMap, "layers");
    ensureSingle(arrayPropertyMap, "width");
    ensureSingle(arrayPropertyMap, "stroke");
    ensureSingle(arrayPropertyMap, "rect_delta");
    ensureSingle(arrayPropertyMap, "roundrect_rratio");
    ensureSingle(arrayPropertyMap, "chamfer_ratio");
    ensureSingle(arrayPropertyMap, "chamfer");
    ensureSingle(arrayPropertyMap, "net");
    ensureSingle(arrayPropertyMap, "uuid");
    ensureSingle(arrayPropertyMap, "pinfunction");
    ensureSingle(arrayPropertyMap, "pintype");
    ensureSingle(arrayPropertyMap, "die_length");
    ensureSingle(arrayPropertyMap, "solder_mask_margin");
    ensureSingle(arrayPropertyMap, "solder_paste_margin");
    ensureSingle(arrayPropertyMap, "solder_paste_margin_ratio");
    ensureSingle(arrayPropertyMap, "clearance");
    ensureSingle(arrayPropertyMap, "zone_connect");
    ensureSingle(arrayPropertyMap, "thermal_width");
    ensureSingle(arrayPropertyMap, "thermal_gap");
    ensureSingle(arrayPropertyMap, "thermal_bridge_angle");
    ensureSingle(arrayPropertyMap, "options");
    ensureSingle(arrayPropertyMap, "primitives");
    pad._sxAt = propertyMap.at;
    pad._sxSize = propertyMap.size;
    pad._sxDrill = propertyMap.drill;
    pad._sxLayers = propertyMap.layers;
    pad._sxWidth = propertyMap.width;
    pad._sxStroke = propertyMap.stroke;
    pad._sxRectDelta = propertyMap.rect_delta;
    pad._properties = arrayPropertyMap.property ?? [];
    pad._sxRoundrectRatio = propertyMap.roundrect_rratio;
    pad._sxChamferRatio = propertyMap.chamfer_ratio;
    pad._sxChamfer = propertyMap.chamfer;
    pad._sxNet = propertyMap.net;
    pad._sxTstamp = propertyMap.tstamp;
    pad._sxUuid = propertyMap.uuid;
    pad._sxPinFunction = propertyMap.pinfunction;
    pad._sxPinType = propertyMap.pintype;
    pad._sxDieLength = propertyMap.die_length;
    pad._sxSolderMaskMargin = propertyMap.solder_mask_margin;
    pad._sxSolderPasteMargin = propertyMap.solder_paste_margin;
    pad._sxSolderPasteMarginRatio = propertyMap.solder_paste_margin_ratio;
    pad._sxClearance = propertyMap.clearance;
    pad._sxZoneConnect = propertyMap.zone_connect;
    pad._sxThermalWidth = propertyMap.thermal_width;
    pad._sxThermalGap = propertyMap.thermal_gap;
    pad._sxThermalBridgeAngle = propertyMap.thermal_bridge_angle;
    pad._sxOptions = propertyMap.options;
    pad._sxPrimitives = propertyMap.primitives;
    pad._sxRemoveUnusedLayers = arrayPropertyMap.remove_unused_layers?.[0] ?? pad._sxRemoveUnusedLayers;
    pad._sxKeepEndLayers = arrayPropertyMap.keep_end_layers?.[0] ?? pad._sxKeepEndLayers;
    pad._sxTeardrops = arrayPropertyMap.teardrops?.[0] ?? void 0;
    return pad;
  }
  get number() {
    return this._number;
  }
  set number(value) {
    this._number = value;
  }
  get padType() {
    return this._padType;
  }
  set padType(value) {
    this._padType = value;
  }
  get shape() {
    return this._shape;
  }
  set shape(value) {
    this._shape = value;
  }
  get locked() {
    return this._locked;
  }
  set locked(value) {
    this._locked = value;
  }
  get removeUnusedLayer() {
    return this._sxRemoveUnusedLayers?.value ?? false;
  }
  set removeUnusedLayer(value) {
    this._sxRemoveUnusedLayers = value ? new PadRemoveUnusedLayers({ value }) : void 0;
  }
  get keepEndLayers() {
    return this._sxKeepEndLayers?.value ?? false;
  }
  set keepEndLayers(value) {
    this._sxKeepEndLayers = value ? new PadKeepEndLayers({ value }) : void 0;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get size() {
    return this._sxSize;
  }
  set size(value) {
    this._sxSize = value !== void 0 ? PadSize.from(value) : void 0;
  }
  get drill() {
    return this._sxDrill;
  }
  set drill(value) {
    this._sxDrill = value;
  }
  get layers() {
    return this._sxLayers;
  }
  set layers(value) {
    this._sxLayers = value !== void 0 ? PadLayers.from(value) : void 0;
  }
  get width() {
    return this._sxWidth;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    this._sxWidth = typeof value === "number" ? new Width(value) : value;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get properties() {
    return [...this._properties];
  }
  set properties(value) {
    this._properties = [...value];
  }
  get roundrectRatio() {
    return this._sxRoundrectRatio?.value;
  }
  set roundrectRatio(value) {
    if (value === void 0) {
      this._sxRoundrectRatio = void 0;
      return;
    }
    this._sxRoundrectRatio = typeof value === "number" ? new PadRoundrectRratio(value) : value;
  }
  get chamferRatio() {
    return this._sxChamferRatio?.value;
  }
  set chamferRatio(value) {
    if (value === void 0) {
      this._sxChamferRatio = void 0;
      return;
    }
    this._sxChamferRatio = typeof value === "number" ? new PadChamferRatio(value) : value;
  }
  get chamfer() {
    return this._sxChamfer;
  }
  set chamfer(value) {
    this._sxChamfer = value;
  }
  get chamferCorners() {
    return this._sxChamfer?.corners;
  }
  get rectDelta() {
    return this._sxRectDelta;
  }
  set rectDelta(value) {
    if (value === void 0) {
      this._sxRectDelta = void 0;
      return;
    }
    if (value instanceof PadRectDelta) {
      this._sxRectDelta = value;
      return;
    }
    this._sxRectDelta = new PadRectDelta(value.x, value.y);
  }
  get net() {
    return this._sxNet;
  }
  set net(value) {
    this._sxNet = value;
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get pinfunction() {
    return this._sxPinFunction?.value;
  }
  set pinfunction(value) {
    if (value === void 0) {
      this._sxPinFunction = void 0;
      return;
    }
    this._sxPinFunction = typeof value === "string" ? new PadPinFunction(value) : value;
  }
  get pintype() {
    return this._sxPinType?.value;
  }
  set pintype(value) {
    if (value === void 0) {
      this._sxPinType = void 0;
      return;
    }
    this._sxPinType = typeof value === "string" ? new PadPinType(value) : value;
  }
  get dieLength() {
    return this._sxDieLength?.value;
  }
  set dieLength(value) {
    if (value === void 0) {
      this._sxDieLength = void 0;
      return;
    }
    this._sxDieLength = typeof value === "number" ? new PadDieLength(value) : value;
  }
  get solderMaskMargin() {
    return this._sxSolderMaskMargin?.value;
  }
  set solderMaskMargin(value) {
    if (value === void 0) {
      this._sxSolderMaskMargin = void 0;
      return;
    }
    this._sxSolderMaskMargin = typeof value === "number" ? new PadSolderMaskMargin(value) : value;
  }
  get solderPasteMargin() {
    return this._sxSolderPasteMargin?.value;
  }
  set solderPasteMargin(value) {
    if (value === void 0) {
      this._sxSolderPasteMargin = void 0;
      return;
    }
    this._sxSolderPasteMargin = typeof value === "number" ? new PadSolderPasteMargin(value) : value;
  }
  get solderPasteMarginRatio() {
    return this._sxSolderPasteMarginRatio?.value;
  }
  set solderPasteMarginRatio(value) {
    if (value === void 0) {
      this._sxSolderPasteMarginRatio = void 0;
      return;
    }
    this._sxSolderPasteMarginRatio = typeof value === "number" ? new PadSolderPasteMarginRatio(value) : value;
  }
  get clearance() {
    return this._sxClearance?.value;
  }
  set clearance(value) {
    if (value === void 0) {
      this._sxClearance = void 0;
      return;
    }
    this._sxClearance = typeof value === "number" ? new PadClearance(value) : value;
  }
  get zoneConnect() {
    return this._sxZoneConnect?.value;
  }
  set zoneConnect(value) {
    if (value === void 0) {
      this._sxZoneConnect = void 0;
      return;
    }
    this._sxZoneConnect = typeof value === "number" ? new PadZoneConnect(value) : value;
  }
  get thermalWidth() {
    return this._sxThermalWidth?.value;
  }
  set thermalWidth(value) {
    if (value === void 0) {
      this._sxThermalWidth = void 0;
      return;
    }
    this._sxThermalWidth = typeof value === "number" ? new PadThermalWidth(value) : value;
  }
  get thermalGap() {
    return this._sxThermalGap?.value;
  }
  set thermalGap(value) {
    if (value === void 0) {
      this._sxThermalGap = void 0;
      return;
    }
    this._sxThermalGap = typeof value === "number" ? new PadThermalGap(value) : value;
  }
  get thermalBridgeAngle() {
    return this._sxThermalBridgeAngle?.value;
  }
  set thermalBridgeAngle(value) {
    if (value === void 0) {
      this._sxThermalBridgeAngle = void 0;
      return;
    }
    this._sxThermalBridgeAngle = typeof value === "number" ? new PadThermalBridgeAngle(value) : value;
  }
  get options() {
    return this._sxOptions;
  }
  set options(value) {
    this._sxOptions = value;
  }
  get primitives() {
    return this._sxPrimitives;
  }
  set primitives(value) {
    this._sxPrimitives = value;
  }
  get teardrops() {
    return this._sxTeardrops;
  }
  set teardrops(value) {
    this._sxTeardrops = value;
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxSize) children.push(this._sxSize);
    if (this._sxDrill) children.push(this._sxDrill);
    if (this._sxLayers) children.push(this._sxLayers);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxStroke) children.push(this._sxStroke);
    children.push(...this._properties);
    if (this._sxRoundrectRatio) children.push(this._sxRoundrectRatio);
    if (this._sxChamferRatio) children.push(this._sxChamferRatio);
    if (this._sxChamfer) children.push(this._sxChamfer);
    if (this._sxRectDelta) children.push(this._sxRectDelta);
    if (this._sxNet) children.push(this._sxNet);
    if (this._sxPinFunction) children.push(this._sxPinFunction);
    if (this._sxPinType) children.push(this._sxPinType);
    if (this._sxDieLength) children.push(this._sxDieLength);
    if (this._sxSolderMaskMargin) children.push(this._sxSolderMaskMargin);
    if (this._sxSolderPasteMargin) children.push(this._sxSolderPasteMargin);
    if (this._sxSolderPasteMarginRatio)
      children.push(this._sxSolderPasteMarginRatio);
    if (this._sxClearance) children.push(this._sxClearance);
    if (this._sxZoneConnect) children.push(this._sxZoneConnect);
    if (this._sxThermalWidth) children.push(this._sxThermalWidth);
    if (this._sxThermalGap) children.push(this._sxThermalGap);
    if (this._sxThermalBridgeAngle) children.push(this._sxThermalBridgeAngle);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxRemoveUnusedLayers) children.push(this._sxRemoveUnusedLayers);
    if (this._sxKeepEndLayers) children.push(this._sxKeepEndLayers);
    if (this._sxTeardrops) children.push(this._sxTeardrops);
    if (this._sxOptions) children.push(this._sxOptions);
    if (this._sxPrimitives) children.push(this._sxPrimitives);
    return children;
  }
  getString() {
    const lines = [
      `(pad ${quoteSExprString(this._number)} ${this._padType} ${this._shape}`
    ];
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    if (this._locked) {
      lines.push("  locked");
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(FootprintPad);
var PadRemoveUnusedLayers = class _PadRemoveUnusedLayers extends SxPrimitiveBoolean {
  static token = "remove_unused_layers";
  static parentToken = "pad";
  token = "remove_unused_layers";
  bareToken;
  constructor(options = {}) {
    super(options.value ?? false);
    this.bareToken = options.bareToken;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [raw] = primitiveSexprs;
    if (raw === void 0) {
      return new _PadRemoveUnusedLayers({ value: false });
    }
    if (typeof raw === "boolean") {
      return new _PadRemoveUnusedLayers({ value: raw });
    }
    if (typeof raw === "string") {
      const normalized = raw.toLowerCase();
      if (normalized === "yes" || normalized === "true") {
        return new _PadRemoveUnusedLayers({ value: true });
      }
      if (normalized === "no" || normalized === "false") {
        return new _PadRemoveUnusedLayers({ value: false });
      }
    }
    throw new Error(
      `remove_unused_layers expects yes/no or boolean, received ${JSON.stringify(raw)}`
    );
  }
  getString() {
    if (this.bareToken) {
      return this.bareToken;
    }
    return `(remove_unused_layers ${this.value ? "yes" : "no"})`;
  }
};
SxClass.register(PadRemoveUnusedLayers);
var PadKeepEndLayers = class _PadKeepEndLayers extends SxPrimitiveBoolean {
  static token = "keep_end_layers";
  static parentToken = "pad";
  token = "keep_end_layers";
  renderBare;
  constructor(options = {}) {
    super(options.value ?? false);
    this.renderBare = options.bare ?? false;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [raw] = primitiveSexprs;
    if (raw === void 0) {
      return new _PadKeepEndLayers({ value: false });
    }
    if (typeof raw === "boolean") {
      return new _PadKeepEndLayers({ value: raw });
    }
    if (typeof raw === "string") {
      const normalized = raw.toLowerCase();
      if (normalized === "yes" || normalized === "true") {
        return new _PadKeepEndLayers({ value: true });
      }
      if (normalized === "no" || normalized === "false") {
        return new _PadKeepEndLayers({ value: false });
      }
    }
    throw new Error(
      `keep_end_layers expects yes/no or boolean, received ${JSON.stringify(raw)}`
    );
  }
  getString() {
    if (this.renderBare) {
      return "keep_end_layers";
    }
    return `(keep_end_layers ${this.value ? "yes" : "no"})`;
  }
};
SxClass.register(PadKeepEndLayers);

// lib/sexpr/classes/FpText.ts
var SUPPORTED_SINGLE_TOKENS2 = /* @__PURE__ */ new Set([
  "at",
  "xy",
  "layer",
  "effects",
  "tstamp",
  "uuid",
  "unlocked",
  "hide"
]);
var SUPPORTED_MULTI_TOKENS2 = /* @__PURE__ */ new Set();
var FpText = class _FpText extends SxClass {
  static token = "fp_text";
  token = "fp_text";
  _type;
  _text = "";
  _sxPosition;
  _sxUnlocked;
  _sxHide;
  _sxLayer;
  _sxEffects;
  _sxTstamp;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.type !== void 0) this.type = params.type;
    if (params.text !== void 0) this.text = params.text;
    if (params.position !== void 0) this.position = params.position;
    if (params.unlocked !== void 0) this.unlocked = params.unlocked;
    if (params.hidden !== void 0) this.hidden = params.hidden;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.effects !== void 0) this.effects = params.effects;
    if (params.tstamp !== void 0) this.tstamp = params.tstamp;
    if (params.uuid !== void 0) this.uuid = params.uuid;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length < 2) {
      throw new Error("fp_text requires a type and text value");
    }
    const [rawType, rawText, ...rest] = primitiveSexprs;
    const fpText = new _FpText();
    if (typeof rawType !== "string") {
      throw new Error(
        `fp_text type must be a string token, received ${JSON.stringify(rawType)}`
      );
    }
    fpText._type = rawType;
    fpText._text = primitiveToString3(rawText);
    const structuredPrimitives = [];
    let sawBareUnlocked = false;
    let sawBareHide = false;
    for (const primitive of rest) {
      if (typeof primitive === "string") {
        if (primitive === "unlocked") {
          if (sawBareUnlocked) {
            throw new Error(
              "fp_text encountered duplicate bare unlocked tokens"
            );
          }
          sawBareUnlocked = true;
          continue;
        }
        if (primitive === "hide") {
          if (sawBareHide) {
            throw new Error("fp_text encountered duplicate bare hide tokens");
          }
          sawBareHide = true;
          continue;
        }
        throw new Error(`fp_text encountered unsupported flag "${primitive}"`);
      }
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `fp_text encountered invalid child expression: ${JSON.stringify(primitive)}`
        );
      }
      structuredPrimitives.push(primitive);
    }
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(structuredPrimitives, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS2.has(token)) {
        throw new Error(
          `fp_text encountered unsupported child token "${token}"`
        );
      }
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS2.has(token)) {
        throw new Error(
          `fp_text encountered unsupported child token "${token}"`
        );
      }
      if (!SUPPORTED_MULTI_TOKENS2.has(token) && entries.length > 1) {
        throw new Error(
          `fp_text does not support repeated child token "${token}"`
        );
      }
    }
    const atInstance = propertyMap.at;
    const xyInstance = propertyMap.xy;
    if (atInstance && xyInstance) {
      throw new Error("fp_text cannot include both at and xy child tokens");
    }
    fpText._sxPosition = atInstance ?? xyInstance;
    fpText._sxLayer = propertyMap.layer;
    fpText._sxEffects = propertyMap.effects;
    fpText._sxTstamp = propertyMap.tstamp;
    fpText._sxUuid = propertyMap.uuid;
    const unlockedEntry = propertyMap.unlocked;
    const hideEntry = propertyMap.hide;
    if (unlockedEntry && sawBareUnlocked) {
      throw new Error(
        "fp_text encountered both bare and structured unlocked tokens"
      );
    }
    if (hideEntry && sawBareHide) {
      throw new Error(
        "fp_text encountered both bare and structured hide tokens"
      );
    }
    fpText._sxUnlocked = unlockedEntry;
    fpText._sxHide = hideEntry;
    if (sawBareUnlocked) {
      fpText._sxUnlocked = new FpTextUnlocked({ value: true, bare: true });
    }
    if (sawBareHide) {
      fpText._sxHide = new FpTextHide({ value: true, bare: true });
    }
    return fpText;
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get position() {
    return this._sxPosition;
  }
  set position(value) {
    if (value === void 0) {
      this._sxPosition = void 0;
      return;
    }
    if (value instanceof Xy) {
      this._sxPosition = value;
      return;
    }
    this._sxPosition = At.from(value);
  }
  get unlocked() {
    return this._sxUnlocked?.value ?? false;
  }
  set unlocked(value) {
    this._sxUnlocked = value ? new FpTextUnlocked({ value: true, bare: true }) : void 0;
  }
  get hidden() {
    return this._sxHide?.value ?? false;
  }
  set hidden(value) {
    this._sxHide = value ? new FpTextHide({ value: true, bare: true }) : void 0;
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
    } else {
      const names = Array.isArray(value) ? value : [value];
      this._sxLayer = new Layer(names);
    }
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  getChildren() {
    const children = [];
    if (this._sxPosition) children.push(this._sxPosition);
    if (this._sxUnlocked) children.push(this._sxUnlocked);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxHide) children.push(this._sxHide);
    if (this._sxEffects) children.push(this._sxEffects);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
  getString() {
    const lines = ["(fp_text"];
    if (this._type !== void 0) {
      lines.push(`  ${this._type}`);
    }
    lines.push(`  ${quoteSExprString(this._text)}`);
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(FpText);
function primitiveToString3(value) {
  if (value === void 0) return "";
  const str = toStringValue(value);
  if (str !== void 0) return str;
  return printSExpr(value);
}
var FpTextUnlocked = class _FpTextUnlocked extends SxClass {
  static token = "unlocked";
  static parentToken = "fp_text";
  token = "unlocked";
  value;
  renderBare;
  constructor(options = {}) {
    super();
    this.value = options.value ?? true;
    this.renderBare = options.bare ?? false;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [raw] = primitiveSexprs;
    const rawString = toStringValue(raw);
    const value = rawString === void 0 ? true : !/^(no|false)$/iu.test(rawString);
    return new _FpTextUnlocked({ value, bare: false });
  }
  getChildren() {
    return [];
  }
  getString() {
    if (this.renderBare) {
      return "unlocked";
    }
    return `(unlocked ${this.value ? "yes" : "no"})`;
  }
};
SxClass.register(FpTextUnlocked);
var FpTextHide = class _FpTextHide extends SxClass {
  static token = "hide";
  static parentToken = "fp_text";
  token = "hide";
  value;
  renderBare;
  constructor(options = {}) {
    super();
    this.value = options.value ?? true;
    this.renderBare = options.bare ?? false;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [raw] = primitiveSexprs;
    const rawString = toStringValue(raw);
    const value = rawString === void 0 ? true : !/^(no|false)$/iu.test(rawString);
    return new _FpTextHide({ value, bare: false });
  }
  getChildren() {
    return [];
  }
  getString() {
    if (this.renderBare) {
      return "hide";
    }
    return `(hide ${this.value ? "yes" : "no"})`;
  }
};
SxClass.register(FpTextHide);

// lib/sexpr/classes/FpTextBox.ts
function primitiveToString4(value) {
  if (value === void 0) return "";
  const str = toStringValue(value);
  if (str !== void 0) return str;
  return printSExpr(value);
}
var SUPPORTED_SINGLE_TOKENS3 = /* @__PURE__ */ new Set([
  "start",
  "end",
  "pts",
  "angle",
  "layer",
  "uuid",
  "effects",
  "stroke",
  "render_cache"
]);
var SUPPORTED_MULTI_TOKENS3 = /* @__PURE__ */ new Set();
var FpTextBox = class _FpTextBox extends SxClass {
  static token = "fp_text_box";
  token = "fp_text_box";
  _sxLocked;
  _text = "";
  _sxStart;
  _sxEnd;
  _sxPts;
  _sxAngle;
  _sxLayer;
  _sxUuid;
  _sxEffects;
  _sxStroke;
  _sxRenderCache;
  constructor(params = {}) {
    super();
    if (params.locked !== void 0) this.locked = params.locked;
    if (params.text !== void 0) this.text = params.text;
    if (params.start !== void 0) this.start = params.start;
    if (params.end !== void 0) this.end = params.end;
    if (params.pts !== void 0) this.pts = params.pts;
    if (params.angle !== void 0) this.angle = params.angle;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.effects !== void 0) this.effects = params.effects;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.renderCache !== void 0) this.renderCache = params.renderCache;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const fpTextBox = new _FpTextBox();
    if (primitiveSexprs.length === 0) {
      throw new Error("fp_text_box requires a text value");
    }
    let capturedText = false;
    let locked = false;
    const structuredPrimitives = [];
    for (const primitive of primitiveSexprs) {
      if (typeof primitive === "string") {
        if (primitive === "locked") {
          if (locked) {
            throw new Error("fp_text_box encountered duplicate locked flags");
          }
          locked = true;
          continue;
        }
        if (!capturedText) {
          fpTextBox._text = primitive;
          capturedText = true;
          continue;
        }
        throw new Error(
          `fp_text_box encountered unsupported flag "${primitive}"`
        );
      }
      if (!capturedText) {
        fpTextBox._text = primitiveToString4(primitive);
        capturedText = true;
        continue;
      }
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `fp_text_box encountered invalid child expression: ${JSON.stringify(primitive)}`
        );
      }
      structuredPrimitives.push(primitive);
    }
    if (!capturedText) {
      throw new Error("fp_text_box did not include a text value");
    }
    if (locked) {
      fpTextBox._sxLocked = new FpTextBoxLocked();
    }
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(structuredPrimitives, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS3.has(token)) {
        throw new Error(
          `fp_text_box encountered unsupported child token "${token}"`
        );
      }
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS3.has(token)) {
        throw new Error(
          `fp_text_box encountered unsupported child token "${token}"`
        );
      }
      if (!SUPPORTED_MULTI_TOKENS3.has(token) && entries.length > 1) {
        throw new Error(
          `fp_text_box does not support repeated child token "${token}"`
        );
      }
    }
    fpTextBox._sxStart = propertyMap.start;
    fpTextBox._sxEnd = propertyMap.end;
    fpTextBox._sxPts = propertyMap.pts;
    fpTextBox._sxAngle = propertyMap.angle;
    fpTextBox._sxLayer = propertyMap.layer;
    fpTextBox._sxUuid = propertyMap.uuid;
    fpTextBox._sxEffects = propertyMap.effects;
    fpTextBox._sxStroke = propertyMap.stroke;
    fpTextBox._sxRenderCache = propertyMap.render_cache;
    return fpTextBox;
  }
  get locked() {
    return this._sxLocked !== void 0;
  }
  set locked(value) {
    this._sxLocked = value ? new FpTextBoxLocked() : void 0;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get start() {
    return this._sxStart;
  }
  set start(value) {
    if (value === void 0) {
      this._sxStart = void 0;
      return;
    }
    this._sxStart = value instanceof FpTextBoxStart ? value : new FpTextBoxStart([value.x, value.y]);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    if (value === void 0) {
      this._sxEnd = void 0;
      return;
    }
    this._sxEnd = value instanceof FpTextBoxEnd ? value : new FpTextBoxEnd([value.x, value.y]);
  }
  get pts() {
    return this._sxPts;
  }
  set pts(value) {
    this._sxPts = value;
  }
  get angle() {
    return this._sxAngle;
  }
  set angle(value) {
    if (value === void 0) {
      this._sxAngle = void 0;
      return;
    }
    this._sxAngle = value instanceof FpTextBoxAngle ? value : new FpTextBoxAngle([value]);
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
    } else {
      const names = Array.isArray(value) ? value : [value];
      this._sxLayer = new Layer(names);
    }
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get renderCache() {
    return this._sxRenderCache;
  }
  set renderCache(value) {
    this._sxRenderCache = value;
  }
  getChildren() {
    const children = [];
    if (this._sxLocked) children.push(this._sxLocked);
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxPts) children.push(this._sxPts);
    if (this._sxAngle) children.push(this._sxAngle);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxEffects) children.push(this._sxEffects);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxRenderCache) children.push(this._sxRenderCache);
    return children;
  }
  getString() {
    const lines = ["(fp_text_box"];
    if (this._sxLocked) {
      lines.push(this._sxLocked.getStringIndented());
    }
    lines.push(`  ${quoteSExprString(this._text)}`);
    for (const child of this.getChildren()) {
      if (child === this._sxLocked) continue;
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(FpTextBox);
var FpTextBoxStart = class _FpTextBoxStart extends SxClass {
  static token = "start";
  static parentToken = "fp_text_box";
  token = "start";
  x;
  y;
  constructor(args) {
    super();
    this.x = args[0];
    this.y = args[1];
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = Number(rawX);
    const y = Number(rawY);
    return new _FpTextBoxStart([
      Number.isFinite(x) ? x : 0,
      Number.isFinite(y) ? y : 0
    ]);
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(start ${this.x} ${this.y})`;
  }
};
SxClass.register(FpTextBoxStart);
var FpTextBoxEnd = class _FpTextBoxEnd extends SxClass {
  static token = "end";
  static parentToken = "fp_text_box";
  token = "end";
  x;
  y;
  constructor(args) {
    super();
    this.x = args[0];
    this.y = args[1];
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = Number(rawX);
    const y = Number(rawY);
    return new _FpTextBoxEnd([
      Number.isFinite(x) ? x : 0,
      Number.isFinite(y) ? y : 0
    ]);
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(end ${this.x} ${this.y})`;
  }
};
SxClass.register(FpTextBoxEnd);
var FpTextBoxAngle = class _FpTextBoxAngle extends SxClass {
  static token = "angle";
  static parentToken = "fp_text_box";
  token = "angle";
  value;
  constructor(args) {
    super();
    this.value = args[0];
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [raw] = primitiveSexprs;
    const numeric = typeof raw === "number" ? raw : toNumberValue(raw) ?? 0;
    return new _FpTextBoxAngle([numeric]);
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(angle ${this.value})`;
  }
};
SxClass.register(FpTextBoxAngle);
var FpTextBoxLocked = class _FpTextBoxLocked extends SxClass {
  static token = "locked";
  static parentToken = "fp_text_box";
  token = "locked";
  static fromSexprPrimitives() {
    return new _FpTextBoxLocked();
  }
  getChildren() {
    return [];
  }
  getString() {
    return "locked";
  }
};
SxClass.register(FpTextBoxLocked);

// lib/sexpr/classes/FpRect.ts
var FpRect = class _FpRect extends SxClass {
  static token = "fp_rect";
  token = "fp_rect";
  _sxStart;
  _sxEnd;
  _sxLayer;
  _sxWidth;
  _sxStroke;
  _sxFill;
  _sxUuid;
  _locked = false;
  constructor(params = {}) {
    super();
    if (params.start !== void 0) this.start = params.start;
    if (params.end !== void 0) this.end = params.end;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.width !== void 0) this.width = params.width;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.fill !== void 0) this.fill = params.fill;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.locked !== void 0) this.locked = params.locked;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const rect = new _FpRect();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    rect._sxStart = propertyMap.start;
    rect._sxEnd = propertyMap.end;
    rect._sxLayer = propertyMap.layer;
    rect._sxWidth = propertyMap.width;
    rect._sxStroke = propertyMap.stroke;
    rect._sxFill = propertyMap.fill;
    rect._sxUuid = propertyMap.uuid;
    for (const primitive of primitiveSexprs) {
      if (primitive === "locked") {
        rect._locked = true;
      }
    }
    return rect;
  }
  get start() {
    return this._sxStart;
  }
  set start(value) {
    if (value === void 0) {
      this._sxStart = void 0;
      return;
    }
    if (value instanceof FpRectStart) {
      this._sxStart = value;
      return;
    }
    this._sxStart = new FpRectStart(value.x, value.y);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    if (value === void 0) {
      this._sxEnd = void 0;
      return;
    }
    if (value instanceof FpRectEnd) {
      this._sxEnd = value;
      return;
    }
    this._sxEnd = new FpRectEnd(value.x, value.y);
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    if (value instanceof Width) {
      this._sxWidth = value;
      return;
    }
    this._sxWidth = new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  get fill() {
    return this._sxFill?.filled;
  }
  set fill(value) {
    if (value === void 0) {
      this._sxFill = void 0;
      return;
    }
    if (value instanceof FpRectFill) {
      this._sxFill = value;
      return;
    }
    this._sxFill = new FpRectFill(value);
  }
  get fillClass() {
    return this._sxFill;
  }
  get uuid() {
    return this._sxUuid?.value;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    if (value instanceof Uuid) {
      this._sxUuid = value;
      return;
    }
    this._sxUuid = new Uuid(value);
  }
  get uuidClass() {
    return this._sxUuid;
  }
  get locked() {
    return this._locked;
  }
  set locked(value) {
    this._locked = value;
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxFill) children.push(this._sxFill);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
  getString() {
    const lines = ["(fp_rect"];
    const push = (value) => {
      if (!value) return;
      lines.push(value.getStringIndented());
    };
    push(this._sxStart);
    push(this._sxEnd);
    push(this._sxLayer);
    push(this._sxWidth);
    push(this._sxStroke);
    push(this._sxFill);
    push(this._sxUuid);
    if (this._locked) {
      lines.push("  locked");
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(FpRect);
var FpRectStart = class _FpRectStart extends SxClass {
  static token = "start";
  static parentToken = "fp_rect";
  token = "start";
  x;
  y;
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const x = toNumberValue(primitiveSexprs[0]) ?? 0;
    const y = toNumberValue(primitiveSexprs[1]) ?? 0;
    return new _FpRectStart(x, y);
  }
  getString() {
    return `(start ${this.x} ${this.y})`;
  }
};
SxClass.register(FpRectStart);
var FpRectEnd = class _FpRectEnd extends SxClass {
  static token = "end";
  static parentToken = "fp_rect";
  token = "end";
  x;
  y;
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const x = toNumberValue(primitiveSexprs[0]) ?? 0;
    const y = toNumberValue(primitiveSexprs[1]) ?? 0;
    return new _FpRectEnd(x, y);
  }
  getString() {
    return `(end ${this.x} ${this.y})`;
  }
};
SxClass.register(FpRectEnd);
var FpRectFill = class _FpRectFill extends SxClass {
  static token = "fill";
  static parentToken = "fp_rect";
  token = "fill";
  filled;
  constructor(filled) {
    super();
    this.filled = filled;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const state = toStringValue(primitiveSexprs[0]);
    return new _FpRectFill(state === "yes");
  }
  getString() {
    return `(fill ${this.filled ? "yes" : "no"})`;
  }
};
SxClass.register(FpRectFill);

// lib/sexpr/classes/FpCircle.ts
var FpCircle = class _FpCircle extends SxClass {
  static token = "fp_circle";
  token = "fp_circle";
  _sxCenter;
  _sxEnd;
  _sxLayer;
  _sxWidth;
  _sxStroke;
  _sxFill;
  _sxUuid;
  _locked = false;
  constructor(params = {}) {
    super();
    if (params.center !== void 0) this.center = params.center;
    if (params.end !== void 0) this.end = params.end;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.width !== void 0) this.width = params.width;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.fill !== void 0) this.fill = params.fill;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.locked !== void 0) this.locked = params.locked;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const circle = new _FpCircle();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    circle._sxCenter = propertyMap.center;
    circle._sxEnd = propertyMap.end;
    circle._sxLayer = propertyMap.layer;
    circle._sxWidth = propertyMap.width;
    circle._sxStroke = propertyMap.stroke;
    circle._sxFill = propertyMap.fill;
    circle._sxUuid = propertyMap.uuid;
    for (const primitive of primitiveSexprs) {
      if (primitive === "locked") {
        circle._locked = true;
      }
    }
    return circle;
  }
  get center() {
    return this._sxCenter;
  }
  set center(value) {
    if (value === void 0) {
      this._sxCenter = void 0;
      return;
    }
    if (value instanceof FpCircleCenter) {
      this._sxCenter = value;
      return;
    }
    this._sxCenter = new FpCircleCenter(value.x, value.y);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    if (value === void 0) {
      this._sxEnd = void 0;
      return;
    }
    if (value instanceof FpCircleEnd) {
      this._sxEnd = value;
      return;
    }
    this._sxEnd = new FpCircleEnd(value.x, value.y);
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    if (value instanceof Width) {
      this._sxWidth = value;
      return;
    }
    this._sxWidth = new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get fill() {
    return this._sxFill?.filled;
  }
  set fill(value) {
    if (value === void 0) {
      this._sxFill = void 0;
      return;
    }
    if (value instanceof FpCircleFill) {
      this._sxFill = value;
      return;
    }
    this._sxFill = new FpCircleFill(value);
  }
  get fillClass() {
    return this._sxFill;
  }
  get uuid() {
    return this._sxUuid?.value;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    if (value instanceof Uuid) {
      this._sxUuid = value;
      return;
    }
    this._sxUuid = new Uuid(value);
  }
  get uuidClass() {
    return this._sxUuid;
  }
  get locked() {
    return this._locked;
  }
  set locked(value) {
    this._locked = value;
  }
  getChildren() {
    const children = [];
    if (this._sxCenter) children.push(this._sxCenter);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxFill) children.push(this._sxFill);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
  getString() {
    const lines = ["(fp_circle"];
    const push = (value) => {
      if (!value) return;
      lines.push(value.getStringIndented());
    };
    push(this._sxCenter);
    push(this._sxEnd);
    push(this._sxLayer);
    push(this._sxWidth);
    push(this._sxStroke);
    push(this._sxFill);
    push(this._sxUuid);
    if (this._locked) {
      lines.push("  locked");
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(FpCircle);
var FpCircleCenter = class _FpCircleCenter extends SxClass {
  static token = "center";
  static parentToken = "fp_circle";
  token = "center";
  x;
  y;
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const x = toNumberValue(primitiveSexprs[0]) ?? 0;
    const y = toNumberValue(primitiveSexprs[1]) ?? 0;
    return new _FpCircleCenter(x, y);
  }
  getString() {
    return `(center ${this.x} ${this.y})`;
  }
};
SxClass.register(FpCircleCenter);
var FpCircleEnd = class _FpCircleEnd extends SxClass {
  static token = "end";
  static parentToken = "fp_circle";
  token = "end";
  x;
  y;
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const x = toNumberValue(primitiveSexprs[0]) ?? 0;
    const y = toNumberValue(primitiveSexprs[1]) ?? 0;
    return new _FpCircleEnd(x, y);
  }
  getString() {
    return `(end ${this.x} ${this.y})`;
  }
};
SxClass.register(FpCircleEnd);
var FpCircleFill = class _FpCircleFill extends SxClass {
  static token = "fill";
  static parentToken = "fp_circle";
  token = "fill";
  filled;
  constructor(filled) {
    super();
    this.filled = filled;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const state = toStringValue(primitiveSexprs[0]);
    return new _FpCircleFill(state === "yes");
  }
  getString() {
    return `(fill ${this.filled ? "yes" : "no"})`;
  }
};
SxClass.register(FpCircleFill);

// lib/sexpr/classes/FpArc.ts
var FpArc = class _FpArc extends SxClass {
  static token = "fp_arc";
  token = "fp_arc";
  _sxStart;
  _sxMid;
  _sxEnd;
  _sxLayer;
  _sxWidth;
  _sxStroke;
  _sxTstamp;
  _sxUuid;
  _locked = false;
  constructor(params = {}) {
    super();
    if (params.start !== void 0) this.start = params.start;
    if (params.mid !== void 0) this.mid = params.mid;
    if (params.end !== void 0) this.end = params.end;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.width !== void 0) this.width = params.width;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.tstamp !== void 0) this.tstamp = params.tstamp;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.locked !== void 0) this.locked = params.locked;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const arc = new _FpArc();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    arc._sxStart = propertyMap.start;
    arc._sxMid = propertyMap.mid;
    arc._sxEnd = propertyMap.end;
    arc._sxLayer = propertyMap.layer;
    arc._sxWidth = propertyMap.width;
    arc._sxStroke = propertyMap.stroke;
    arc._sxTstamp = propertyMap.tstamp;
    arc._sxUuid = propertyMap.uuid;
    for (const primitive of primitiveSexprs) {
      if (primitive === "locked") {
        arc._locked = true;
      }
    }
    return arc;
  }
  get start() {
    return this._sxStart;
  }
  set start(value) {
    if (value === void 0) {
      this._sxStart = void 0;
      return;
    }
    if (value instanceof FpArcStart) {
      this._sxStart = value;
      return;
    }
    this._sxStart = new FpArcStart(value.x, value.y);
  }
  get mid() {
    return this._sxMid;
  }
  set mid(value) {
    if (value === void 0) {
      this._sxMid = void 0;
      return;
    }
    if (value instanceof FpArcMid) {
      this._sxMid = value;
      return;
    }
    this._sxMid = new FpArcMid(value.x, value.y);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    if (value === void 0) {
      this._sxEnd = void 0;
      return;
    }
    if (value instanceof FpArcEnd) {
      this._sxEnd = value;
      return;
    }
    this._sxEnd = new FpArcEnd(value.x, value.y);
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    if (value instanceof Width) {
      this._sxWidth = value;
      return;
    }
    this._sxWidth = new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid?.value;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    if (value instanceof Uuid) {
      this._sxUuid = value;
      return;
    }
    this._sxUuid = new Uuid(value);
  }
  get uuidClass() {
    return this._sxUuid;
  }
  get locked() {
    return this._locked;
  }
  set locked(value) {
    this._locked = value;
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxMid) children.push(this._sxMid);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
  getString() {
    const lines = ["(fp_arc"];
    const push = (value) => {
      if (!value) return;
      lines.push(value.getStringIndented());
    };
    push(this._sxStart);
    push(this._sxMid);
    push(this._sxEnd);
    push(this._sxLayer);
    push(this._sxWidth);
    push(this._sxStroke);
    push(this._sxTstamp);
    push(this._sxUuid);
    if (this._locked) {
      lines.push("  locked");
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(FpArc);
var FpArcStart = class _FpArcStart extends SxClass {
  static token = "start";
  static parentToken = "fp_arc";
  token = "start";
  x;
  y;
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const x = toNumberValue(primitiveSexprs[0]) ?? 0;
    const y = toNumberValue(primitiveSexprs[1]) ?? 0;
    return new _FpArcStart(x, y);
  }
  getString() {
    return `(start ${this.x} ${this.y})`;
  }
};
SxClass.register(FpArcStart);
var FpArcMid = class _FpArcMid extends SxClass {
  static token = "mid";
  static parentToken = "fp_arc";
  token = "mid";
  x;
  y;
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const x = toNumberValue(primitiveSexprs[0]) ?? 0;
    const y = toNumberValue(primitiveSexprs[1]) ?? 0;
    return new _FpArcMid(x, y);
  }
  getString() {
    return `(mid ${this.x} ${this.y})`;
  }
};
SxClass.register(FpArcMid);
var FpArcEnd = class _FpArcEnd extends SxClass {
  static token = "end";
  static parentToken = "fp_arc";
  token = "end";
  x;
  y;
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const x = toNumberValue(primitiveSexprs[0]) ?? 0;
    const y = toNumberValue(primitiveSexprs[1]) ?? 0;
    return new _FpArcEnd(x, y);
  }
  getString() {
    return `(end ${this.x} ${this.y})`;
  }
};
SxClass.register(FpArcEnd);

// lib/sexpr/classes/FpPolyFill.ts
var truthyStrings = /* @__PURE__ */ new Set(["yes", "true", "1", "solid"]);
var FpPolyFill = class _FpPolyFill extends SxClass {
  static token = "fill";
  static parentToken = "fp_poly";
  token = "fill";
  value;
  constructor(value) {
    super();
    if (typeof value === "boolean") {
      this.value = value ? "yes" : "no";
    } else {
      this.value = value;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawValue] = primitiveSexprs;
    if (rawValue === void 0) {
      return new _FpPolyFill("no");
    }
    if (typeof rawValue === "boolean") {
      return new _FpPolyFill(rawValue);
    }
    if (typeof rawValue === "string") {
      return new _FpPolyFill(rawValue);
    }
    return new _FpPolyFill("no");
  }
  get filled() {
    return truthyStrings.has(this.value.toLowerCase());
  }
  set filled(filled) {
    this.value = filled ? "yes" : "no";
  }
  getString() {
    return `(fill ${this.value})`;
  }
};
SxClass.register(FpPolyFill);

// lib/sexpr/classes/FpPolyLocked.ts
var truthyStrings2 = /* @__PURE__ */ new Set(["yes", "true", "1"]);
var FpPolyLocked = class _FpPolyLocked extends SxPrimitiveBoolean {
  static token = "locked";
  static parentToken = "fp_poly";
  token = "locked";
  constructor(value) {
    super(value);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawValue] = primitiveSexprs;
    if (rawValue === void 0) {
      return new _FpPolyLocked(true);
    }
    if (typeof rawValue === "boolean") {
      return new _FpPolyLocked(rawValue);
    }
    if (typeof rawValue === "string") {
      return new _FpPolyLocked(truthyStrings2.has(rawValue.toLowerCase()));
    }
    return new _FpPolyLocked(false);
  }
  getString() {
    return `(locked ${this.value ? "yes" : "no"})`;
  }
};
SxClass.register(FpPolyLocked);

// lib/sexpr/classes/FpPoly.ts
var SUPPORTED_TOKENS12 = /* @__PURE__ */ new Set([
  "pts",
  "xy",
  "layer",
  "width",
  "stroke",
  "fill",
  "locked",
  "tstamp",
  "uuid"
]);
var FpPoly = class _FpPoly extends SxClass {
  static token = "fp_poly";
  token = "fp_poly";
  _sxPts;
  _sxLayer;
  _sxWidth;
  _sxStroke;
  _sxFill;
  _sxLocked;
  _sxTstamp;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.points !== void 0) this.points = params.points;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.width !== void 0) this.width = params.width;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.fill !== void 0) this.fill = params.fill;
    if (params.locked !== void 0) this.locked = params.locked;
    if (params.tstamp !== void 0) this.tstamp = params.tstamp;
    if (params.uuid !== void 0) this.uuid = params.uuid;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const fpPoly = new _FpPoly();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    const unexpectedTokens = /* @__PURE__ */ new Set();
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_TOKENS12.has(token)) {
        unexpectedTokens.add(token);
      }
    }
    for (const token of Object.keys(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS12.has(token)) {
        unexpectedTokens.add(token);
      }
      if (token !== "xy" && arrayPropertyMap[token].length > 1) {
        unexpectedTokens.add(token);
      }
    }
    if (unexpectedTokens.size > 0) {
      throw new Error(
        `Unsupported child tokens inside fp_poly expression: ${[...unexpectedTokens].join(", ")}`
      );
    }
    const ptsEntries = arrayPropertyMap.pts;
    if (ptsEntries && ptsEntries.length > 1) {
      throw new Error("fp_poly does not support repeated pts tokens");
    }
    const xyEntries = arrayPropertyMap.xy;
    let pts = propertyMap.pts;
    if (pts && xyEntries && xyEntries.length > 0) {
      throw new Error("fp_poly cannot mix pts and xy child tokens");
    }
    if (!pts && ptsEntries?.length) {
      pts = ptsEntries[0];
    }
    if (!pts && xyEntries && xyEntries.length > 0) {
      pts = new Pts(xyEntries);
    }
    fpPoly._sxPts = pts;
    fpPoly._sxLayer = propertyMap.layer;
    fpPoly._sxWidth = propertyMap.width;
    fpPoly._sxStroke = propertyMap.stroke;
    fpPoly._sxFill = propertyMap.fill;
    const lockedClass = propertyMap.locked;
    fpPoly._sxLocked = lockedClass && lockedClass.value ? lockedClass : void 0;
    fpPoly._sxTstamp = propertyMap.tstamp;
    fpPoly._sxUuid = propertyMap.uuid;
    for (const primitive of primitiveSexprs) {
      if (primitive === "locked") {
        if (!fpPoly._sxLocked) {
          fpPoly._sxLocked = new FpPolyLocked(true);
        }
        continue;
      }
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `fp_poly encountered unexpected primitive child: ${JSON.stringify(primitive)}`
        );
      }
      const [token, ...rest] = primitive;
      if (typeof token !== "string") {
        throw new Error(
          `fp_poly child token must be a string, received: ${JSON.stringify(token)}`
        );
      }
      if (!SUPPORTED_TOKENS12.has(token)) {
        throw new Error(
          `Unsupported child token inside fp_poly expression: ${token}`
        );
      }
      if (token === "locked" && !fpPoly._sxLocked) {
        fpPoly._sxLocked = FpPolyLocked.fromSexprPrimitives(
          rest
        );
        if (!fpPoly._sxLocked.value) {
          fpPoly._sxLocked = void 0;
        }
      }
    }
    if (!fpPoly._sxPts) {
      throw new Error("fp_poly requires pts or xy child tokens");
    }
    if (!fpPoly._sxLayer) {
      throw new Error("fp_poly requires a layer child token");
    }
    if (!fpPoly._sxUuid && !fpPoly._sxTstamp) {
      throw new Error("fp_poly requires a uuid or tstamp child token");
    }
    return fpPoly;
  }
  get points() {
    return this._sxPts;
  }
  set points(value) {
    if (value === void 0) {
      this._sxPts = void 0;
      return;
    }
    if (value instanceof Pts) {
      this._sxPts = value;
      return;
    }
    if (Array.isArray(value) && value.every((point) => point instanceof Xy)) {
      this._sxPts = new Pts(value);
      return;
    }
    if (Array.isArray(value)) {
      this._sxPts = new Pts(value.map(({ x, y }) => new Xy(x, y)));
      return;
    }
    throw new Error("Unsupported points value provided to fp_poly");
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    this._sxWidth = value instanceof Width ? value : new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  set widthClass(value) {
    this._sxWidth = value;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get fill() {
    return this._sxFill;
  }
  set fill(value) {
    if (value === void 0) {
      this._sxFill = void 0;
      return;
    }
    if (value instanceof FpPolyFill) {
      this._sxFill = value;
      return;
    }
    this._sxFill = new FpPolyFill(value);
  }
  get locked() {
    return this._sxLocked?.value ?? false;
  }
  set locked(value) {
    this._sxLocked = value ? new FpPolyLocked(true) : void 0;
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  getChildren() {
    const children = [];
    if (this._sxPts) children.push(this._sxPts);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxFill) children.push(this._sxFill);
    if (this._sxLocked) children.push(this._sxLocked);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
};
SxClass.register(FpPoly);

// lib/sexpr/classes/FootprintSheetname.ts
var FootprintSheetname = class _FootprintSheetname extends SxClass {
  static token = "sheetname";
  static parentToken = "footprint";
  token = "sheetname";
  _value;
  constructor(value) {
    super();
    this._value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const value = toStringValue(primitiveSexprs[0]);
    if (value === void 0) {
      throw new Error("sheetname expects a string value");
    }
    return new _FootprintSheetname(value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(sheetname ${quoteSExprString(this._value)})`;
  }
};
SxClass.register(FootprintSheetname);

// lib/sexpr/classes/FootprintSheetfile.ts
var FootprintSheetfile = class _FootprintSheetfile extends SxClass {
  static token = "sheetfile";
  static parentToken = "footprint";
  token = "sheetfile";
  _value;
  constructor(value) {
    super();
    this._value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const value = toStringValue(primitiveSexprs[0]);
    if (value === void 0) {
      throw new Error("sheetfile expects a string value");
    }
    return new _FootprintSheetfile(value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(sheetfile ${quoteSExprString(this._value)})`;
  }
};
SxClass.register(FootprintSheetfile);

// lib/sexpr/classes/FpLine.ts
var SUPPORTED_SINGLE_TOKENS4 = /* @__PURE__ */ new Set([
  "start",
  "end",
  "layer",
  "width",
  "stroke",
  "tstamp",
  "uuid"
]);
var FpLine = class _FpLine extends SxClass {
  static token = "fp_line";
  static parentToken = "footprint";
  token = "fp_line";
  _sxStart;
  _sxEnd;
  _sxLayer;
  _sxWidth;
  _sxStroke;
  _sxTstamp;
  _sxUuid;
  _locked = false;
  constructor(params = {}) {
    super();
    if (params.start !== void 0) this.start = params.start;
    if (params.end !== void 0) this.end = params.end;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.width !== void 0) this.width = params.width;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.tstamp !== void 0) this.tstamp = params.tstamp;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.locked !== void 0) this.locked = params.locked;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const fpLine = new _FpLine();
    const structuredPrimitives = [];
    for (const primitive of primitiveSexprs) {
      if (typeof primitive === "string") {
        if (primitive === "locked") {
          if (fpLine._locked) {
            throw new Error("fp_line encountered duplicate locked flags");
          }
          fpLine._locked = true;
          continue;
        }
        throw new Error(`fp_line encountered unsupported flag "${primitive}"`);
      }
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `fp_line encountered invalid child expression: ${JSON.stringify(primitive)}`
        );
      }
      structuredPrimitives.push(primitive);
    }
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(structuredPrimitives, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS4.has(token)) {
        throw new Error(
          `fp_line encountered unsupported child token "${token}"`
        );
      }
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS4.has(token)) {
        throw new Error(
          `fp_line encountered unsupported child token "${token}"`
        );
      }
      if (entries.length > 1) {
        throw new Error(
          `fp_line does not support repeated child token "${token}"`
        );
      }
    }
    fpLine._sxStart = arrayPropertyMap.start?.[0] ?? propertyMap.start;
    fpLine._sxEnd = arrayPropertyMap.end?.[0] ?? propertyMap.end;
    fpLine._sxLayer = arrayPropertyMap.layer?.[0] ?? propertyMap.layer;
    fpLine._sxWidth = arrayPropertyMap.width?.[0] ?? propertyMap.width;
    fpLine._sxStroke = arrayPropertyMap.stroke?.[0] ?? propertyMap.stroke;
    fpLine._sxTstamp = arrayPropertyMap.tstamp?.[0] ?? propertyMap.tstamp;
    fpLine._sxUuid = arrayPropertyMap.uuid?.[0] ?? propertyMap.uuid;
    if (!fpLine._sxStart) {
      throw new Error("fp_line requires a start child token");
    }
    if (!fpLine._sxEnd) {
      throw new Error("fp_line requires an end child token");
    }
    if (!fpLine._sxLayer) {
      throw new Error("fp_line requires a layer child token");
    }
    return fpLine;
  }
  get start() {
    return this._sxStart;
  }
  set start(value) {
    if (value === void 0) {
      this._sxStart = void 0;
      return;
    }
    this._sxStart = value instanceof FpLineStart ? value : new FpLineStart(value.x, value.y);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    if (value === void 0) {
      this._sxEnd = void 0;
      return;
    }
    this._sxEnd = value instanceof FpLineEnd ? value : new FpLineEnd(value.x, value.y);
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    this._sxWidth = value === void 0 ? void 0 : new Width(value);
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get locked() {
    return this._locked;
  }
  set locked(value) {
    this._locked = value;
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxStroke) {
      children.push(this._sxStroke);
    } else if (this._sxWidth) {
      children.push(this._sxWidth);
    }
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._locked) children.push(new FpLineLocked());
    return children;
  }
};
SxClass.register(FpLine);
var FpLineStart = class _FpLineStart extends SxClass {
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static token = "start";
  static parentToken = "fp_line";
  token = "start";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = Number(rawX);
    const y = Number(rawY);
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      throw new Error("fp_line start expects numeric coordinates");
    }
    return new _FpLineStart(x, y);
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(start ${this.x} ${this.y})`;
  }
};
SxClass.register(FpLineStart);
var FpLineEnd = class _FpLineEnd extends SxClass {
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static token = "end";
  static parentToken = "fp_line";
  token = "end";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = Number(rawX);
    const y = Number(rawY);
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      throw new Error("fp_line end expects numeric coordinates");
    }
    return new _FpLineEnd(x, y);
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(end ${this.x} ${this.y})`;
  }
};
SxClass.register(FpLineEnd);
var FpLineLocked = class _FpLineLocked extends SxClass {
  static token = "locked";
  static parentToken = "fp_line";
  token = "locked";
  static fromSexprPrimitives() {
    return new _FpLineLocked();
  }
  getChildren() {
    return [];
  }
  getString() {
    return "locked";
  }
};
SxClass.register(FpLineLocked);

// lib/sexpr/classes/FootprintModel.ts
var DEFAULT_VECTOR = { x: 0, y: 0, z: 0 };
var FootprintModel = class _FootprintModel extends SxClass {
  static token = "model";
  static parentToken = "footprint";
  token = "model";
  _path;
  _offset;
  _scale;
  _rotate;
  _hide = false;
  constructor(path) {
    super();
    this._path = path;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length === 0) {
      throw new Error("model requires a path argument");
    }
    const [rawPath, ...rest] = primitiveSexprs;
    const path = toStringValue(rawPath);
    if (path === void 0) {
      throw new Error("model path must be a string value");
    }
    const model = new _FootprintModel(path);
    for (const primitive of rest) {
      if (typeof primitive === "string") {
        if (primitive === "hide") {
          model._hide = true;
          continue;
        }
        throw new Error(`model encountered unsupported flag "${primitive}"`);
      }
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `model encountered invalid child expression: ${JSON.stringify(primitive)}`
        );
      }
      const [token, ...args] = primitive;
      if (token === "offset") {
        model._offset = parseVectorArgs(args, "offset");
        continue;
      }
      if (token === "scale") {
        model._scale = parseVectorArgs(args, "scale");
        continue;
      }
      if (token === "rotate") {
        model._rotate = parseVectorArgs(args, "rotate");
        continue;
      }
      throw new Error(`model encountered unsupported child token "${token}"`);
    }
    return model;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get offset() {
    return this._offset ? { ...this._offset } : void 0;
  }
  set offset(value) {
    this._offset = value ? { ...value } : void 0;
  }
  get scale() {
    return this._scale ? { ...this._scale } : void 0;
  }
  set scale(value) {
    this._scale = value ? { ...value } : void 0;
  }
  get rotate() {
    return this._rotate ? { ...this._rotate } : void 0;
  }
  set rotate(value) {
    this._rotate = value ? { ...value } : void 0;
  }
  get hide() {
    return this._hide;
  }
  set hide(value) {
    this._hide = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    const lines = [`(model ${quoteSExprString(this._path)}`];
    if (this._hide) {
      lines.push("  hide");
    }
    if (this._offset) {
      lines.push(renderVectorBlock("offset", this._offset));
    }
    if (this._scale) {
      lines.push(renderVectorBlock("scale", this._scale));
    }
    if (this._rotate) {
      lines.push(renderVectorBlock("rotate", this._rotate));
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(FootprintModel);
function parseVectorArgs(args, token) {
  if (args.length !== 1) {
    throw new Error(`model ${token} expects a single xyz child`);
  }
  const [first] = args;
  if (!Array.isArray(first) || first.length !== 4 || first[0] !== "xyz") {
    throw new Error(
      `model ${token} expects (xyz x y z), received ${JSON.stringify(first)}`
    );
  }
  const [, rawX, rawY, rawZ] = first;
  const x = toNumberValue(rawX) ?? DEFAULT_VECTOR.x;
  const y = toNumberValue(rawY) ?? DEFAULT_VECTOR.y;
  const z = toNumberValue(rawZ) ?? DEFAULT_VECTOR.z;
  return { x, y, z };
}
function renderVectorBlock(label, vector) {
  return `  (${label}
    (xyz ${vector.x} ${vector.y} ${vector.z})
  )`;
}

// lib/sexpr/classes/FootprintLocked.ts
var FootprintLocked = class _FootprintLocked extends SxPrimitiveBoolean {
  static token = "locked";
  static parentToken = "footprint";
  token = "locked";
  constructor(value = true) {
    super(value);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length === 0) {
      return new _FootprintLocked(true);
    }
    const parsed = parseYesNo(primitiveSexprs[0]);
    if (parsed === void 0) {
      throw new Error(
        `locked expects yes/no, received ${JSON.stringify(primitiveSexprs[0])}`
      );
    }
    return new _FootprintLocked(parsed);
  }
};
SxClass.register(FootprintLocked);

// lib/sexpr/classes/FootprintPlaced.ts
var FootprintPlaced = class _FootprintPlaced extends SxPrimitiveBoolean {
  static token = "placed";
  static parentToken = "footprint";
  token = "placed";
  constructor(value = true) {
    super(value);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length === 0) {
      return new _FootprintPlaced(true);
    }
    const parsed = parseYesNo(primitiveSexprs[0]);
    if (parsed === void 0) {
      throw new Error(
        `placed expects yes/no, received ${JSON.stringify(primitiveSexprs[0])}`
      );
    }
    return new _FootprintPlaced(parsed);
  }
};
SxClass.register(FootprintPlaced);

// lib/sexpr/classes/Footprint.ts
var SINGLE_TOKENS2 = /* @__PURE__ */ new Set([
  "layer",
  "locked",
  "placed",
  "tedit",
  "tstamp",
  "uuid",
  "at",
  "xy",
  "descr",
  "tags",
  "path",
  "autoplace_cost90",
  "autoplace_cost180",
  "solder_mask_margin",
  "solder_paste_margin",
  "solder_paste_ratio",
  "clearance",
  "zone_connect",
  "thermal_width",
  "thermal_gap",
  "attr",
  "private_layers",
  "net_tie_pad_groups",
  "sheetname",
  "sheetfile",
  "embedded_fonts"
]);
var MULTI_TOKENS2 = /* @__PURE__ */ new Set([
  "property",
  "fp_text",
  "fp_text_box",
  "fp_line",
  "fp_rect",
  "fp_circle",
  "fp_arc",
  "fp_poly",
  "pad",
  "model"
]);
var SUPPORTED_TOKENS13 = /* @__PURE__ */ new Set([...SINGLE_TOKENS2, ...MULTI_TOKENS2]);
var Footprint = class _Footprint extends SxClass {
  static token = "footprint";
  token = "footprint";
  _libraryLink;
  _sxLocked;
  _sxPlaced;
  _sxLayer;
  _sxTedit;
  _sxTstamp;
  _sxUuid;
  _sxAt;
  _sxXy;
  _sxDescr;
  _sxTags;
  _sxPath;
  _sxAutoplaceCost90;
  _sxAutoplaceCost180;
  _sxSolderMaskMargin;
  _sxSolderPasteMargin;
  _sxSolderPasteRatio;
  _sxClearance;
  _sxZoneConnect;
  _sxThermalWidth;
  _sxThermalGap;
  _sxAttr;
  _sxPrivateLayers;
  _sxNetTiePadGroups;
  _sxSheetname;
  _sxSheetfile;
  _sxEmbeddedFonts;
  _properties = [];
  _fpTexts = [];
  _fpTextBoxes = [];
  _fpLines = [];
  _fpRects = [];
  _fpCircles = [];
  _fpArcs = [];
  _fpPolys = [];
  _fpPads = [];
  _models = [];
  constructor(params = {}) {
    super();
    if (params.libraryLink !== void 0) this.libraryLink = params.libraryLink;
    if (params.locked !== void 0) this.locked = params.locked;
    if (params.placed !== void 0) this.placed = params.placed;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.tstamp !== void 0) this.tstamp = params.tstamp;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.at !== void 0) this.position = params.at;
    if (params.descr !== void 0) this.descr = params.descr;
    if (params.tags !== void 0) this.tags = params.tags;
    if (params.path !== void 0) this.path = params.path;
    if (params.autoplaceCost90 !== void 0)
      this.autoplaceCost90 = params.autoplaceCost90;
    if (params.autoplaceCost180 !== void 0)
      this.autoplaceCost180 = params.autoplaceCost180;
    if (params.solderMaskMargin !== void 0)
      this.solderMaskMargin = params.solderMaskMargin;
    if (params.solderPasteMargin !== void 0)
      this.solderPasteMargin = params.solderPasteMargin;
    if (params.solderPasteRatio !== void 0)
      this.solderPasteRatio = params.solderPasteRatio;
    if (params.clearance !== void 0) this.clearance = params.clearance;
    if (params.zoneConnect !== void 0) this.zoneConnect = params.zoneConnect;
    if (params.thermalWidth !== void 0)
      this.thermalWidth = params.thermalWidth;
    if (params.thermalGap !== void 0) this.thermalGap = params.thermalGap;
    if (params.attr !== void 0) this.attr = params.attr;
    if (params.privateLayers !== void 0)
      this.privateLayers = params.privateLayers;
    if (params.netTiePadGroups !== void 0)
      this.netTiePadGroups = params.netTiePadGroups;
    if (params.sheetname !== void 0) this.sheetname = params.sheetname;
    if (params.sheetfile !== void 0) this.sheetfile = params.sheetfile;
    if (params.embeddedFonts !== void 0)
      this.embeddedFonts = params.embeddedFonts;
    if (params.properties !== void 0) this.properties = params.properties;
    if (params.fpTexts !== void 0) this.fpTexts = params.fpTexts;
    if (params.fpTextBoxes !== void 0) this.fpTextBoxes = params.fpTextBoxes;
    if (params.fpLines !== void 0) this.fpLines = params.fpLines;
    if (params.fpRects !== void 0) this.fpRects = params.fpRects;
    if (params.fpCircles !== void 0) this.fpCircles = params.fpCircles;
    if (params.fpArcs !== void 0) this.fpArcs = params.fpArcs;
    if (params.fpPolys !== void 0) this.fpPolys = params.fpPolys;
    if (params.pads !== void 0) this.fpPads = params.pads;
    if (params.models !== void 0) this.models = params.models;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const footprint = new _Footprint();
    const rawStrings = [];
    const rawNodes = [];
    for (const primitive of primitiveSexprs) {
      if (typeof primitive === "string") {
        rawStrings.push(primitive);
        continue;
      }
      if (Array.isArray(primitive)) {
        rawNodes.push(primitive);
        continue;
      }
      throw new Error(
        `footprint encountered unsupported primitive child: ${JSON.stringify(primitive)}`
      );
    }
    let pendingFlags = [];
    if (rawStrings.length > 0) {
      footprint._libraryLink = rawStrings[0];
      pendingFlags = rawStrings.slice(1);
    }
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(rawNodes, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_TOKENS13.has(token)) {
        throw new Error(
          `footprint encountered unsupported child token "${token}"`
        );
      }
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS13.has(token)) {
        throw new Error(
          `footprint encountered unsupported child token "${token}"`
        );
      }
      if (!MULTI_TOKENS2.has(token) && entries.length > 1) {
        throw new Error(
          `footprint does not support repeated child token "${token}"`
        );
      }
    }
    footprint._sxLocked = propertyMap.locked;
    if (footprint._sxLocked && !footprint._sxLocked.value) {
      footprint._sxLocked = void 0;
    }
    footprint._sxPlaced = propertyMap.placed;
    if (footprint._sxPlaced && !footprint._sxPlaced.value) {
      footprint._sxPlaced = void 0;
    }
    footprint._sxLayer = propertyMap.layer;
    footprint._sxTedit = propertyMap.tedit;
    footprint._sxTstamp = propertyMap.tstamp;
    footprint._sxUuid = propertyMap.uuid;
    footprint._sxAt = propertyMap.at;
    footprint._sxXy = propertyMap.xy;
    if (footprint._sxAt && footprint._sxXy) {
      throw new Error("footprint cannot include both at and xy children");
    }
    footprint._sxDescr = propertyMap.descr;
    footprint._sxTags = propertyMap.tags;
    footprint._sxPath = propertyMap.path;
    footprint._sxAutoplaceCost90 = propertyMap.autoplace_cost90;
    footprint._sxAutoplaceCost180 = propertyMap.autoplace_cost180;
    footprint._sxSolderMaskMargin = propertyMap.solder_mask_margin;
    footprint._sxSolderPasteMargin = propertyMap.solder_paste_margin;
    footprint._sxSolderPasteRatio = propertyMap.solder_paste_ratio;
    footprint._sxClearance = propertyMap.clearance;
    footprint._sxZoneConnect = propertyMap.zone_connect;
    footprint._sxThermalWidth = propertyMap.thermal_width;
    footprint._sxThermalGap = propertyMap.thermal_gap;
    footprint._sxAttr = propertyMap.attr;
    footprint._sxPrivateLayers = propertyMap.private_layers;
    footprint._sxNetTiePadGroups = propertyMap.net_tie_pad_groups;
    footprint._sxSheetname = propertyMap.sheetname;
    footprint._sxSheetfile = propertyMap.sheetfile;
    footprint._sxEmbeddedFonts = propertyMap.embedded_fonts;
    footprint._properties = arrayPropertyMap.property ?? [];
    footprint._fpTexts = arrayPropertyMap["fp_text"] ?? [];
    footprint._fpTextBoxes = arrayPropertyMap["fp_text_box"] ?? [];
    footprint._fpLines = arrayPropertyMap["fp_line"] ?? [];
    footprint._fpRects = arrayPropertyMap["fp_rect"] ?? [];
    footprint._fpCircles = arrayPropertyMap["fp_circle"] ?? [];
    footprint._fpArcs = arrayPropertyMap["fp_arc"] ?? [];
    footprint._fpPolys = arrayPropertyMap["fp_poly"] ?? [];
    footprint._fpPads = arrayPropertyMap.pad ?? [];
    footprint._models = arrayPropertyMap.model ?? [];
    for (const flag of pendingFlags) {
      if (flag === "locked") {
        if (footprint._sxLocked) {
          throw new Error("footprint encountered duplicate locked tokens");
        }
        footprint._sxLocked = new FootprintLocked(true);
        continue;
      }
      if (flag === "placed") {
        if (footprint._sxPlaced) {
          throw new Error("footprint encountered duplicate placed tokens");
        }
        footprint._sxPlaced = new FootprintPlaced(true);
        continue;
      }
      throw new Error(`footprint encountered unsupported flag "${flag}"`);
    }
    return footprint;
  }
  get libraryLink() {
    return this._libraryLink;
  }
  set libraryLink(value) {
    this._libraryLink = value;
  }
  get locked() {
    return this._sxLocked?.value ?? false;
  }
  set locked(value) {
    if (value === void 0) {
      this._sxLocked = void 0;
      return;
    }
    if (value instanceof FootprintLocked) {
      this._sxLocked = value.value ? value : void 0;
      return;
    }
    this._sxLocked = value ? new FootprintLocked(true) : void 0;
  }
  get placed() {
    return this._sxPlaced?.value ?? false;
  }
  set placed(value) {
    if (value === void 0) {
      this._sxPlaced = void 0;
      return;
    }
    if (value instanceof FootprintPlaced) {
      this._sxPlaced = value.value ? value : void 0;
      return;
    }
    this._sxPlaced = value ? new FootprintPlaced(true) : void 0;
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
    } else {
      const names = Array.isArray(value) ? value : [value];
      this._sxLayer = new Layer(names);
    }
  }
  get tedit() {
    return this._sxTedit;
  }
  set tedit(value) {
    if (value === void 0) {
      this._sxTedit = void 0;
      return;
    }
    this._sxTedit = value instanceof FootprintTedit ? value : new FootprintTedit(value);
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get position() {
    return this._sxAt ?? this._sxXy;
  }
  set position(value) {
    if (value === void 0) {
      this._sxAt = void 0;
      this._sxXy = void 0;
      return;
    }
    if (value instanceof Xy) {
      this._sxXy = value;
      this._sxAt = void 0;
      return;
    }
    this._sxAt = At.from(value);
    this._sxXy = void 0;
  }
  get descr() {
    return this._sxDescr;
  }
  set descr(value) {
    if (value === void 0) {
      this._sxDescr = void 0;
      return;
    }
    this._sxDescr = value instanceof FootprintDescr ? value : new FootprintDescr(value);
  }
  get tags() {
    return this._sxTags;
  }
  set tags(value) {
    if (value === void 0) {
      this._sxTags = void 0;
      return;
    }
    if (value instanceof FootprintTags) {
      this._sxTags = value;
      return;
    }
    const tagString = Array.isArray(value) ? value.join(" ") : value;
    this._sxTags = new FootprintTags(tagString);
  }
  get path() {
    return this._sxPath;
  }
  set path(value) {
    if (value === void 0) {
      this._sxPath = void 0;
      return;
    }
    this._sxPath = value instanceof FootprintPath ? value : new FootprintPath(value);
  }
  get autoplaceCost90() {
    return this._sxAutoplaceCost90;
  }
  set autoplaceCost90(value) {
    if (value === void 0) {
      this._sxAutoplaceCost90 = void 0;
      return;
    }
    this._sxAutoplaceCost90 = value instanceof FootprintAutoplaceCost90 ? value : new FootprintAutoplaceCost90(value);
  }
  get autoplaceCost180() {
    return this._sxAutoplaceCost180;
  }
  set autoplaceCost180(value) {
    if (value === void 0) {
      this._sxAutoplaceCost180 = void 0;
      return;
    }
    this._sxAutoplaceCost180 = value instanceof FootprintAutoplaceCost180 ? value : new FootprintAutoplaceCost180(value);
  }
  get solderMaskMargin() {
    return this._sxSolderMaskMargin;
  }
  set solderMaskMargin(value) {
    if (value === void 0) {
      this._sxSolderMaskMargin = void 0;
      return;
    }
    this._sxSolderMaskMargin = value instanceof FootprintSolderMaskMargin ? value : new FootprintSolderMaskMargin(value);
  }
  get solderPasteMargin() {
    return this._sxSolderPasteMargin;
  }
  set solderPasteMargin(value) {
    if (value === void 0) {
      this._sxSolderPasteMargin = void 0;
      return;
    }
    this._sxSolderPasteMargin = value instanceof FootprintSolderPasteMargin ? value : new FootprintSolderPasteMargin(value);
  }
  get solderPasteRatio() {
    return this._sxSolderPasteRatio;
  }
  set solderPasteRatio(value) {
    if (value === void 0) {
      this._sxSolderPasteRatio = void 0;
      return;
    }
    this._sxSolderPasteRatio = value instanceof FootprintSolderPasteRatio ? value : new FootprintSolderPasteRatio(value);
  }
  get clearance() {
    return this._sxClearance;
  }
  set clearance(value) {
    if (value === void 0) {
      this._sxClearance = void 0;
      return;
    }
    this._sxClearance = value instanceof FootprintClearance ? value : new FootprintClearance(value);
  }
  get zoneConnect() {
    return this._sxZoneConnect;
  }
  set zoneConnect(value) {
    if (value === void 0) {
      this._sxZoneConnect = void 0;
      return;
    }
    this._sxZoneConnect = value instanceof FootprintZoneConnect ? value : new FootprintZoneConnect(value);
  }
  get thermalWidth() {
    return this._sxThermalWidth;
  }
  set thermalWidth(value) {
    if (value === void 0) {
      this._sxThermalWidth = void 0;
      return;
    }
    this._sxThermalWidth = value instanceof FootprintThermalWidth ? value : new FootprintThermalWidth(value);
  }
  get thermalGap() {
    return this._sxThermalGap;
  }
  set thermalGap(value) {
    if (value === void 0) {
      this._sxThermalGap = void 0;
      return;
    }
    this._sxThermalGap = value instanceof FootprintThermalGap ? value : new FootprintThermalGap(value);
  }
  get attr() {
    return this._sxAttr;
  }
  set attr(value) {
    this._sxAttr = value;
  }
  get privateLayers() {
    return this._sxPrivateLayers;
  }
  set privateLayers(value) {
    if (value === void 0) {
      this._sxPrivateLayers = void 0;
      return;
    }
    this._sxPrivateLayers = value instanceof FootprintPrivateLayers ? value : new FootprintPrivateLayers(value);
  }
  get netTiePadGroups() {
    return this._sxNetTiePadGroups;
  }
  set netTiePadGroups(value) {
    if (value === void 0) {
      this._sxNetTiePadGroups = void 0;
      return;
    }
    this._sxNetTiePadGroups = value instanceof FootprintNetTiePadGroups ? value : new FootprintNetTiePadGroups(value);
  }
  get sheetname() {
    return this._sxSheetname?.value;
  }
  set sheetname(value) {
    if (value === void 0) {
      this._sxSheetname = void 0;
      return;
    }
    this._sxSheetname = value instanceof FootprintSheetname ? value : new FootprintSheetname(value);
  }
  get sheetfile() {
    return this._sxSheetfile?.value;
  }
  set sheetfile(value) {
    if (value === void 0) {
      this._sxSheetfile = void 0;
      return;
    }
    this._sxSheetfile = value instanceof FootprintSheetfile ? value : new FootprintSheetfile(value);
  }
  get embeddedFonts() {
    return this._sxEmbeddedFonts;
  }
  set embeddedFonts(value) {
    this._sxEmbeddedFonts = value;
  }
  get properties() {
    return [...this._properties];
  }
  set properties(value) {
    this._properties = [...value];
  }
  get fpTexts() {
    return [...this._fpTexts];
  }
  set fpTexts(value) {
    this._fpTexts = [...value];
  }
  get fpTextBoxes() {
    return [...this._fpTextBoxes];
  }
  set fpTextBoxes(value) {
    this._fpTextBoxes = [...value];
  }
  get fpLines() {
    return [...this._fpLines];
  }
  set fpLines(value) {
    this._fpLines = [...value];
  }
  get fpRects() {
    return [...this._fpRects];
  }
  set fpRects(value) {
    this._fpRects = [...value];
  }
  get fpCircles() {
    return [...this._fpCircles];
  }
  set fpCircles(value) {
    this._fpCircles = [...value];
  }
  get fpArcs() {
    return [...this._fpArcs];
  }
  set fpArcs(value) {
    this._fpArcs = [...value];
  }
  get fpPolys() {
    return [...this._fpPolys];
  }
  set fpPolys(value) {
    this._fpPolys = [...value];
  }
  get fpPads() {
    return [...this._fpPads];
  }
  set fpPads(value) {
    this._fpPads = [...value];
  }
  get models() {
    return [...this._models];
  }
  set models(value) {
    this._models = [...value];
  }
  getChildren() {
    const children = [];
    if (this._sxLocked) children.push(this._sxLocked);
    if (this._sxPlaced) children.push(this._sxPlaced);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxTedit) children.push(this._sxTedit);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxXy) children.push(this._sxXy);
    if (this._sxDescr) children.push(this._sxDescr);
    if (this._sxTags) children.push(this._sxTags);
    if (this._sxPath) children.push(this._sxPath);
    if (this._sxAutoplaceCost90) children.push(this._sxAutoplaceCost90);
    if (this._sxAutoplaceCost180) children.push(this._sxAutoplaceCost180);
    if (this._sxSolderMaskMargin) children.push(this._sxSolderMaskMargin);
    if (this._sxSolderPasteMargin) children.push(this._sxSolderPasteMargin);
    if (this._sxSolderPasteRatio) children.push(this._sxSolderPasteRatio);
    if (this._sxClearance) children.push(this._sxClearance);
    if (this._sxZoneConnect) children.push(this._sxZoneConnect);
    if (this._sxThermalWidth) children.push(this._sxThermalWidth);
    if (this._sxThermalGap) children.push(this._sxThermalGap);
    if (this._sxAttr) children.push(this._sxAttr);
    if (this._sxPrivateLayers) children.push(this._sxPrivateLayers);
    if (this._sxNetTiePadGroups) children.push(this._sxNetTiePadGroups);
    if (this._sxSheetname) children.push(this._sxSheetname);
    if (this._sxSheetfile) children.push(this._sxSheetfile);
    if (this._sxEmbeddedFonts) children.push(this._sxEmbeddedFonts);
    children.push(...this._properties);
    children.push(...this._fpTexts);
    children.push(...this._fpTextBoxes);
    children.push(...this._fpLines);
    children.push(...this._fpRects);
    children.push(...this._fpCircles);
    children.push(...this._fpArcs);
    children.push(...this._fpPolys);
    children.push(...this._fpPads);
    children.push(...this._models);
    return children;
  }
  getString() {
    const lines = ["(footprint"];
    if (this._libraryLink !== void 0) {
      lines.push(`  ${quoteSExprString(this._libraryLink)}`);
    }
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(Footprint);

// lib/sexpr/classes/GrArc.ts
var SUPPORTED_SINGLE_TOKENS5 = /* @__PURE__ */ new Set([
  "start",
  "mid",
  "end",
  "layer",
  "width",
  "stroke",
  "tstamp",
  "uuid"
]);
var GrArc = class _GrArc extends SxClass {
  static token = "gr_arc";
  token = "gr_arc";
  _sxStart;
  _sxMid;
  _sxEnd;
  _sxLayer;
  _sxWidth;
  _sxStroke;
  _sxTstamp;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.start !== void 0) this.start = params.start;
    if (params.mid !== void 0) this.mid = params.mid;
    if (params.end !== void 0) this.end = params.end;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.width !== void 0) this.width = params.width;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.tstamp !== void 0) this.tstamp = params.tstamp;
    if (params.uuid !== void 0) this.uuid = params.uuid;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const grArc = new _GrArc();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    const unexpectedTokens = /* @__PURE__ */ new Set();
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS5.has(token)) {
        unexpectedTokens.add(token);
      }
    }
    for (const token of Object.keys(arrayPropertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS5.has(token)) {
        unexpectedTokens.add(token);
        continue;
      }
      if (arrayPropertyMap[token].length > 1) {
        throw new Error(
          `gr_arc does not support repeated child tokens: ${token}`
        );
      }
    }
    if (unexpectedTokens.size > 0) {
      throw new Error(
        `Unsupported child tokens inside gr_arc expression: ${[...unexpectedTokens].join(", ")}`
      );
    }
    for (const primitive of primitiveSexprs) {
      if (Array.isArray(primitive)) continue;
      throw new Error(
        `gr_arc encountered unexpected primitive child: ${JSON.stringify(primitive)}`
      );
    }
    grArc._sxStart = propertyMap.start;
    grArc._sxMid = propertyMap.mid;
    grArc._sxEnd = propertyMap.end;
    grArc._sxLayer = propertyMap.layer;
    grArc._sxWidth = propertyMap.width;
    grArc._sxStroke = propertyMap.stroke;
    grArc._sxTstamp = propertyMap.tstamp;
    grArc._sxUuid = propertyMap.uuid;
    if (!grArc._sxStart) {
      throw new Error("gr_arc requires a start child token");
    }
    if (!grArc._sxMid) {
      throw new Error("gr_arc requires a mid child token");
    }
    if (!grArc._sxEnd) {
      throw new Error("gr_arc requires an end child token");
    }
    if (!grArc._sxLayer) {
      throw new Error("gr_arc requires a layer child token");
    }
    return grArc;
  }
  get start() {
    return this._sxStart;
  }
  set start(value) {
    this._sxStart = this.normalizeStart(value);
  }
  get mid() {
    return this._sxMid;
  }
  set mid(value) {
    this._sxMid = this.normalizeMid(value);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    this._sxEnd = this.normalizeEnd(value);
  }
  get startPoint() {
    return this._sxStart?.toObject();
  }
  get midPoint() {
    return this._sxMid?.toObject();
  }
  get endPoint() {
    return this._sxEnd?.toObject();
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    this._sxWidth = value instanceof Width ? value : new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  set widthClass(value) {
    this._sxWidth = value;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxMid) children.push(this._sxMid);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
  normalizeStart(value) {
    if (value === void 0) {
      return void 0;
    }
    if (value instanceof GrArcStart) {
      return value;
    }
    return new GrArcStart(value.x, value.y);
  }
  normalizeMid(value) {
    if (value === void 0) {
      return void 0;
    }
    if (value instanceof GrArcMid) {
      return value;
    }
    return new GrArcMid(value.x, value.y);
  }
  normalizeEnd(value) {
    if (value === void 0) {
      return void 0;
    }
    if (value instanceof GrArcEnd) {
      return value;
    }
    return new GrArcEnd(value.x, value.y);
  }
};
SxClass.register(GrArc);
var GrArcStart = class _GrArcStart extends SxClass {
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static token = "start";
  static parentToken = "gr_arc";
  token = "start";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = Number(rawX);
    const y = Number(rawY);
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      throw new Error("gr_arc start expects numeric coordinates");
    }
    return new _GrArcStart(x, y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(start ${this.x} ${this.y})`;
  }
};
SxClass.register(GrArcStart);
var GrArcMid = class _GrArcMid extends SxClass {
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static token = "mid";
  static parentToken = "gr_arc";
  token = "mid";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = Number(rawX);
    const y = Number(rawY);
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      throw new Error("gr_arc mid expects numeric coordinates");
    }
    return new _GrArcMid(x, y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(mid ${this.x} ${this.y})`;
  }
};
SxClass.register(GrArcMid);
var GrArcEnd = class _GrArcEnd extends SxClass {
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static token = "end";
  static parentToken = "gr_arc";
  token = "end";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = Number(rawX);
    const y = Number(rawY);
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      throw new Error("gr_arc end expects numeric coordinates");
    }
    return new _GrArcEnd(x, y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(end ${this.x} ${this.y})`;
  }
};
SxClass.register(GrArcEnd);

// lib/sexpr/classes/GrCircle.ts
var SUPPORTED_SINGLE_TOKENS6 = /* @__PURE__ */ new Set([
  "center",
  "end",
  "layer",
  "width",
  "stroke",
  "fill",
  "locked",
  "tstamp",
  "uuid"
]);
var GrCircle = class _GrCircle extends SxClass {
  static token = "gr_circle";
  token = "gr_circle";
  _sxCenter;
  _sxEnd;
  _sxLayer;
  _sxWidth;
  _sxStroke;
  _sxFill;
  _sxLocked;
  _sxTstamp;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.center !== void 0) this.center = params.center;
    if (params.end !== void 0) this.end = params.end;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.width !== void 0) this.width = params.width;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.fill !== void 0) this.fill = params.fill;
    if (params.locked !== void 0) this.locked = params.locked;
    if (params.tstamp !== void 0) this.tstamp = params.tstamp;
    if (params.uuid !== void 0) this.uuid = params.uuid;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const grCircle = new _GrCircle();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    const unexpectedTokens = /* @__PURE__ */ new Set();
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS6.has(token)) {
        unexpectedTokens.add(token);
      }
    }
    for (const token of Object.keys(arrayPropertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS6.has(token)) {
        unexpectedTokens.add(token);
        continue;
      }
      if (arrayPropertyMap[token].length > 1) {
        throw new Error(
          `gr_circle does not support repeated child tokens: ${token}`
        );
      }
    }
    if (unexpectedTokens.size > 0) {
      throw new Error(
        `Unsupported child tokens inside gr_circle expression: ${[...unexpectedTokens].join(", ")}`
      );
    }
    for (const primitive of primitiveSexprs) {
      if (Array.isArray(primitive)) continue;
      throw new Error(
        `gr_circle encountered unexpected primitive child: ${JSON.stringify(primitive)}`
      );
    }
    grCircle._sxCenter = propertyMap.center;
    grCircle._sxEnd = propertyMap.end;
    grCircle._sxLayer = propertyMap.layer;
    grCircle._sxWidth = propertyMap.width;
    grCircle._sxStroke = propertyMap.stroke;
    grCircle._sxFill = propertyMap.fill;
    const locked = propertyMap.locked;
    grCircle._sxLocked = locked && locked.value ? locked : void 0;
    grCircle._sxTstamp = propertyMap.tstamp;
    grCircle._sxUuid = propertyMap.uuid;
    if (!grCircle._sxCenter) {
      throw new Error("gr_circle requires a center child token");
    }
    if (!grCircle._sxEnd) {
      throw new Error("gr_circle requires an end child token");
    }
    if (!grCircle._sxLayer) {
      throw new Error("gr_circle requires a layer child token");
    }
    return grCircle;
  }
  get center() {
    return this._sxCenter;
  }
  set center(value) {
    this._sxCenter = this.normalizeCenter(value);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    this._sxEnd = this.normalizeEnd(value);
  }
  get centerPoint() {
    return this._sxCenter?.toObject();
  }
  get endPoint() {
    return this._sxEnd?.toObject();
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    this._sxWidth = value instanceof Width ? value : new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  set widthClass(value) {
    this._sxWidth = value;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get fill() {
    return this._sxFill;
  }
  set fill(value) {
    if (value === void 0) {
      this._sxFill = void 0;
      return;
    }
    if (value instanceof PadPrimitiveGrCircleFill) {
      this._sxFill = value;
      return;
    }
    const boolValue = value === "yes" || value === "true" ? true : value === "no" || value === "false" ? false : value;
    if (typeof boolValue === "boolean") {
      this._sxFill = new PadPrimitiveGrCircleFill(boolValue);
    } else {
      this._sxFill = new PadPrimitiveGrCircleFill(
        value === "none" ? false : true
      );
    }
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid?.value;
  }
  get uuidClass() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get locked() {
    return this._sxLocked?.value ?? false;
  }
  set locked(value) {
    this._sxLocked = value ? new GrCircleLocked(true) : void 0;
  }
  getChildren() {
    const children = [];
    if (this._sxCenter) children.push(this._sxCenter);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxFill) children.push(this._sxFill);
    if (this._sxLocked) children.push(this._sxLocked);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
  normalizeCenter(value) {
    if (value === void 0) {
      return void 0;
    }
    if (value instanceof GrCircleCenter) {
      return value;
    }
    return new GrCircleCenter(value.x, value.y);
  }
  normalizeEnd(value) {
    if (value === void 0) {
      return void 0;
    }
    if (value instanceof GrCircleEnd) {
      return value;
    }
    return new GrCircleEnd(value.x, value.y);
  }
};
SxClass.register(GrCircle);
var GrCircleCenter = class _GrCircleCenter extends SxClass {
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static token = "center";
  static parentToken = "gr_circle";
  token = "center";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = Number(rawX);
    const y = Number(rawY);
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      throw new Error("gr_circle center expects numeric coordinates");
    }
    return new _GrCircleCenter(x, y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(center ${this.x} ${this.y})`;
  }
};
SxClass.register(GrCircleCenter);
var GrCircleEnd = class _GrCircleEnd extends SxClass {
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  static token = "end";
  static parentToken = "gr_circle";
  token = "end";
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = Number(rawX);
    const y = Number(rawY);
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      throw new Error("gr_circle end expects numeric coordinates");
    }
    return new _GrCircleEnd(x, y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(end ${this.x} ${this.y})`;
  }
};
SxClass.register(GrCircleEnd);
var GrCircleLocked = class _GrCircleLocked extends SxClass {
  static token = "locked";
  static parentToken = "gr_circle";
  token = "locked";
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length === 0) {
      return new _GrCircleLocked(true);
    }
    const state = String(primitiveSexprs[0]);
    return new _GrCircleLocked(state === "yes");
  }
  getString() {
    return this.value ? "(locked yes)" : "(locked no)";
  }
};
SxClass.register(GrCircleLocked);

// lib/sexpr/classes/GrCurve.ts
var SUPPORTED_TOKENS14 = /* @__PURE__ */ new Set([
  "pts",
  "xy",
  "layer",
  "width",
  "stroke",
  "tstamp",
  "uuid"
]);
var GrCurve = class _GrCurve extends SxClass {
  static token = "gr_curve";
  token = "gr_curve";
  _sxPts;
  _sxLayer;
  _sxWidth;
  _sxStroke;
  _sxTstamp;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.points !== void 0) this.points = params.points;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.width !== void 0) this.width = params.width;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.tstamp !== void 0) this.tstamp = params.tstamp;
    if (params.uuid !== void 0) this.uuid = params.uuid;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const grCurve = new _GrCurve();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    const unexpectedTokens = /* @__PURE__ */ new Set();
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_TOKENS14.has(token)) {
        unexpectedTokens.add(token);
      }
    }
    for (const token of Object.keys(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS14.has(token)) {
        unexpectedTokens.add(token);
        continue;
      }
      if (token !== "xy" && arrayPropertyMap[token].length > 1) {
        throw new Error(
          `gr_curve does not support repeated child token "${token}"`
        );
      }
    }
    if (unexpectedTokens.size > 0) {
      throw new Error(
        `Unsupported child tokens inside gr_curve expression: ${[...unexpectedTokens].join(", ")}`
      );
    }
    const ptsEntries = arrayPropertyMap.pts;
    if (ptsEntries && ptsEntries.length > 1) {
      throw new Error("gr_curve does not support repeated pts tokens");
    }
    const xyEntries = arrayPropertyMap.xy;
    let pts = propertyMap.pts;
    if (pts && xyEntries && xyEntries.length > 0) {
      throw new Error("gr_curve cannot mix pts and xy child tokens");
    }
    if (!pts && ptsEntries?.length) {
      pts = ptsEntries[0];
    }
    if (!pts && xyEntries && xyEntries.length > 0) {
      pts = new Pts(xyEntries);
    }
    grCurve._sxPts = pts;
    grCurve._sxLayer = propertyMap.layer;
    grCurve._sxWidth = propertyMap.width;
    grCurve._sxStroke = propertyMap.stroke;
    grCurve._sxTstamp = propertyMap.tstamp;
    grCurve._sxUuid = propertyMap.uuid;
    for (const primitive of primitiveSexprs) {
      if (Array.isArray(primitive)) continue;
      throw new Error(
        `gr_curve encountered unexpected primitive child: ${JSON.stringify(primitive)}`
      );
    }
    if (!grCurve._sxPts) {
      throw new Error("gr_curve requires pts or xy child tokens");
    }
    if (!grCurve._sxLayer) {
      throw new Error("gr_curve requires a layer child token");
    }
    return grCurve;
  }
  get points() {
    return this._sxPts;
  }
  set points(value) {
    if (value === void 0) {
      this._sxPts = void 0;
      return;
    }
    if (value instanceof Pts) {
      this._sxPts = value;
      return;
    }
    if (Array.isArray(value) && value.every((point) => point instanceof Xy)) {
      this._sxPts = new Pts(value);
      return;
    }
    if (Array.isArray(value)) {
      this._sxPts = new Pts(value.map(({ x, y }) => new Xy(x, y)));
      return;
    }
    throw new Error("Unsupported points value provided to gr_curve");
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    this._sxWidth = value instanceof Width ? value : new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  set widthClass(value) {
    this._sxWidth = value;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  getChildren() {
    const children = [];
    if (this._sxPts) children.push(this._sxPts);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
};
SxClass.register(GrCurve);

// lib/sexpr/classes/GrLineAngle.ts
var GrLineAngle = class _GrLineAngle extends SxPrimitiveNumber {
  static token = "angle";
  static parentToken = "gr_line";
  token = "angle";
  constructor(value) {
    super(value);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawAngle] = primitiveSexprs;
    const angle = toNumberValue(rawAngle);
    if (angle === void 0) {
      throw new Error("gr_line angle expects a numeric value");
    }
    return new _GrLineAngle(angle);
  }
  getString() {
    return `(angle ${this.value})`;
  }
};
SxClass.register(GrLineAngle);

// lib/sexpr/classes/GrLineLocked.ts
var truthyStrings3 = /* @__PURE__ */ new Set(["true", "yes", "1"]);
var GrLineLocked = class _GrLineLocked extends SxPrimitiveBoolean {
  static token = "locked";
  static parentToken = "gr_line";
  token = "locked";
  constructor(value) {
    super(value);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawValue] = primitiveSexprs;
    if (rawValue === void 0) {
      return new _GrLineLocked(true);
    }
    if (typeof rawValue === "boolean") {
      return new _GrLineLocked(rawValue);
    }
    if (typeof rawValue === "string") {
      return new _GrLineLocked(truthyStrings3.has(rawValue.toLowerCase()));
    }
    return new _GrLineLocked(false);
  }
  getString() {
    return `(locked ${this.value ? "yes" : "no"})`;
  }
};
SxClass.register(GrLineLocked);

// lib/sexpr/classes/GrLine.ts
var SUPPORTED_SINGLE_TOKENS7 = /* @__PURE__ */ new Set([
  "start",
  "end",
  "angle",
  "layer",
  "width",
  "stroke",
  "tstamp",
  "uuid",
  "locked"
]);
var GrLine = class _GrLine extends SxClass {
  static token = "gr_line";
  token = "gr_line";
  _sxStart;
  _sxEnd;
  _sxAngle;
  _sxLayer;
  _sxWidth;
  _sxStroke;
  _sxTstamp;
  _sxUuid;
  _sxLocked;
  constructor(params = {}) {
    super();
    if (params.start !== void 0) this.start = params.start;
    if (params.end !== void 0) this.end = params.end;
    if (params.angle !== void 0) this.angle = params.angle;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.width !== void 0) this.width = params.width;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.tstamp !== void 0) this.tstamp = params.tstamp;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.locked !== void 0) this.locked = params.locked;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const grLine = new _GrLine();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    const unexpectedTokens = /* @__PURE__ */ new Set();
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS7.has(token)) {
        unexpectedTokens.add(token);
      }
    }
    for (const token of Object.keys(arrayPropertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS7.has(token)) {
        unexpectedTokens.add(token);
        continue;
      }
      if (arrayPropertyMap[token].length > 1) {
        throw new Error(
          `gr_line does not support repeated child tokens: ${token}`
        );
      }
    }
    if (unexpectedTokens.size > 0) {
      throw new Error(
        `Unsupported child tokens inside gr_line expression: ${[...unexpectedTokens].join(", ")}`
      );
    }
    for (const primitive of primitiveSexprs) {
      if (Array.isArray(primitive)) continue;
      throw new Error(
        `gr_line encountered unexpected primitive child: ${JSON.stringify(primitive)}`
      );
    }
    grLine._sxStart = propertyMap.start;
    grLine._sxEnd = propertyMap.end;
    grLine._sxAngle = propertyMap.angle;
    grLine._sxLayer = propertyMap.layer;
    grLine._sxWidth = propertyMap.width;
    grLine._sxStroke = propertyMap.stroke;
    const locked = propertyMap.locked;
    grLine._sxLocked = locked && locked.value ? locked : void 0;
    grLine._sxTstamp = propertyMap.tstamp;
    grLine._sxUuid = propertyMap.uuid;
    if (!grLine._sxStart) {
      throw new Error("gr_line requires a start child token");
    }
    if (!grLine._sxEnd) {
      throw new Error("gr_line requires an end child token");
    }
    if (!grLine._sxLayer) {
      throw new Error("gr_line requires a layer child token");
    }
    return grLine;
  }
  get start() {
    return this._sxStart;
  }
  set start(value) {
    this._sxStart = this.normalizeStart(value);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    this._sxEnd = this.normalizeEnd(value);
  }
  get startPoint() {
    return this._sxStart?.toObject();
  }
  get endPoint() {
    return this._sxEnd?.toObject();
  }
  get angle() {
    return this._sxAngle?.value;
  }
  set angle(value) {
    if (value === void 0) {
      this._sxAngle = void 0;
      return;
    }
    this._sxAngle = new GrLineAngle(value);
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    this._sxWidth = value instanceof Width ? value : new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  set widthClass(value) {
    this._sxWidth = value;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get locked() {
    return this._sxLocked?.value ?? false;
  }
  set locked(value) {
    this._sxLocked = value ? new GrLineLocked(true) : void 0;
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxAngle) children.push(this._sxAngle);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxLocked) children.push(this._sxLocked);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
  normalizeStart(value) {
    if (value === void 0) {
      return void 0;
    }
    if (value instanceof GrLineStart) {
      return value;
    }
    return new GrLineStart(value.x, value.y);
  }
  normalizeEnd(value) {
    if (value === void 0) {
      return void 0;
    }
    if (value instanceof GrLineEnd) {
      return value;
    }
    return new GrLineEnd(value.x, value.y);
  }
};
SxClass.register(GrLine);

// lib/sexpr/classes/GrRect.ts
var SUPPORTED_SINGLE_TOKENS8 = /* @__PURE__ */ new Set([
  "start",
  "end",
  "layer",
  "width",
  "stroke",
  "fill",
  "uuid",
  "locked"
]);
var GrRect = class _GrRect extends SxClass {
  static token = "gr_rect";
  token = "gr_rect";
  _sxStart;
  _sxEnd;
  _sxLayer;
  _sxWidth;
  _sxStroke;
  _sxFill;
  _sxUuid;
  _sxLocked;
  constructor(params = {}) {
    super();
    if (params.start !== void 0) this.start = params.start;
    if (params.end !== void 0) this.end = params.end;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.width !== void 0) this.width = params.width;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.fill !== void 0) this.fill = params.fill;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.locked !== void 0) this.locked = params.locked;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const grRect = new _GrRect();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    const unexpectedTokens = /* @__PURE__ */ new Set();
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS8.has(token)) {
        unexpectedTokens.add(token);
      }
    }
    for (const token of Object.keys(arrayPropertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS8.has(token)) {
        unexpectedTokens.add(token);
        continue;
      }
      if (arrayPropertyMap[token].length > 1) {
        throw new Error(
          `gr_rect does not support repeated child tokens: ${token}`
        );
      }
    }
    if (unexpectedTokens.size > 0) {
      throw new Error(
        `Unsupported child tokens inside gr_rect expression: ${[...unexpectedTokens].join(", ")}`
      );
    }
    for (const primitive of primitiveSexprs) {
      if (Array.isArray(primitive)) continue;
      throw new Error(
        `gr_rect encountered unexpected primitive child: ${JSON.stringify(primitive)}`
      );
    }
    grRect._sxStart = propertyMap.start;
    grRect._sxEnd = propertyMap.end;
    grRect._sxLayer = propertyMap.layer;
    grRect._sxWidth = propertyMap.width;
    grRect._sxStroke = propertyMap.stroke;
    grRect._sxFill = propertyMap.fill;
    const locked = propertyMap.locked;
    grRect._sxLocked = locked && locked.value ? locked : void 0;
    grRect._sxUuid = propertyMap.uuid;
    if (!grRect._sxStart) {
      throw new Error("gr_rect requires a start child token");
    }
    if (!grRect._sxEnd) {
      throw new Error("gr_rect requires an end child token");
    }
    if (!grRect._sxLayer) {
      throw new Error("gr_rect requires a layer child token");
    }
    return grRect;
  }
  get start() {
    return this._sxStart;
  }
  set start(value) {
    if (value === void 0) {
      this._sxStart = void 0;
      return;
    }
    if (value instanceof GrRectStart) {
      this._sxStart = value;
      return;
    }
    this._sxStart = new GrRectStart(value.x, value.y);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    if (value === void 0) {
      this._sxEnd = void 0;
      return;
    }
    if (value instanceof GrRectEnd) {
      this._sxEnd = value;
      return;
    }
    this._sxEnd = new GrRectEnd(value.x, value.y);
  }
  get startPoint() {
    return this._sxStart ? { x: this._sxStart.x, y: this._sxStart.y } : void 0;
  }
  get endPoint() {
    return this._sxEnd ? { x: this._sxEnd.x, y: this._sxEnd.y } : void 0;
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    if (value instanceof Width) {
      this._sxWidth = value;
      return;
    }
    this._sxWidth = new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  set widthClass(value) {
    this._sxWidth = value;
  }
  get fill() {
    return this._sxFill?.filled;
  }
  set fill(value) {
    if (value === void 0) {
      this._sxFill = void 0;
      return;
    }
    if (value instanceof GrRectFill) {
      this._sxFill = value;
      return;
    }
    this._sxFill = new GrRectFill(value);
  }
  get fillClass() {
    return this._sxFill;
  }
  get uuid() {
    return this._sxUuid?.value;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    if (value instanceof Uuid) {
      this._sxUuid = value;
      return;
    }
    this._sxUuid = new Uuid(value);
  }
  get uuidClass() {
    return this._sxUuid;
  }
  get locked() {
    return this._sxLocked?.value ?? false;
  }
  set locked(value) {
    this._sxLocked = value ? new GrRectLocked(true) : void 0;
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxFill) children.push(this._sxFill);
    if (this._sxLocked) children.push(this._sxLocked);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
};
SxClass.register(GrRect);
var GrRectStart = class _GrRectStart extends SxClass {
  static token = "start";
  static parentToken = "gr_rect";
  token = "start";
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error("gr_rect start expects two numeric arguments");
    }
    return new _GrRectStart(x, y);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  toObject() {
    return { x: this._x, y: this._y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(start ${this._x} ${this._y})`;
  }
};
SxClass.register(GrRectStart);
var GrRectEnd = class _GrRectEnd extends SxClass {
  static token = "end";
  static parentToken = "gr_rect";
  token = "end";
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error("gr_rect end expects two numeric arguments");
    }
    return new _GrRectEnd(x, y);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  toObject() {
    return { x: this._x, y: this._y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(end ${this._x} ${this._y})`;
  }
};
SxClass.register(GrRectEnd);
var GrRectFill = class _GrRectFill extends SxClass {
  static token = "fill";
  static parentToken = "gr_rect";
  token = "fill";
  filled;
  constructor(filled) {
    super();
    this.filled = filled;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const state = toStringValue(primitiveSexprs[0]);
    return new _GrRectFill(state === "yes");
  }
  getString() {
    return `(fill ${this.filled ? "yes" : "no"})`;
  }
};
SxClass.register(GrRectFill);
var GrRectLocked = class _GrRectLocked extends SxClass {
  static token = "locked";
  static parentToken = "gr_rect";
  token = "locked";
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length === 0) {
      return new _GrRectLocked(true);
    }
    const state = toStringValue(primitiveSexprs[0]);
    return new _GrRectLocked(state === "yes");
  }
  getString() {
    return this.value ? "(locked yes)" : "(locked no)";
  }
};
SxClass.register(GrRectLocked);

// lib/sexpr/classes/GrText.ts
var SUPPORTED_SINGLE_TOKENS9 = /* @__PURE__ */ new Set([
  "at",
  "xy",
  "layer",
  "tstamp",
  "uuid",
  "effects",
  "render_cache"
]);
var SUPPORTED_ARRAY_TOKENS3 = /* @__PURE__ */ new Set([
  "at",
  "xy",
  "layer",
  "tstamp",
  "uuid",
  "effects",
  "render_cache"
]);
var GrText = class _GrText extends SxClass {
  static token = "gr_text";
  token = "gr_text";
  _text = "";
  _sxPosition;
  _sxLayer;
  _sxTstamp;
  _sxUuid;
  _sxEffects;
  _renderCaches = [];
  constructor(params = {}) {
    super();
    if (typeof params === "string") {
      this.text = params;
    } else {
      if (params.text !== void 0) this.text = params.text;
      if (params.position !== void 0) this.position = params.position;
      if (params.layer !== void 0) this.layer = params.layer;
      if (params.tstamp !== void 0) this.tstamp = params.tstamp;
      if (params.uuid !== void 0) this.uuid = params.uuid;
      if (params.effects !== void 0) this.effects = params.effects;
      if (params.renderCaches !== void 0)
        this.renderCaches = params.renderCaches;
    }
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length === 0) {
      throw new Error("gr_text requires a text argument");
    }
    const [rawText, ...rest] = primitiveSexprs;
    const text = toStringValue(rawText);
    if (text === void 0) {
      throw new Error("gr_text text must be a string value");
    }
    const grText = new _GrText(text);
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(rest, this.token);
    const unexpectedTokens = /* @__PURE__ */ new Set();
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS9.has(token)) {
        unexpectedTokens.add(token);
      }
    }
    for (const token of Object.keys(arrayPropertyMap)) {
      if (!SUPPORTED_ARRAY_TOKENS3.has(token)) {
        unexpectedTokens.add(token);
        continue;
      }
      if (token !== "render_cache" && arrayPropertyMap[token].length > 1) {
        throw new Error(
          `gr_text does not support repeated child tokens: ${token}`
        );
      }
    }
    if (unexpectedTokens.size > 0) {
      throw new Error(
        `Unsupported child tokens inside gr_text expression: ${[...unexpectedTokens].join(", ")}`
      );
    }
    for (const primitive of rest) {
      if (Array.isArray(primitive)) continue;
      throw new Error(
        `gr_text encountered unexpected primitive child: ${JSON.stringify(primitive)}`
      );
    }
    const atInstance = propertyMap.at;
    const xyInstance = propertyMap.xy;
    if (atInstance && xyInstance) {
      throw new Error("gr_text cannot include both at and xy tokens");
    }
    grText._sxPosition = atInstance ?? xyInstance;
    grText._sxLayer = propertyMap.layer;
    grText._sxTstamp = propertyMap.tstamp;
    grText._sxUuid = propertyMap.uuid;
    grText._sxEffects = propertyMap.effects;
    const renderCaches = arrayPropertyMap.render_cache;
    if (renderCaches && renderCaches.length > 0) {
      grText._renderCaches = renderCaches;
    }
    if (!grText._sxPosition) {
      throw new Error("gr_text requires a position child token");
    }
    if (!grText._sxLayer) {
      throw new Error("gr_text requires a layer child token");
    }
    if (!grText._sxUuid && !grText._sxTstamp) {
      throw new Error("gr_text requires a uuid or tstamp child token");
    }
    if (!grText._sxEffects) {
      throw new Error("gr_text requires an effects child token");
    }
    return grText;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get position() {
    return this._sxPosition;
  }
  set position(value) {
    if (value === void 0) {
      this._sxPosition = void 0;
      return;
    }
    if (value instanceof Xy) {
      this._sxPosition = value;
      return;
    }
    if (typeof value === "object" && "x" in value && "y" in value && !Array.isArray(value) && !(value instanceof At)) {
      const { x, y, angle } = value;
      if (angle !== void 0) {
        this._sxPosition = new At([x, y, angle]);
      } else {
        this._sxPosition = new Xy(x, y);
      }
      return;
    }
    this._sxPosition = At.from(value);
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get effects() {
    return this._sxEffects;
  }
  set effects(value) {
    this._sxEffects = value;
  }
  get renderCaches() {
    return [...this._renderCaches];
  }
  set renderCaches(value) {
    this._renderCaches = [...value];
  }
  getChildren() {
    const children = [];
    if (this._sxPosition) children.push(this._sxPosition);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxEffects) children.push(this._sxEffects);
    children.push(...this._renderCaches);
    return children;
  }
  getString() {
    const lines = ["(gr_text", `  ${quoteSExprString(this._text)}`];
    for (const child of this.getChildren()) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(GrText);
var GrTextRenderCache = class _GrTextRenderCache extends SxClass {
  static token = "render_cache";
  static parentToken = "gr_text";
  token = "render_cache";
  _text = "";
  _angle = 0;
  _polygons = [];
  constructor(params = {}) {
    super();
    if (params.text !== void 0) this._text = params.text;
    if (params.angle !== void 0) this._angle = params.angle;
    if (params.polygons !== void 0) this._polygons = params.polygons;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const renderCache = new _GrTextRenderCache();
    if (primitiveSexprs.length >= 1) {
      renderCache._text = toStringValue(primitiveSexprs[0]) ?? "";
    }
    if (primitiveSexprs.length >= 2) {
      renderCache._angle = toNumberValue(primitiveSexprs[1]) ?? 0;
    }
    for (let i = 2; i < primitiveSexprs.length; i++) {
      const primitive = primitiveSexprs[i];
      if (!Array.isArray(primitive) || primitive.length === 0) {
        continue;
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (parsed instanceof GrTextRenderCachePolygon) {
        renderCache._polygons.push(parsed);
      }
    }
    return renderCache;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get angle() {
    return this._angle;
  }
  set angle(value) {
    this._angle = value;
  }
  get polygons() {
    return [...this._polygons];
  }
  set polygons(value) {
    this._polygons = [...value];
  }
  getChildren() {
    return [...this._polygons];
  }
  getString() {
    const lines = [
      `(render_cache ${quoteSExprString(this._text)} ${this._angle}`
    ];
    for (const polygon of this._polygons) {
      lines.push(polygon.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(GrTextRenderCache);
var GrTextRenderCachePolygon = class _GrTextRenderCachePolygon extends SxClass {
  static token = "polygon";
  static parentToken = "render_cache";
  token = "polygon";
  _pts;
  constructor(params = {}) {
    super();
    if (params.pts !== void 0) this._pts = params.pts;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const polygon = new _GrTextRenderCachePolygon();
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        continue;
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (parsed instanceof Pts) {
        polygon._pts = parsed;
      }
    }
    return polygon;
  }
  get pts() {
    return this._pts;
  }
  set pts(value) {
    this._pts = value;
  }
  getChildren() {
    return this._pts ? [this._pts] : [];
  }
  getString() {
    if (!this._pts) return "(polygon)";
    const lines = ["(polygon"];
    lines.push(this._pts.getStringIndented());
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(GrTextRenderCachePolygon);

// lib/sexpr/classes/GrPoly.ts
var GrPolyFill = class _GrPolyFill extends SxClass {
  static token = "fill";
  static parentToken = "gr_poly";
  token = "fill";
  filled;
  constructor(filled) {
    super();
    this.filled = filled;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const state = toStringValue(primitiveSexprs[0]);
    return new _GrPolyFill(state === "yes");
  }
  getString() {
    return `(fill ${this.filled ? "yes" : "no"})`;
  }
};
SxClass.register(GrPolyFill);
var SUPPORTED_TOKENS15 = /* @__PURE__ */ new Set([
  "pts",
  "xy",
  "layer",
  "width",
  "stroke",
  "fill",
  "uuid"
]);
var GrPoly = class _GrPoly extends SxClass {
  static token = "gr_poly";
  token = "gr_poly";
  _sxPts;
  _sxLayer;
  _sxWidth;
  _sxStroke;
  _sxFill;
  _sxUuid;
  constructor(params = {}) {
    super();
    if (params.points !== void 0) this.points = params.points;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.width !== void 0) this.width = params.width;
    if (params.stroke !== void 0) this.stroke = params.stroke;
    if (params.fill !== void 0) this.fill = params.fill;
    if (params.uuid !== void 0) this.uuid = params.uuid;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const grPoly = new _GrPoly();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    const unexpectedTokens = /* @__PURE__ */ new Set();
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_TOKENS15.has(token)) {
        unexpectedTokens.add(token);
      }
    }
    for (const token of Object.keys(arrayPropertyMap)) {
      if (!SUPPORTED_TOKENS15.has(token)) {
        unexpectedTokens.add(token);
      }
      if (token !== "xy" && arrayPropertyMap[token].length > 1) {
        unexpectedTokens.add(token);
      }
    }
    if (unexpectedTokens.size > 0) {
      throw new Error(
        `Unsupported child tokens inside gr_poly expression: ${[...unexpectedTokens].join(", ")}`
      );
    }
    const ptsEntries = arrayPropertyMap.pts;
    if (ptsEntries && ptsEntries.length > 1) {
      throw new Error("gr_poly does not support repeated pts tokens");
    }
    const xyEntries = arrayPropertyMap.xy;
    let pts = propertyMap.pts;
    if (pts && xyEntries && xyEntries.length > 0) {
      throw new Error("gr_poly cannot mix pts and xy child tokens");
    }
    if (!pts && ptsEntries?.length) {
      pts = ptsEntries[0];
    }
    if (!pts && xyEntries && xyEntries.length > 0) {
      pts = new Pts(xyEntries);
    }
    grPoly._sxPts = pts;
    grPoly._sxLayer = propertyMap.layer;
    grPoly._sxWidth = propertyMap.width;
    grPoly._sxStroke = propertyMap.stroke;
    grPoly._sxFill = propertyMap.fill;
    grPoly._sxUuid = propertyMap.uuid;
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `gr_poly encountered unexpected primitive child: ${JSON.stringify(primitive)}`
        );
      }
      const [token, ...rest] = primitive;
      if (typeof token !== "string") {
        throw new Error(
          `gr_poly child token must be a string, received: ${JSON.stringify(token)}`
        );
      }
      if (!SUPPORTED_TOKENS15.has(token)) {
        throw new Error(
          `Unsupported child token inside gr_poly expression: ${token}`
        );
      }
    }
    if (!grPoly._sxPts) {
      throw new Error("gr_poly requires pts or xy child tokens");
    }
    if (!grPoly._sxLayer) {
      throw new Error("gr_poly requires a layer child token");
    }
    return grPoly;
  }
  get points() {
    return this._sxPts;
  }
  set points(value) {
    if (value === void 0) {
      this._sxPts = void 0;
      return;
    }
    if (value instanceof Pts) {
      this._sxPts = value;
      return;
    }
    if (Array.isArray(value) && value.every((point) => point instanceof Xy)) {
      this._sxPts = new Pts(value);
      return;
    }
    if (Array.isArray(value)) {
      this._sxPts = new Pts(value.map(({ x, y }) => new Xy(x, y)));
      return;
    }
    throw new Error("Unsupported points value provided to gr_poly");
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    this._sxWidth = value instanceof Width ? value : new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  set widthClass(value) {
    this._sxWidth = value;
  }
  get stroke() {
    return this._sxStroke;
  }
  set stroke(value) {
    this._sxStroke = value;
  }
  get fill() {
    if (!this._sxFill) return void 0;
    if ("filled" in this._sxFill) {
      return this._sxFill.filled;
    }
    if ("value" in this._sxFill) {
      return this._sxFill.value;
    }
    return void 0;
  }
  set fill(value) {
    if (value === void 0) {
      this._sxFill = void 0;
      return;
    }
    if (value instanceof GrPolyFill) {
      this._sxFill = value;
      return;
    }
    this._sxFill = new GrPolyFill(value);
  }
  get fillClass() {
    return this._sxFill;
  }
  get uuid() {
    return this._sxUuid?.value;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get uuidClass() {
    return this._sxUuid;
  }
  getChildren() {
    const children = [];
    if (this._sxPts) children.push(this._sxPts);
    if (this._sxStroke) children.push(this._sxStroke);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxFill) children.push(this._sxFill);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
};
SxClass.register(GrPoly);

// lib/sexpr/classes/Group.ts
var SUPPORTED_SINGLE_TOKENS10 = /* @__PURE__ */ new Set(["uuid", "locked", "members"]);
var Group = class _Group extends SxClass {
  static token = "group";
  token = "group";
  _name = "";
  _sxUuid;
  _sxLocked;
  _sxMembers;
  constructor(params = {}) {
    super();
    if (params.name !== void 0) this.name = params.name;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.locked !== void 0) this.locked = params.locked;
    if (params.members !== void 0) this.members = params.members;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const group = new _Group();
    if (primitiveSexprs.length > 0 && typeof primitiveSexprs[0] === "string") {
      group._name = primitiveSexprs[0];
    }
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs.slice(1),
      this.token
    );
    const unexpectedTokens = /* @__PURE__ */ new Set();
    for (const token of Object.keys(propertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS10.has(token)) {
        unexpectedTokens.add(token);
      }
    }
    for (const token of Object.keys(arrayPropertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS10.has(token)) {
        unexpectedTokens.add(token);
        continue;
      }
      if (arrayPropertyMap[token].length > 1) {
        throw new Error(
          `group does not support repeated child tokens: ${token}`
        );
      }
    }
    if (unexpectedTokens.size > 0) {
      throw new Error(
        `Unsupported child tokens inside group expression: ${[...unexpectedTokens].join(", ")}`
      );
    }
    for (const primitive of primitiveSexprs.slice(1)) {
      if (Array.isArray(primitive)) continue;
      throw new Error(
        `group encountered unexpected primitive child: ${JSON.stringify(primitive)}`
      );
    }
    group._sxUuid = propertyMap.uuid;
    const locked = propertyMap.locked;
    group._sxLocked = locked && locked.value ? locked : void 0;
    group._sxMembers = propertyMap.members;
    return group;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get uuid() {
    return this._sxUuid?.value;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get uuidClass() {
    return this._sxUuid;
  }
  get locked() {
    return this._sxLocked?.value ?? false;
  }
  set locked(value) {
    this._sxLocked = value ? new GroupLocked(true) : void 0;
  }
  get members() {
    return this._sxMembers?.members ?? [];
  }
  set members(value) {
    this._sxMembers = new GroupMembers(value);
  }
  get membersClass() {
    return this._sxMembers;
  }
  getChildren() {
    const children = [];
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxLocked) children.push(this._sxLocked);
    if (this._sxMembers) children.push(this._sxMembers);
    return children;
  }
  getString() {
    const lines = [`(group "${this._name}"`];
    const push = (value) => {
      if (!value) return;
      lines.push(value.getStringIndented());
    };
    push(this._sxUuid);
    push(this._sxLocked);
    push(this._sxMembers);
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(Group);
var GroupLocked = class _GroupLocked extends SxClass {
  static token = "locked";
  static parentToken = "group";
  token = "locked";
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length === 0) {
      return new _GroupLocked(true);
    }
    const state = toStringValue(primitiveSexprs[0]);
    return new _GroupLocked(state === "yes");
  }
  getString() {
    return this.value ? "(locked yes)" : "(locked no)";
  }
};
SxClass.register(GroupLocked);
var GroupMembers = class _GroupMembers extends SxClass {
  static token = "members";
  static parentToken = "group";
  token = "members";
  members;
  constructor(members) {
    super();
    this.members = members;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const members = [];
    for (const primitive of primitiveSexprs) {
      const str = toStringValue(primitive);
      if (str) {
        members.push(str);
      }
    }
    return new _GroupMembers(members);
  }
  getString() {
    if (this.members.length === 0) {
      return "(members)";
    }
    const memberStrings = this.members.map((m) => `"${m}"`).join(" ");
    return `(members ${memberStrings})`;
  }
};
SxClass.register(GroupMembers);

// lib/sexpr/classes/SegmentEnd.ts
var SegmentEnd = class _SegmentEnd extends SxClass {
  static token = "end";
  static parentToken = "segment";
  token = "end";
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error("end expects two numeric arguments");
    }
    return new _SegmentEnd(x, y);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  toObject() {
    return { x: this._x, y: this._y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(end ${this._x} ${this._y})`;
  }
};
SxClass.register(SegmentEnd);

// lib/sexpr/classes/SegmentLocked.ts
var truthyStrings4 = /* @__PURE__ */ new Set(["true", "yes", "1"]);
var SegmentLocked = class _SegmentLocked extends SxPrimitiveBoolean {
  static token = "locked";
  static parentToken = "segment";
  token = "locked";
  constructor(value) {
    super(value);
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawValue] = primitiveSexprs;
    if (typeof rawValue === "boolean") {
      return new _SegmentLocked(rawValue);
    }
    if (typeof rawValue === "string") {
      return new _SegmentLocked(truthyStrings4.has(rawValue.toLowerCase()));
    }
    return new _SegmentLocked(false);
  }
  getString() {
    return `(locked ${this.value ? "yes" : "no"})`;
  }
};
SxClass.register(SegmentLocked);

// lib/sexpr/classes/SegmentNet.ts
var SegmentNet = class _SegmentNet extends SxClass {
  static token = "net";
  static parentToken = "segment";
  token = "net";
  _id;
  _name;
  constructor(id, name) {
    super();
    this._id = id;
    this._name = name;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawId, rawName] = primitiveSexprs;
    const id = toNumberValue(rawId);
    if (id === void 0) {
      throw new Error("net expects a numeric identifier");
    }
    const name = rawName === void 0 ? void 0 : toStringValue(rawName);
    return new _SegmentNet(id, name ?? void 0);
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value === "" ? void 0 : value;
  }
  toObject() {
    return this._name === void 0 ? { id: this._id } : { id: this._id, name: this._name };
  }
  getChildren() {
    return [];
  }
  getString() {
    const namePart = this._name ? ` ${quoteSExprString(this._name)}` : "";
    return `(net ${this._id}${namePart})`;
  }
};
SxClass.register(SegmentNet);

// lib/sexpr/classes/SegmentStart.ts
var SegmentStart = class _SegmentStart extends SxClass {
  static token = "start";
  static parentToken = "segment";
  token = "start";
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [rawX, rawY] = primitiveSexprs;
    const x = toNumberValue(rawX);
    const y = toNumberValue(rawY);
    if (x === void 0 || y === void 0) {
      throw new Error("start expects two numeric arguments");
    }
    return new _SegmentStart(x, y);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  toObject() {
    return { x: this._x, y: this._y };
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(start ${this._x} ${this._y})`;
  }
};
SxClass.register(SegmentStart);

// lib/sexpr/classes/Segment.ts
var SUPPORTED_SINGLE_TOKENS11 = /* @__PURE__ */ new Set([
  "start",
  "end",
  "width",
  "layer",
  "net",
  "tstamp",
  "uuid",
  "locked"
]);
var Segment = class _Segment extends SxClass {
  static token = "segment";
  token = "segment";
  _sxStart;
  _sxEnd;
  _sxWidth;
  _sxLayer;
  _sxNet;
  _sxTstamp;
  _sxUuid;
  _sxLocked;
  constructor(params = {}) {
    super();
    if (params.start !== void 0) this.start = params.start;
    if (params.end !== void 0) this.end = params.end;
    if (params.width !== void 0) this.width = params.width;
    if (params.layer !== void 0) this.layer = params.layer;
    if (params.net !== void 0) this.net = params.net;
    if (params.tstamp !== void 0) this.tstamp = params.tstamp;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.locked !== void 0) this.locked = params.locked;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const segment = new _Segment();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    const unexpectedSingleTokens = Object.keys(propertyMap).filter(
      (token) => !SUPPORTED_SINGLE_TOKENS11.has(token)
    );
    if (unexpectedSingleTokens.length > 0) {
      throw new Error(
        `Unsupported child tokens inside segment expression: ${unexpectedSingleTokens.join(", ")}`
      );
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SUPPORTED_SINGLE_TOKENS11.has(token)) {
        throw new Error(
          `Unsupported child tokens inside segment expression: ${token}`
        );
      }
      if (entries.length > 1) {
        throw new Error(
          `Segment does not support repeated child tokens: ${token}`
        );
      }
    }
    segment._sxStart = arrayPropertyMap.start?.[0] ?? propertyMap.start;
    segment._sxEnd = arrayPropertyMap.end?.[0] ?? propertyMap.end;
    segment._sxWidth = arrayPropertyMap.width?.[0] ?? propertyMap.width;
    segment._sxLayer = arrayPropertyMap.layer?.[0] ?? propertyMap.layer;
    segment._sxNet = arrayPropertyMap.net?.[0] ?? propertyMap.net;
    const locked = arrayPropertyMap.locked?.[0] ?? propertyMap.locked;
    segment._sxLocked = locked && locked.value ? locked : void 0;
    segment._sxTstamp = arrayPropertyMap.tstamp?.[0] ?? propertyMap.tstamp;
    segment._sxUuid = arrayPropertyMap.uuid?.[0] ?? propertyMap.uuid;
    return segment;
  }
  get start() {
    return this._sxStart;
  }
  set start(value) {
    this._sxStart = this.normalizeStart(value);
  }
  get end() {
    return this._sxEnd;
  }
  set end(value) {
    this._sxEnd = this.normalizeEnd(value);
  }
  get startPoint() {
    return this._sxStart?.toObject();
  }
  get endPoint() {
    return this._sxEnd?.toObject();
  }
  get width() {
    return this._sxWidth?.value;
  }
  set width(value) {
    if (value === void 0) {
      this._sxWidth = void 0;
      return;
    }
    this._sxWidth = value instanceof Width ? value : new Width(value);
  }
  get widthClass() {
    return this._sxWidth;
  }
  set widthClass(value) {
    this._sxWidth = value;
  }
  get layer() {
    return this._sxLayer;
  }
  set layer(value) {
    if (value === void 0) {
      this._sxLayer = void 0;
      return;
    }
    if (value instanceof Layer) {
      this._sxLayer = value;
      return;
    }
    const names = Array.isArray(value) ? value : [value];
    this._sxLayer = new Layer(names);
  }
  get net() {
    return this._sxNet;
  }
  set net(value) {
    if (value === void 0) {
      this._sxNet = void 0;
      return;
    }
    if (value instanceof SegmentNet) {
      this._sxNet = value;
      return;
    }
    this._sxNet = new SegmentNet(value.id, value.name);
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get locked() {
    return this._sxLocked?.value ?? false;
  }
  set locked(value) {
    this._sxLocked = value ? new SegmentLocked(true) : void 0;
  }
  getChildren() {
    const children = [];
    if (this._sxStart) children.push(this._sxStart);
    if (this._sxEnd) children.push(this._sxEnd);
    if (this._sxWidth) children.push(this._sxWidth);
    if (this._sxLayer) children.push(this._sxLayer);
    if (this._sxNet) children.push(this._sxNet);
    if (this._sxLocked) children.push(this._sxLocked);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxUuid) children.push(this._sxUuid);
    return children;
  }
  normalizeStart(value) {
    if (value === void 0) {
      return void 0;
    }
    if (value instanceof SegmentStart) {
      return value;
    }
    return new SegmentStart(value.x, value.y);
  }
  normalizeEnd(value) {
    if (value === void 0) {
      return void 0;
    }
    if (value instanceof SegmentEnd) {
      return value;
    }
    return new SegmentEnd(value.x, value.y);
  }
};
SxClass.register(Segment);

// lib/sexpr/classes/Zone.ts
var Zone = class _Zone extends SxClass {
  static token = "zone";
  token = "zone";
  _rawChildren = [];
  static fromSexprPrimitives(primitiveSexprs) {
    const zone = new _Zone();
    zone._rawChildren = [...primitiveSexprs];
    return zone;
  }
  get rawChildren() {
    return [...this._rawChildren];
  }
  set rawChildren(children) {
    this._rawChildren = [...children];
  }
  getChildren() {
    return [];
  }
  getString() {
    const lines = ["(zone"];
    for (const arg of this._rawChildren) {
      lines.push(`  ${printSExpr(arg)}`);
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(Zone);

// lib/sexpr/classes/Layers.ts
var Layers = class _Layers extends SxClass {
  static token = "layers";
  token = "layers";
  _names = [];
  constructor(names = []) {
    super();
    this.names = names;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const names = primitiveSexprs.map(
      (primitive) => typeof primitive === "string" || typeof primitive === "number" ? String(primitive) : printSExpr(primitive)
    );
    return new _Layers(names);
  }
  get names() {
    return [...this._names];
  }
  set names(values) {
    this._names = values.map((value) => String(value));
  }
  getString() {
    const rendered = this._names.map((name) => {
      if (/^[^\s()"]+$/u.test(name) && !["nil", "#t", "#f"].includes(name)) {
        return name;
      }
      return quoteSExprString(name);
    }).join(" ");
    return `(layers ${rendered})`;
  }
};
SxClass.register(Layers);

// lib/sexpr/classes/Setup/base.ts
var SingleValueProperty = class extends SxClass {
  _value;
  quoteStringValue = false;
  constructor(value) {
    super();
    this._value = value;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [valuePrimitive] = primitiveSexprs;
    const value = this.parsePrimitiveValue(
      valuePrimitive
    );
    const Constructor = this;
    return new Constructor(value);
  }
  static parsePrimitiveValue(value) {
    const stringValue = toStringValue(value);
    if (stringValue === void 0) {
      throw new Error(`${this.name} expects a primitive value`);
    }
    return stringValue;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  getChildren() {
    return [];
  }
  formatValue() {
    if (typeof this._value === "string") {
      return this.quoteStringValue ? quoteSExprString(this._value) : this._value;
    }
    return `${this._value}`;
  }
  getString() {
    return `(${this.token} ${this.formatValue()})`;
  }
};
var NumericListProperty = class extends SxClass {
  _values;
  constructor(values) {
    super();
    this._values = values;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const values = primitiveSexprs.map((primitive) => {
      const value = toNumberValue(primitive);
      if (value === void 0) {
        throw new Error(
          `${this.name} expects numeric primitives but received ${primitive}`
        );
      }
      return value;
    });
    const Constructor = this;
    return new Constructor(values);
  }
  get values() {
    return [...this._values];
  }
  set values(values) {
    this._values = [...values];
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(${this.token} ${this._values.join(" ")})`;
  }
};
var CoordinateProperty = class extends SxClass {
  _x;
  _y;
  constructor(x, y) {
    super();
    this._x = x;
    this._y = y;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const [xPrimitive, yPrimitive] = primitiveSexprs;
    const x = toNumberValue(xPrimitive);
    const y = toNumberValue(yPrimitive);
    if (x === void 0 || y === void 0) {
      throw new Error(`${this.name} expects two numeric values`);
    }
    const Constructor = this;
    return new Constructor(x, y);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(${this.token} ${this._x} ${this._y})`;
  }
};

// lib/sexpr/classes/Setup/PcbPlotParamsBase.ts
var PlotParamProperty = class extends SingleValueProperty {
  static parentToken = "pcbplotparams";
};

// lib/sexpr/classes/Setup/PcbPlotParamsNumericProperties.ts
var PlotParamNumberProperty = class extends PlotParamProperty {
  static parsePrimitiveValue(value) {
    const parsed = toNumberValue(value);
    if (parsed === void 0) {
      throw new Error(`pcbplotparams ${this.token} expects a numeric value`);
    }
    return parsed;
  }
};
var PlotParamLayerSelection = class extends PlotParamProperty {
  static token = "layerselection";
  token = "layerselection";
};
SxClass.register(PlotParamLayerSelection);
var PlotParamPlotOnAllLayersSelection = class extends PlotParamProperty {
  static token = "plot_on_all_layers_selection";
  token = "plot_on_all_layers_selection";
};
SxClass.register(PlotParamPlotOnAllLayersSelection);
var PlotParamDashedLineDashRatio = class extends PlotParamNumberProperty {
  static token = "dashed_line_dash_ratio";
  token = "dashed_line_dash_ratio";
};
SxClass.register(PlotParamDashedLineDashRatio);
var PlotParamDashedLineGapRatio = class extends PlotParamNumberProperty {
  static token = "dashed_line_gap_ratio";
  token = "dashed_line_gap_ratio";
};
SxClass.register(PlotParamDashedLineGapRatio);
var PlotParamSvgPrecision = class extends PlotParamNumberProperty {
  static token = "svgprecision";
  token = "svgprecision";
};
SxClass.register(PlotParamSvgPrecision);
var PlotParamLineWidth = class extends PlotParamNumberProperty {
  static token = "linewidth";
  token = "linewidth";
};
SxClass.register(PlotParamLineWidth);
var PlotParamMode = class extends PlotParamNumberProperty {
  static token = "mode";
  token = "mode";
};
SxClass.register(PlotParamMode);
var PlotParamHpglPenNumber = class extends PlotParamNumberProperty {
  static token = "hpglpennumber";
  token = "hpglpennumber";
};
SxClass.register(PlotParamHpglPenNumber);
var PlotParamHpglPenSpeed = class extends PlotParamNumberProperty {
  static token = "hpglpenspeed";
  token = "hpglpenspeed";
};
SxClass.register(PlotParamHpglPenSpeed);
var PlotParamHpglPenDiameter = class extends PlotParamNumberProperty {
  static token = "hpglpendiameter";
  token = "hpglpendiameter";
};
SxClass.register(PlotParamHpglPenDiameter);
var PlotParamHpglPenOverlay = class extends PlotParamNumberProperty {
  static token = "hpglpenoverlay";
  token = "hpglpenoverlay";
};
SxClass.register(PlotParamHpglPenOverlay);
var PlotParamOutputFormat = class extends PlotParamNumberProperty {
  static token = "outputformat";
  token = "outputformat";
};
SxClass.register(PlotParamOutputFormat);
var PlotParamDrillShape = class extends PlotParamNumberProperty {
  static token = "drillshape";
  token = "drillshape";
};
SxClass.register(PlotParamDrillShape);
var PlotParamScaleSelection = class extends PlotParamNumberProperty {
  static token = "scaleselection";
  token = "scaleselection";
};
SxClass.register(PlotParamScaleSelection);

// lib/sexpr/classes/Setup/PcbPlotParamsStringPropertiesA.ts
var PlotParamDisableApertMacros = class extends PlotParamProperty {
  static token = "disableapertmacros";
  token = "disableapertmacros";
};
SxClass.register(PlotParamDisableApertMacros);
var PlotParamUseGerberExtensions = class extends PlotParamProperty {
  static token = "usegerberextensions";
  token = "usegerberextensions";
};
SxClass.register(PlotParamUseGerberExtensions);
var PlotParamUseGerberAttributes = class extends PlotParamProperty {
  static token = "usegerberattributes";
  token = "usegerberattributes";
};
SxClass.register(PlotParamUseGerberAttributes);
var PlotParamUseGerberAdvancedAttributes = class extends PlotParamProperty {
  static token = "usegerberadvancedattributes";
  token = "usegerberadvancedattributes";
};
SxClass.register(PlotParamUseGerberAdvancedAttributes);
var PlotParamCreateGerberJobFile = class extends PlotParamProperty {
  static token = "creategerberjobfile";
  token = "creategerberjobfile";
};
SxClass.register(PlotParamCreateGerberJobFile);
var PlotParamExcludeEdgeLayer = class extends PlotParamProperty {
  static token = "excludeedgelayer";
  token = "excludeedgelayer";
};
SxClass.register(PlotParamExcludeEdgeLayer);
var PlotParamPlotFrameRef = class extends PlotParamProperty {
  static token = "plotframeref";
  token = "plotframeref";
};
SxClass.register(PlotParamPlotFrameRef);
var PlotParamViaOnMask = class extends PlotParamProperty {
  static token = "viasonmask";
  token = "viasonmask";
};
SxClass.register(PlotParamViaOnMask);
var PlotParamUseAuxOrigin = class extends PlotParamProperty {
  static token = "useauxorigin";
  token = "useauxorigin";
};
SxClass.register(PlotParamUseAuxOrigin);
var PlotParamPdfFrontFpPropertyPopups = class extends PlotParamProperty {
  static token = "pdf_front_fp_property_popups";
  token = "pdf_front_fp_property_popups";
};
SxClass.register(PlotParamPdfFrontFpPropertyPopups);
var PlotParamPdfBackFpPropertyPopups = class extends PlotParamProperty {
  static token = "pdf_back_fp_property_popups";
  token = "pdf_back_fp_property_popups";
};
SxClass.register(PlotParamPdfBackFpPropertyPopups);
var PlotParamPdfMetadata = class extends PlotParamProperty {
  static token = "pdf_metadata";
  token = "pdf_metadata";
};
SxClass.register(PlotParamPdfMetadata);
var PlotParamPdfSingleDocument = class extends PlotParamProperty {
  static token = "pdf_single_document";
  token = "pdf_single_document";
};
SxClass.register(PlotParamPdfSingleDocument);
var PlotParamDxfPolygonMode = class extends PlotParamProperty {
  static token = "dxfpolygonmode";
  token = "dxfpolygonmode";
};
SxClass.register(PlotParamDxfPolygonMode);
var PlotParamDxfImperialUnits = class extends PlotParamProperty {
  static token = "dxfimperialunits";
  token = "dxfimperialunits";
};
SxClass.register(PlotParamDxfImperialUnits);
var PlotParamDxfUsePcbnewFont = class extends PlotParamProperty {
  static token = "dxfusepcbnewfont";
  token = "dxfusepcbnewfont";
};
SxClass.register(PlotParamDxfUsePcbnewFont);
var PlotParamPsNegative = class extends PlotParamProperty {
  static token = "psnegative";
  token = "psnegative";
};
SxClass.register(PlotParamPsNegative);

// lib/sexpr/classes/Setup/PcbPlotParamsStringPropertiesB.ts
var PlotParamPsA4Output = class extends PlotParamProperty {
  static token = "psa4output";
  token = "psa4output";
};
SxClass.register(PlotParamPsA4Output);
var PlotParamPlotReference = class extends PlotParamProperty {
  static token = "plotreference";
  token = "plotreference";
};
SxClass.register(PlotParamPlotReference);
var PlotParamPlotValue = class extends PlotParamProperty {
  static token = "plotvalue";
  token = "plotvalue";
};
SxClass.register(PlotParamPlotValue);
var PlotParamPlotOtherText = class extends PlotParamProperty {
  static token = "plotothertext";
  token = "plotothertext";
};
SxClass.register(PlotParamPlotOtherText);
var PlotParamPlotInvisibleText = class extends PlotParamProperty {
  static token = "plotinvisibletext";
  token = "plotinvisibletext";
};
SxClass.register(PlotParamPlotInvisibleText);
var PlotParamPadOnSilk = class extends PlotParamProperty {
  static token = "padsonsilk";
  token = "padsonsilk";
};
SxClass.register(PlotParamPadOnSilk);
var PlotParamSketchPadsOnFab = class extends PlotParamProperty {
  static token = "sketchpadsonfab";
  token = "sketchpadsonfab";
};
SxClass.register(PlotParamSketchPadsOnFab);
var PlotParamPlotPadNumbers = class extends PlotParamProperty {
  static token = "plotpadnumbers";
  token = "plotpadnumbers";
};
SxClass.register(PlotParamPlotPadNumbers);
var PlotParamHideDnpOnFab = class extends PlotParamProperty {
  static token = "hidednponfab";
  token = "hidednponfab";
};
SxClass.register(PlotParamHideDnpOnFab);
var PlotParamSketchDnpOnFab = class extends PlotParamProperty {
  static token = "sketchdnponfab";
  token = "sketchdnponfab";
};
SxClass.register(PlotParamSketchDnpOnFab);
var PlotParamCrossoutDnpOnFab = class extends PlotParamProperty {
  static token = "crossoutdnponfab";
  token = "crossoutdnponfab";
};
SxClass.register(PlotParamCrossoutDnpOnFab);
var PlotParamSubtractMaskFromSilk = class extends PlotParamProperty {
  static token = "subtractmaskfromsilk";
  token = "subtractmaskfromsilk";
};
SxClass.register(PlotParamSubtractMaskFromSilk);
var PlotParamPlotBlackAndWhite = class extends PlotParamProperty {
  static token = "plot_black_and_white";
  token = "plot_black_and_white";
};
SxClass.register(PlotParamPlotBlackAndWhite);
var PlotParamMirror = class extends PlotParamProperty {
  static token = "mirror";
  token = "mirror";
};
SxClass.register(PlotParamMirror);
var PlotParamOutputDirectory = class extends PlotParamProperty {
  static token = "outputdirectory";
  token = "outputdirectory";
  quoteStringValue = true;
};
SxClass.register(PlotParamOutputDirectory);
var PlotParamPlotOnAllLayers = class extends PlotParamProperty {
  static token = "plot_on_all_layers";
  token = "plot_on_all_layers";
};
SxClass.register(PlotParamPlotOnAllLayers);
var PlotParamPlotInvisible = class extends PlotParamProperty {
  static token = "plotinvisible";
  token = "plotinvisible";
};
SxClass.register(PlotParamPlotInvisible);

// lib/sexpr/classes/Setup/PcbPlotParams.ts
var TOKEN_TO_KEY = {
  layerselection: "layerselection",
  plot_on_all_layers_selection: "plot_on_all_layers_selection",
  disableapertmacros: "disableapertmacros",
  usegerberextensions: "usegerberextensions",
  usegerberattributes: "usegerberattributes",
  usegerberadvancedattributes: "usegerberadvancedattributes",
  creategerberjobfile: "creategerberjobfile",
  excludeedgelayer: "excludeedgelayer",
  dashed_line_dash_ratio: "dashed_line_dash_ratio",
  dashed_line_gap_ratio: "dashed_line_gap_ratio",
  svgprecision: "svgprecision",
  linewidth: "linewidth",
  plotframeref: "plotframeref",
  plotreference: "plotreference",
  plotvalue: "plotvalue",
  plotothertext: "plotothertext",
  plotinvisibletext: "plotinvisibletext",
  padsonsilk: "padsonsilk",
  sketchpadsonfab: "sketchpadsonfab",
  plotpadnumbers: "plotpadnumbers",
  hidednponfab: "hidednponfab",
  sketchdnponfab: "sketchdnponfab",
  crossoutdnponfab: "crossoutdnponfab",
  subtractmaskfromsilk: "subtractmaskfromsilk",
  plot_black_and_white: "plot_black_and_white",
  plot_on_all_layers: "plot_on_all_layers",
  plotinvisible: "plotinvisible",
  mode: "mode",
  useauxorigin: "useauxorigin",
  viasonmask: "viasonmask",
  hpglpennumber: "hpglpennumber",
  hpglpenspeed: "hpglpenspeed",
  hpglpendiameter: "hpglpendiameter",
  hpglpenoverlay: "hpglpenoverlay",
  pdf_front_fp_property_popups: "pdf_front_fp_property_popups",
  pdf_back_fp_property_popups: "pdf_back_fp_property_popups",
  pdf_metadata: "pdf_metadata",
  pdf_single_document: "pdf_single_document",
  dxfpolygonmode: "dxfpolygonmode",
  dxfimperialunits: "dxfimperialunits",
  dxfusepcbnewfont: "dxfusepcbnewfont",
  psnegative: "psnegative",
  psa4output: "psa4output",
  mirror: "mirror",
  outputformat: "outputformat",
  drillshape: "drillshape",
  scaleselection: "scaleselection",
  outputdirectory: "outputdirectory"
};
var PCB_PLOT_PARAM_CHILD_ORDER = [
  "layerselection",
  "plot_on_all_layers_selection",
  "disableapertmacros",
  "usegerberextensions",
  "usegerberattributes",
  "usegerberadvancedattributes",
  "creategerberjobfile",
  "excludeedgelayer",
  "dashed_line_dash_ratio",
  "dashed_line_gap_ratio",
  "svgprecision",
  "linewidth",
  "plotframeref",
  "plotreference",
  "plotvalue",
  "plotothertext",
  "mode",
  "useauxorigin",
  "viasonmask",
  "hpglpennumber",
  "hpglpenspeed",
  "hpglpendiameter",
  "hpglpenoverlay",
  "pdf_front_fp_property_popups",
  "pdf_back_fp_property_popups",
  "pdf_metadata",
  "pdf_single_document",
  "dxfpolygonmode",
  "dxfimperialunits",
  "dxfusepcbnewfont",
  "psnegative",
  "psa4output",
  "plot_black_and_white",
  "plot_on_all_layers",
  "plotinvisible",
  "plotinvisibletext",
  "padsonsilk",
  "sketchpadsonfab",
  "plotpadnumbers",
  "hidednponfab",
  "sketchdnponfab",
  "crossoutdnponfab",
  "subtractmaskfromsilk",
  "outputformat",
  "mirror",
  "drillshape",
  "scaleselection",
  "outputdirectory"
];
var PcbPlotParams = class _PcbPlotParams extends SxClass {
  static token = "pcbplotparams";
  static parentToken = "setup";
  token = "pcbplotparams";
  _properties = {};
  static fromSexprPrimitives(primitiveSexprs) {
    const params = new _PcbPlotParams();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    for (const [token, instance] of Object.entries(propertyMap)) {
      const key = TOKEN_TO_KEY[token];
      if (!key) {
        throw new Error(`Unsupported pcbplotparams token: ${token}`);
      }
      params._properties[key] = instance;
    }
    return params;
  }
  getChildren() {
    const children = [];
    for (const key of PCB_PLOT_PARAM_CHILD_ORDER) {
      const child = this._properties[key];
      if (child) {
        children.push(child);
      }
    }
    return children;
  }
  clearProperty(key) {
    delete this._properties[key];
  }
  setStringProperty(key, value, ClassRef) {
    if (value === void 0) {
      this.clearProperty(key);
      return;
    }
    this._properties[key] = new ClassRef(value);
  }
  setNumberProperty(key, value, ClassRef) {
    if (value === void 0) {
      this.clearProperty(key);
      return;
    }
    this._properties[key] = new ClassRef(value);
  }
  setStringOrNumberProperty(key, value, ClassRef) {
    if (value === void 0) {
      this.clearProperty(key);
      return;
    }
    this._properties[key] = new ClassRef(value);
  }
  get layerselection() {
    return this._properties.layerselection?.value;
  }
  set layerselection(value) {
    this.setStringOrNumberProperty(
      "layerselection",
      value,
      PlotParamLayerSelection
    );
  }
  get plot_on_all_layers_selection() {
    return this._properties.plot_on_all_layers_selection?.value;
  }
  set plot_on_all_layers_selection(value) {
    this.setStringOrNumberProperty(
      "plot_on_all_layers_selection",
      value,
      PlotParamPlotOnAllLayersSelection
    );
  }
  get disableapertmacros() {
    return this._properties.disableapertmacros?.value;
  }
  set disableapertmacros(value) {
    this.setStringProperty(
      "disableapertmacros",
      value,
      PlotParamDisableApertMacros
    );
  }
  get usegerberextensions() {
    return this._properties.usegerberextensions?.value;
  }
  set usegerberextensions(value) {
    this.setStringProperty(
      "usegerberextensions",
      value,
      PlotParamUseGerberExtensions
    );
  }
  get usegerberattributes() {
    return this._properties.usegerberattributes?.value;
  }
  set usegerberattributes(value) {
    this.setStringProperty(
      "usegerberattributes",
      value,
      PlotParamUseGerberAttributes
    );
  }
  get usegerberadvancedattributes() {
    return this._properties.usegerberadvancedattributes?.value;
  }
  set usegerberadvancedattributes(value) {
    this.setStringProperty(
      "usegerberadvancedattributes",
      value,
      PlotParamUseGerberAdvancedAttributes
    );
  }
  get creategerberjobfile() {
    return this._properties.creategerberjobfile?.value;
  }
  set creategerberjobfile(value) {
    this.setStringProperty(
      "creategerberjobfile",
      value,
      PlotParamCreateGerberJobFile
    );
  }
  get excludeedgelayer() {
    return this._properties.excludeedgelayer?.value;
  }
  set excludeedgelayer(value) {
    this.setStringProperty("excludeedgelayer", value, PlotParamExcludeEdgeLayer);
  }
  get dashed_line_dash_ratio() {
    return this._properties.dashed_line_dash_ratio?.value;
  }
  set dashed_line_dash_ratio(value) {
    this.setNumberProperty(
      "dashed_line_dash_ratio",
      value,
      PlotParamDashedLineDashRatio
    );
  }
  get dashed_line_gap_ratio() {
    return this._properties.dashed_line_gap_ratio?.value;
  }
  set dashed_line_gap_ratio(value) {
    this.setNumberProperty(
      "dashed_line_gap_ratio",
      value,
      PlotParamDashedLineGapRatio
    );
  }
  get svgprecision() {
    return this._properties.svgprecision?.value;
  }
  set svgprecision(value) {
    this.setNumberProperty("svgprecision", value, PlotParamSvgPrecision);
  }
  get linewidth() {
    return this._properties.linewidth?.value;
  }
  set linewidth(value) {
    this.setNumberProperty("linewidth", value, PlotParamLineWidth);
  }
  get plotframeref() {
    return this._properties.plotframeref?.value;
  }
  set plotframeref(value) {
    this.setStringProperty("plotframeref", value, PlotParamPlotFrameRef);
  }
  get plotreference() {
    return this._properties.plotreference?.value;
  }
  set plotreference(value) {
    this.setStringProperty("plotreference", value, PlotParamPlotReference);
  }
  get plotvalue() {
    return this._properties.plotvalue?.value;
  }
  set plotvalue(value) {
    this.setStringProperty("plotvalue", value, PlotParamPlotValue);
  }
  get plotothertext() {
    return this._properties.plotothertext?.value;
  }
  set plotothertext(value) {
    this.setStringProperty("plotothertext", value, PlotParamPlotOtherText);
  }
  get plotinvisibletext() {
    return this._properties.plotinvisibletext?.value;
  }
  set plotinvisibletext(value) {
    this.setStringProperty(
      "plotinvisibletext",
      value,
      PlotParamPlotInvisibleText
    );
  }
  get padsonsilk() {
    return this._properties.padsonsilk?.value;
  }
  set padsonsilk(value) {
    this.setStringProperty("padsonsilk", value, PlotParamPadOnSilk);
  }
  get plotpadnumbers() {
    return this._properties.plotpadnumbers?.value;
  }
  set plotpadnumbers(value) {
    this.setStringProperty("plotpadnumbers", value, PlotParamPlotPadNumbers);
  }
  get sketchpadsonfab() {
    return this._properties.sketchpadsonfab?.value;
  }
  set sketchpadsonfab(value) {
    this.setStringProperty("sketchpadsonfab", value, PlotParamSketchPadsOnFab);
  }
  get hidednponfab() {
    return this._properties.hidednponfab?.value;
  }
  set hidednponfab(value) {
    this.setStringProperty("hidednponfab", value, PlotParamHideDnpOnFab);
  }
  get sketchdnponfab() {
    return this._properties.sketchdnponfab?.value;
  }
  set sketchdnponfab(value) {
    this.setStringProperty("sketchdnponfab", value, PlotParamSketchDnpOnFab);
  }
  get crossoutdnponfab() {
    return this._properties.crossoutdnponfab?.value;
  }
  set crossoutdnponfab(value) {
    this.setStringProperty("crossoutdnponfab", value, PlotParamCrossoutDnpOnFab);
  }
  get subtractmaskfromsilk() {
    return this._properties.subtractmaskfromsilk?.value;
  }
  set subtractmaskfromsilk(value) {
    this.setStringProperty(
      "subtractmaskfromsilk",
      value,
      PlotParamSubtractMaskFromSilk
    );
  }
  get plot_black_and_white() {
    return this._properties.plot_black_and_white?.value;
  }
  set plot_black_and_white(value) {
    this.setStringProperty(
      "plot_black_and_white",
      value,
      PlotParamPlotBlackAndWhite
    );
  }
  get plot_on_all_layers() {
    return this._properties.plot_on_all_layers?.value;
  }
  set plot_on_all_layers(value) {
    this.setStringProperty(
      "plot_on_all_layers",
      value,
      PlotParamPlotOnAllLayers
    );
  }
  get plotinvisible() {
    return this._properties.plotinvisible?.value;
  }
  set plotinvisible(value) {
    this.setStringProperty("plotinvisible", value, PlotParamPlotInvisible);
  }
  get mode() {
    return this._properties.mode?.value;
  }
  set mode(value) {
    this.setNumberProperty("mode", value, PlotParamMode);
  }
  get useauxorigin() {
    return this._properties.useauxorigin?.value;
  }
  set useauxorigin(value) {
    this.setStringProperty("useauxorigin", value, PlotParamUseAuxOrigin);
  }
  get viasonmask() {
    return this._properties.viasonmask?.value;
  }
  set viasonmask(value) {
    this.setStringProperty("viasonmask", value, PlotParamViaOnMask);
  }
  get hpglpennumber() {
    return this._properties.hpglpennumber?.value;
  }
  set hpglpennumber(value) {
    this.setNumberProperty("hpglpennumber", value, PlotParamHpglPenNumber);
  }
  get hpglpenspeed() {
    return this._properties.hpglpenspeed?.value;
  }
  set hpglpenspeed(value) {
    this.setNumberProperty("hpglpenspeed", value, PlotParamHpglPenSpeed);
  }
  get hpglpendiameter() {
    return this._properties.hpglpendiameter?.value;
  }
  set hpglpendiameter(value) {
    this.setNumberProperty("hpglpendiameter", value, PlotParamHpglPenDiameter);
  }
  get hpglpenoverlay() {
    return this._properties.hpglpenoverlay?.value;
  }
  set hpglpenoverlay(value) {
    this.setNumberProperty("hpglpenoverlay", value, PlotParamHpglPenOverlay);
  }
  get pdf_front_fp_property_popups() {
    return this._properties.pdf_front_fp_property_popups?.value;
  }
  set pdf_front_fp_property_popups(value) {
    this.setStringProperty(
      "pdf_front_fp_property_popups",
      value,
      PlotParamPdfFrontFpPropertyPopups
    );
  }
  get pdf_back_fp_property_popups() {
    return this._properties.pdf_back_fp_property_popups?.value;
  }
  set pdf_back_fp_property_popups(value) {
    this.setStringProperty(
      "pdf_back_fp_property_popups",
      value,
      PlotParamPdfBackFpPropertyPopups
    );
  }
  get pdf_metadata() {
    return this._properties.pdf_metadata?.value;
  }
  set pdf_metadata(value) {
    this.setStringProperty("pdf_metadata", value, PlotParamPdfMetadata);
  }
  get pdf_single_document() {
    return this._properties.pdf_single_document?.value;
  }
  set pdf_single_document(value) {
    this.setStringProperty(
      "pdf_single_document",
      value,
      PlotParamPdfSingleDocument
    );
  }
  get dxfpolygonmode() {
    return this._properties.dxfpolygonmode?.value;
  }
  set dxfpolygonmode(value) {
    this.setStringProperty("dxfpolygonmode", value, PlotParamDxfPolygonMode);
  }
  get dxfimperialunits() {
    return this._properties.dxfimperialunits?.value;
  }
  set dxfimperialunits(value) {
    this.setStringProperty("dxfimperialunits", value, PlotParamDxfImperialUnits);
  }
  get dxfusepcbnewfont() {
    return this._properties.dxfusepcbnewfont?.value;
  }
  set dxfusepcbnewfont(value) {
    this.setStringProperty("dxfusepcbnewfont", value, PlotParamDxfUsePcbnewFont);
  }
  get psnegative() {
    return this._properties.psnegative?.value;
  }
  set psnegative(value) {
    this.setStringProperty("psnegative", value, PlotParamPsNegative);
  }
  get psa4output() {
    return this._properties.psa4output?.value;
  }
  set psa4output(value) {
    this.setStringProperty("psa4output", value, PlotParamPsA4Output);
  }
  get mirror() {
    return this._properties.mirror?.value;
  }
  set mirror(value) {
    this.setStringProperty("mirror", value, PlotParamMirror);
  }
  get outputformat() {
    return this._properties.outputformat?.value;
  }
  set outputformat(value) {
    this.setNumberProperty("outputformat", value, PlotParamOutputFormat);
  }
  get drillshape() {
    return this._properties.drillshape?.value;
  }
  set drillshape(value) {
    this.setNumberProperty("drillshape", value, PlotParamDrillShape);
  }
  get scaleselection() {
    return this._properties.scaleselection?.value;
  }
  set scaleselection(value) {
    this.setNumberProperty("scaleselection", value, PlotParamScaleSelection);
  }
  get outputdirectory() {
    return this._properties.outputdirectory?.value;
  }
  set outputdirectory(value) {
    this.setStringProperty("outputdirectory", value, PlotParamOutputDirectory);
  }
};
SxClass.register(PcbPlotParams);

// lib/sexpr/classes/Setup/setupStringProperties.ts
var SetupStringProperty = class extends SingleValueProperty {
  static parentToken = "setup";
};
var SetupZone45Only = class extends SetupStringProperty {
  static token = "zone_45_only";
  token = "zone_45_only";
};
SxClass.register(SetupZone45Only);
var SetupAllowSoldermaskBridgesInFootprints = class extends SetupStringProperty {
  static token = "allow_soldermask_bridges_in_footprints";
  token = "allow_soldermask_bridges_in_footprints";
};
SxClass.register(SetupAllowSoldermaskBridgesInFootprints);
var SetupVisibleElements = class extends SetupStringProperty {
  static token = "visible_elements";
  token = "visible_elements";
};
SxClass.register(SetupVisibleElements);
var SetupUviasAllowed = class extends SetupStringProperty {
  static token = "uvias_allowed";
  token = "uvias_allowed";
};
SxClass.register(SetupUviasAllowed);
var SetupTenting = class _SetupTenting extends SxClass {
  static token = "tenting";
  static parentToken = "setup";
  token = "tenting";
  _sides = [];
  constructor(sides = []) {
    super();
    this.sides = sides;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const sides = primitiveSexprs.map((primitive) => toStringValue(primitive)).filter((value) => value !== void 0);
    return new _SetupTenting(sides);
  }
  get sides() {
    return [...this._sides];
  }
  set sides(sides) {
    this._sides = sides.map((side) => String(side));
  }
  getChildren() {
    return [];
  }
  getString() {
    if (this._sides.length === 0) {
      return "(tenting)";
    }
    return `(tenting ${this._sides.join(" ")})`;
  }
};
SxClass.register(SetupTenting);

// lib/sexpr/classes/Setup/setupMultiValueProperties.ts
var SetupNumericListProperty = class extends NumericListProperty {
  static parentToken = "setup";
};
var SetupCoordinateProperty = class extends CoordinateProperty {
  static parentToken = "setup";
};
var SetupPcbTextSize = class extends SetupNumericListProperty {
  static token = "pcb_text_size";
  token = "pcb_text_size";
};
SxClass.register(SetupPcbTextSize);
var SetupModTextSize = class extends SetupNumericListProperty {
  static token = "mod_text_size";
  token = "mod_text_size";
};
SxClass.register(SetupModTextSize);
var SetupPadSize = class extends SetupNumericListProperty {
  static token = "pad_size";
  token = "pad_size";
};
SxClass.register(SetupPadSize);
var SetupPadToPasteClearanceValues = class extends SetupNumericListProperty {
  static token = "pad_to_paste_clearance_values";
  token = "pad_to_paste_clearance_values";
};
SxClass.register(SetupPadToPasteClearanceValues);
var SetupTraceWidth = class extends SetupNumericListProperty {
  static token = "trace_width";
  token = "trace_width";
};
SxClass.register(SetupTraceWidth);
var SetupAuxAxisOrigin = class extends SetupCoordinateProperty {
  static token = "aux_axis_origin";
  token = "aux_axis_origin";
};
SxClass.register(SetupAuxAxisOrigin);
var SetupGridOrigin = class extends SetupCoordinateProperty {
  static token = "grid_origin";
  token = "grid_origin";
};
SxClass.register(SetupGridOrigin);

// lib/sexpr/classes/Setup/setupNumericProperties.ts
var SetupNumberProperty = class extends SingleValueProperty {
  static parentToken = "setup";
  static parsePrimitiveValue(value) {
    const parsed = toNumberValue(value);
    if (parsed === void 0) {
      throw new Error(`${this.name} expects a numeric value`);
    }
    return parsed;
  }
};
var SetupPadToMaskClearance = class extends SetupNumberProperty {
  static token = "pad_to_mask_clearance";
  token = "pad_to_mask_clearance";
};
SxClass.register(SetupPadToMaskClearance);
var SetupSolderMaskMinWidth = class extends SetupNumberProperty {
  static token = "solder_mask_min_width";
  token = "solder_mask_min_width";
};
SxClass.register(SetupSolderMaskMinWidth);
var SetupPadToPasteClearance = class extends SetupNumberProperty {
  static token = "pad_to_paste_clearance";
  token = "pad_to_paste_clearance";
};
SxClass.register(SetupPadToPasteClearance);
var SetupPadToPasteClearanceRatio = class extends SetupNumberProperty {
  static token = "pad_to_paste_clearance_ratio";
  token = "pad_to_paste_clearance_ratio";
};
SxClass.register(SetupPadToPasteClearanceRatio);
var SetupLastTraceWidth = class extends SetupNumberProperty {
  static token = "last_trace_width";
  token = "last_trace_width";
};
SxClass.register(SetupLastTraceWidth);
var SetupTraceClearance = class extends SetupNumberProperty {
  static token = "trace_clearance";
  token = "trace_clearance";
};
SxClass.register(SetupTraceClearance);
var SetupZoneClearance = class extends SetupNumberProperty {
  static token = "zone_clearance";
  token = "zone_clearance";
};
SxClass.register(SetupZoneClearance);
var SetupTraceMin = class extends SetupNumberProperty {
  static token = "trace_min";
  token = "trace_min";
};
SxClass.register(SetupTraceMin);
var SetupSegmentWidth = class extends SetupNumberProperty {
  static token = "segment_width";
  token = "segment_width";
};
SxClass.register(SetupSegmentWidth);
var SetupEdgeWidth = class extends SetupNumberProperty {
  static token = "edge_width";
  token = "edge_width";
};
SxClass.register(SetupEdgeWidth);
var SetupViaSize = class extends SetupNumberProperty {
  static token = "via_size";
  token = "via_size";
};
SxClass.register(SetupViaSize);
var SetupViaDrill = class extends SetupNumberProperty {
  static token = "via_drill";
  token = "via_drill";
};
SxClass.register(SetupViaDrill);
var SetupViaMinSize = class extends SetupNumberProperty {
  static token = "via_min_size";
  token = "via_min_size";
};
SxClass.register(SetupViaMinSize);
var SetupViaMinDrill = class extends SetupNumberProperty {
  static token = "via_min_drill";
  token = "via_min_drill";
};
SxClass.register(SetupViaMinDrill);
var SetupUviaSize = class extends SetupNumberProperty {
  static token = "uvia_size";
  token = "uvia_size";
};
SxClass.register(SetupUviaSize);
var SetupUviaDrill = class extends SetupNumberProperty {
  static token = "uvia_drill";
  token = "uvia_drill";
};
SxClass.register(SetupUviaDrill);
var SetupUviaMinSize = class extends SetupNumberProperty {
  static token = "uvia_min_size";
  token = "uvia_min_size";
};
SxClass.register(SetupUviaMinSize);
var SetupUviaMinDrill = class extends SetupNumberProperty {
  static token = "uvia_min_drill";
  token = "uvia_min_drill";
};
SxClass.register(SetupUviaMinDrill);
var SetupPcbTextWidth = class extends SetupNumberProperty {
  static token = "pcb_text_width";
  token = "pcb_text_width";
};
SxClass.register(SetupPcbTextWidth);
var SetupModEdgeWidth = class extends SetupNumberProperty {
  static token = "mod_edge_width";
  token = "mod_edge_width";
};
SxClass.register(SetupModEdgeWidth);
var SetupModTextWidth = class extends SetupNumberProperty {
  static token = "mod_text_width";
  token = "mod_text_width";
};
SxClass.register(SetupModTextWidth);
var SetupPadDrill = class extends SetupNumberProperty {
  static token = "pad_drill";
  token = "pad_drill";
};
SxClass.register(SetupPadDrill);

// lib/sexpr/classes/Setup/StackupProperties.ts
var StackupSingleValueProperty = class extends SingleValueProperty {
  static parentToken = "stackup";
};
var StackupCopperFinish = class extends StackupSingleValueProperty {
  static token = "copper_finish";
  token = "copper_finish";
  quoteStringValue = true;
};
SxClass.register(StackupCopperFinish);
var StackupDielectricConstraints = class extends StackupSingleValueProperty {
  static token = "dielectric_constraints";
  token = "dielectric_constraints";
};
SxClass.register(StackupDielectricConstraints);
var StackupEdgeConnector = class extends StackupSingleValueProperty {
  static token = "edge_connector";
  token = "edge_connector";
};
SxClass.register(StackupEdgeConnector);
var StackupCastellatedPads = class extends StackupSingleValueProperty {
  static token = "castellated_pads";
  token = "castellated_pads";
};
SxClass.register(StackupCastellatedPads);
var StackupEdgePlating = class extends StackupSingleValueProperty {
  static token = "edge_plating";
  token = "edge_plating";
};
SxClass.register(StackupEdgePlating);

// lib/sexpr/classes/Setup/StackupLayerProperties.ts
var StackupLayerProperty = class extends SingleValueProperty {
  static parentToken = "layer";
};
var StackupLayerType = class extends StackupLayerProperty {
  static token = "type";
  token = "type";
  quoteStringValue = true;
};
SxClass.register(StackupLayerType);
var StackupLayerColor = class extends StackupLayerProperty {
  static token = "color";
  token = "color";
  quoteStringValue = true;
};
SxClass.register(StackupLayerColor);
var StackupLayerThickness = class extends StackupLayerProperty {
  static token = "thickness";
  token = "thickness";
  static parsePrimitiveValue(value) {
    const parsed = toNumberValue(value);
    if (parsed === void 0) {
      throw new Error("Stackup layer thickness expects a numeric value");
    }
    return parsed;
  }
};
SxClass.register(StackupLayerThickness);
var StackupLayerMaterial = class extends StackupLayerProperty {
  static token = "material";
  token = "material";
  quoteStringValue = true;
};
SxClass.register(StackupLayerMaterial);
var StackupLayerEpsilonR = class extends StackupLayerProperty {
  static token = "epsilon_r";
  token = "epsilon_r";
  static parsePrimitiveValue(value) {
    const parsed = toNumberValue(value);
    if (parsed === void 0) {
      throw new Error("Stackup layer epsilon_r expects a numeric value");
    }
    return parsed;
  }
};
SxClass.register(StackupLayerEpsilonR);
var StackupLayerLossTangent = class extends StackupLayerProperty {
  static token = "loss_tangent";
  token = "loss_tangent";
  static parsePrimitiveValue(value) {
    const parsed = toNumberValue(value);
    if (parsed === void 0) {
      throw new Error("Stackup layer loss_tangent expects a numeric value");
    }
    return parsed;
  }
};
SxClass.register(StackupLayerLossTangent);

// lib/sexpr/classes/Setup/StackupLayer.ts
var StackupLayer = class _StackupLayer extends SxClass {
  static token = "layer";
  static parentToken = "stackup";
  token = "layer";
  _name;
  _number;
  _sxType;
  _sxColor;
  _sxThickness;
  _sxMaterial;
  _sxEpsilonR;
  _sxLossTangent;
  constructor(name, opts = {}) {
    super();
    this._name = name;
    this._number = opts.number;
    this._sxType = opts.type;
    this._sxColor = opts.color;
    this._sxThickness = opts.thickness;
    this._sxMaterial = opts.material;
    this._sxEpsilonR = opts.epsilonR;
    this._sxLossTangent = opts.lossTangent;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    if (primitiveSexprs.length === 0) {
      throw new Error("Stackup layer requires at least a name");
    }
    const name = toStringValue(primitiveSexprs[0]);
    if (name === void 0) {
      throw new Error("Stackup layer name must be a string");
    }
    let propertyIndex = 1;
    let number;
    const maybeNumber = primitiveSexprs[propertyIndex];
    const numericLayerNumber = toNumberValue(maybeNumber);
    if (numericLayerNumber !== void 0) {
      number = numericLayerNumber;
      propertyIndex += 1;
    }
    const propertyPrimitives = primitiveSexprs.slice(propertyIndex);
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      propertyPrimitives,
      this.token
    );
    return new _StackupLayer(name, {
      number,
      type: propertyMap.type,
      color: propertyMap.color,
      thickness: propertyMap.thickness,
      material: propertyMap.material,
      epsilonR: propertyMap.epsilon_r,
      lossTangent: propertyMap.loss_tangent
    });
  }
  get name() {
    return this._name;
  }
  set name(value) {
    const parsed = toStringValue(value);
    if (parsed === void 0) {
      throw new Error("Stackup layer name must be a string");
    }
    this._name = parsed;
  }
  get number() {
    return this._number;
  }
  set number(value) {
    if (value === void 0) {
      this._number = void 0;
      return;
    }
    const parsed = toNumberValue(value);
    if (parsed === void 0) {
      throw new Error("Stackup layer number must be numeric");
    }
    this._number = parsed;
  }
  get type() {
    return this._sxType?.value;
  }
  set type(value) {
    if (value === void 0) {
      this._sxType = void 0;
      return;
    }
    this._sxType = value instanceof StackupLayerType ? value : new StackupLayerType(value);
  }
  get color() {
    return this._sxColor?.value;
  }
  set color(value) {
    if (value === void 0) {
      this._sxColor = void 0;
      return;
    }
    this._sxColor = value instanceof StackupLayerColor ? value : new StackupLayerColor(value);
  }
  get thickness() {
    return this._sxThickness?.value;
  }
  set thickness(value) {
    if (value === void 0) {
      this._sxThickness = void 0;
      return;
    }
    this._sxThickness = value instanceof StackupLayerThickness ? value : new StackupLayerThickness(value);
  }
  get material() {
    return this._sxMaterial?.value;
  }
  set material(value) {
    if (value === void 0) {
      this._sxMaterial = void 0;
      return;
    }
    this._sxMaterial = value instanceof StackupLayerMaterial ? value : new StackupLayerMaterial(value);
  }
  get epsilonR() {
    return this._sxEpsilonR?.value;
  }
  set epsilonR(value) {
    if (value === void 0) {
      this._sxEpsilonR = void 0;
      return;
    }
    this._sxEpsilonR = value instanceof StackupLayerEpsilonR ? value : new StackupLayerEpsilonR(value);
  }
  get lossTangent() {
    return this._sxLossTangent?.value;
  }
  set lossTangent(value) {
    if (value === void 0) {
      this._sxLossTangent = void 0;
      return;
    }
    this._sxLossTangent = value instanceof StackupLayerLossTangent ? value : new StackupLayerLossTangent(value);
  }
  getChildren() {
    const children = [];
    if (this._sxType) children.push(this._sxType);
    if (this._sxColor) children.push(this._sxColor);
    if (this._sxThickness) children.push(this._sxThickness);
    if (this._sxMaterial) children.push(this._sxMaterial);
    if (this._sxEpsilonR) children.push(this._sxEpsilonR);
    if (this._sxLossTangent) children.push(this._sxLossTangent);
    return children;
  }
  getString() {
    const header = `(layer ${quoteSExprString(this._name)}${this._number !== void 0 ? ` ${this._number}` : ""}`;
    const children = this.getChildren();
    if (children.length === 0) {
      return `${header})`;
    }
    const lines = [header];
    for (const child of children) {
      lines.push(child.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(StackupLayer);

// lib/sexpr/classes/Setup/Stackup.ts
var Stackup = class _Stackup extends SxClass {
  static token = "stackup";
  static parentToken = "setup";
  token = "stackup";
  _layers = [];
  _sxCopperFinish;
  _sxDielectricConstraints;
  _sxEdgeConnector;
  _sxCastellatedPads;
  _sxEdgePlating;
  constructor(opts = {}) {
    super();
    this.layers = opts.layers ?? [];
    this._sxCopperFinish = opts.copperFinish;
    this._sxDielectricConstraints = opts.dielectricConstraints;
    this._sxEdgeConnector = opts.edgeConnector;
    this._sxCastellatedPads = opts.castellatedPads;
    this._sxEdgePlating = opts.edgePlating;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    return new _Stackup({
      layers: arrayPropertyMap.layer ?? [],
      copperFinish: propertyMap.copper_finish,
      dielectricConstraints: propertyMap.dielectric_constraints,
      edgeConnector: propertyMap.edge_connector,
      castellatedPads: propertyMap.castellated_pads,
      edgePlating: propertyMap.edge_plating
    });
  }
  get layers() {
    return [...this._layers];
  }
  set layers(layers) {
    this._layers = layers.map((layer) => {
      if (!(layer instanceof StackupLayer)) {
        throw new Error("Stackup layers must be StackupLayer instances");
      }
      return layer;
    });
  }
  get copperFinish() {
    return this._sxCopperFinish?.value;
  }
  set copperFinish(value) {
    this._sxCopperFinish = value ? new StackupCopperFinish(value) : void 0;
  }
  get dielectricConstraints() {
    return this._sxDielectricConstraints?.value;
  }
  set dielectricConstraints(value) {
    this._sxDielectricConstraints = value ? new StackupDielectricConstraints(value) : void 0;
  }
  get edgeConnector() {
    return this._sxEdgeConnector?.value;
  }
  set edgeConnector(value) {
    this._sxEdgeConnector = value ? new StackupEdgeConnector(value) : void 0;
  }
  get castellatedPads() {
    return this._sxCastellatedPads?.value;
  }
  set castellatedPads(value) {
    this._sxCastellatedPads = value ? new StackupCastellatedPads(value) : void 0;
  }
  get edgePlating() {
    return this._sxEdgePlating?.value;
  }
  set edgePlating(value) {
    this._sxEdgePlating = value ? new StackupEdgePlating(value) : void 0;
  }
  getChildren() {
    const children = [...this._layers];
    const optionalChildren = [
      this._sxCopperFinish,
      this._sxDielectricConstraints,
      this._sxEdgeConnector,
      this._sxCastellatedPads,
      this._sxEdgePlating
    ];
    for (const child of optionalChildren) {
      if (child) {
        children.push(child);
      }
    }
    return children;
  }
};
SxClass.register(Stackup);

// lib/sexpr/classes/Setup/Setup.ts
var TOKEN_TO_KEY2 = {
  stackup: "stackup",
  pcbplotparams: "pcbPlotParams",
  pad_to_mask_clearance: "padToMaskClearance",
  solder_mask_min_width: "solderMaskMinWidth",
  pad_to_paste_clearance: "padToPasteClearance",
  pad_to_paste_clearance_ratio: "padToPasteClearanceRatio",
  last_trace_width: "lastTraceWidth",
  trace_clearance: "traceClearance",
  zone_clearance: "zoneClearance",
  zone_45_only: "zone45Only",
  trace_min: "traceMin",
  segment_width: "segmentWidth",
  edge_width: "edgeWidth",
  via_size: "viaSize",
  via_drill: "viaDrill",
  via_min_size: "viaMinSize",
  via_min_drill: "viaMinDrill",
  uvias_allowed: "uviasAllowed",
  uvia_size: "uviaSize",
  uvia_drill: "uviaDrill",
  uvia_min_size: "uviaMinSize",
  uvia_min_drill: "uviaMinDrill",
  pcb_text_width: "pcbTextWidth",
  pcb_text_size: "pcbTextSize",
  mod_edge_width: "modEdgeWidth",
  mod_text_size: "modTextSize",
  mod_text_width: "modTextWidth",
  pad_size: "padSize",
  pad_drill: "padDrill",
  allow_soldermask_bridges_in_footprints: "allowSoldermaskBridgesInFootprints",
  tenting: "tenting",
  aux_axis_origin: "auxAxisOrigin",
  grid_origin: "gridOrigin",
  visible_elements: "visibleElements",
  pad_to_paste_clearance_values: "padToPasteClearanceValues",
  trace_width: "traceWidth"
};
var SETUP_CHILD_ORDER = [
  "stackup",
  "padToMaskClearance",
  "solderMaskMinWidth",
  "padToPasteClearance",
  "padToPasteClearanceRatio",
  "lastTraceWidth",
  "traceClearance",
  "zoneClearance",
  "zone45Only",
  "traceMin",
  "segmentWidth",
  "edgeWidth",
  "viaSize",
  "viaDrill",
  "viaMinSize",
  "viaMinDrill",
  "uviaSize",
  "uviaDrill",
  "uviasAllowed",
  "uviaMinSize",
  "uviaMinDrill",
  "pcbTextWidth",
  "pcbTextSize",
  "modEdgeWidth",
  "modTextSize",
  "modTextWidth",
  "padSize",
  "padDrill",
  "allowSoldermaskBridgesInFootprints",
  "tenting",
  "auxAxisOrigin",
  "gridOrigin",
  "visibleElements",
  "padToPasteClearanceValues",
  "traceWidth",
  "pcbPlotParams"
];
var Setup = class _Setup extends SxClass {
  static token = "setup";
  token = "setup";
  _properties = {};
  static fromSexprPrimitives(primitiveSexprs) {
    const setup = new _Setup();
    const { propertyMap } = SxClass.parsePrimitivesToClassProperties(
      primitiveSexprs,
      this.token
    );
    for (const [token, instance] of Object.entries(propertyMap)) {
      const key = TOKEN_TO_KEY2[token];
      if (!key) {
        throw new Error(`Unsupported setup property token: ${token}`);
      }
      setup._properties[key] = instance;
    }
    return setup;
  }
  getChildren() {
    const children = [];
    for (const key of SETUP_CHILD_ORDER) {
      const child = this._properties[key];
      if (child) {
        children.push(child);
      }
    }
    return children;
  }
  setProperty(key, instance) {
    if (instance) {
      this._properties[key] = instance;
      return;
    }
    delete this._properties[key];
  }
  setNumberProperty(key, value, ClassRef) {
    if (value === void 0) {
      delete this._properties[key];
      return;
    }
    this._properties[key] = new ClassRef(value);
  }
  getPropertyInstance(key, ClassRef) {
    const value = this._properties[key];
    return value instanceof ClassRef ? value : void 0;
  }
  get stackup() {
    return this.getPropertyInstance("stackup", Stackup);
  }
  set stackup(value) {
    if (value !== void 0 && !(value instanceof Stackup)) {
      throw new Error("stackup must be a Stackup instance");
    }
    this.setProperty("stackup", value);
  }
  get pcbPlotParams() {
    return this.getPropertyInstance("pcbPlotParams", PcbPlotParams);
  }
  set pcbPlotParams(value) {
    if (value !== void 0 && !(value instanceof PcbPlotParams)) {
      throw new Error("pcbPlotParams must be a PcbPlotParams instance");
    }
    this.setProperty("pcbPlotParams", value);
  }
  get padToMaskClearance() {
    return this.getPropertyInstance(
      "padToMaskClearance",
      SetupPadToMaskClearance
    )?.value;
  }
  set padToMaskClearance(value) {
    this.setNumberProperty("padToMaskClearance", value, SetupPadToMaskClearance);
  }
  get solderMaskMinWidth() {
    return this.getPropertyInstance(
      "solderMaskMinWidth",
      SetupSolderMaskMinWidth
    )?.value;
  }
  set solderMaskMinWidth(value) {
    this.setNumberProperty("solderMaskMinWidth", value, SetupSolderMaskMinWidth);
  }
  get padToPasteClearance() {
    return this.getPropertyInstance(
      "padToPasteClearance",
      SetupPadToPasteClearance
    )?.value;
  }
  set padToPasteClearance(value) {
    this.setNumberProperty(
      "padToPasteClearance",
      value,
      SetupPadToPasteClearance
    );
  }
  get padToPasteClearanceRatio() {
    return this.getPropertyInstance(
      "padToPasteClearanceRatio",
      SetupPadToPasteClearanceRatio
    )?.value;
  }
  set padToPasteClearanceRatio(value) {
    this.setNumberProperty(
      "padToPasteClearanceRatio",
      value,
      SetupPadToPasteClearanceRatio
    );
  }
  get lastTraceWidth() {
    return this.getPropertyInstance("lastTraceWidth", SetupLastTraceWidth)?.value;
  }
  set lastTraceWidth(value) {
    this.setNumberProperty("lastTraceWidth", value, SetupLastTraceWidth);
  }
  get traceClearance() {
    return this.getPropertyInstance("traceClearance", SetupTraceClearance)?.value;
  }
  set traceClearance(value) {
    this.setNumberProperty("traceClearance", value, SetupTraceClearance);
  }
  get zoneClearance() {
    return this.getPropertyInstance("zoneClearance", SetupZoneClearance)?.value;
  }
  set zoneClearance(value) {
    this.setNumberProperty("zoneClearance", value, SetupZoneClearance);
  }
  get zone45Only() {
    return this.getPropertyInstance("zone45Only", SetupZone45Only)?.value;
  }
  set zone45Only(value) {
    this.setProperty(
      "zone45Only",
      value === void 0 ? void 0 : new SetupZone45Only(value)
    );
  }
  get traceMin() {
    return this.getPropertyInstance("traceMin", SetupTraceMin)?.value;
  }
  set traceMin(value) {
    this.setNumberProperty("traceMin", value, SetupTraceMin);
  }
  get segmentWidth() {
    return this.getPropertyInstance("segmentWidth", SetupSegmentWidth)?.value;
  }
  set segmentWidth(value) {
    this.setNumberProperty("segmentWidth", value, SetupSegmentWidth);
  }
  get edgeWidth() {
    return this.getPropertyInstance("edgeWidth", SetupEdgeWidth)?.value;
  }
  set edgeWidth(value) {
    this.setNumberProperty("edgeWidth", value, SetupEdgeWidth);
  }
  get viaSize() {
    return this.getPropertyInstance("viaSize", SetupViaSize)?.value;
  }
  set viaSize(value) {
    this.setNumberProperty("viaSize", value, SetupViaSize);
  }
  get viaDrill() {
    return this.getPropertyInstance("viaDrill", SetupViaDrill)?.value;
  }
  set viaDrill(value) {
    this.setNumberProperty("viaDrill", value, SetupViaDrill);
  }
  get viaMinSize() {
    return this.getPropertyInstance("viaMinSize", SetupViaMinSize)?.value;
  }
  set viaMinSize(value) {
    this.setNumberProperty("viaMinSize", value, SetupViaMinSize);
  }
  get viaMinDrill() {
    return this.getPropertyInstance("viaMinDrill", SetupViaMinDrill)?.value;
  }
  set viaMinDrill(value) {
    this.setNumberProperty("viaMinDrill", value, SetupViaMinDrill);
  }
  get uviasAllowed() {
    return this.getPropertyInstance("uviasAllowed", SetupUviasAllowed)?.value;
  }
  set uviasAllowed(value) {
    this.setProperty(
      "uviasAllowed",
      value === void 0 ? void 0 : new SetupUviasAllowed(value)
    );
  }
  get uviaSize() {
    return this.getPropertyInstance("uviaSize", SetupUviaSize)?.value;
  }
  set uviaSize(value) {
    this.setNumberProperty("uviaSize", value, SetupUviaSize);
  }
  get uviaDrill() {
    return this.getPropertyInstance("uviaDrill", SetupUviaDrill)?.value;
  }
  set uviaDrill(value) {
    this.setNumberProperty("uviaDrill", value, SetupUviaDrill);
  }
  get uviaMinSize() {
    return this.getPropertyInstance("uviaMinSize", SetupUviaMinSize)?.value;
  }
  set uviaMinSize(value) {
    this.setNumberProperty("uviaMinSize", value, SetupUviaMinSize);
  }
  get uviaMinDrill() {
    return this.getPropertyInstance("uviaMinDrill", SetupUviaMinDrill)?.value;
  }
  set uviaMinDrill(value) {
    this.setNumberProperty("uviaMinDrill", value, SetupUviaMinDrill);
  }
  get pcbTextWidth() {
    return this.getPropertyInstance("pcbTextWidth", SetupPcbTextWidth)?.value;
  }
  set pcbTextWidth(value) {
    this.setNumberProperty("pcbTextWidth", value, SetupPcbTextWidth);
  }
  get pcbTextSize() {
    return this.getPropertyInstance("pcbTextSize", SetupPcbTextSize)?.values;
  }
  set pcbTextSize(values) {
    if (values === void 0) {
      delete this._properties.pcbTextSize;
      return;
    }
    this.setProperty("pcbTextSize", new SetupPcbTextSize(values));
  }
  get modEdgeWidth() {
    return this.getPropertyInstance("modEdgeWidth", SetupModEdgeWidth)?.value;
  }
  set modEdgeWidth(value) {
    this.setNumberProperty("modEdgeWidth", value, SetupModEdgeWidth);
  }
  get modTextSize() {
    return this.getPropertyInstance("modTextSize", SetupModTextSize)?.values;
  }
  set modTextSize(values) {
    if (values === void 0) {
      delete this._properties.modTextSize;
      return;
    }
    this.setProperty("modTextSize", new SetupModTextSize(values));
  }
  get modTextWidth() {
    return this.getPropertyInstance("modTextWidth", SetupModTextWidth)?.value;
  }
  set modTextWidth(value) {
    this.setNumberProperty("modTextWidth", value, SetupModTextWidth);
  }
  get padSize() {
    return this.getPropertyInstance("padSize", SetupPadSize)?.values;
  }
  set padSize(values) {
    if (values === void 0) {
      delete this._properties.padSize;
      return;
    }
    this.setProperty("padSize", new SetupPadSize(values));
  }
  get padDrill() {
    return this.getPropertyInstance("padDrill", SetupPadDrill)?.value;
  }
  set padDrill(value) {
    this.setNumberProperty("padDrill", value, SetupPadDrill);
  }
  get allowSoldermaskBridgesInFootprints() {
    return this.getPropertyInstance(
      "allowSoldermaskBridgesInFootprints",
      SetupAllowSoldermaskBridgesInFootprints
    )?.value;
  }
  set allowSoldermaskBridgesInFootprints(value) {
    this.setProperty(
      "allowSoldermaskBridgesInFootprints",
      value === void 0 ? void 0 : new SetupAllowSoldermaskBridgesInFootprints(value)
    );
  }
  get tenting() {
    return this.getPropertyInstance("tenting", SetupTenting)?.sides;
  }
  set tenting(sides) {
    if (sides === void 0) {
      delete this._properties.tenting;
      return;
    }
    this.setProperty("tenting", new SetupTenting(sides));
  }
  get auxAxisOrigin() {
    const origin = this.getPropertyInstance("auxAxisOrigin", SetupAuxAxisOrigin);
    if (!origin) return void 0;
    return { x: origin.x, y: origin.y };
  }
  set auxAxisOrigin(origin) {
    if (!origin) {
      delete this._properties.auxAxisOrigin;
      return;
    }
    this.setProperty(
      "auxAxisOrigin",
      new SetupAuxAxisOrigin(origin.x, origin.y)
    );
  }
  get gridOrigin() {
    const origin = this.getPropertyInstance("gridOrigin", SetupGridOrigin);
    if (!origin) return void 0;
    return { x: origin.x, y: origin.y };
  }
  set gridOrigin(origin) {
    if (!origin) {
      delete this._properties.gridOrigin;
      return;
    }
    this.setProperty("gridOrigin", new SetupGridOrigin(origin.x, origin.y));
  }
  get visibleElements() {
    return this.getPropertyInstance("visibleElements", SetupVisibleElements)?.value;
  }
  set visibleElements(value) {
    this.setProperty(
      "visibleElements",
      value === void 0 ? void 0 : new SetupVisibleElements(value)
    );
  }
  get padToPasteClearanceValues() {
    return this.getPropertyInstance(
      "padToPasteClearanceValues",
      SetupPadToPasteClearanceValues
    )?.values;
  }
  set padToPasteClearanceValues(values) {
    if (values === void 0) {
      delete this._properties.padToPasteClearanceValues;
      return;
    }
    this.setProperty(
      "padToPasteClearanceValues",
      new SetupPadToPasteClearanceValues(values)
    );
  }
  get traceWidth() {
    return this.getPropertyInstance("traceWidth", SetupTraceWidth)?.values;
  }
  set traceWidth(values) {
    if (values === void 0) {
      delete this._properties.traceWidth;
      return;
    }
    this.setProperty("traceWidth", new SetupTraceWidth(values));
  }
};
SxClass.register(Setup);

// lib/sexpr/classes/PcbGeneralThickness.ts
var PcbGeneralThickness = class extends SxPrimitiveNumber {
  static token = "thickness";
  static parentToken = "general";
  token = "thickness";
};
SxClass.register(PcbGeneralThickness);

// lib/sexpr/classes/PcbGeneralLegacyTeardrops.ts
var PcbGeneralLegacyTeardrops = class _PcbGeneralLegacyTeardrops extends SxClass {
  static token = "legacy_teardrops";
  static parentToken = "general";
  token = "legacy_teardrops";
  _enabled;
  constructor(enabled) {
    super();
    this._enabled = enabled;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const value = toStringValue(primitiveSexprs[0]);
    if (value === void 0) {
      throw new Error("legacy_teardrops expects a string value");
    }
    const enabled = /^(yes|true)$/iu.test(value);
    return new _PcbGeneralLegacyTeardrops(enabled);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(legacy_teardrops ${this._enabled ? "yes" : "no"})`;
  }
};
SxClass.register(PcbGeneralLegacyTeardrops);

// lib/sexpr/classes/PcbGeneral.ts
var SINGLE_TOKENS3 = /* @__PURE__ */ new Set(["thickness", "legacy_teardrops"]);
var PcbGeneral = class _PcbGeneral extends SxClass {
  static token = "general";
  static parentToken = "kicad_pcb";
  token = "general";
  _sxThickness;
  _sxLegacyTeardrops;
  static fromSexprPrimitives(primitiveSexprs) {
    const general = new _PcbGeneral();
    const { propertyMap, arrayPropertyMap } = SxClass.parsePrimitivesToClassProperties(primitiveSexprs, this.token);
    for (const token of Object.keys(propertyMap)) {
      if (!SINGLE_TOKENS3.has(token)) {
        throw new Error(
          `general encountered unsupported child token "${token}"`
        );
      }
    }
    for (const [token, entries] of Object.entries(arrayPropertyMap)) {
      if (!SINGLE_TOKENS3.has(token)) {
        throw new Error(
          `general encountered unsupported child token "${token}"`
        );
      }
      if (entries.length > 1) {
        throw new Error(`general encountered repeated child token "${token}"`);
      }
    }
    general._sxThickness = arrayPropertyMap.thickness?.[0] ?? propertyMap.thickness;
    general._sxLegacyTeardrops = arrayPropertyMap.legacy_teardrops?.[0] ?? propertyMap.legacy_teardrops;
    return general;
  }
  get thickness() {
    return this._sxThickness?.value;
  }
  set thickness(value) {
    this._sxThickness = value === void 0 ? void 0 : new PcbGeneralThickness(value);
  }
  get legacyTeardrops() {
    return this._sxLegacyTeardrops?.enabled;
  }
  set legacyTeardrops(value) {
    if (value === void 0) {
      this._sxLegacyTeardrops = void 0;
      return;
    }
    this._sxLegacyTeardrops = new PcbGeneralLegacyTeardrops(value);
  }
  getChildren() {
    const children = [];
    if (this._sxThickness) children.push(this._sxThickness);
    if (this._sxLegacyTeardrops) children.push(this._sxLegacyTeardrops);
    return children;
  }
};
SxClass.register(PcbGeneral);

// lib/sexpr/classes/PcbLayerDefinition.ts
var PcbLayerDefinition = class _PcbLayerDefinition extends SxClass {
  static token = "__pcb_layer_definition__";
  static parentToken = "layers";
  token = "__pcb_layer_definition__";
  _index;
  _name;
  _type;
  _userName;
  constructor(options) {
    super();
    this._index = options.index;
    this._name = options.name;
    this._type = options.type;
    this._userName = options.userName;
  }
  static fromPrimitive(primitive) {
    if (!Array.isArray(primitive) || primitive.length < 3) {
      throw new Error(
        `layers entry must be an array with at least index, name, and type: ${JSON.stringify(primitive)}`
      );
    }
    const [rawIndex, rawName, rawType, rawUser] = primitive;
    const index = toNumberValue(rawIndex);
    const name = toStringValue(rawName);
    const type = toStringValue(rawType);
    const userName = rawUser === void 0 ? void 0 : toStringValue(rawUser);
    if (index === void 0 || name === void 0 || type === void 0) {
      throw new Error(
        `layers entry is missing required values: ${JSON.stringify(primitive)}`
      );
    }
    return new _PcbLayerDefinition({ index, name, type, userName });
  }
  get index() {
    return this._index;
  }
  set index(value) {
    this._index = value;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  get userName() {
    return this._userName;
  }
  set userName(value) {
    this._userName = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    if (this._index === void 0 || this._name === void 0 || this._type === void 0) {
      return "()";
    }
    const tokens = [
      String(this._index),
      quoteSExprString(this._name),
      this._type
    ];
    if (this._userName !== void 0) {
      tokens.push(quoteSExprString(this._userName));
    }
    return `(${tokens.join(" ")})`;
  }
};
SxClass.register(PcbLayerDefinition);

// lib/sexpr/classes/PcbLayers.ts
var PcbLayers = class _PcbLayers extends SxClass {
  static token = "layers";
  static parentToken = "kicad_pcb";
  token = "layers";
  _definitions = [];
  static fromSexprPrimitives(primitiveSexprs) {
    const layers = new _PcbLayers();
    layers._definitions = primitiveSexprs.map(
      (primitive) => PcbLayerDefinition.fromPrimitive(primitive)
    );
    return layers;
  }
  get definitions() {
    return [...this._definitions];
  }
  set definitions(value) {
    this._definitions = [...value];
  }
  getChildren() {
    return [...this._definitions];
  }
};
SxClass.register(PcbLayers);

// lib/sexpr/classes/PcbNet.ts
var PcbNet = class _PcbNet extends SxClass {
  static token = "net";
  static parentToken = "kicad_pcb";
  token = "net";
  _id;
  _name;
  constructor(id, name) {
    super();
    this._id = id;
    this._name = name;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const id = toNumberValue(primitiveSexprs[0]);
    const name = toStringValue(primitiveSexprs[1]);
    if (id === void 0 || name === void 0) {
      throw new Error("net requires numeric id and string name");
    }
    return new _PcbNet(id, name);
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    return `(net ${this._id} ${quoteSExprString(this._name)})`;
  }
};
SxClass.register(PcbNet);

// lib/sexpr/classes/PcbVersion.ts
var PcbVersion = class extends SxPrimitiveNumber {
  static token = "version";
  static parentToken = "kicad_pcb";
  token = "version";
};
SxClass.register(PcbVersion);

// lib/sexpr/classes/PcbGenerator.ts
var isSymbol = (value) => /^[A-Za-z0-9._-]+$/.test(value);
var PcbGenerator = class extends SxPrimitiveString {
  static token = "generator";
  static parentToken = "kicad_pcb";
  token = "generator";
  getString() {
    return `(generator ${isSymbol(this.value) ? this.value : quoteSExprString(this.value)})`;
  }
};
SxClass.register(PcbGenerator);

// lib/sexpr/classes/PcbGeneratorVersion.ts
var isSymbol2 = (value) => /^[A-Za-z0-9._-]+$/.test(value);
var PcbGeneratorVersion = class extends SxPrimitiveString {
  static token = "generator_version";
  static parentToken = "kicad_pcb";
  token = "generator_version";
  getString() {
    return `(generator_version ${isSymbol2(this.value) ? this.value : quoteSExprString(this.value)})`;
  }
};
SxClass.register(PcbGeneratorVersion);

// lib/sexpr/classes/ViaNet.ts
var ViaNet = class _ViaNet extends SxClass {
  static token = "net";
  static parentToken = "via";
  token = "net";
  _id;
  _name;
  constructor(id, name) {
    super();
    this._id = id;
    this._name = name;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const id = toNumberValue(primitiveSexprs[0]);
    if (id === void 0) {
      throw new Error("via net requires a numeric id");
    }
    const name = primitiveSexprs.length > 1 ? toStringValue(primitiveSexprs[1]) : void 0;
    return new _ViaNet(id, name);
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  getChildren() {
    return [];
  }
  getString() {
    if (this._name !== void 0) {
      return `(net ${this._id} ${quoteSExprString(this._name)})`;
    }
    return `(net ${this._id})`;
  }
};
SxClass.register(ViaNet);

// lib/sexpr/classes/Via.ts
var BARE_FLAGS = /* @__PURE__ */ new Set([
  "locked",
  "free",
  "remove_unused_layers",
  "keep_end_layers"
]);
var Via = class _Via extends SxClass {
  static token = "via";
  token = "via";
  _type;
  _locked = false;
  _free = false;
  _removeUnusedLayers = false;
  _keepEndLayers = false;
  _sxAt;
  _size;
  _drill;
  _sxLayers;
  _sxNet;
  _sxUuid;
  _sxTstamp;
  _sxTeardrops;
  constructor(params = {}) {
    super();
    if (params.type !== void 0) this.type = params.type;
    if (params.locked !== void 0) this.locked = params.locked;
    if (params.free !== void 0) this.free = params.free;
    if (params.removeUnusedLayers !== void 0)
      this.removeUnusedLayers = params.removeUnusedLayers;
    if (params.keepEndLayers !== void 0)
      this.keepEndLayers = params.keepEndLayers;
    if (params.at !== void 0) this.at = params.at;
    if (params.size !== void 0) this.size = params.size;
    if (params.drill !== void 0) this.drill = params.drill;
    if (params.layers !== void 0) this.layers = params.layers;
    if (params.net !== void 0) this.net = params.net;
    if (params.uuid !== void 0) this.uuid = params.uuid;
    if (params.tstamp !== void 0) this.tstamp = params.tstamp;
    if (params.teardrops !== void 0) this.teardrops = params.teardrops;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const via = new _Via();
    for (const primitive of primitiveSexprs) {
      if (typeof primitive === "string") {
        via.consumeBareToken(primitive);
        continue;
      }
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `via encountered unsupported primitive child: ${JSON.stringify(primitive)}`
        );
      }
      const [token, ...rest] = primitive;
      if (typeof token !== "string") {
        throw new Error(
          `via encountered child with non-string token: ${JSON.stringify(primitive)}`
        );
      }
      via.consumeNode(token, rest);
    }
    return via;
  }
  consumeBareToken(token) {
    if (token === "blind" || token === "micro") {
      this._type = token;
      return;
    }
    if (!BARE_FLAGS.has(token)) {
      throw new Error(`via encountered unsupported flag "${token}"`);
    }
    switch (token) {
      case "locked":
        this._locked = true;
        break;
      case "free":
        this._free = true;
        break;
      case "remove_unused_layers":
        this._removeUnusedLayers = true;
        break;
      case "keep_end_layers":
        this._keepEndLayers = true;
        break;
    }
  }
  consumeNode(token, args) {
    switch (token) {
      case "type": {
        const value = toStringValue(args[0]);
        if (value === void 0) {
          throw new Error("via type expects a string value");
        }
        this._type = value;
        return;
      }
      case "locked":
        this._locked = this.parseYesNo(args);
        return;
      case "free":
        this._free = this.parseYesNo(args);
        return;
      case "remove_unused_layers":
        this._removeUnusedLayers = this.parseYesNo(args);
        return;
      case "keep_end_layers":
        this._keepEndLayers = this.parseYesNo(args);
        return;
      case "at": {
        const parsed = SxClass.parsePrimitiveSexpr(["at", ...args], {
          parentToken: this.token
        });
        if (!(parsed instanceof At)) {
          throw new Error("via failed to parse at child");
        }
        this._sxAt = parsed;
        return;
      }
      case "size": {
        const value = toNumberValue(args[0]);
        if (value === void 0) {
          throw new Error("via size expects a numeric value");
        }
        this._size = value;
        return;
      }
      case "drill": {
        const value = toNumberValue(args[0]);
        if (value === void 0) {
          throw new Error("via drill expects a numeric value");
        }
        this._drill = value;
        return;
      }
      case "layers": {
        this._sxLayers = Layers.fromSexprPrimitives(args);
        return;
      }
      case "net": {
        this._sxNet = ViaNet.fromSexprPrimitives(args);
        return;
      }
      case "teardrops": {
        this._sxTeardrops = PadTeardrops.fromSexprPrimitives(args);
        return;
      }
      case "uuid": {
        const value = toStringValue(args[0]);
        if (value === void 0) {
          throw new Error("via uuid expects a string value");
        }
        this._sxUuid = new Uuid(value);
        return;
      }
      case "tstamp": {
        const value = toStringValue(args[0]);
        if (value === void 0) {
          throw new Error("via tstamp expects a string value");
        }
        this._sxTstamp = new Tstamp(value);
        return;
      }
      default:
        throw new Error(`via encountered unsupported child token "${token}"`);
    }
  }
  parseYesNo(args) {
    if (args.length === 0) return true;
    const value = toStringValue(args[0]);
    if (value === void 0) {
      throw new Error("Expected string when parsing via boolean child");
    }
    return /^(yes|true)$/iu.test(value);
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  get locked() {
    return this._locked;
  }
  set locked(value) {
    this._locked = value;
  }
  get free() {
    return this._free;
  }
  set free(value) {
    this._free = value;
  }
  get removeUnusedLayers() {
    return this._removeUnusedLayers;
  }
  set removeUnusedLayers(value) {
    this._removeUnusedLayers = value;
  }
  get keepEndLayers() {
    return this._keepEndLayers;
  }
  set keepEndLayers(value) {
    this._keepEndLayers = value;
  }
  get at() {
    return this._sxAt;
  }
  set at(value) {
    this._sxAt = value !== void 0 ? At.from(value) : void 0;
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
  }
  get drill() {
    return this._drill;
  }
  set drill(value) {
    this._drill = value;
  }
  get layers() {
    return this._sxLayers;
  }
  set layers(value) {
    if (value === void 0) {
      this._sxLayers = void 0;
      return;
    }
    this._sxLayers = value instanceof Layers ? value : new Layers(value);
  }
  get net() {
    return this._sxNet;
  }
  set net(value) {
    this._sxNet = value;
  }
  get uuid() {
    return this._sxUuid;
  }
  set uuid(value) {
    if (value === void 0) {
      this._sxUuid = void 0;
      return;
    }
    this._sxUuid = value instanceof Uuid ? value : new Uuid(value);
  }
  get teardrops() {
    return this._sxTeardrops;
  }
  set teardrops(value) {
    this._sxTeardrops = value;
  }
  get tstamp() {
    return this._sxTstamp;
  }
  set tstamp(value) {
    if (value === void 0) {
      this._sxTstamp = void 0;
      return;
    }
    this._sxTstamp = value instanceof Tstamp ? value : new Tstamp(value);
  }
  getChildren() {
    const children = [];
    if (this._sxAt) children.push(this._sxAt);
    if (this._sxLayers) children.push(this._sxLayers);
    if (this._sxNet) children.push(this._sxNet);
    if (this._sxUuid) children.push(this._sxUuid);
    if (this._sxTstamp) children.push(this._sxTstamp);
    if (this._sxTeardrops) children.push(this._sxTeardrops);
    return children;
  }
  getString() {
    const lines = ["(via"];
    if (this._type !== void 0) {
      lines.push(`  (type ${this._type})`);
    }
    if (this._locked) lines.push("  (locked)");
    if (this._free) lines.push("  (free)");
    if (this._removeUnusedLayers) lines.push("  (remove_unused_layers)");
    if (this._keepEndLayers) lines.push("  (keep_end_layers)");
    if (this._sxAt) lines.push(this._sxAt.getStringIndented());
    if (this._size !== void 0) lines.push(`  (size ${this._size})`);
    if (this._drill !== void 0) lines.push(`  (drill ${this._drill})`);
    if (this._sxLayers) lines.push(this._sxLayers.getStringIndented());
    if (this._sxNet) lines.push(this._sxNet.getStringIndented());
    if (this._sxUuid) lines.push(this._sxUuid.getStringIndented());
    if (this._sxTstamp) lines.push(this._sxTstamp.getStringIndented());
    if (this._sxTeardrops) {
      lines.push(this._sxTeardrops.getStringIndented());
    }
    lines.push(")");
    return lines.join("\n");
  }
};
SxClass.register(Via);

// lib/sexpr/classes/KicadPcb.ts
var KicadPcb = class _KicadPcb extends SxClass {
  static token = "kicad_pcb";
  token = "kicad_pcb";
  _sxVersion;
  _sxGenerator;
  _sxGeneratorVersion;
  _sxGeneral;
  _sxPaper;
  _sxTitleBlock;
  _sxLayers;
  _sxSetup;
  _properties = [];
  _nets = [];
  _footprints = [];
  _images = [];
  _segments = [];
  _grLines = [];
  _grTexts = [];
  _grPolys = [];
  _grRects = [];
  _vias = [];
  _zones = [];
  _otherChildren = [];
  constructor(params = {}) {
    super();
    if (params.version !== void 0) this.version = params.version;
    if (params.generator !== void 0) this.generator = params.generator;
    if (params.generatorVersion !== void 0)
      this.generatorVersion = params.generatorVersion;
    if (params.general !== void 0) this.general = params.general;
    if (params.paper !== void 0) this.paper = params.paper;
    if (params.titleBlock !== void 0) this.titleBlock = params.titleBlock;
    if (params.layers !== void 0) this.layers = params.layers;
    if (params.setup !== void 0) this.setup = params.setup;
    if (params.properties !== void 0) this.properties = params.properties;
    if (params.nets !== void 0) this.nets = params.nets;
    if (params.footprints !== void 0) this.footprints = params.footprints;
    if (params.images !== void 0) this.images = params.images;
    if (params.segments !== void 0) this.segments = params.segments;
    if (params.graphicLines !== void 0)
      this.graphicLines = params.graphicLines;
    if (params.graphicTexts !== void 0)
      this.graphicTexts = params.graphicTexts;
    if (params.graphicPolys !== void 0)
      this.graphicPolys = params.graphicPolys;
    if (params.graphicRects !== void 0)
      this.graphicRects = params.graphicRects;
    if (params.vias !== void 0) this.vias = params.vias;
    if (params.zones !== void 0) this.zones = params.zones;
    if (params.otherChildren !== void 0)
      this.otherChildren = params.otherChildren;
  }
  static fromSexprPrimitives(primitiveSexprs) {
    const pcb = new _KicadPcb();
    for (const primitive of primitiveSexprs) {
      if (!Array.isArray(primitive) || primitive.length === 0) {
        throw new Error(
          `kicad_pcb encountered unsupported primitive child: ${JSON.stringify(primitive)}`
        );
      }
      const parsed = SxClass.parsePrimitiveSexpr(primitive, {
        parentToken: this.token
      });
      if (!(parsed instanceof SxClass)) {
        throw new Error(
          `kicad_pcb expected SxClass child, received ${JSON.stringify(primitive)}`
        );
      }
      pcb.consumeChild(parsed);
    }
    return pcb;
  }
  consumeChild(child) {
    if (child instanceof PcbVersion) {
      this._sxVersion = child;
      return;
    }
    if (child instanceof PcbGenerator) {
      this._sxGenerator = child;
      return;
    }
    if (child instanceof PcbGeneratorVersion) {
      this._sxGeneratorVersion = child;
      return;
    }
    if (child instanceof PcbGeneral) {
      this._sxGeneral = child;
      return;
    }
    if (child instanceof Paper) {
      this._sxPaper = child;
      return;
    }
    if (child instanceof TitleBlock) {
      this._sxTitleBlock = child;
      return;
    }
    if (child instanceof PcbLayers) {
      this._sxLayers = child;
      return;
    }
    if (child instanceof Setup) {
      this._sxSetup = child;
      return;
    }
    if (child instanceof Property) {
      this._properties.push(child);
      return;
    }
    if (child instanceof PcbNet) {
      this._nets.push(child);
      return;
    }
    if (child instanceof Footprint) {
      this._footprints.push(child);
      return;
    }
    if (child instanceof Image) {
      this._images.push(child);
      return;
    }
    if (child instanceof Segment) {
      this._segments.push(child);
      return;
    }
    if (child instanceof GrLine) {
      this._grLines.push(child);
      return;
    }
    if (child instanceof GrText) {
      this._grTexts.push(child);
      return;
    }
    if (child instanceof GrPoly) {
      this._grPolys.push(child);
      return;
    }
    if (child instanceof GrRect) {
      this._grRects.push(child);
      return;
    }
    if (child instanceof Via) {
      this._vias.push(child);
      return;
    }
    if (child instanceof Zone) {
      this._zones.push(child);
      return;
    }
    this._otherChildren.push(child);
  }
  get version() {
    return this._sxVersion?.value;
  }
  set version(value) {
    this._sxVersion = value === void 0 ? void 0 : new PcbVersion(value);
  }
  get generator() {
    return this._sxGenerator?.value;
  }
  set generator(value) {
    this._sxGenerator = value === void 0 ? void 0 : new PcbGenerator(value);
  }
  get generatorVersion() {
    return this._sxGeneratorVersion?.value;
  }
  set generatorVersion(value) {
    this._sxGeneratorVersion = value === void 0 ? void 0 : new PcbGeneratorVersion(value);
  }
  get general() {
    return this._sxGeneral;
  }
  set general(value) {
    this._sxGeneral = value;
  }
  get paper() {
    return this._sxPaper;
  }
  set paper(value) {
    this._sxPaper = value;
  }
  get titleBlock() {
    return this._sxTitleBlock;
  }
  set titleBlock(value) {
    this._sxTitleBlock = value;
  }
  get layers() {
    return this._sxLayers;
  }
  set layers(value) {
    this._sxLayers = value;
  }
  get setup() {
    return this._sxSetup;
  }
  set setup(value) {
    this._sxSetup = value;
  }
  get properties() {
    return [...this._properties];
  }
  set properties(value) {
    this._properties = [...value];
  }
  get nets() {
    return [...this._nets];
  }
  set nets(value) {
    this._nets = [...value];
  }
  get footprints() {
    return [...this._footprints];
  }
  set footprints(value) {
    this._footprints = [...value];
  }
  get images() {
    return [...this._images];
  }
  set images(value) {
    this._images = [...value];
  }
  get segments() {
    return [...this._segments];
  }
  set segments(value) {
    this._segments = [...value];
  }
  get graphicLines() {
    return [...this._grLines];
  }
  set graphicLines(value) {
    this._grLines = [...value];
  }
  get graphicTexts() {
    return [...this._grTexts];
  }
  set graphicTexts(value) {
    this._grTexts = [...value];
  }
  get graphicPolys() {
    return [...this._grPolys];
  }
  set graphicPolys(value) {
    this._grPolys = [...value];
  }
  get graphicRects() {
    return [...this._grRects];
  }
  set graphicRects(value) {
    this._grRects = [...value];
  }
  get vias() {
    return [...this._vias];
  }
  set vias(value) {
    this._vias = [...value];
  }
  get zones() {
    return [...this._zones];
  }
  set zones(value) {
    this._zones = [...value];
  }
  get otherChildren() {
    return [...this._otherChildren];
  }
  set otherChildren(value) {
    this._otherChildren = [...value];
  }
  getChildren() {
    const children = [];
    if (this._sxVersion) children.push(this._sxVersion);
    if (this._sxGenerator) children.push(this._sxGenerator);
    if (this._sxGeneratorVersion) children.push(this._sxGeneratorVersion);
    if (this._sxGeneral) children.push(this._sxGeneral);
    if (this._sxPaper) children.push(this._sxPaper);
    if (this._sxTitleBlock) children.push(this._sxTitleBlock);
    if (this._sxLayers) children.push(this._sxLayers);
    if (this._sxSetup) children.push(this._sxSetup);
    children.push(...this._properties);
    children.push(...this._nets);
    children.push(...this._footprints);
    children.push(...this._images);
    children.push(...this._segments);
    children.push(...this._grLines);
    children.push(...this._grTexts);
    children.push(...this._grPolys);
    children.push(...this._grRects);
    children.push(...this._vias);
    children.push(...this._zones);
    children.push(...this._otherChildren);
    return children;
  }
};
SxClass.register(KicadPcb);

// lib/sexpr/parseKicadSexpr.ts
var parseKicadSexpr = (sexpr) => {
  return SxClass.parse(sexpr);
};
var parseKicadSch = (sexpr) => {
  const [root] = parseKicadSexpr(sexpr);
  if (!(root instanceof KicadSch)) {
    throw new Error(
      `Expected KicadSch root, got ${root?.constructor.name ?? "undefined"}`
    );
  }
  return root;
};
var parseKicadPcb = (sexpr) => {
  const [root] = parseKicadSexpr(sexpr);
  if (!(root instanceof KicadPcb)) {
    throw new Error(
      `Expected KicadPcb root, got ${root?.constructor.name ?? "undefined"}`
    );
  }
  return root;
};
var parseKicadMod = (sexpr) => {
  const [root] = parseKicadSexpr(sexpr);
  if (!(root instanceof Footprint)) {
    throw new Error(
      `Expected Footprint root, got ${root?.constructor.name ?? "undefined"}`
    );
  }
  return root;
};
export {
  At,
  Bus,
  BusEntry,
  BusEntrySize,
  Color,
  Dnp,
  EmbeddedFonts,
  ExcludeFromSim,
  FieldsAutoplaced,
  Footprint,
  FootprintAttr,
  FootprintAutoplaceCost180,
  FootprintAutoplaceCost90,
  FootprintClearance,
  FootprintDescr,
  FootprintLocked,
  FootprintModel,
  FootprintNetTiePadGroups,
  FootprintPad,
  FootprintPath,
  FootprintPlaced,
  FootprintPrivateLayers,
  FootprintSheetfile,
  FootprintSheetname,
  FootprintSolderMaskMargin,
  FootprintSolderPasteMargin,
  FootprintSolderPasteRatio,
  FootprintTags,
  FootprintTedit,
  FootprintThermalGap,
  FootprintThermalWidth,
  FootprintZoneConnect,
  FpArc,
  FpArcEnd,
  FpArcMid,
  FpArcStart,
  FpCircle,
  FpCircleCenter,
  FpCircleEnd,
  FpCircleFill,
  FpLine,
  FpLineEnd,
  FpLineStart,
  FpPoly,
  FpPolyFill,
  FpPolyLocked,
  FpRect,
  FpRectEnd,
  FpRectFill,
  FpRectStart,
  FpText,
  FpTextBox,
  FpTextBoxAngle,
  FpTextBoxEnd,
  FpTextBoxStart,
  GlobalLabel,
  GrArc,
  GrArcEnd,
  GrArcMid,
  GrArcStart,
  GrCircle,
  GrCircleCenter,
  GrCircleEnd,
  GrCircleLocked,
  GrCurve,
  GrLine,
  GrLineAngle,
  GrLineEnd,
  GrLineLocked,
  GrLineStart,
  GrPoly,
  GrPolyFill,
  GrRect,
  GrRectEnd,
  GrRectFill,
  GrRectLocked,
  GrRectStart,
  GrText,
  GrTextRenderCache,
  GrTextRenderCachePolygon,
  Group,
  GroupLocked,
  GroupMembers,
  Image,
  ImageData,
  ImageScale,
  InBom,
  Junction,
  JunctionDiameter,
  KicadPcb,
  KicadSch,
  KicadSchGenerator,
  KicadSchGeneratorVersion,
  KicadSchVersion,
  Label,
  Layer,
  Layers,
  LibSymbols,
  Mirror,
  NoConnect,
  OnBoard,
  PadChamfer,
  PadChamferRatio,
  PadClearance,
  PadDieLength,
  PadDrill,
  PadDrillOffset,
  PadLayers,
  PadNet,
  PadOptions,
  PadPinFunction,
  PadPinType,
  PadPrimitiveGrArc,
  PadPrimitiveGrCircle,
  PadPrimitiveGrCircleFill,
  PadPrimitiveGrLine,
  PadPrimitiveGrPoly,
  PadPrimitives,
  PadRectDelta,
  PadRoundrectRratio,
  PadSize,
  PadSolderMaskMargin,
  PadSolderPasteMargin,
  PadSolderPasteMarginRatio,
  PadTeardrops,
  PadThermalBridgeAngle,
  PadThermalGap,
  PadThermalWidth,
  PadZoneConnect,
  Paper,
  PcbGeneral,
  PcbGeneralLegacyTeardrops,
  PcbGeneralThickness,
  PcbGenerator,
  PcbGeneratorVersion,
  PcbLayerDefinition,
  PcbLayers,
  PcbNet,
  PcbPlotParams,
  PcbVersion,
  PlotParamCreateGerberJobFile,
  PlotParamCrossoutDnpOnFab,
  PlotParamDashedLineDashRatio,
  PlotParamDashedLineGapRatio,
  PlotParamDisableApertMacros,
  PlotParamDrillShape,
  PlotParamDxfImperialUnits,
  PlotParamDxfPolygonMode,
  PlotParamDxfUsePcbnewFont,
  PlotParamExcludeEdgeLayer,
  PlotParamHideDnpOnFab,
  PlotParamHpglPenDiameter,
  PlotParamHpglPenNumber,
  PlotParamHpglPenOverlay,
  PlotParamHpglPenSpeed,
  PlotParamLayerSelection,
  PlotParamLineWidth,
  PlotParamMirror,
  PlotParamMode,
  PlotParamOutputDirectory,
  PlotParamOutputFormat,
  PlotParamPadOnSilk,
  PlotParamPdfBackFpPropertyPopups,
  PlotParamPdfFrontFpPropertyPopups,
  PlotParamPdfMetadata,
  PlotParamPdfSingleDocument,
  PlotParamPlotBlackAndWhite,
  PlotParamPlotFrameRef,
  PlotParamPlotInvisible,
  PlotParamPlotInvisibleText,
  PlotParamPlotOnAllLayers,
  PlotParamPlotOnAllLayersSelection,
  PlotParamPlotOtherText,
  PlotParamPlotPadNumbers,
  PlotParamPlotReference,
  PlotParamPlotValue,
  PlotParamProperty,
  PlotParamPsA4Output,
  PlotParamPsNegative,
  PlotParamScaleSelection,
  PlotParamSketchDnpOnFab,
  PlotParamSketchPadsOnFab,
  PlotParamSubtractMaskFromSilk,
  PlotParamSvgPrecision,
  PlotParamUseAuxOrigin,
  PlotParamUseGerberAdvancedAttributes,
  PlotParamUseGerberAttributes,
  PlotParamUseGerberExtensions,
  PlotParamViaOnMask,
  Polyline,
  Property,
  PropertyHide,
  PropertyUnlocked,
  Pts,
  PtsArc,
  PtsArcEnd,
  PtsArcMid,
  PtsArcStart,
  RenderCache,
  SchematicPolyline,
  SchematicSymbol,
  SchematicText,
  Segment,
  SegmentEnd,
  SegmentLocked,
  SegmentNet,
  SegmentStart,
  Setup,
  SetupAllowSoldermaskBridgesInFootprints,
  SetupAuxAxisOrigin,
  SetupEdgeWidth,
  SetupGridOrigin,
  SetupLastTraceWidth,
  SetupModEdgeWidth,
  SetupModTextSize,
  SetupModTextWidth,
  SetupPadDrill,
  SetupPadSize,
  SetupPadToMaskClearance,
  SetupPadToPasteClearance,
  SetupPadToPasteClearanceRatio,
  SetupPadToPasteClearanceValues,
  SetupPcbTextSize,
  SetupPcbTextWidth,
  SetupSegmentWidth,
  SetupSolderMaskMinWidth,
  SetupTenting,
  SetupTraceClearance,
  SetupTraceMin,
  SetupTraceWidth,
  SetupUviaDrill,
  SetupUviaMinDrill,
  SetupUviaMinSize,
  SetupUviaSize,
  SetupUviasAllowed,
  SetupViaDrill,
  SetupViaMinDrill,
  SetupViaMinSize,
  SetupViaSize,
  SetupVisibleElements,
  SetupZone45Only,
  SetupZoneClearance,
  Sheet,
  SheetFill,
  SheetInstancePage,
  SheetInstancePath,
  SheetInstances,
  SheetInstancesForSheet,
  SheetInstancesProject,
  SheetInstancesRoot,
  SheetInstancesRootPage,
  SheetInstancesRootPath,
  SheetPin,
  SheetProperty,
  SheetSize,
  Stackup,
  StackupCastellatedPads,
  StackupCopperFinish,
  StackupDielectricConstraints,
  StackupEdgeConnector,
  StackupEdgePlating,
  StackupLayer,
  StackupLayerColor,
  StackupLayerEpsilonR,
  StackupLayerLossTangent,
  StackupLayerMaterial,
  StackupLayerThickness,
  StackupLayerType,
  Stroke,
  StrokeType,
  SxClass,
  SymbolArc,
  SymbolArcEnd,
  SymbolArcFill,
  SymbolArcMid,
  SymbolArcStart,
  SymbolCircle,
  SymbolCircleCenter,
  SymbolCircleFill,
  SymbolCircleRadius,
  SymbolDuplicatePinNumbersAreJumpers,
  SymbolFillType,
  SymbolInstancePath,
  SymbolInstanceReference,
  SymbolInstanceUnit,
  SymbolInstances,
  SymbolInstancesProject,
  SymbolLibId,
  SymbolPin,
  SymbolPinLength,
  SymbolPinName,
  SymbolPinNames,
  SymbolPinNamesHide,
  SymbolPinNamesOffset,
  SymbolPinNumber,
  SymbolPinNumbers,
  SymbolPinNumbersHide,
  SymbolPolyline,
  SymbolPolylineFill,
  SymbolPower,
  SymbolProperty,
  SymbolPropertyId,
  SymbolRectangle,
  SymbolRectangleEnd,
  SymbolRectangleFill,
  SymbolRectangleStart,
  SymbolText,
  SymbolUnit,
  TextEffects,
  TextEffectsFont,
  TextEffectsFontBold,
  TextEffectsFontFace,
  TextEffectsFontItalic,
  TextEffectsFontLineSpacing,
  TextEffectsFontSize,
  TextEffectsFontThickness,
  TextEffectsJustify,
  TitleBlock,
  TitleBlockComment,
  TitleBlockCompany,
  TitleBlockDate,
  TitleBlockRevision,
  TitleBlockTitle,
  Tstamp,
  Unit,
  Uuid,
  Via,
  ViaNet,
  Width,
  Wire,
  Xy,
  Zone,
  parseKicadMod,
  parseKicadPcb,
  parseKicadSch,
  parseKicadSexpr
};
