{"version":3,"sources":["../lib/pcb/convert-circuit-json-to-pcb-svg.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-trace-error.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-footprint-overlap-error.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-fabrication-note-path.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-fabrication-note-text.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-fabrication-note-rect.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-fabrication-note-dimension.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-note-dimension.ts","../lib/utils/colors.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-note-text.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-note-rect.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-note-path.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-note-line.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-plated-hole.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-path.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-text.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-rect.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-circle.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-line.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-courtyard-rect.ts","../lib/utils/pairs.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-trace.ts","../lib/pcb/colors.ts","../lib/pcb/layer-name-to-color.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-smt-pads.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-board.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-panel.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-via.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-hole.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-rats-nests.ts","../lib/pcb/create-svg-objects-from-pcb-rats-nest/get-element-position.ts","../lib/pcb/create-svg-objects-from-pcb-rats-nest/find-nearest-point-in-nest.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-cutout.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-copper-pour.ts","../lib/utils/ring-to-path-d.ts","../lib/pcb/svg-object-fns/create-svg-objects-for-pcb-grid.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-component.ts","../lib/utils/create-pcb-component-anchor-offset-indicators.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-group.ts","../lib/utils/get-software-used-string.ts","../package.json","../lib/package-version.ts","../lib/pcb/sort-svg-objects-by-pcb-layer.ts","../lib/utils/create-error-text-overlay.ts","../lib/assembly/convert-circuit-json-to-assembly-svg.ts","../lib/assembly/svg-object-fns/create-svg-objects-from-assembly-board.ts","../lib/assembly/svg-object-fns/create-svg-objects-from-assembly-component.ts","../lib/utils/get-sch-font-size.ts","../lib/assembly/svg-object-fns/create-svg-objects-from-assembly-hole.ts","../lib/assembly/svg-object-fns/create-svg-objects-from-assembly-plated-hole.ts","../lib/assembly/svg-object-fns/create-svg-objects-from-assembly-smt-pad.ts","../lib/pinout/convert-circuit-json-to-pinout-svg.ts","../lib/pinout/svg-object-fns/create-svg-objects-from-pinout-board.ts","../lib/pinout/svg-object-fns/create-svg-objects-from-pinout-component.ts","../lib/pinout/svg-object-fns/create-svg-objects-from-pinout-hole.ts","../lib/pinout/svg-object-fns/create-svg-objects-from-pinout-plated-hole.ts","../lib/pinout/svg-object-fns/create-svg-objects-from-pinout-smt-pad.ts","../lib/pinout/svg-object-fns/create-svg-objects-from-pinout-port.ts","../lib/pinout/svg-object-fns/pinout-label-box.ts","../lib/pinout/calculate-label-positions.ts","../lib/pinout/constants.ts","../lib/pinout/pinout-utils.ts","../lib/sch/convert-circuit-json-to-schematic-svg.ts","../lib/sch/draw-schematic-grid.ts","../lib/sch/draw-schematic-labeled-points.ts","../lib/sch/arial-text-metrics.ts","../lib/sch/estimate-text-width.ts","../lib/sch/get-table-dimensions.ts","../lib/utils/get-unit-vector-from-outside-to-edge.ts","../lib/utils/net-label-utils.ts","../lib/sch/get-schematic-bounds-from-circuit-json.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-component-with-symbol.ts","../lib/utils/get-sch-stroke-size.ts","../lib/utils/match-sch-ports-with-symbol-ports.ts","../lib/utils/point-pairs-to-matrix.ts","../lib/sch/svg-object-fns/create-svg-error-text.ts","../lib/utils/is-source-port-connected.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-component-with-box.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-port-on-box.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-port-box-line.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-port-pin-number-text.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-port-pin-label.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-text.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-component.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-voltage-probe.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-debug-object.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-trace.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-net-label.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-net-label-with-symbol.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-box.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-table.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-port-hover.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-line.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-circle.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-rect.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-arc.ts","../lib/convert-circuit-json-to-schematic-simulation-svg.ts","../lib/sim/convert-circuit-json-to-simulation-graph-svg.ts","../lib/sim/types.ts","../lib/pcb/convert-circuit-json-to-solder-paste-mask.ts","../lib/pcb/svg-object-fns/convert-circuit-json-to-solder-paste-mask.ts"],"sourcesContent":["import type {\n  Point,\n  AnyCircuitElement,\n  pcb_cutout,\n  PcbCutout,\n  PcbPanel,\n} from \"circuit-json\"\nimport { distance } from \"circuit-json\"\nimport { type INode as SvgObject, stringify } from \"svgson\"\nimport {\n  type Matrix,\n  applyToPoint,\n  compose,\n  scale,\n  translate,\n} from \"transformation-matrix\"\nimport { createSvgObjectsFromPcbTraceError } from \"./svg-object-fns/create-svg-objects-from-pcb-trace-error\"\nimport { createSvgObjectsFromPcbFootprintOverlapError } from \"./svg-object-fns/create-svg-objects-from-pcb-footprint-overlap-error\"\nimport { createSvgObjectsFromPcbFabricationNotePath } from \"./svg-object-fns/create-svg-objects-from-pcb-fabrication-note-path\"\nimport { createSvgObjectsFromPcbFabricationNoteText } from \"./svg-object-fns/create-svg-objects-from-pcb-fabrication-note-text\"\nimport { createSvgObjectsFromPcbFabricationNoteRect } from \"./svg-object-fns/create-svg-objects-from-pcb-fabrication-note-rect\"\nimport { createSvgObjectsFromPcbFabricationNoteDimension } from \"./svg-object-fns/create-svg-objects-from-pcb-fabrication-note-dimension\"\nimport { createSvgObjectsFromPcbNoteDimension } from \"./svg-object-fns/create-svg-objects-from-pcb-note-dimension\"\nimport { createSvgObjectsFromPcbNoteText } from \"./svg-object-fns/create-svg-objects-from-pcb-note-text\"\nimport { createSvgObjectsFromPcbNoteRect } from \"./svg-object-fns/create-svg-objects-from-pcb-note-rect\"\nimport { createSvgObjectsFromPcbNotePath } from \"./svg-object-fns/create-svg-objects-from-pcb-note-path\"\nimport { createSvgObjectsFromPcbNoteLine } from \"./svg-object-fns/create-svg-objects-from-pcb-note-line\"\nimport { createSvgObjectsFromPcbPlatedHole } from \"./svg-object-fns/create-svg-objects-from-pcb-plated-hole\"\nimport { createSvgObjectsFromPcbSilkscreenPath } from \"./svg-object-fns/create-svg-objects-from-pcb-silkscreen-path\"\nimport { createSvgObjectsFromPcbSilkscreenText } from \"./svg-object-fns/create-svg-objects-from-pcb-silkscreen-text\"\nimport { createSvgObjectsFromPcbSilkscreenRect } from \"./svg-object-fns/create-svg-objects-from-pcb-silkscreen-rect\"\nimport { createSvgObjectsFromPcbSilkscreenCircle } from \"./svg-object-fns/create-svg-objects-from-pcb-silkscreen-circle\"\nimport { createSvgObjectsFromPcbSilkscreenLine } from \"./svg-object-fns/create-svg-objects-from-pcb-silkscreen-line\"\nimport { createSvgObjectsFromPcbCourtyardRect } from \"./svg-object-fns/create-svg-objects-from-pcb-courtyard-rect\"\nimport { createSvgObjectsFromPcbTrace } from \"./svg-object-fns/create-svg-objects-from-pcb-trace\"\nimport { createSvgObjectsFromSmtPad } from \"./svg-object-fns/create-svg-objects-from-smt-pads\"\nimport { createSvgObjectsFromPcbBoard } from \"./svg-object-fns/create-svg-objects-from-pcb-board\"\nimport { createSvgObjectsFromPcbPanel } from \"./svg-object-fns/create-svg-objects-from-pcb-panel\"\nimport { createSvgObjectsFromPcbVia } from \"./svg-object-fns/create-svg-objects-from-pcb-via\"\nimport { createSvgObjectsFromPcbHole } from \"./svg-object-fns/create-svg-objects-from-pcb-hole\"\nimport { createSvgObjectsForRatsNest } from \"./svg-object-fns/create-svg-objects-from-pcb-rats-nests\"\nimport { createSvgObjectsFromPcbCutout } from \"./svg-object-fns/create-svg-objects-from-pcb-cutout\"\nimport { createSvgObjectsFromPcbCopperPour } from \"./svg-object-fns/create-svg-objects-from-pcb-copper-pour\"\nimport {\n  createSvgObjectsForPcbGrid,\n  type PcbGridOptions,\n} from \"./svg-object-fns/create-svg-objects-for-pcb-grid\"\nimport {\n  DEFAULT_PCB_COLOR_MAP,\n  type CopperColorMap,\n  type PcbColorMap,\n  type PcbColorOverrides,\n} from \"./colors\"\nimport { createSvgObjectsFromPcbComponent } from \"./svg-object-fns/create-svg-objects-from-pcb-component\"\nimport { createSvgObjectsFromPcbGroup } from \"./svg-object-fns/create-svg-objects-from-pcb-group\"\nimport { getSoftwareUsedString } from \"../utils/get-software-used-string\"\nimport { CIRCUIT_TO_SVG_VERSION } from \"../package-version\"\nimport { sortSvgObjectsByPcbLayer } from \"./sort-svg-objects-by-pcb-layer\"\nimport { createErrorTextOverlay } from \"../utils/create-error-text-overlay\"\n\ninterface PointObjectNotation {\n  x: number\n  y: number\n}\n\ninterface Options {\n  colorOverrides?: PcbColorOverrides\n  width?: number\n  height?: number\n  shouldDrawErrors?: boolean\n  showErrorsInTextOverlay?: boolean\n  shouldDrawRatsNest?: boolean\n  showCourtyards?: boolean\n  showPcbGroups?: boolean\n  layer?: \"top\" | \"bottom\"\n  matchBoardAspectRatio?: boolean\n  backgroundColor?: string\n  drawPaddingOutsideBoard?: boolean\n  includeVersion?: boolean\n  showSolderMask?: boolean\n  grid?: PcbGridOptions\n  showAnchorOffsets?: boolean\n}\n\nexport interface PcbContext {\n  transform: Matrix\n  layer?: \"top\" | \"bottom\"\n  shouldDrawErrors?: boolean\n  showCourtyards?: boolean\n  showPcbGroups?: boolean\n  drawPaddingOutsideBoard?: boolean\n  colorMap: PcbColorMap\n  showSolderMask?: boolean\n  showAnchorOffsets?: boolean\n  circuitJson?: AnyCircuitElement[]\n}\n\nexport function convertCircuitJsonToPcbSvg(\n  circuitJson: AnyCircuitElement[],\n  options?: Options,\n): string {\n  const drawPaddingOutsideBoard = options?.drawPaddingOutsideBoard ?? true\n  const layer = options?.layer\n  const colorOverrides = options?.colorOverrides\n\n  const copperColors: CopperColorMap = {\n    ...DEFAULT_PCB_COLOR_MAP.copper,\n  }\n\n  if (colorOverrides?.copper) {\n    for (const [layerName, color] of Object.entries(colorOverrides.copper)) {\n      if (color !== undefined) {\n        copperColors[layerName] = color\n      }\n    }\n  }\n\n  const colorMap: PcbColorMap = {\n    copper: copperColors,\n    drill: colorOverrides?.drill ?? DEFAULT_PCB_COLOR_MAP.drill,\n    silkscreen: {\n      top:\n        colorOverrides?.silkscreen?.top ?? DEFAULT_PCB_COLOR_MAP.silkscreen.top,\n      bottom:\n        colorOverrides?.silkscreen?.bottom ??\n        DEFAULT_PCB_COLOR_MAP.silkscreen.bottom,\n    },\n    boardOutline:\n      colorOverrides?.boardOutline ?? DEFAULT_PCB_COLOR_MAP.boardOutline,\n    soldermask: {\n      top:\n        colorOverrides?.soldermask?.top ?? DEFAULT_PCB_COLOR_MAP.soldermask.top,\n      bottom:\n        colorOverrides?.soldermask?.bottom ??\n        DEFAULT_PCB_COLOR_MAP.soldermask.bottom,\n    },\n    courtyard: colorOverrides?.courtyard ?? DEFAULT_PCB_COLOR_MAP.courtyard,\n    debugComponent: {\n      fill:\n        colorOverrides?.debugComponent?.fill ??\n        DEFAULT_PCB_COLOR_MAP.debugComponent.fill,\n      stroke:\n        colorOverrides?.debugComponent?.stroke ??\n        DEFAULT_PCB_COLOR_MAP.debugComponent.stroke,\n    },\n  }\n\n  let minX = Number.POSITIVE_INFINITY\n  let minY = Number.POSITIVE_INFINITY\n  let maxX = Number.NEGATIVE_INFINITY\n  let maxY = Number.NEGATIVE_INFINITY\n  let hasBounds = false\n\n  // Track bounds for pcb_board specifically\n  let boardMinX = Number.POSITIVE_INFINITY\n  let boardMinY = Number.POSITIVE_INFINITY\n  let boardMaxX = Number.NEGATIVE_INFINITY\n  let boardMaxY = Number.NEGATIVE_INFINITY\n  let hasBoardBounds = false\n\n  // Process all elements to determine bounds\n  for (const circuitJsonElm of circuitJson) {\n    if (circuitJsonElm.type === \"pcb_panel\") {\n      const panel = circuitJsonElm as PcbPanel\n      const width = distance.parse(panel.width)\n      const height = distance.parse(panel.height)\n      if (width === undefined || height === undefined) {\n        continue\n      }\n      const center = panel.center ?? { x: width / 2, y: height / 2 }\n      updateBounds(center, width, height)\n    } else if (circuitJsonElm.type === \"pcb_board\") {\n      if (\n        circuitJsonElm.outline &&\n        Array.isArray(circuitJsonElm.outline) &&\n        circuitJsonElm.outline.length >= 3\n      ) {\n        updateBoundsToIncludeOutline(circuitJsonElm.outline)\n        updateBoardBoundsToIncludeOutline(circuitJsonElm.outline)\n      } else if (\n        \"center\" in circuitJsonElm &&\n        \"width\" in circuitJsonElm &&\n        \"height\" in circuitJsonElm\n      ) {\n        updateBounds(\n          circuitJsonElm.center,\n          circuitJsonElm.width,\n          circuitJsonElm.height,\n        )\n        updateBoardBounds(\n          circuitJsonElm.center,\n          circuitJsonElm.width,\n          circuitJsonElm.height,\n        )\n      }\n    } else if (circuitJsonElm.type === \"pcb_smtpad\") {\n      const pad = circuitJsonElm as any\n      if (\n        pad.shape === \"rect\" ||\n        pad.shape === \"rotated_rect\" ||\n        pad.shape === \"pill\"\n      ) {\n        updateBounds({ x: pad.x, y: pad.y }, pad.width, pad.height)\n      } else if (pad.shape === \"circle\") {\n        const radius = distance.parse(pad.radius)\n        if (radius !== undefined) {\n          updateBounds({ x: pad.x, y: pad.y }, radius * 2, radius * 2)\n        }\n      } else if (pad.shape === \"polygon\") {\n        updateTraceBounds(pad.points)\n      }\n    } else if (\"x\" in circuitJsonElm && \"y\" in circuitJsonElm) {\n      updateBounds({ x: circuitJsonElm.x, y: circuitJsonElm.y }, 0, 0)\n    } else if (\"route\" in circuitJsonElm) {\n      updateTraceBounds(circuitJsonElm.route)\n    } else if (\n      circuitJsonElm.type === \"pcb_note_rect\" ||\n      circuitJsonElm.type === \"pcb_fabrication_note_rect\"\n    ) {\n      updateBounds(\n        (circuitJsonElm as any).center,\n        (circuitJsonElm as any).width,\n        (circuitJsonElm as any).height,\n      )\n    } else if (circuitJsonElm.type === \"pcb_cutout\") {\n      const cutout = circuitJsonElm as PcbCutout\n      if (cutout.shape === \"rect\") {\n        updateBounds(cutout.center, cutout.width, cutout.height)\n      } else if (cutout.shape === \"circle\") {\n        const radius = distance.parse(cutout.radius)\n        if (radius !== undefined) {\n          updateBounds(cutout.center, radius * 2, radius * 2)\n        }\n      } else if (cutout.shape === \"polygon\") {\n        updateTraceBounds(cutout.points)\n      }\n    } else if (\n      circuitJsonElm.type === \"pcb_silkscreen_text\" ||\n      circuitJsonElm.type === \"pcb_silkscreen_rect\" ||\n      circuitJsonElm.type === \"pcb_silkscreen_circle\" ||\n      circuitJsonElm.type === \"pcb_silkscreen_line\"\n    ) {\n      updateSilkscreenBounds(circuitJsonElm)\n    } else if (circuitJsonElm.type === \"pcb_copper_pour\") {\n      if (circuitJsonElm.shape === \"rect\") {\n        updateBounds(\n          circuitJsonElm.center,\n          circuitJsonElm.width,\n          circuitJsonElm.height,\n        )\n      } else if (circuitJsonElm.shape === \"polygon\") {\n        updateTraceBounds(circuitJsonElm.points)\n      }\n    }\n  }\n\n  const padding = drawPaddingOutsideBoard ? 1 : 0\n  const boundsMinX =\n    drawPaddingOutsideBoard || !Number.isFinite(boardMinX) ? minX : boardMinX\n  const boundsMinY =\n    drawPaddingOutsideBoard || !Number.isFinite(boardMinY) ? minY : boardMinY\n  const boundsMaxX =\n    drawPaddingOutsideBoard || !Number.isFinite(boardMaxX) ? maxX : boardMaxX\n  const boundsMaxY =\n    drawPaddingOutsideBoard || !Number.isFinite(boardMaxY) ? maxY : boardMaxY\n\n  const circuitWidth = boundsMaxX - boundsMinX + 2 * padding\n  const circuitHeight = boundsMaxY - boundsMinY + 2 * padding\n\n  let svgWidth = options?.width ?? 800\n  let svgHeight = options?.height ?? 600\n\n  if (options?.matchBoardAspectRatio) {\n    const boardWidth = boardMaxX - boardMinX\n    const boardHeight = boardMaxY - boardMinY\n    if (boardWidth > 0 && boardHeight > 0) {\n      const aspect = boardWidth / boardHeight\n      if (options?.width && !options?.height) {\n        svgHeight = options.width / aspect\n      } else if (options?.height && !options?.width) {\n        svgWidth = options.height * aspect\n      } else {\n        svgHeight = svgWidth / aspect\n      }\n    }\n  }\n  const paths: PointObjectNotation[][] = []\n  for (const circuitJsonElm of circuitJson) {\n    if (\"route\" in circuitJsonElm && circuitJsonElm.route !== undefined) {\n      paths.push(circuitJsonElm.route as PointObjectNotation[])\n    }\n  }\n\n  // Calculate scale factor to fit the circuit within the SVG, maintaining aspect ratio\n  const scaleX = svgWidth / circuitWidth\n  const scaleY = svgHeight / circuitHeight\n  const scaleFactor = Math.min(scaleX, scaleY)\n\n  // Calculate centering offsets\n  const offsetX = (svgWidth - circuitWidth * scaleFactor) / 2\n  const offsetY = (svgHeight - circuitHeight * scaleFactor) / 2\n\n  const transform = compose(\n    translate(\n      offsetX - boundsMinX * scaleFactor + padding * scaleFactor,\n      svgHeight - offsetY + boundsMinY * scaleFactor - padding * scaleFactor,\n    ),\n    scale(scaleFactor, -scaleFactor), // Flip in y-direction\n  )\n\n  const ctx: PcbContext = {\n    transform,\n    layer,\n    shouldDrawErrors: options?.shouldDrawErrors,\n    showCourtyards: options?.showCourtyards,\n    showPcbGroups: options?.showPcbGroups,\n    drawPaddingOutsideBoard,\n    colorMap,\n    showSolderMask: options?.showSolderMask,\n    showAnchorOffsets: options?.showAnchorOffsets,\n    circuitJson,\n  }\n\n  const unsortedSvgObjects = circuitJson.flatMap((elm) =>\n    createSvgObjects({ elm, circuitJson, ctx }),\n  )\n\n  let svgObjects = sortSvgObjectsByPcbLayer(unsortedSvgObjects)\n\n  let strokeWidth = String(0.05 * scaleFactor)\n\n  for (const element of circuitJson) {\n    if (\"stroke_width\" in element) {\n      strokeWidth = String(scaleFactor * element.stroke_width!)\n      break\n    }\n  }\n\n  if (options?.shouldDrawRatsNest) {\n    const ratsNestObjects = createSvgObjectsForRatsNest(circuitJson, ctx)\n    svgObjects = sortSvgObjectsByPcbLayer([...svgObjects, ...ratsNestObjects])\n  }\n\n  const children: SvgObject[] = [\n    {\n      name: \"style\",\n      type: \"element\",\n      value: \"\",\n      attributes: {},\n      children: [\n        {\n          type: \"text\",\n          value: \"\",\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n    },\n  ]\n\n  const gridObjects = createSvgObjectsForPcbGrid({\n    grid: options?.grid,\n    svgWidth,\n    svgHeight,\n  })\n\n  if (gridObjects.defs) {\n    children.push(gridObjects.defs)\n  }\n\n  children.push({\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      class: \"boundary\",\n      x: \"0\",\n      y: \"0\",\n      fill: options?.backgroundColor ?? \"#000\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n      \"data-type\": \"pcb_background\",\n      \"data-pcb-layer\": \"global\",\n    },\n    children: [],\n  })\n\n  if (drawPaddingOutsideBoard) {\n    children.push(\n      createSvgObjectFromPcbBoundary(transform, minX, minY, maxX, maxY),\n    )\n  }\n\n  children.push(...svgObjects)\n\n  if (gridObjects.rect) {\n    children.push(gridObjects.rect)\n  }\n\n  if (options?.showErrorsInTextOverlay) {\n    const errorOverlay = createErrorTextOverlay(\n      circuitJson,\n      \"pcb_error_text_overlay\",\n    )\n    if (errorOverlay) {\n      children.push(errorOverlay)\n    }\n  }\n\n  const softwareUsedString = getSoftwareUsedString(circuitJson)\n  const version = CIRCUIT_TO_SVG_VERSION\n\n  const svgObject: SvgObject = {\n    name: \"svg\",\n    type: \"element\",\n    attributes: {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n      ...(softwareUsedString && {\n        \"data-software-used-string\": softwareUsedString,\n      }),\n      ...(options?.includeVersion && {\n        \"data-circuit-to-svg-version\": version,\n      }),\n    },\n    value: \"\",\n    children: children.filter((child): child is SvgObject => child !== null),\n  }\n\n  try {\n    return stringify(svgObject as SvgObject)\n  } catch (error) {\n    console.error(\"Error stringifying SVG object:\", error)\n    throw error\n  }\n\n  function updateBounds(center: any, width: any, height: any) {\n    if (!center) return\n    const centerX = distance.parse(center.x)\n    const centerY = distance.parse(center.y)\n    if (centerX === undefined || centerY === undefined) return\n    const numericWidth = distance.parse(width) ?? 0\n    const numericHeight = distance.parse(height) ?? 0\n    const halfWidth = numericWidth / 2\n    const halfHeight = numericHeight / 2\n    minX = Math.min(minX, centerX - halfWidth)\n    minY = Math.min(minY, centerY - halfHeight)\n    maxX = Math.max(maxX, centerX + halfWidth)\n    maxY = Math.max(maxY, centerY + halfHeight)\n    hasBounds = true\n  }\n\n  function updateBoardBounds(center: any, width: any, height: any) {\n    if (!center) return\n    const centerX = distance.parse(center.x)\n    const centerY = distance.parse(center.y)\n    if (centerX === undefined || centerY === undefined) return\n    const numericWidth = distance.parse(width) ?? 0\n    const numericHeight = distance.parse(height) ?? 0\n    const halfWidth = numericWidth / 2\n    const halfHeight = numericHeight / 2\n    boardMinX = Math.min(boardMinX, centerX - halfWidth)\n    boardMinY = Math.min(boardMinY, centerY - halfHeight)\n    boardMaxX = Math.max(boardMaxX, centerX + halfWidth)\n    boardMaxY = Math.max(boardMaxY, centerY + halfHeight)\n    hasBounds = true\n    hasBoardBounds = true\n  }\n\n  function updateBoundsToIncludeOutline(outline: Point[]) {\n    let updated = false\n    for (const point of outline) {\n      const x = distance.parse(point.x)\n      const y = distance.parse(point.y)\n      if (x === undefined || y === undefined) continue\n      minX = Math.min(minX, x)\n      minY = Math.min(minY, y)\n      maxX = Math.max(maxX, x)\n      maxY = Math.max(maxY, y)\n      updated = true\n    }\n    if (updated) {\n      hasBounds = true\n    }\n  }\n\n  function updateBoardBoundsToIncludeOutline(outline: Point[]) {\n    let updated = false\n    for (const point of outline) {\n      const x = distance.parse(point.x)\n      const y = distance.parse(point.y)\n      if (x === undefined || y === undefined) continue\n      boardMinX = Math.min(boardMinX, x)\n      boardMinY = Math.min(boardMinY, y)\n      boardMaxX = Math.max(boardMaxX, x)\n      boardMaxY = Math.max(boardMaxY, y)\n      updated = true\n    }\n    if (updated) {\n      hasBounds = true\n      hasBoardBounds = true\n    }\n  }\n\n  function updateTraceBounds(route: any[]) {\n    let updated = false\n    for (const point of route) {\n      const x = distance.parse(point?.x)\n      const y = distance.parse(point?.y)\n      if (x === undefined || y === undefined) continue\n      minX = Math.min(minX, x)\n      minY = Math.min(minY, y)\n      maxX = Math.max(maxX, x)\n      maxY = Math.max(maxY, y)\n      updated = true\n    }\n    if (updated) {\n      hasBounds = true\n    }\n  }\n\n  function updateSilkscreenBounds(item: AnyCircuitElement) {\n    if (item.type === \"pcb_silkscreen_text\") {\n      updateBounds(item.anchor_position, 0, 0)\n    } else if (item.type === \"pcb_silkscreen_path\") {\n      updateTraceBounds(item.route)\n    } else if (item.type === \"pcb_silkscreen_rect\") {\n      updateBounds(item.center, item.width, item.height)\n    } else if (item.type === \"pcb_silkscreen_circle\") {\n      const radius = distance.parse(item.radius)\n      if (radius !== undefined) {\n        updateBounds(item.center, radius * 2, radius * 2)\n      }\n    } else if (item.type === \"pcb_silkscreen_line\") {\n      updateBounds({ x: item.x1, y: item.y1 }, 0, 0)\n      updateBounds({ x: item.x2, y: item.y2 }, 0, 0)\n    } else if (item.type === \"pcb_cutout\") {\n      const cutout = item as PcbCutout\n      if (cutout.shape === \"rect\") {\n        updateBounds(cutout.center, cutout.width, cutout.height)\n      } else if (cutout.shape === \"circle\") {\n        const radius = distance.parse(cutout.radius)\n        if (radius !== undefined) {\n          updateBounds(cutout.center, radius * 2, radius * 2)\n        }\n      } else if (cutout.shape === \"polygon\") {\n        updateTraceBounds(cutout.points)\n      }\n    }\n  }\n}\n\ninterface CreateSvgObjectsParams {\n  elm: AnyCircuitElement\n  circuitJson: AnyCircuitElement[]\n  ctx: PcbContext\n}\n\nfunction createSvgObjects({\n  elm,\n  circuitJson,\n  ctx,\n}: CreateSvgObjectsParams): SvgObject[] {\n  switch (elm.type) {\n    case \"pcb_trace_error\":\n      return createSvgObjectsFromPcbTraceError(elm, circuitJson, ctx).filter(\n        Boolean,\n      )\n    case \"pcb_footprint_overlap_error\":\n      return createSvgObjectsFromPcbFootprintOverlapError(\n        elm as any,\n        circuitJson,\n        ctx,\n      ).filter(Boolean)\n    case \"pcb_component\":\n      return createSvgObjectsFromPcbComponent(elm, ctx).filter(Boolean)\n    case \"pcb_trace\":\n      return createSvgObjectsFromPcbTrace(elm, ctx)\n    case \"pcb_copper_pour\":\n      return createSvgObjectsFromPcbCopperPour(elm as any, ctx)\n    case \"pcb_plated_hole\":\n      return createSvgObjectsFromPcbPlatedHole(elm, ctx).filter(Boolean)\n    case \"pcb_hole\":\n      return createSvgObjectsFromPcbHole(elm, ctx)\n    case \"pcb_smtpad\":\n      return createSvgObjectsFromSmtPad(elm, ctx)\n    case \"pcb_silkscreen_text\":\n      return createSvgObjectsFromPcbSilkscreenText(elm, ctx)\n    case \"pcb_silkscreen_rect\":\n      return createSvgObjectsFromPcbSilkscreenRect(elm, ctx)\n    case \"pcb_silkscreen_circle\":\n      return createSvgObjectsFromPcbSilkscreenCircle(elm, ctx)\n    case \"pcb_silkscreen_line\":\n      return createSvgObjectsFromPcbSilkscreenLine(elm, ctx)\n    case \"pcb_courtyard_rect\":\n      if (!ctx.showCourtyards) return []\n      return createSvgObjectsFromPcbCourtyardRect(elm, ctx)\n\n    case \"pcb_fabrication_note_path\":\n      return createSvgObjectsFromPcbFabricationNotePath(elm, ctx)\n    case \"pcb_fabrication_note_text\":\n      return createSvgObjectsFromPcbFabricationNoteText(elm, ctx)\n    case \"pcb_fabrication_note_rect\":\n      return createSvgObjectsFromPcbFabricationNoteRect(elm, ctx)\n    case \"pcb_fabrication_note_dimension\":\n      return createSvgObjectsFromPcbFabricationNoteDimension(elm, ctx)\n    case \"pcb_note_dimension\":\n      return createSvgObjectsFromPcbNoteDimension(elm, ctx)\n    case \"pcb_note_text\":\n      return createSvgObjectsFromPcbNoteText(elm, ctx)\n    case \"pcb_note_rect\":\n      return createSvgObjectsFromPcbNoteRect(elm, ctx)\n    case \"pcb_note_path\":\n      return createSvgObjectsFromPcbNotePath(elm, ctx)\n    case \"pcb_note_line\":\n      return createSvgObjectsFromPcbNoteLine(elm, ctx)\n    case \"pcb_silkscreen_path\":\n      return createSvgObjectsFromPcbSilkscreenPath(elm, ctx)\n    case \"pcb_panel\":\n      return ctx.drawPaddingOutsideBoard\n        ? createSvgObjectsFromPcbPanel(elm as PcbPanel, ctx)\n        : []\n    case \"pcb_board\":\n      return ctx.drawPaddingOutsideBoard\n        ? createSvgObjectsFromPcbBoard(elm, ctx)\n        : []\n    case \"pcb_via\":\n      return createSvgObjectsFromPcbVia(elm, ctx)\n    case \"pcb_cutout\":\n      return createSvgObjectsFromPcbCutout(elm as any, ctx)\n    case \"pcb_group\":\n      return ctx.showPcbGroups\n        ? createSvgObjectsFromPcbGroup(elm as any, ctx)\n        : []\n    default:\n      return []\n  }\n}\n\nfunction createSvgObjectFromPcbBoundary(\n  transform: any,\n  minX: number,\n  minY: number,\n  maxX: number,\n  maxY: number,\n): SvgObject {\n  const [x1, y1] = applyToPoint(transform, [minX, minY])\n  const [x2, y2] = applyToPoint(transform, [maxX, maxY])\n  const width = Math.abs(x2 - x1)\n  const height = Math.abs(y2 - y1)\n  const x = Math.min(x1, x2)\n  const y = Math.min(y1, y2)\n  return {\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    children: [],\n    attributes: {\n      class: \"pcb-boundary\",\n      fill: \"none\",\n      stroke: \"#fff\",\n      \"stroke-width\": \"0.3\",\n      x: x.toString(),\n      y: y.toString(),\n      width: width.toString(),\n      height: height.toString(),\n      \"data-type\": \"pcb_boundary\",\n      \"data-pcb-layer\": \"global\",\n    },\n  }\n}\n\n/**\n * @deprecated use `convertCircuitJsonToPcbSvg` instead\n */\nexport const circuitJsonToPcbSvg = convertCircuitJsonToPcbSvg\n","import type { PcbTraceError, PcbPort, AnyCircuitElement } from \"circuit-json\"\nimport type { SvgObject } from \"../../../lib/svg-object\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbTraceError(\n  pcbTraceError: PcbTraceError,\n  circuitJson: AnyCircuitElement[],\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, shouldDrawErrors } = ctx\n  if (!shouldDrawErrors) return []\n\n  const { pcb_port_ids } = pcbTraceError\n\n  const port1 = circuitJson.find(\n    (el): el is PcbPort =>\n      el.type === \"pcb_port\" && el.pcb_port_id === pcb_port_ids?.[0],\n  )\n  const port2 = circuitJson.find(\n    (el): el is PcbPort =>\n      el.type === \"pcb_port\" && el.pcb_port_id === pcb_port_ids?.[1],\n  )\n\n  if (!port1 || !port2) {\n    const viaIdMatch = pcbTraceError.message?.match(\n      /pcb_via\\[#?(pcb_via_\\d+)\\]/,\n    )\n    const viaId = viaIdMatch?.[1]\n    const via = circuitJson.find(\n      (el) => el.type === \"pcb_via\" && el.pcb_via_id === viaId,\n    ) as { x: number; y: number; type: string } | undefined\n\n    if (via && via.type === \"pcb_via\") {\n      return createSvgObjectsForViaTraceError(pcbTraceError, via, ctx)\n    }\n\n    if (pcbTraceError.center) {\n      const screenCenter = applyToPoint(transform, {\n        x: pcbTraceError.center.x,\n        y: pcbTraceError.center.y,\n      })\n      return annotateTraceErrorSvgObjects([\n        {\n          name: \"rect\",\n          type: \"element\",\n          attributes: {\n            x: (screenCenter.x - 5).toString(),\n            y: (screenCenter.y - 5).toString(),\n            width: \"10\",\n            height: \"10\",\n            fill: \"red\",\n            transform: `rotate(45 ${screenCenter.x} ${screenCenter.y})`,\n          },\n          children: [],\n          value: \"\",\n        },\n        {\n          name: \"text\",\n          type: \"element\",\n          attributes: {\n            x: screenCenter.x.toString(),\n            y: (screenCenter.y - 15).toString(),\n            fill: \"red\",\n            \"font-family\": \"sans-serif\",\n            \"font-size\": \"12\",\n            \"text-anchor\": \"middle\",\n          },\n          children: [\n            {\n              type: \"text\",\n              value: pcbTraceError.message || \"Pcb Trace Error\",\n              name: \"\",\n              attributes: {},\n              children: [],\n            },\n          ],\n          value: \"\",\n        },\n      ])\n    } else return []\n  }\n\n  const screenPort1 = applyToPoint(transform, {\n    x: port1.x,\n    y: port1.y,\n  })\n  const screenPort2 = applyToPoint(transform, {\n    x: port2.x,\n    y: port2.y,\n  })\n\n  const errorCenter = {\n    x: (screenPort1.x + screenPort2.x) / 2,\n    y: (screenPort1.y + screenPort2.y) / 2,\n  }\n\n  if (\n    isNaN(screenPort1.x) ||\n    isNaN(screenPort1.y) ||\n    isNaN(screenPort2.x) ||\n    isNaN(screenPort2.y) ||\n    isNaN(errorCenter.x) ||\n    isNaN(errorCenter.y)\n  ) {\n    return []\n  }\n\n  const svgObjects: SvgObject[] = [\n    {\n      name: \"line\",\n      type: \"element\",\n      attributes: {\n        x1: screenPort1.x.toString(),\n        y1: screenPort1.y.toString(),\n        x2: errorCenter.x.toString(),\n        y2: errorCenter.y.toString(),\n        stroke: \"red\",\n        \"stroke-width\": \"1.5\",\n        \"stroke-dasharray\": \"2,2\",\n      },\n      children: [],\n      value: \"\",\n    },\n    {\n      name: \"line\",\n      type: \"element\",\n      attributes: {\n        x1: errorCenter.x.toString(),\n        y1: errorCenter.y.toString(),\n        x2: screenPort2.x.toString(),\n        y2: screenPort2.y.toString(),\n        stroke: \"red\",\n        \"stroke-width\": \"1.5\",\n        \"stroke-dasharray\": \"2,2\",\n      },\n      children: [],\n      value: \"\",\n    },\n    {\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        x: (errorCenter.x - 5).toString(),\n        y: (errorCenter.y - 5).toString(),\n        width: \"10\",\n        height: \"10\",\n        fill: \"red\",\n        transform: `rotate(45 ${errorCenter.x} ${errorCenter.y})`,\n      },\n      children: [],\n      value: \"\",\n    },\n    {\n      name: \"text\",\n      type: \"element\",\n      attributes: {\n        x: errorCenter.x.toString(),\n        y: (errorCenter.y - 15).toString(),\n        fill: \"red\",\n        \"font-family\": \"sans-serif\",\n        \"font-size\": \"12\",\n        \"text-anchor\": \"middle\",\n      },\n      children: [\n        {\n          type: \"text\",\n          value: pcbTraceError.message || \"Pcb Trace Error\",\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n      value: \"\",\n    },\n  ]\n\n  return annotateTraceErrorSvgObjects(svgObjects)\n}\n\nfunction createSvgObjectsForViaTraceError(\n  pcbTraceError: PcbTraceError,\n  via: { x: number; y: number },\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform } = ctx\n  if (pcbTraceError.center && via) {\n    const screenCenter = applyToPoint(transform, {\n      x: pcbTraceError.center.x,\n      y: pcbTraceError.center.y,\n    })\n    const screenVia = applyToPoint(transform, {\n      x: via.x,\n      y: via.y,\n    })\n\n    // Vector from center to via\n    const dx = screenVia.x - screenCenter.x\n    const dy = screenVia.y - screenCenter.y\n    const dist = Math.sqrt(dx * dx + dy * dy)\n    const angle = (Math.atan2(dy, dx) * 180) / Math.PI\n    const margin = 10 // px\n    const boxWidth = dist + margin * 2\n    const boxHeight = 20 // px, can be adjusted\n    const midX = (screenCenter.x + screenVia.x) / 2\n    const midY = (screenCenter.y + screenVia.y) / 2\n\n    return annotateTraceErrorSvgObjects([\n      // Rotated bounding box\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          x: (midX - boxWidth / 2).toString(),\n          y: (midY - boxHeight / 2).toString(),\n          width: boxWidth.toString(),\n          height: boxHeight.toString(),\n          fill: \"none\",\n          stroke: \"red\",\n          \"stroke-width\": \"1\",\n          \"stroke-dasharray\": \"3,2\",\n          transform: `rotate(${angle} ${midX} ${midY})`,\n        },\n        children: [],\n        value: \"\",\n      },\n      // Error diamond\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          x: (midX - 5).toString(),\n          y: (midY - 5).toString(),\n          width: \"10\",\n          height: \"10\",\n          fill: \"red\",\n          transform: `rotate(45 ${midX} ${midY})`,\n        },\n        children: [],\n        value: \"\",\n      },\n      // Error label\n      {\n        name: \"text\",\n        type: \"element\",\n        attributes: {\n          x: midX.toString(),\n          y: (midY - boxHeight / 2 - 5).toString(),\n          fill: \"red\",\n          \"font-family\": \"sans-serif\",\n          \"font-size\": \"12\",\n          \"text-anchor\": \"middle\",\n        },\n        children: [\n          {\n            type: \"text\",\n            value: pcbTraceError.message || \"Pcb Trace Error\",\n            name: \"\",\n            attributes: {},\n            children: [],\n          },\n        ],\n        value: \"\",\n      },\n    ])\n  }\n\n  return []\n}\n\nfunction annotateTraceErrorSvgObjects(objects: SvgObject[]): SvgObject[] {\n  return objects.map((object) => ({\n    ...object,\n    attributes: {\n      ...(object.attributes ?? {}),\n      \"data-type\": object.attributes?.[\"data-type\"] ?? \"pcb_trace_error\",\n      \"data-pcb-layer\": object.attributes?.[\"data-pcb-layer\"] ?? \"overlay\",\n    },\n    children: (object.children ?? []).map((child: any) => {\n      if (child?.type === \"element\") {\n        return {\n          ...child,\n          attributes: {\n            ...(child.attributes ?? {}),\n            \"data-type\": child.attributes?.[\"data-type\"] ?? \"pcb_trace_error\",\n            \"data-pcb-layer\": child.attributes?.[\"data-pcb-layer\"] ?? \"overlay\",\n          },\n        }\n      }\n      return child\n    }),\n  }))\n}\n","import type { AnyCircuitElement, PcbFootprintOverlapError } from \"circuit-json\"\nimport type { SvgObject } from \"../../../lib/svg-object\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nfunction annotateFootprintErrorSvgObjects(objects: SvgObject[]): SvgObject[] {\n  return objects.map((object) => ({\n    ...object,\n    attributes: {\n      ...(object.attributes ?? {}),\n      \"data-type\":\n        object.attributes?.[\"data-type\"] ?? \"pcb_footprint_overlap_error\",\n      \"data-pcb-layer\": object.attributes?.[\"data-pcb-layer\"] ?? \"overlay\",\n    },\n    children: (object.children ?? []).map((child: any) => {\n      if (child?.type === \"element\") {\n        return {\n          ...child,\n          attributes: {\n            ...(child.attributes ?? {}),\n            \"data-type\":\n              child.attributes?.[\"data-type\"] ?? \"pcb_footprint_overlap_error\",\n            \"data-pcb-layer\": child.attributes?.[\"data-pcb-layer\"] ?? \"overlay\",\n          },\n        }\n      }\n      return child\n    }),\n  }))\n}\n\nexport function createSvgObjectsFromPcbFootprintOverlapError(\n  error: PcbFootprintOverlapError,\n  circuitJson: AnyCircuitElement[],\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, shouldDrawErrors } = ctx\n  if (!shouldDrawErrors) return []\n\n  const svgObjects: SvgObject[] = []\n\n  // Find all the elements referenced in the error\n  const referencedElements: Array<{\n    x: number\n    y: number\n    type: string\n    id: string\n    pcb_port_id?: string\n  }> = []\n\n  // Check SMT pads\n  let padPortIds: string[] = []\n  if (error.pcb_smtpad_ids) {\n    for (const padId of error.pcb_smtpad_ids) {\n      const pad = circuitJson.find(\n        (el) => el.type === \"pcb_smtpad\" && el.pcb_smtpad_id === padId,\n      ) as\n        | {\n            x: number\n            y: number\n            type: string\n            pcb_smtpad_id: string\n            pcb_port_id?: string\n          }\n        | undefined\n      if (pad) {\n        referencedElements.push({\n          x: pad.x,\n          y: pad.y,\n          type: \"pcb_smtpad\",\n          id: padId,\n          pcb_port_id: pad.pcb_port_id,\n        })\n        if (pad.pcb_port_id) padPortIds.push(pad.pcb_port_id)\n      }\n    }\n  }\n\n  // If all SMT pads share the same pcb_port_id, skip error indicator for those pads\n  const allPadsSamePort =\n    padPortIds.length > 1 && padPortIds.every((id) => id === padPortIds[0])\n  let filteredReferencedElements = referencedElements\n  if (allPadsSamePort) {\n    filteredReferencedElements = referencedElements.filter(\n      (e) => e.type !== \"pcb_smtpad\",\n    )\n  }\n\n  // Check plated holes\n  if (error.pcb_plated_hole_ids) {\n    for (const holeId of error.pcb_plated_hole_ids) {\n      const hole = circuitJson.find(\n        (el) =>\n          el.type === \"pcb_plated_hole\" && el.pcb_plated_hole_id === holeId,\n      ) as\n        | { x: number; y: number; type: string; pcb_plated_hole_id: string }\n        | undefined\n      if (hole) {\n        filteredReferencedElements.push({\n          x: hole.x,\n          y: hole.y,\n          type: \"pcb_plated_hole\",\n          id: holeId,\n        })\n      }\n    }\n  }\n\n  // Check holes\n  if (error.pcb_hole_ids) {\n    for (const holeId of error.pcb_hole_ids) {\n      const hole = circuitJson.find(\n        (el) => el.type === \"pcb_hole\" && el.pcb_hole_id === holeId,\n      ) as\n        | { x: number; y: number; type: string; pcb_hole_id: string }\n        | undefined\n      if (hole) {\n        filteredReferencedElements.push({\n          x: hole.x,\n          y: hole.y,\n          type: \"pcb_hole\",\n          id: holeId,\n        })\n      }\n    }\n  }\n\n  // If we found elements, draw error indicators at their positions\n  if (filteredReferencedElements.length > 0) {\n    // Calculate center point of all elements\n    const centerX =\n      filteredReferencedElements.reduce((sum, el) => sum + el.x, 0) /\n      filteredReferencedElements.length\n    const centerY =\n      filteredReferencedElements.reduce((sum, el) => sum + el.y, 0) /\n      filteredReferencedElements.length\n\n    const screenCenter = applyToPoint(transform, { x: centerX, y: centerY })\n\n    // Draw error indicator at center\n    svgObjects.push({\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        x: (screenCenter.x - 5).toString(),\n        y: (screenCenter.y - 5).toString(),\n        width: \"10\",\n        height: \"10\",\n        fill: \"red\",\n        transform: `rotate(45 ${screenCenter.x} ${screenCenter.y})`,\n      },\n      children: [],\n      value: \"\",\n    })\n\n    // Draw error message\n    svgObjects.push({\n      name: \"text\",\n      type: \"element\",\n      attributes: {\n        x: screenCenter.x.toString(),\n        y: (screenCenter.y - 15).toString(),\n        fill: \"red\",\n        \"font-family\": \"sans-serif\",\n        \"font-size\": \"12\",\n        \"text-anchor\": \"middle\",\n      },\n      children: [\n        {\n          type: \"text\",\n          value: error.message || \"PCB Footprint Overlap Error\",\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n      value: \"\",\n    })\n\n    // Draw indicators at each affected element\n    for (const element of filteredReferencedElements) {\n      const screenPos = applyToPoint(transform, { x: element.x, y: element.y })\n      // Draw a red diamond at each element\n      svgObjects.push({\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          x: (screenPos.x - 5).toString(),\n          y: (screenPos.y - 5).toString(),\n          width: \"10\",\n          height: \"10\",\n          fill: \"red\",\n          transform: `rotate(45 ${screenPos.x} ${screenPos.y})`,\n        },\n        children: [],\n        value: \"\",\n      })\n\n      // Draw a dashed line from center to this element\n      if (filteredReferencedElements.length > 1) {\n        svgObjects.push({\n          name: \"line\",\n          type: \"element\",\n          attributes: {\n            x1: screenCenter.x.toString(),\n            y1: screenCenter.y.toString(),\n            x2: screenPos.x.toString(),\n            y2: screenPos.y.toString(),\n            stroke: \"red\",\n            \"stroke-width\": \"1.5\",\n            \"stroke-dasharray\": \"2,2\",\n          },\n          children: [],\n          value: \"\",\n        })\n      }\n    }\n  }\n\n  return annotateFootprintErrorSvgObjects(svgObjects)\n}\n","import type { PcbSilkscreenPath, PcbFabricationNotePath } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbFabricationNotePath(\n  fabNotePath: PcbFabricationNotePath,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter } = ctx\n  if (!fabNotePath.route || !Array.isArray(fabNotePath.route)) return []\n\n  // Close the path if the first and last points are the same\n  const firstPoint = fabNotePath.route[0]\n  const lastPoint = fabNotePath.route[fabNotePath.route.length - 1]\n  const isClosed =\n    firstPoint!.x === lastPoint!.x && firstPoint!.y === lastPoint!.y\n\n  const path =\n    fabNotePath.route\n      .slice(0, isClosed ? -1 : undefined)\n      .map((point: any, index: number) => {\n        const [x, y] = applyToPoint(transform, [point.x, point.y])\n        return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`\n      })\n      .join(\" \") + (isClosed ? \" Z\" : \"\")\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        class: \"pcb-fabrication-note-path\",\n        stroke: fabNotePath.color || \"rgba(255,255,255,0.5)\",\n        fill: \"none\",\n        d: path,\n        \"stroke-width\": (\n          fabNotePath.stroke_width * Math.abs(transform.a)\n        ).toString(),\n        \"data-pcb-component-id\": fabNotePath.pcb_component_id,\n        \"data-pcb-fabrication-note-path-id\":\n          fabNotePath.pcb_fabrication_note_path_id,\n        \"data-type\": \"pcb_fabrication_note_path\",\n        \"data-pcb-layer\": \"overlay\",\n      },\n      value: \"\",\n      children: [],\n    },\n  ]\n}\n","import type { PcbFabricationNoteText } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { toString as matrixToString } from \"transformation-matrix\"\nimport { applyToPoint, compose, rotate, translate } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbFabricationNoteText(\n  pcbFabNoteText: PcbFabricationNoteText,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter } = ctx\n  const {\n    anchor_position,\n    anchor_alignment,\n    text,\n    font_size = 1,\n    layer = \"top\",\n    color,\n  } = pcbFabNoteText\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    !anchor_position ||\n    typeof anchor_position.x !== \"number\" ||\n    typeof anchor_position.y !== \"number\"\n  ) {\n    console.error(\"Invalid anchor_position:\", anchor_position)\n    return []\n  }\n\n  const [transformedX, transformedY] = applyToPoint(transform, [\n    anchor_position.x,\n    anchor_position.y,\n  ])\n  const transformedFontSize = font_size * Math.abs(transform.a)\n\n  // Remove ${} from text value and handle undefined text\n\n  // Create a composite transformation\n  const textTransform = compose(\n    translate(transformedX, transformedY), // TODO do anchor_alignment\n    rotate(Math.PI / 180), // Convert degrees to radians\n  )\n\n  const svgObject: SvgObject = {\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      x: \"0\",\n      y: \"0\",\n      \"font-family\": \"Arial, sans-serif\",\n      \"font-size\": transformedFontSize.toString(),\n      \"text-anchor\": \"middle\",\n      \"dominant-baseline\": \"central\",\n      transform: matrixToString(textTransform),\n      class: \"pcb-fabrication-note-text\",\n      fill: color || \"rgba(255,255,255,0.5)\",\n      \"data-type\": \"pcb_fabrication_note_text\",\n      \"data-pcb-layer\": \"overlay\",\n    },\n    children: [\n      {\n        type: \"text\",\n        value: text,\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  }\n\n  return [svgObject]\n}\n","import type { PcbFabricationNoteRect } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nconst DEFAULT_OVERLAY_STROKE_COLOR = \"rgba(255,255,255,0.5)\"\nconst DEFAULT_OVERLAY_FILL_COLOR = \"rgba(255,255,255,0.2)\"\n\nexport function createSvgObjectsFromPcbFabricationNoteRect(\n  fabricationNoteRect: PcbFabricationNoteRect,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter } = ctx\n  const {\n    center,\n    width,\n    height,\n    stroke_width,\n    is_filled,\n    has_stroke,\n    is_stroke_dashed,\n    color,\n    layer = \"top\",\n    pcb_component_id,\n    pcb_fabrication_note_rect_id,\n    corner_radius,\n  } = fabricationNoteRect\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    !center ||\n    typeof center.x !== \"number\" ||\n    typeof center.y !== \"number\" ||\n    typeof width !== \"number\" ||\n    typeof height !== \"number\"\n  ) {\n    console.error(\"Invalid pcb_fabrication_note_rect data\", {\n      center,\n      width,\n      height,\n    })\n    return []\n  }\n\n  const halfWidth = width / 2\n  const halfHeight = height / 2\n\n  const [topLeftX, topLeftY] = applyToPoint(transform, [\n    center.x - halfWidth,\n    center.y + halfHeight,\n  ])\n  const [bottomRightX, bottomRightY] = applyToPoint(transform, [\n    center.x + halfWidth,\n    center.y - halfHeight,\n  ])\n\n  const rectX = Math.min(topLeftX, bottomRightX)\n  const rectY = Math.min(topLeftY, bottomRightY)\n  const rectWidth = Math.abs(bottomRightX - topLeftX)\n  const rectHeight = Math.abs(bottomRightY - topLeftY)\n\n  const baseStrokeWidth = typeof stroke_width === \"number\" ? stroke_width : 0\n  const transformedStrokeWidth = baseStrokeWidth * Math.abs(transform.a)\n\n  const overlayStrokeColor = color ?? DEFAULT_OVERLAY_STROKE_COLOR\n  const baseCornerRadius =\n    typeof corner_radius === \"number\" && corner_radius > 0 ? corner_radius : 0\n  const transformedCornerRadiusX = baseCornerRadius * Math.abs(transform.a)\n  const transformedCornerRadiusY = baseCornerRadius * Math.abs(transform.d)\n\n  const attributes: Record<string, string> = {\n    x: rectX.toString(),\n    y: rectY.toString(),\n    width: rectWidth.toString(),\n    height: rectHeight.toString(),\n    class: \"pcb-fabrication-note-rect\",\n    \"data-type\": \"pcb_fabrication_note_rect\",\n    \"data-pcb-fabrication-note-rect-id\": pcb_fabrication_note_rect_id,\n    \"data-pcb-layer\": \"overlay\",\n  }\n\n  if (pcb_component_id !== undefined) {\n    attributes[\"data-pcb-component-id\"] = pcb_component_id\n  }\n  if (transformedCornerRadiusX > 0) {\n    attributes.rx = transformedCornerRadiusX.toString()\n  }\n\n  if (transformedCornerRadiusY > 0) {\n    attributes.ry = transformedCornerRadiusY.toString()\n  }\n\n  if (is_filled) {\n    attributes.fill = color ?? DEFAULT_OVERLAY_FILL_COLOR\n  } else {\n    attributes.fill = \"none\"\n  }\n\n  const shouldDrawStroke = has_stroke ?? transformedStrokeWidth > 0\n\n  if (shouldDrawStroke) {\n    attributes.stroke = overlayStrokeColor\n    attributes[\"stroke-width\"] = transformedStrokeWidth.toString()\n\n    if (is_stroke_dashed) {\n      const dash = 0.2 * Math.abs(transform.a)\n      const gap = 0.1 * Math.abs(transform.a)\n      attributes[\"stroke-dasharray\"] = `${dash} ${gap}`\n    }\n  } else {\n    attributes.stroke = \"none\"\n  }\n\n  const svgObject: SvgObject = {\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes,\n    children: [],\n  }\n\n  return [svgObject]\n}\n","import type { PcbFabricationNoteDimension } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\ninterface Point2D {\n  x: number\n  y: number\n}\n\nfunction normalize(vector: Point2D): Point2D {\n  const length = Math.hypot(vector.x, vector.y) || 1\n  return { x: vector.x / length, y: vector.y / length }\n}\n\nfunction toPath(points: Point2D[]): string {\n  return points\n    .map((point, index) =>\n      index === 0 ? `M ${point.x} ${point.y}` : `L ${point.x} ${point.y}`,\n    )\n    .join(\" \")\n}\n\nexport function createSvgObjectsFromPcbFabricationNoteDimension(\n  dimension: PcbFabricationNoteDimension,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter } = ctx\n  const {\n    from,\n    to,\n    text,\n    font_size = 1,\n    color,\n    arrow_size,\n    layer,\n    pcb_component_id,\n    pcb_fabrication_note_dimension_id,\n    offset_distance,\n    offset_direction,\n  } = dimension\n\n  if (layerFilter && layer && layer !== layerFilter) return []\n\n  if (!from || !to || typeof from !== \"object\" || typeof to !== \"object\") {\n    console.error(\"Invalid pcb_fabrication_note_dimension endpoints\", {\n      from,\n      to,\n    })\n    return []\n  }\n\n  if (\n    typeof (from as Point2D).x !== \"number\" ||\n    typeof (from as Point2D).y !== \"number\" ||\n    typeof (to as Point2D).x !== \"number\" ||\n    typeof (to as Point2D).y !== \"number\"\n  ) {\n    console.error(\"Invalid pcb_fabrication_note_dimension point values\", {\n      from,\n      to,\n    })\n    return []\n  }\n\n  const numericArrowSize =\n    typeof arrow_size === \"number\" ? arrow_size : undefined\n\n  if (\n    numericArrowSize === undefined ||\n    !Number.isFinite(numericArrowSize) ||\n    numericArrowSize <= 0\n  ) {\n    console.error(\n      \"Invalid pcb_fabrication_note_dimension arrow_size\",\n      arrow_size,\n    )\n    return []\n  }\n\n  const arrowSize = numericArrowSize\n\n  const direction = normalize({ x: to.x - from.x, y: to.y - from.y })\n\n  if (Number.isNaN(direction.x) || Number.isNaN(direction.y)) {\n    return []\n  }\n\n  const perpendicular = { x: -direction.y, y: direction.x }\n\n  const hasOffsetDirection =\n    offset_direction &&\n    typeof offset_direction.x === \"number\" &&\n    typeof offset_direction.y === \"number\"\n\n  const normalizedOffsetDirection = hasOffsetDirection\n    ? normalize({ x: offset_direction.x, y: offset_direction.y })\n    : { x: 0, y: 0 }\n\n  const offsetMagnitude =\n    typeof offset_distance === \"number\" ? offset_distance : 0\n\n  const offsetVector = {\n    x: normalizedOffsetDirection.x * offsetMagnitude,\n    y: normalizedOffsetDirection.y * offsetMagnitude,\n  }\n\n  const applyOffset = (point: Point2D): Point2D => ({\n    x: point.x + offsetVector.x,\n    y: point.y + offsetVector.y,\n  })\n\n  const fromOffset = applyOffset(from)\n  const toOffset = applyOffset(to)\n\n  const arrowHalfWidth = arrowSize / 2\n\n  const fromBase = {\n    x: fromOffset.x + direction.x * arrowSize,\n    y: fromOffset.y + direction.y * arrowSize,\n  }\n\n  const toBase = {\n    x: toOffset.x - direction.x * arrowSize,\n    y: toOffset.y - direction.y * arrowSize,\n  }\n\n  const fromTriangle = [\n    toScreen(fromOffset),\n    toScreen({\n      x: fromBase.x + perpendicular.x * arrowHalfWidth,\n      y: fromBase.y + perpendicular.y * arrowHalfWidth,\n    }),\n    toScreen({\n      x: fromBase.x - perpendicular.x * arrowHalfWidth,\n      y: fromBase.y - perpendicular.y * arrowHalfWidth,\n    }),\n  ]\n\n  const toTriangle = [\n    toScreen(toOffset),\n    toScreen({\n      x: toBase.x + perpendicular.x * arrowHalfWidth,\n      y: toBase.y + perpendicular.y * arrowHalfWidth,\n    }),\n    toScreen({\n      x: toBase.x - perpendicular.x * arrowHalfWidth,\n      y: toBase.y - perpendicular.y * arrowHalfWidth,\n    }),\n  ]\n\n  const [lineStartX, lineStartY] = applyToPoint(transform, [\n    fromBase.x,\n    fromBase.y,\n  ])\n  const [lineEndX, lineEndY] = applyToPoint(transform, [toBase.x, toBase.y])\n\n  const strokeWidth = (arrowSize / 5) * Math.abs(transform.a)\n  const lineColor = color || \"rgba(255,255,255,0.5)\"\n\n  const extensionDirection =\n    hasOffsetDirection &&\n    (Math.abs(normalizedOffsetDirection.x) > Number.EPSILON ||\n      Math.abs(normalizedOffsetDirection.y) > Number.EPSILON)\n      ? normalizedOffsetDirection\n      : perpendicular\n\n  const extensionLength = offsetMagnitude + arrowSize\n\n  const createExtensionLine = (anchor: Point2D): SvgObject => {\n    const endPoint = {\n      x: anchor.x + extensionDirection.x * extensionLength,\n      y: anchor.y + extensionDirection.y * extensionLength,\n    }\n\n    const [startX, startY] = applyToPoint(transform, [anchor.x, anchor.y])\n    const [endX, endY] = applyToPoint(transform, [endPoint.x, endPoint.y])\n\n    return {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        d: `M ${startX} ${startY} L ${endX} ${endY}`,\n        stroke: lineColor,\n        fill: \"none\",\n        \"stroke-width\": strokeWidth.toString(),\n        \"stroke-linecap\": \"round\",\n        class: \"pcb-fabrication-note-dimension-extension\",\n      },\n      children: [],\n    }\n  }\n\n  const extensionSegments = [createExtensionLine(from), createExtensionLine(to)]\n\n  const midPoint = {\n    x: (from.x + to.x) / 2 + offsetVector.x,\n    y: (from.y + to.y) / 2 + offsetVector.y,\n  }\n\n  const textOffset = arrowSize * 1.5\n  const textPoint = {\n    x: midPoint.x + perpendicular.x * textOffset,\n    y: midPoint.y + perpendicular.y * textOffset,\n  }\n\n  const [textX, textY] = applyToPoint(transform, [textPoint.x, textPoint.y])\n  const [screenFromX, screenFromY] = applyToPoint(transform, [\n    fromOffset.x,\n    fromOffset.y,\n  ])\n  const [screenToX, screenToY] = applyToPoint(transform, [\n    toOffset.x,\n    toOffset.y,\n  ])\n\n  const screenDirection = normalize({\n    x: screenToX - screenFromX,\n    y: screenToY - screenFromY,\n  })\n\n  let textAngle =\n    (Math.atan2(screenDirection.y, screenDirection.x) * 180) / Math.PI\n\n  if (textAngle > 90 || textAngle < -90) {\n    textAngle += 180\n  }\n\n  const transformedFontSize = font_size * Math.abs(transform.a)\n\n  const children: SvgObject[] = [\n    ...extensionSegments,\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        d: `M ${lineStartX} ${lineStartY} L ${lineEndX} ${lineEndY}`,\n        stroke: lineColor,\n        fill: \"none\",\n        \"stroke-width\": strokeWidth.toString(),\n        \"stroke-linecap\": \"round\",\n        class: \"pcb-fabrication-note-dimension-line\",\n      },\n      children: [],\n    },\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        d: `${toPath(fromTriangle)} Z`,\n        fill: lineColor,\n        class: \"pcb-fabrication-note-dimension-arrow\",\n      },\n      children: [],\n    },\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        d: `${toPath(toTriangle)} Z`,\n        fill: lineColor,\n        class: \"pcb-fabrication-note-dimension-arrow\",\n      },\n      children: [],\n    },\n  ]\n\n  if (text) {\n    children.push({\n      name: \"text\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        x: textX.toString(),\n        y: textY.toString(),\n        fill: lineColor,\n        \"font-size\": transformedFontSize.toString(),\n        \"font-family\": \"Arial, sans-serif\",\n        \"text-anchor\": \"middle\",\n        \"dominant-baseline\": \"central\",\n        class: \"pcb-fabrication-note-dimension-text\",\n        transform: `rotate(${textAngle} ${textX} ${textY})`,\n      },\n      children: [\n        {\n          type: \"text\",\n          name: \"\",\n          value: text,\n          attributes: {},\n          children: [],\n        },\n      ],\n    })\n  }\n\n  const attributes: Record<string, string> = {\n    class: \"pcb-fabrication-note-dimension\",\n    \"data-type\": \"pcb_fabrication_note_dimension\",\n    \"data-pcb-fabrication-note-dimension-id\": pcb_fabrication_note_dimension_id,\n    \"data-pcb-layer\": layer ?? \"overlay\",\n  }\n\n  if (pcb_component_id !== undefined) {\n    attributes[\"data-pcb-component-id\"] = pcb_component_id\n  }\n\n  return [\n    {\n      name: \"g\",\n      type: \"element\",\n      value: \"\",\n      attributes,\n      children,\n    },\n  ]\n\n  function toScreen(point: Point2D): Point2D {\n    const [x, y] = applyToPoint(transform, [point.x, point.y])\n    return { x, y }\n  }\n}\n","import type { PcbNoteDimension } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\nimport { colorMap } from \"lib/utils/colors\"\n\ninterface Point2D {\n  x: number\n  y: number\n}\n\nfunction normalize(vector: Point2D): Point2D {\n  const length = Math.hypot(vector.x, vector.y) || 1\n  return { x: vector.x / length, y: vector.y / length }\n}\n\nfunction toPath(points: Point2D[]): string {\n  return points\n    .map((point, index) =>\n      index === 0 ? `M ${point.x} ${point.y}` : `L ${point.x} ${point.y}`,\n    )\n    .join(\" \")\n}\n\nexport function createSvgObjectsFromPcbNoteDimension(\n  dimension: PcbNoteDimension,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const {\n    from,\n    to,\n    text,\n    font_size = 1,\n    color,\n    arrow_size,\n    offset_distance,\n    offset_direction,\n  } = dimension\n\n  if (!from || !to) {\n    console.error(\"Invalid pcb_note_dimension endpoints\", { from, to })\n    return []\n  }\n\n  if (!Number.isFinite(arrow_size) || arrow_size <= 0) {\n    console.error(\"Invalid pcb_note_dimension arrow_size\", arrow_size)\n    return []\n  }\n\n  const direction = normalize({ x: to.x - from.x, y: to.y - from.y })\n\n  if (Number.isNaN(direction.x) || Number.isNaN(direction.y)) {\n    return []\n  }\n\n  const perpendicular = { x: -direction.y, y: direction.x }\n\n  const hasOffsetDirection =\n    offset_direction &&\n    typeof offset_direction.x === \"number\" &&\n    typeof offset_direction.y === \"number\"\n\n  const normalizedOffsetDirection = hasOffsetDirection\n    ? normalize({ x: offset_direction.x, y: offset_direction.y })\n    : { x: 0, y: 0 }\n\n  const offsetMagnitude =\n    typeof offset_distance === \"number\" ? offset_distance : 0\n\n  const offsetVector = {\n    x: normalizedOffsetDirection.x * offsetMagnitude,\n    y: normalizedOffsetDirection.y * offsetMagnitude,\n  }\n\n  const applyOffset = (point: Point2D): Point2D => ({\n    x: point.x + offsetVector.x,\n    y: point.y + offsetVector.y,\n  })\n\n  const fromOffset = applyOffset(from)\n  const toOffset = applyOffset(to)\n\n  const arrowHalfWidth = arrow_size / 2\n\n  const fromBase = {\n    x: fromOffset.x + direction.x * arrow_size,\n    y: fromOffset.y + direction.y * arrow_size,\n  }\n\n  const toBase = {\n    x: toOffset.x - direction.x * arrow_size,\n    y: toOffset.y - direction.y * arrow_size,\n  }\n\n  const fromTriangle = [\n    toScreen(fromOffset),\n    toScreen({\n      x: fromBase.x + perpendicular.x * arrowHalfWidth,\n      y: fromBase.y + perpendicular.y * arrowHalfWidth,\n    }),\n    toScreen({\n      x: fromBase.x - perpendicular.x * arrowHalfWidth,\n      y: fromBase.y - perpendicular.y * arrowHalfWidth,\n    }),\n  ]\n\n  const toTriangle = [\n    toScreen(toOffset),\n    toScreen({\n      x: toBase.x + perpendicular.x * arrowHalfWidth,\n      y: toBase.y + perpendicular.y * arrowHalfWidth,\n    }),\n    toScreen({\n      x: toBase.x - perpendicular.x * arrowHalfWidth,\n      y: toBase.y - perpendicular.y * arrowHalfWidth,\n    }),\n  ]\n\n  const [lineStartX, lineStartY] = applyToPoint(transform, [\n    fromBase.x,\n    fromBase.y,\n  ])\n  const [lineEndX, lineEndY] = applyToPoint(transform, [toBase.x, toBase.y])\n\n  const strokeWidth = (arrow_size / 5) * Math.abs(transform.a)\n  const lineColor = color || colorMap.board.user_2\n\n  const extensionDirection =\n    hasOffsetDirection &&\n    (Math.abs(normalizedOffsetDirection.x) > Number.EPSILON ||\n      Math.abs(normalizedOffsetDirection.y) > Number.EPSILON)\n      ? normalizedOffsetDirection\n      : perpendicular\n\n  const extensionLength = offsetMagnitude + arrow_size\n\n  const createExtensionLine = (anchor: Point2D): SvgObject => {\n    const endPoint = {\n      x: anchor.x + extensionDirection.x * extensionLength,\n      y: anchor.y + extensionDirection.y * extensionLength,\n    }\n\n    const [startX, startY] = applyToPoint(transform, [anchor.x, anchor.y])\n    const [endX, endY] = applyToPoint(transform, [endPoint.x, endPoint.y])\n\n    return {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        d: `M ${startX} ${startY} L ${endX} ${endY}`,\n        stroke: lineColor,\n        fill: \"none\",\n        \"stroke-width\": strokeWidth.toString(),\n        \"stroke-linecap\": \"round\",\n        class: \"pcb-note-dimension-extension\",\n      },\n      children: [],\n    }\n  }\n\n  const extensionSegments = [createExtensionLine(from), createExtensionLine(to)]\n\n  const midPoint = {\n    x: (from.x + to.x) / 2 + offsetVector.x,\n    y: (from.y + to.y) / 2 + offsetVector.y,\n  }\n\n  const textOffset = arrow_size * 1.5\n  const textPoint = {\n    x: midPoint.x + perpendicular.x * textOffset,\n    y: midPoint.y + perpendicular.y * textOffset,\n  }\n\n  const [textX, textY] = applyToPoint(transform, [textPoint.x, textPoint.y])\n  const [screenFromX, screenFromY] = applyToPoint(transform, [\n    fromOffset.x,\n    fromOffset.y,\n  ])\n  const [screenToX, screenToY] = applyToPoint(transform, [\n    toOffset.x,\n    toOffset.y,\n  ])\n\n  const screenDirection = normalize({\n    x: screenToX - screenFromX,\n    y: screenToY - screenFromY,\n  })\n\n  let textAngle =\n    (Math.atan2(screenDirection.y, screenDirection.x) * 180) / Math.PI\n\n  if (textAngle > 90 || textAngle < -90) {\n    textAngle += 180\n  }\n\n  const transformedFontSize = font_size * Math.abs(transform.a)\n\n  const children: SvgObject[] = [\n    ...extensionSegments,\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        d: `M ${lineStartX} ${lineStartY} L ${lineEndX} ${lineEndY}`,\n        stroke: lineColor,\n        fill: \"none\",\n        \"stroke-width\": strokeWidth.toString(),\n        \"stroke-linecap\": \"round\",\n        class: \"pcb-note-dimension-line\",\n      },\n      children: [],\n    },\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        d: `${toPath(fromTriangle)} Z`,\n        fill: lineColor,\n        class: \"pcb-note-dimension-arrow\",\n      },\n      children: [],\n    },\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        d: `${toPath(toTriangle)} Z`,\n        fill: lineColor,\n        class: \"pcb-note-dimension-arrow\",\n      },\n      children: [],\n    },\n  ]\n\n  if (text) {\n    children.push({\n      name: \"text\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        x: textX.toString(),\n        y: textY.toString(),\n        fill: lineColor,\n        \"font-size\": transformedFontSize.toString(),\n        \"font-family\": \"Arial, sans-serif\",\n        \"text-anchor\": \"middle\",\n        \"dominant-baseline\": \"central\",\n        class: \"pcb-note-dimension-text\",\n        transform: `rotate(${textAngle} ${textX} ${textY})`,\n      },\n      children: [\n        {\n          type: \"text\",\n          name: \"\",\n          value: text,\n          attributes: {},\n          children: [],\n        },\n      ],\n    })\n  }\n\n  return [\n    {\n      name: \"g\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        class: \"pcb-note-dimension\",\n        \"data-type\": \"pcb_note_dimension\",\n        \"data-pcb-note-dimension-id\": dimension.pcb_note_dimension_id,\n        \"data-pcb-layer\": \"overlay\",\n      },\n      children,\n    },\n  ]\n\n  function toScreen(point: Point2D): Point2D {\n    const [x, y] = applyToPoint(transform, [point.x, point.y])\n    return { x, y }\n  }\n}\n","// Kicad-2020 color scheme\nexport const colorMap = {\n  \"3d_viewer\": {\n    background_bottom: \"rgb(102, 102, 128)\",\n    background_top: \"rgb(204, 204, 230)\",\n    board: \"rgb(51, 43, 23)\",\n    copper: \"rgb(179, 156, 0)\",\n    silkscreen_bottom: \"rgb(230, 230, 230)\",\n    silkscreen_top: \"rgb(230, 230, 230)\",\n    soldermask: \"rgb(20, 51, 36)\",\n    solderpaste: \"rgb(128, 128, 128)\",\n  },\n  board: {\n    anchor: \"rgb(255, 38, 226)\",\n    aux_items: \"rgb(255, 255, 255)\",\n    b_adhes: \"rgb(0, 0, 132)\",\n    b_crtyd: \"rgb(255, 38, 226)\",\n    b_fab: \"rgb(88, 93, 132)\",\n    b_mask: \"rgba(2, 255, 238, 0.400)\",\n    b_paste: \"rgb(0, 194, 194)\",\n    b_silks: \"rgb(232, 178, 167)\",\n    background: \"rgb(0, 16, 35)\",\n    cmts_user: \"rgb(89, 148, 220)\",\n    copper: {\n      b: \"rgb(77, 127, 196)\",\n      f: \"rgb(200, 52, 52)\",\n      in1: \"rgb(127, 200, 127)\",\n      in10: \"rgb(237, 124, 51)\",\n      in11: \"rgb(91, 195, 235)\",\n      in12: \"rgb(247, 111, 142)\",\n      in13: \"rgb(167, 165, 198)\",\n      in14: \"rgb(40, 204, 217)\",\n      in15: \"rgb(232, 178, 167)\",\n      in16: \"rgb(242, 237, 161)\",\n      in17: \"rgb(237, 124, 51)\",\n      in18: \"rgb(91, 195, 235)\",\n      in19: \"rgb(247, 111, 142)\",\n      in2: \"rgb(206, 125, 44)\",\n      in20: \"rgb(167, 165, 198)\",\n      in21: \"rgb(40, 204, 217)\",\n      in22: \"rgb(232, 178, 167)\",\n      in23: \"rgb(242, 237, 161)\",\n      in24: \"rgb(237, 124, 51)\",\n      in25: \"rgb(91, 195, 235)\",\n      in26: \"rgb(247, 111, 142)\",\n      in27: \"rgb(167, 165, 198)\",\n      in28: \"rgb(40, 204, 217)\",\n      in29: \"rgb(232, 178, 167)\",\n      in3: \"rgb(79, 203, 203)\",\n      in30: \"rgb(242, 237, 161)\",\n      in4: \"rgb(219, 98, 139)\",\n      in5: \"rgb(167, 165, 198)\",\n      in6: \"rgb(40, 204, 217)\",\n      in7: \"rgb(232, 178, 167)\",\n      in8: \"rgb(242, 237, 161)\",\n      in9: \"rgb(141, 203, 129)\",\n    },\n    cursor: \"rgb(255, 255, 255)\",\n    drc: \"rgb(194, 194, 194)\",\n    drc_error: \"rgba(215, 91, 107, 0.800)\",\n    drc_exclusion: \"rgb(255, 255, 255)\",\n    drc_warning: \"rgba(255, 208, 66, 0.902)\",\n    dwgs_user: \"rgb(194, 194, 194)\",\n    eco1_user: \"rgb(180, 219, 210)\",\n    eco2_user: \"rgb(216, 200, 82)\",\n    edge_cuts: \"rgb(208, 210, 205)\",\n    f_adhes: \"rgb(132, 0, 132)\",\n    f_crtyd: \"rgb(255, 0, 245)\",\n    f_fab: \"rgb(175, 175, 175)\",\n    f_mask: \"rgba(216, 100, 255, 0.400)\",\n    f_paste: \"rgba(180, 160, 154, 0.902)\",\n    f_silks: \"rgb(242, 237, 161)\",\n    footprint_text_back: \"rgb(0, 0, 132)\",\n    footprint_text_front: \"rgb(194, 194, 194)\",\n    footprint_text_invisible: \"rgb(132, 132, 132)\",\n    grid: \"rgb(132, 132, 132)\",\n    grid_axes: \"rgb(194, 194, 194)\",\n    margin: \"rgb(255, 38, 226)\",\n    microvia: \"rgb(0, 132, 132)\",\n    no_connect: \"rgb(0, 0, 132)\",\n    pad_back: \"rgb(77, 127, 196)\",\n    pad_front: \"rgb(200, 52, 52)\",\n    pad_plated_hole: \"rgb(194, 194, 0)\",\n    pad_through_hole: \"rgb(227, 183, 46)\",\n    plated_hole: \"rgb(26, 196, 210)\",\n    ratsnest: \"rgba(245, 255, 213, 0.702)\",\n    select_overlay: \"rgb(4, 255, 67)\",\n    through_via: \"rgb(236, 236, 236)\",\n    user_1: \"rgb(194, 194, 194)\",\n    user_2: \"rgb(89, 148, 220)\",\n    user_3: \"rgb(180, 219, 210)\",\n    user_4: \"rgb(216, 200, 82)\",\n    user_5: \"rgb(194, 194, 194)\",\n    user_6: \"rgb(89, 148, 220)\",\n    user_7: \"rgb(180, 219, 210)\",\n    user_8: \"rgb(216, 200, 82)\",\n    user_9: \"rgb(232, 178, 167)\",\n    via_blind_buried: \"rgb(187, 151, 38)\",\n    via_hole: \"rgb(227, 183, 46)\",\n    via_micro: \"rgb(0, 132, 132)\",\n    via_through: \"rgb(236, 236, 236)\",\n    worksheet: \"rgb(200, 114, 171)\",\n  },\n  gerbview: {\n    axes: \"rgb(0, 0, 132)\",\n    background: \"rgb(0, 0, 0)\",\n    dcodes: \"rgb(255, 255, 255)\",\n    grid: \"rgb(132, 132, 132)\",\n    layers: [\n      \"rgb(132, 0, 0)\",\n      \"rgb(194, 194, 0)\",\n      \"rgb(194, 0, 194)\",\n      \"rgb(194, 0, 0)\",\n      \"rgb(0, 132, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(132, 132, 132)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(132, 132, 0)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(194, 194, 0)\",\n      \"rgb(194, 0, 194)\",\n      \"rgb(194, 0, 0)\",\n      \"rgb(0, 132, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(132, 132, 132)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(132, 132, 0)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(194, 194, 0)\",\n      \"rgb(194, 0, 194)\",\n      \"rgb(194, 0, 0)\",\n      \"rgb(0, 132, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(132, 132, 132)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(132, 132, 0)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(194, 194, 0)\",\n      \"rgb(194, 0, 194)\",\n      \"rgb(194, 0, 0)\",\n      \"rgb(0, 132, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(132, 132, 132)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(132, 0, 0)\",\n    ],\n    negative_objects: \"rgb(132, 132, 132)\",\n    worksheet: \"rgb(0, 0, 132)\",\n  },\n  meta: {\n    filename: \"kicad_2020\",\n    name: \"KiCad 2020\",\n    version: 2,\n  },\n  palette: [\n    \"rgb(132, 0, 0)\",\n    \"rgb(194, 194, 0)\",\n    \"rgb(194, 0, 194)\",\n    \"rgb(194, 0, 0)\",\n    \"rgb(0, 132, 132)\",\n    \"rgb(0, 132, 0)\",\n    \"rgb(0, 0, 132)\",\n    \"rgb(132, 132, 132)\",\n    \"rgb(132, 0, 132)\",\n    \"rgb(194, 194, 194)\",\n    \"rgb(132, 0, 132)\",\n    \"rgb(132, 0, 0)\",\n    \"rgb(132, 132, 0)\",\n    \"rgb(194, 194, 194)\",\n    \"rgb(0, 0, 132)\",\n    \"rgb(0, 132, 0)\",\n  ],\n  schematic: {\n    aux_items: \"rgb(46, 46, 46)\",\n    background: \"rgb(245, 241, 237)\",\n    brightened: \"rgb(255, 0, 255)\",\n    bus: \"rgb(0, 0, 132)\",\n    bus_junction: \"rgb(0, 0, 132)\",\n    component_body: \"rgb(255, 255, 194)\",\n    component_outline: \"rgb(132, 0, 0)\",\n    cursor: \"rgb(15, 15, 15)\",\n    erc_error: \"rgba(230, 9, 13, 0.800)\",\n    erc_warning: \"rgba(209, 146, 0, 0.800)\",\n    fields: \"rgb(132, 0, 132)\",\n    grid: \"rgb(181, 181, 181)\",\n    grid_axes: \"rgb(0, 0, 132)\",\n    hidden: \"rgb(194, 194, 194)\",\n    junction: \"rgb(0, 150, 0)\",\n    label_global: \"rgb(132, 0, 0)\",\n    label_background: \"rgba(255, 255, 255, 0.6)\",\n    label_hier: \"rgb(114, 86, 0)\",\n    label_local: \"rgb(15, 15, 15)\",\n    net_name: \"rgb(132, 132, 132)\",\n    no_connect: \"rgb(0, 0, 132)\",\n    note: \"rgb(0, 0, 194)\",\n    override_item_colors: false,\n    pin: \"rgb(132, 0, 0)\",\n    pin_name: \"rgb(0, 100, 100)\",\n    pin_number: \"rgb(169, 0, 0)\",\n    reference: \"rgb(0, 100, 100)\",\n    shadow: \"rgba(102, 179, 255, 0.800)\",\n    sheet: \"rgb(132, 0, 0)\",\n    sheet_background: \"rgba(253, 255, 231, 0.000)\",\n    sheet_fields: \"rgb(132, 0, 132)\",\n    sheet_filename: \"rgb(114, 86, 0)\",\n    sheet_label: \"rgb(0, 100, 100)\",\n    sheet_name: \"rgb(0, 100, 100)\",\n    table: \"rgb(102, 102, 102)\",\n    value: \"rgb(0, 100, 100)\",\n    wire: \"rgb(0, 150, 0)\",\n    wire_crossing: \"rgb(30, 180, 30)\",\n    worksheet: \"rgb(132, 0, 0)\",\n  },\n}\n\nexport type ColorMap = typeof colorMap\n","import type { PcbNoteText } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\nimport { colorMap } from \"lib/utils/colors\"\n\nconst DEFAULT_OVERLAY_COLOR = colorMap.board.user_2\n\nexport function createSvgObjectsFromPcbNoteText(\n  note: PcbNoteText,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const {\n    anchor_position,\n    text,\n    font_size = 1,\n    anchor_alignment = \"center\",\n    color,\n  } = note\n\n  if (\n    !anchor_position ||\n    typeof anchor_position.x !== \"number\" ||\n    typeof anchor_position.y !== \"number\"\n  ) {\n    console.error(\"Invalid pcb_note_text anchor_position\", anchor_position)\n    return []\n  }\n\n  if (typeof text !== \"string\" || text.length === 0) {\n    console.error(\"Invalid pcb_note_text text\", text)\n    return []\n  }\n\n  const [x, y] = applyToPoint(transform, [anchor_position.x, anchor_position.y])\n  const transformedFontSize = font_size * Math.abs(transform.a)\n\n  let textAnchor: \"start\" | \"middle\" | \"end\" = \"middle\"\n  let dominantBaseline: \"central\" | \"text-before-edge\" | \"text-after-edge\" =\n    \"central\"\n\n  switch (anchor_alignment) {\n    case \"top_left\":\n      textAnchor = \"start\"\n      dominantBaseline = \"text-before-edge\"\n      break\n    case \"top_right\":\n      textAnchor = \"end\"\n      dominantBaseline = \"text-before-edge\"\n      break\n    case \"bottom_left\":\n      textAnchor = \"start\"\n      dominantBaseline = \"text-after-edge\"\n      break\n    case \"bottom_right\":\n      textAnchor = \"end\"\n      dominantBaseline = \"text-after-edge\"\n      break\n    case \"center\":\n    default:\n      textAnchor = \"middle\"\n      dominantBaseline = \"central\"\n      break\n  }\n\n  const svgObject: SvgObject = {\n    name: \"text\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      x: x.toString(),\n      y: y.toString(),\n      fill: color ?? DEFAULT_OVERLAY_COLOR,\n      \"font-family\": \"Arial, sans-serif\",\n      \"font-size\": transformedFontSize.toString(),\n      \"text-anchor\": textAnchor,\n      \"dominant-baseline\": dominantBaseline,\n      class: \"pcb-note-text\",\n      \"data-type\": \"pcb_note_text\",\n      \"data-pcb-note-text-id\": note.pcb_note_text_id,\n      \"data-pcb-layer\": \"overlay\",\n    },\n    children: [\n      {\n        type: \"text\",\n        name: \"\",\n        value: text,\n        attributes: {},\n        children: [],\n      },\n    ],\n  }\n\n  return [svgObject]\n}\n","import type { PcbNoteRect } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\nimport { colorMap } from \"lib/utils/colors\"\n\nconst DEFAULT_OVERLAY_COLOR = colorMap.board.user_2\nconst DEFAULT_FILL_COLOR = colorMap.board.user_2\n\nexport function createSvgObjectsFromPcbNoteRect(\n  noteRect: PcbNoteRect,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const {\n    center,\n    width,\n    height,\n    stroke_width,\n    is_filled,\n    has_stroke,\n    is_stroke_dashed,\n    color,\n    corner_radius,\n  } = noteRect\n\n  if (\n    !center ||\n    typeof center.x !== \"number\" ||\n    typeof center.y !== \"number\" ||\n    typeof width !== \"number\" ||\n    typeof height !== \"number\"\n  ) {\n    console.error(\"Invalid pcb_note_rect data\", { center, width, height })\n    return []\n  }\n\n  const halfWidth = width / 2\n  const halfHeight = height / 2\n\n  const [topLeftX, topLeftY] = applyToPoint(transform, [\n    center.x - halfWidth,\n    center.y + halfHeight,\n  ])\n  const [bottomRightX, bottomRightY] = applyToPoint(transform, [\n    center.x + halfWidth,\n    center.y - halfHeight,\n  ])\n\n  const rectX = Math.min(topLeftX, bottomRightX)\n  const rectY = Math.min(topLeftY, bottomRightY)\n  const rectWidth = Math.abs(bottomRightX - topLeftX)\n  const rectHeight = Math.abs(bottomRightY - topLeftY)\n\n  const baseStrokeWidth = typeof stroke_width === \"number\" ? stroke_width : 0\n  const transformedStrokeWidth = baseStrokeWidth * Math.abs(transform.a)\n  const baseCornerRadius =\n    typeof corner_radius === \"number\" && corner_radius > 0 ? corner_radius : 0\n  const transformedCornerRadiusX = baseCornerRadius * Math.abs(transform.a)\n  const transformedCornerRadiusY = baseCornerRadius * Math.abs(transform.d)\n\n  const overlayColor = color ?? DEFAULT_OVERLAY_COLOR\n  const attributes: Record<string, string> = {\n    x: rectX.toString(),\n    y: rectY.toString(),\n    width: rectWidth.toString(),\n    height: rectHeight.toString(),\n    class: \"pcb-note-rect\",\n    \"data-type\": \"pcb_note_rect\",\n    \"data-pcb-note-rect-id\": noteRect.pcb_note_rect_id,\n    \"data-pcb-layer\": \"overlay\",\n  }\n  if (transformedCornerRadiusX > 0) {\n    attributes.rx = transformedCornerRadiusX.toString()\n  }\n\n  if (transformedCornerRadiusY > 0) {\n    attributes.ry = transformedCornerRadiusY.toString()\n  }\n  if (is_filled) {\n    attributes.fill = color ?? DEFAULT_FILL_COLOR\n  } else {\n    attributes.fill = \"none\"\n  }\n\n  const shouldDrawStroke = has_stroke ?? transformedStrokeWidth > 0\n\n  if (shouldDrawStroke) {\n    attributes.stroke = overlayColor\n    attributes[\"stroke-width\"] = transformedStrokeWidth.toString()\n\n    if (is_stroke_dashed) {\n      const dash = 0.2 * Math.abs(transform.a)\n      const gap = 0.1 * Math.abs(transform.a)\n      attributes[\"stroke-dasharray\"] = `${dash} ${gap}`\n    }\n  } else {\n    attributes.stroke = \"none\"\n  }\n\n  const svgObject: SvgObject = {\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes,\n    children: [],\n  }\n\n  return [svgObject]\n}\n","import type { PcbNotePath } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\nimport { colorMap } from \"lib/utils/colors\"\n\nconst DEFAULT_OVERLAY_COLOR = colorMap.board.user_2\n\nexport function createSvgObjectsFromPcbNotePath(\n  notePath: PcbNotePath,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform } = ctx\n\n  if (!Array.isArray(notePath.route) || notePath.route.length === 0) {\n    console.error(\"Invalid pcb_note_path route\", notePath.route)\n    return []\n  }\n\n  for (const point of notePath.route) {\n    if (typeof point.x !== \"number\" || typeof point.y !== \"number\") {\n      console.error(\"Invalid point in pcb_note_path\", point)\n      return []\n    }\n  }\n\n  const pathD = notePath.route\n    .map((point, index) => {\n      const [x, y] = applyToPoint(transform, [point.x, point.y])\n      return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`\n    })\n    .join(\" \")\n\n  const strokeWidth = notePath.stroke_width * Math.abs(transform.a)\n\n  const svgObject: SvgObject = {\n    name: \"path\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      d: pathD,\n      stroke: notePath.color ?? DEFAULT_OVERLAY_COLOR,\n      fill: \"none\",\n      \"stroke-width\": strokeWidth.toString(),\n      class: \"pcb-note-path\",\n      \"data-type\": \"pcb_note_path\",\n      \"data-pcb-note-path-id\": notePath.pcb_note_path_id,\n      \"data-pcb-layer\": \"overlay\",\n    },\n    children: [],\n  }\n\n  return [svgObject]\n}\n","import type { PcbNoteLine } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\nimport { colorMap } from \"lib/utils/colors\"\n\nconst DEFAULT_OVERLAY_COLOR = colorMap.board.user_2\n\nexport function createSvgObjectsFromPcbNoteLine(\n  noteLine: PcbNoteLine,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const { x1, y1, x2, y2, stroke_width, color, is_dashed } = noteLine\n\n  if (\n    typeof x1 !== \"number\" ||\n    typeof y1 !== \"number\" ||\n    typeof x2 !== \"number\" ||\n    typeof y2 !== \"number\"\n  ) {\n    console.error(\"Invalid pcb_note_line coordinates\", {\n      x1,\n      y1,\n      x2,\n      y2,\n    })\n    return []\n  }\n\n  const [startX, startY] = applyToPoint(transform, [x1, y1])\n  const [endX, endY] = applyToPoint(transform, [x2, y2])\n  const baseStrokeWidth = typeof stroke_width === \"number\" ? stroke_width : 0\n  const transformedStrokeWidth = baseStrokeWidth * Math.abs(transform.a)\n\n  const attributes: Record<string, string> = {\n    x1: startX.toString(),\n    y1: startY.toString(),\n    x2: endX.toString(),\n    y2: endY.toString(),\n    stroke: color ?? DEFAULT_OVERLAY_COLOR,\n    \"stroke-width\": transformedStrokeWidth.toString(),\n    \"stroke-linecap\": \"round\",\n    class: \"pcb-note-line\",\n    \"data-type\": \"pcb_note_line\",\n    \"data-pcb-note-line-id\": noteLine.pcb_note_line_id,\n    \"data-pcb-layer\": \"overlay\",\n  }\n\n  if (is_dashed) {\n    const dash = 0.2 * Math.abs(transform.a)\n    const gap = 0.1 * Math.abs(transform.a)\n    attributes[\"stroke-dasharray\"] = `${dash} ${gap}`\n  }\n\n  const svgObject: SvgObject = {\n    name: \"line\",\n    type: \"element\",\n    value: \"\",\n    attributes,\n    children: [],\n  }\n\n  return [svgObject]\n}\n","import type {\n  PcbPlatedHole,\n  PcbHoleCircularWithRectPad,\n  PcbHolePillWithRectPad,\n  PcbHoleRotatedPillWithRectPad,\n} from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\ntype HoleWithRectPadOffsets = {\n  hole_offset_x?: number\n  hole_offset_y?: number\n}\n\nexport function createSvgObjectsFromPcbPlatedHole(\n  hole: PcbPlatedHole,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, colorMap, showSolderMask } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n  const copperLayer =\n    (Array.isArray((hole as any).layers) && (hole as any).layers[0]) ||\n    (hole as any).layer ||\n    \"top\"\n\n  // Positive margin: mask extends beyond hole (less hole exposed)\n  // Negative margin: mask is smaller than hole (spacing around edges)\n  const soldermaskMargin =\n    ((hole as any).soldermask_margin ?? 0) * Math.abs(transform.a)\n\n  // Show soldermask if it's enabled and there's a margin defined\n  const shouldShowSolderMask = showSolderMask && soldermaskMargin !== 0\n\n  const solderMaskColor = colorMap.soldermask.top\n\n  if (hole.shape === \"pill\") {\n    const scaledOuterWidth = hole.outer_width * Math.abs(transform.a)\n    const scaledOuterHeight = hole.outer_height * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a)\n\n    const rotation = hole.ccw_rotation || 0\n\n    const outerTransform = rotation\n      ? `translate(${x} ${y}) rotate(${-rotation})`\n      : `translate(${x} ${y})`\n    const innerTransform = rotation\n      ? `translate(${x} ${y}) rotate(${-rotation})`\n      : `translate(${x} ${y})`\n\n    // Helper function to create pill path\n    const createPillPath = (width: number, height: number) => {\n      if (width > height) {\n        // Horizontal pill (width > height)\n        const radius = height / 2\n        const straightLength = width - 2 * radius\n        return (\n          `M${-width / 2 + radius},${-radius} ` + // Start at top-left of straight section\n          `h${straightLength} ` + // Line right along top\n          `a${radius},${radius} 0 0 1 0,${height} ` + // Arc 180 around right end\n          `h${-straightLength} ` + // Line left along bottom\n          `a${radius},${radius} 0 0 1 0,${-height} ` + // Arc 180 around left end\n          `z`\n        )\n      } else if (height > width) {\n        // Vertical pill (height > width)\n        const radius = width / 2\n        const straightLength = height - 2 * radius\n        return (\n          `M${radius},${-height / 2 + radius} ` + // Start at top-right of straight section\n          `v${straightLength} ` + // Line down along right side\n          `a${radius},${radius} 0 0 1 ${-width},0 ` + // Arc 180 around bottom end\n          `v${-straightLength} ` + // Line up along left side\n          `a${radius},${radius} 0 0 1 ${width},0 ` + // Arc 180 around top end\n          `z`\n        )\n      } else {\n        // Circle (width === height)\n        const radius = width / 2\n        return (\n          `M${-radius},0 ` +\n          `a${radius},${radius} 0 0 1 ${width},0 ` + // Arc from left to right (top half)\n          `a${radius},${radius} 0 0 1 ${-width},0 ` + // Arc from right to left (bottom half)\n          `z`\n        )\n      }\n    }\n\n    const children: SvgObject[] = [\n      // Outer pill shape\n      {\n        name: \"path\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-outer\",\n          fill: colorMap.copper.top,\n          d: createPillPath(scaledOuterWidth, scaledOuterHeight),\n          transform: outerTransform,\n          \"data-type\": \"pcb_plated_hole\",\n          \"data-pcb-layer\": copperLayer,\n        },\n        value: \"\",\n        children: [],\n      },\n      // Inner pill shape\n      {\n        name: \"path\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-inner\",\n          fill: colorMap.drill,\n          d: createPillPath(scaledHoleWidth, scaledHoleHeight),\n          transform: innerTransform,\n          \"data-type\": \"pcb_plated_hole_drill\",\n          \"data-pcb-layer\": \"drill\",\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n\n    // Add soldermask if needed\n    if (shouldShowSolderMask) {\n      const maskWidth = scaledOuterWidth + 2 * soldermaskMargin\n      const maskHeight = scaledOuterHeight + 2 * soldermaskMargin\n      children.push({\n        name: \"path\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-solder-mask\",\n          fill: solderMaskColor,\n          d: createPillPath(maskWidth, maskHeight),\n          transform: outerTransform,\n          \"data-type\": \"pcb_soldermask\",\n        },\n        value: \"\",\n        children: [],\n      })\n    }\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        attributes: {\n          \"data-type\": \"pcb_plated_hole\",\n          \"data-pcb-layer\": \"through\",\n        },\n        children,\n        value: \"\",\n      },\n    ]\n  }\n\n  // Fallback to circular hole if not pill-shaped\n  if (hole.shape === \"circle\") {\n    const scaledOuterWidth = hole.outer_diameter * Math.abs(transform.a)\n    const scaledOuterHeight = hole.outer_diameter * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_diameter * Math.abs(transform.a)\n    const scaledHoleHeight = hole.hole_diameter * Math.abs(transform.a)\n\n    const outerRadius = Math.min(scaledOuterWidth, scaledOuterHeight) / 2\n    const innerRadius = Math.min(scaledHoleWidth, scaledHoleHeight) / 2\n\n    const children: SvgObject[] = [\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-outer\",\n          fill: colorMap.copper.top,\n          cx: x.toString(),\n          cy: y.toString(),\n          r: outerRadius.toString(),\n          \"data-type\": \"pcb_plated_hole\",\n          \"data-pcb-layer\": copperLayer,\n        },\n        value: \"\",\n        children: [],\n      },\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-inner\",\n          fill: colorMap.drill,\n\n          cx: x.toString(),\n          cy: y.toString(),\n          r: innerRadius.toString(),\n          \"data-type\": \"pcb_plated_hole_drill\",\n          \"data-pcb-layer\": \"drill\",\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n\n    // Add soldermask if needed\n    if (shouldShowSolderMask) {\n      const maskRadius = outerRadius + soldermaskMargin\n      children.push({\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-solder-mask\",\n          fill: solderMaskColor,\n          cx: x.toString(),\n          cy: y.toString(),\n          r: maskRadius.toString(),\n          \"data-type\": \"pcb_soldermask\",\n        },\n        value: \"\",\n        children: [],\n      })\n    }\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        attributes: {\n          \"data-type\": \"pcb_plated_hole\",\n          \"data-pcb-layer\": \"through\",\n        },\n        children,\n        value: \"\",\n      },\n    ]\n  }\n\n  // Handle circular hole with rectangular pad (hole is circle, outer pad is rectangle)\n  if (hole.shape === \"circular_hole_with_rect_pad\") {\n    const h = hole as PcbHoleCircularWithRectPad\n    const scaledHoleDiameter = hole.hole_diameter * Math.abs(transform.a)\n    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a)\n    const scaledRectBorderRadius =\n      ((hole as any).rect_border_radius ?? 0) * Math.abs(transform.a)\n\n    const holeRadius = scaledHoleDiameter / 2\n    const [holeCx, holeCy] = applyToPoint(transform, [\n      h.x + (h.hole_offset_x ?? 0),\n      h.y + (h.hole_offset_y ?? 0),\n    ])\n\n    const children: SvgObject[] = [\n      // Rectangular pad (outer shape)\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-outer-pad\",\n          fill: colorMap.copper.top,\n          x: (x - scaledRectPadWidth / 2).toString(),\n          y: (y - scaledRectPadHeight / 2).toString(),\n          width: scaledRectPadWidth.toString(),\n          height: scaledRectPadHeight.toString(),\n          ...(scaledRectBorderRadius\n            ? {\n                rx: scaledRectBorderRadius.toString(),\n                ry: scaledRectBorderRadius.toString(),\n              }\n            : {}),\n          \"data-type\": \"pcb_plated_hole\",\n          \"data-pcb-layer\": copperLayer,\n        },\n        value: \"\",\n        children: [],\n      },\n      // Circular hole inside the rectangle (with optional offset)\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-inner\",\n          fill: colorMap.drill,\n          cx: holeCx.toString(),\n          cy: holeCy.toString(),\n          r: holeRadius.toString(),\n          \"data-type\": \"pcb_plated_hole_drill\",\n          \"data-pcb-layer\": \"drill\",\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n\n    // Add soldermask if needed\n    if (shouldShowSolderMask) {\n      const maskWidth = scaledRectPadWidth + 2 * soldermaskMargin\n      const maskHeight = scaledRectPadHeight + 2 * soldermaskMargin\n      const maskBorderRadius = scaledRectBorderRadius + soldermaskMargin\n      children.push({\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-solder-mask\",\n          fill: solderMaskColor,\n          x: (x - maskWidth / 2).toString(),\n          y: (y - maskHeight / 2).toString(),\n          width: maskWidth.toString(),\n          height: maskHeight.toString(),\n          ...(scaledRectBorderRadius\n            ? {\n                rx: maskBorderRadius.toString(),\n                ry: maskBorderRadius.toString(),\n              }\n            : {}),\n          \"data-type\": \"pcb_soldermask\",\n        },\n        value: \"\",\n        children: [],\n      })\n    }\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        attributes: {\n          \"data-type\": \"pcb_plated_hole\",\n          \"data-pcb-layer\": \"through\",\n        },\n        children,\n        value: \"\",\n      },\n    ]\n  }\n  if (hole.shape === \"pill_hole_with_rect_pad\") {\n    const pillHole = hole as PcbHolePillWithRectPad\n    const scaledRectPadWidth = pillHole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight = pillHole.rect_pad_height * Math.abs(transform.a)\n    const scaledRectBorderRadius =\n      (pillHole.rect_border_radius ?? 0) * Math.abs(transform.a)\n\n    const scaledHoleHeight = pillHole.hole_height * Math.abs(transform.a)\n    const scaledHoleWidth = pillHole.hole_width * Math.abs(transform.a)\n\n    const pillHoleWithOffsets = pillHole as PcbHolePillWithRectPad &\n      HoleWithRectPadOffsets\n    const holeOffsetX = pillHoleWithOffsets.hole_offset_x ?? 0\n    const holeOffsetY = pillHoleWithOffsets.hole_offset_y ?? 0\n    const [holeCenterX, holeCenterY] = applyToPoint(transform, [\n      pillHole.x + holeOffsetX,\n      pillHole.y + holeOffsetY,\n    ])\n\n    // Use the minimum of scaledHoleHeight and scaledHoleWidth for the radius\n    const holeRadius = Math.min(scaledHoleHeight, scaledHoleWidth) / 2\n\n    const children: SvgObject[] = [\n      // Rectangular pad (outer shape)\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-outer-pad\",\n          fill: colorMap.copper.top,\n          x: (x - scaledRectPadWidth / 2).toString(),\n          y: (y - scaledRectPadHeight / 2).toString(),\n          width: scaledRectPadWidth.toString(),\n          height: scaledRectPadHeight.toString(),\n          ...(scaledRectBorderRadius\n            ? {\n                rx: scaledRectBorderRadius.toString(),\n                ry: scaledRectBorderRadius.toString(),\n              }\n            : {}),\n          \"data-type\": \"pcb_plated_hole\",\n          \"data-pcb-layer\": copperLayer,\n        },\n        value: \"\",\n        children: [],\n      },\n      // pill hole inside the rectangle\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-inner\",\n          fill: colorMap.drill,\n          x: (holeCenterX - scaledHoleWidth / 2).toString(),\n          y: (holeCenterY - scaledHoleHeight / 2).toString(),\n          width: scaledHoleWidth.toString(),\n          height: scaledHoleHeight.toString(),\n          rx: holeRadius.toString(),\n          ry: holeRadius.toString(),\n          \"data-type\": \"pcb_plated_hole_drill\",\n          \"data-pcb-layer\": \"drill\",\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n\n    // Add soldermask if needed\n    if (shouldShowSolderMask) {\n      const maskWidth = scaledRectPadWidth + 2 * soldermaskMargin\n      const maskHeight = scaledRectPadHeight + 2 * soldermaskMargin\n      const maskBorderRadius = scaledRectBorderRadius + soldermaskMargin\n      children.push({\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-solder-mask\",\n          fill: solderMaskColor,\n          x: (x - maskWidth / 2).toString(),\n          y: (y - maskHeight / 2).toString(),\n          width: maskWidth.toString(),\n          height: maskHeight.toString(),\n          ...(scaledRectBorderRadius\n            ? {\n                rx: maskBorderRadius.toString(),\n                ry: maskBorderRadius.toString(),\n              }\n            : {}),\n          \"data-type\": \"pcb_soldermask\",\n        },\n        value: \"\",\n        children: [],\n      })\n    }\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        attributes: {\n          \"data-type\": \"pcb_plated_hole\",\n          \"data-pcb-layer\": \"through\",\n        },\n        children,\n        value: \"\",\n      },\n    ]\n  }\n\n  if (hole.shape === \"rotated_pill_hole_with_rect_pad\") {\n    const rotatedHole = hole as PcbHoleRotatedPillWithRectPad\n    const scaledRectPadWidth =\n      rotatedHole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight =\n      rotatedHole.rect_pad_height * Math.abs(transform.a)\n    const scaledRectBorderRadius =\n      (rotatedHole.rect_border_radius ?? 0) * Math.abs(transform.a)\n\n    const scaledHoleHeight = rotatedHole.hole_height * Math.abs(transform.a)\n    const scaledHoleWidth = rotatedHole.hole_width * Math.abs(transform.a)\n\n    const rotatedHoleWithOffsets =\n      rotatedHole as PcbHoleRotatedPillWithRectPad & HoleWithRectPadOffsets\n    const holeOffsetX = rotatedHoleWithOffsets.hole_offset_x ?? 0\n    const holeOffsetY = rotatedHoleWithOffsets.hole_offset_y ?? 0\n    const [holeCenterX, holeCenterY] = applyToPoint(transform, [\n      rotatedHole.x + holeOffsetX,\n      rotatedHole.y + holeOffsetY,\n    ])\n\n    const holeRadius = Math.min(scaledHoleHeight, scaledHoleWidth) / 2\n\n    const children: SvgObject[] = [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-outer-pad\",\n          fill: colorMap.copper.top,\n          x: (-scaledRectPadWidth / 2).toString(),\n          y: (-scaledRectPadHeight / 2).toString(),\n          width: scaledRectPadWidth.toString(),\n          height: scaledRectPadHeight.toString(),\n          transform: `translate(${x} ${y}) rotate(${-rotatedHole.rect_ccw_rotation})`,\n          ...(scaledRectBorderRadius\n            ? {\n                rx: scaledRectBorderRadius.toString(),\n                ry: scaledRectBorderRadius.toString(),\n              }\n            : {}),\n          \"data-type\": \"pcb_plated_hole\",\n          \"data-pcb-layer\": copperLayer,\n        },\n        value: \"\",\n        children: [],\n      },\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-inner\",\n          fill: colorMap.drill,\n          x: (-scaledHoleWidth / 2).toString(),\n          y: (-scaledHoleHeight / 2).toString(),\n          width: scaledHoleWidth.toString(),\n          height: scaledHoleHeight.toString(),\n          rx: holeRadius.toString(),\n          ry: holeRadius.toString(),\n          transform: `translate(${holeCenterX} ${holeCenterY}) rotate(${-rotatedHole.hole_ccw_rotation})`,\n          \"data-type\": \"pcb_plated_hole_drill\",\n          \"data-pcb-layer\": \"drill\",\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n\n    // Add soldermask if needed\n    if (shouldShowSolderMask) {\n      const maskWidth = scaledRectPadWidth + 2 * soldermaskMargin\n      const maskHeight = scaledRectPadHeight + 2 * soldermaskMargin\n      const maskBorderRadius = scaledRectBorderRadius + soldermaskMargin\n      children.push({\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-solder-mask\",\n          fill: solderMaskColor,\n          x: (-maskWidth / 2).toString(),\n          y: (-maskHeight / 2).toString(),\n          width: maskWidth.toString(),\n          height: maskHeight.toString(),\n          transform: `translate(${x} ${y}) rotate(${-rotatedHole.rect_ccw_rotation})`,\n          ...(scaledRectBorderRadius\n            ? {\n                rx: maskBorderRadius.toString(),\n                ry: maskBorderRadius.toString(),\n              }\n            : {}),\n          \"data-type\": \"pcb_soldermask\",\n        },\n        value: \"\",\n        children: [],\n      })\n    }\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        attributes: {\n          \"data-type\": \"pcb_plated_hole\",\n          \"data-pcb-layer\": \"through\",\n        },\n        children,\n        value: \"\",\n      },\n    ]\n  }\n\n  if (hole.shape === \"hole_with_polygon_pad\") {\n    const polygonHole = hole\n    const padOutline = polygonHole.pad_outline || []\n    const holeX = polygonHole.x ?? 0\n    const holeY = polygonHole.y ?? 0\n\n    // Transform polygon pad outline points\n    const padPoints = padOutline.map((point: { x: number; y: number }) =>\n      applyToPoint(transform, [holeX + point.x, holeY + point.y]),\n    )\n    const padPointsString = padPoints\n      .map((p: number[]) => p.join(\",\"))\n      .join(\" \")\n\n    // Calculate hole position with offset\n    const [holeCenterX, holeCenterY] = applyToPoint(transform, [\n      holeX + polygonHole.hole_offset_x,\n      holeY + polygonHole.hole_offset_y,\n    ])\n\n    // Helper function to create hole SVG object based on hole_shape\n    const createHoleSvgObject = (): SvgObject => {\n      if (polygonHole.hole_shape === \"circle\") {\n        const scaledDiameter =\n          (polygonHole.hole_diameter ?? 0) * Math.abs(transform.a)\n        const radius = scaledDiameter / 2\n        return {\n          name: \"circle\",\n          type: \"element\",\n          attributes: {\n            class: \"pcb-hole-inner\",\n            fill: colorMap.drill,\n            cx: holeCenterX.toString(),\n            cy: holeCenterY.toString(),\n            r: radius.toString(),\n            \"data-type\": \"pcb_plated_hole_drill\",\n            \"data-pcb-layer\": \"drill\",\n          },\n          value: \"\",\n          children: [],\n        }\n      }\n\n      if (polygonHole.hole_shape === \"oval\") {\n        const scaledWidth =\n          (polygonHole.hole_width ?? 0) * Math.abs(transform.a)\n        const scaledHeight =\n          (polygonHole.hole_height ?? 0) * Math.abs(transform.a)\n        const rx = scaledWidth / 2\n        const ry = scaledHeight / 2\n        return {\n          name: \"ellipse\",\n          type: \"element\",\n          attributes: {\n            class: \"pcb-hole-inner\",\n            fill: colorMap.drill,\n            cx: holeCenterX.toString(),\n            cy: holeCenterY.toString(),\n            rx: rx.toString(),\n            ry: ry.toString(),\n            \"data-type\": \"pcb_plated_hole_drill\",\n            \"data-pcb-layer\": \"drill\",\n          },\n          value: \"\",\n          children: [],\n        }\n      }\n\n      if (\n        polygonHole.hole_shape === \"pill\" ||\n        polygonHole.hole_shape === \"rotated_pill\"\n      ) {\n        const scaledWidth =\n          (polygonHole.hole_width ?? 0) * Math.abs(transform.a)\n        const scaledHeight =\n          (polygonHole.hole_height ?? 0) * Math.abs(transform.a)\n\n        // Create pill path (same logic as regular pill holes)\n        const isHorizontal = scaledWidth > scaledHeight\n        const radius = Math.min(scaledWidth, scaledHeight) / 2\n        const straightLength = Math.abs(\n          isHorizontal\n            ? scaledWidth - scaledHeight\n            : scaledHeight - scaledWidth,\n        )\n\n        const pathD = isHorizontal\n          ? `M${-straightLength / 2},${-radius} ` +\n            `h${straightLength} ` +\n            `a${radius},${radius} 0 0 1 0,${scaledHeight} ` +\n            `h-${straightLength} ` +\n            `a${radius},${radius} 0 0 1 0,-${scaledHeight} z`\n          : `M${-radius},${-straightLength / 2} ` +\n            `v${straightLength} ` +\n            `a${radius},${radius} 0 0 0 ${scaledWidth},0 ` +\n            `v-${straightLength} ` +\n            `a${radius},${radius} 0 0 0 -${scaledWidth},0 z`\n\n        return {\n          name: \"path\",\n          type: \"element\",\n          attributes: {\n            class: \"pcb-hole-inner\",\n            fill: colorMap.drill,\n            d: pathD,\n            transform: `translate(${holeCenterX} ${holeCenterY})`,\n            \"data-type\": \"pcb_plated_hole_drill\",\n            \"data-pcb-layer\": \"drill\",\n          },\n          value: \"\",\n          children: [],\n        }\n      }\n\n      // Fallback: return empty object (should not happen)\n      return {\n        name: \"g\",\n        type: \"element\",\n        attributes: {},\n        value: \"\",\n        children: [],\n      }\n    }\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        attributes: {\n          \"data-type\": \"pcb_plated_hole\",\n          \"data-pcb-layer\": \"through\",\n        },\n        children: [\n          // Polygon pad (outer shape)\n          {\n            name: \"polygon\",\n            type: \"element\",\n            attributes: {\n              class: \"pcb-hole-outer-pad\",\n              fill: colorMap.copper.top,\n              points: padPointsString,\n              \"data-type\": \"pcb_plated_hole\",\n              \"data-pcb-layer\": copperLayer,\n            },\n            value: \"\",\n            children: [],\n          },\n          // Hole inside the polygon (with offset)\n          createHoleSvgObject(),\n        ],\n        value: \"\",\n      },\n    ]\n  }\n\n  return []\n}\n","import type { PcbSilkscreenPath } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\n\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbSilkscreenPath(\n  silkscreenPath: PcbSilkscreenPath,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  if (!silkscreenPath.route || !Array.isArray(silkscreenPath.route)) return []\n\n  let path = silkscreenPath.route\n    .map((point: any, index: number) => {\n      const [x, y] = applyToPoint(transform, [point.x, point.y])\n      return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`\n    })\n    .join(\" \")\n\n  // Close the path if the first and last points match\n  const firstPoint = silkscreenPath.route[0]\n  const lastPoint = silkscreenPath.route[silkscreenPath.route.length - 1]\n  if (\n    firstPoint &&\n    lastPoint &&\n    firstPoint.x === lastPoint.x &&\n    firstPoint.y === lastPoint.y\n  ) {\n    path += \" Z\"\n  }\n\n  const layer = silkscreenPath.layer || \"top\"\n  if (layerFilter && layer !== layerFilter) return []\n  const color =\n    layer === \"bottom\" ? colorMap.silkscreen.bottom : colorMap.silkscreen.top\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        class: `pcb-silkscreen pcb-silkscreen-${layer}`,\n        d: path,\n        fill: \"none\",\n        stroke: color,\n        \"stroke-width\": (\n          silkscreenPath.stroke_width * Math.abs(transform.a)\n        ).toString(),\n        \"stroke-linecap\": \"round\",\n        \"stroke-linejoin\": \"round\",\n        \"data-pcb-component-id\": silkscreenPath.pcb_component_id,\n        \"data-pcb-silkscreen-path-id\": silkscreenPath.pcb_silkscreen_path_id,\n        \"data-type\": \"pcb_silkscreen_path\",\n        \"data-pcb-layer\": layer,\n      },\n      value: \"\",\n      children: [],\n    },\n  ]\n}\n","import type { PcbSilkscreenText } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport {\n  applyToPoint,\n  compose,\n  rotate,\n  translate,\n  scale,\n  toString as matrixToString,\n} from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbSilkscreenText(\n  pcbSilkscreenText: PcbSilkscreenText,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap, circuitJson } = ctx\n  const {\n    anchor_position,\n    text,\n    font_size = 1,\n    layer = \"top\",\n    ccw_rotation = 0,\n    anchor_alignment = \"center\",\n  } = pcbSilkscreenText\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    !anchor_position ||\n    typeof anchor_position.x !== \"number\" ||\n    typeof anchor_position.y !== \"number\"\n  ) {\n    console.error(\"Invalid anchor_position:\", anchor_position)\n    return []\n  }\n\n  const [transformedX, transformedY] = applyToPoint(transform, [\n    anchor_position.x,\n    anchor_position.y,\n  ])\n\n  const transformedFontSize = font_size * Math.abs(transform.a)\n\n  // Set text-anchor and dominant-baseline based on alignment\n  let textAnchor = \"middle\"\n  let dominantBaseline = \"central\"\n  const dx = 0\n  const dy = 0\n\n  switch (anchor_alignment) {\n    case \"top_left\":\n      textAnchor = \"start\"\n      dominantBaseline = \"text-before-edge\"\n      break\n    case \"top_center\":\n      textAnchor = \"middle\"\n      dominantBaseline = \"text-before-edge\"\n      break\n    case \"top_right\":\n      textAnchor = \"end\"\n      dominantBaseline = \"text-before-edge\"\n      break\n    case \"center_left\":\n      textAnchor = \"start\"\n      dominantBaseline = \"central\"\n      break\n    case \"center_right\":\n      textAnchor = \"end\"\n      dominantBaseline = \"central\"\n      break\n    case \"bottom_left\":\n      textAnchor = \"start\"\n      dominantBaseline = \"text-after-edge\"\n      break\n    case \"bottom_center\":\n      textAnchor = \"middle\"\n      dominantBaseline = \"text-after-edge\"\n      break\n    case \"bottom_right\":\n      textAnchor = \"end\"\n      dominantBaseline = \"text-after-edge\"\n      break\n    case \"center\":\n    default:\n      textAnchor = \"middle\"\n      dominantBaseline = \"central\"\n      break\n  }\n\n  const textTransform = compose(\n    translate(transformedX, transformedY),\n    rotate((-ccw_rotation * Math.PI) / 180), // Negate to make counter-clockwise\n    ...(layer === \"bottom\" ? [scale(-1, 1)] : []),\n  )\n\n  const color =\n    layer === \"bottom\" ? colorMap.silkscreen.bottom : colorMap.silkscreen.top\n\n  const lines = text.split(\"\\n\")\n\n  const children: SvgObject[] =\n    lines.length === 1\n      ? [\n          {\n            type: \"text\",\n            value: text,\n            name: \"\",\n            attributes: {},\n            children: [],\n          },\n        ]\n      : lines.map((line, idx) => ({\n          type: \"element\",\n          name: \"tspan\",\n          value: \"\",\n          attributes: {\n            x: \"0\",\n            ...(idx > 0 ? { dy: transformedFontSize.toString() } : {}),\n          },\n          children: [\n            {\n              type: \"text\",\n              value: line,\n              name: \"\",\n              attributes: {},\n              children: [],\n            },\n          ],\n        }))\n\n  const svgObject: SvgObject = {\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      x: \"0\",\n      y: \"0\",\n      dx: dx.toString(),\n      dy: dy.toString(),\n      fill: color,\n      \"font-family\": \"Arial, sans-serif\",\n      \"font-size\": transformedFontSize.toString(),\n      \"text-anchor\": textAnchor,\n      \"dominant-baseline\": dominantBaseline,\n      transform: matrixToString(textTransform),\n      class: `pcb-silkscreen-text pcb-silkscreen-${layer}`,\n      \"data-pcb-silkscreen-text-id\": pcbSilkscreenText.pcb_component_id,\n      stroke: \"none\",\n      \"data-type\": \"pcb_silkscreen_text\",\n      \"data-pcb-layer\": layer,\n    },\n    children,\n    value: \"\",\n  }\n\n  return [svgObject]\n}\n","import type { PcbSilkscreenRect } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, toString as matrixToString } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbSilkscreenRect(\n  pcbSilkscreenRect: PcbSilkscreenRect,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  const {\n    center,\n    width,\n    height,\n    layer = \"top\",\n    pcb_silkscreen_rect_id,\n    stroke_width,\n    is_filled,\n    has_stroke,\n    is_stroke_dashed,\n    corner_radius,\n  } = pcbSilkscreenRect\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    !center ||\n    typeof center.x !== \"number\" ||\n    typeof center.y !== \"number\" ||\n    typeof width !== \"number\" ||\n    typeof height !== \"number\"\n  ) {\n    console.error(\"Invalid rectangle data:\", { center, width, height })\n    return []\n  }\n\n  const [transformedX, transformedY] = applyToPoint(transform, [\n    center.x,\n    center.y,\n  ])\n  const baseCornerRadius =\n    typeof corner_radius === \"number\" && corner_radius > 0 ? corner_radius : 0\n  const transformedCornerRadiusX = baseCornerRadius * Math.abs(transform.a)\n  const transformedCornerRadiusY = baseCornerRadius * Math.abs(transform.d)\n\n  const transformedWidth = width * Math.abs(transform.a)\n  const transformedHeight = height * Math.abs(transform.d)\n\n  const transformedStrokeWidth = stroke_width * Math.abs(transform.a)\n\n  const color =\n    layer === \"bottom\" ? colorMap.silkscreen.bottom : colorMap.silkscreen.top\n\n  const attributes: { [key: string]: string } = {\n    x: (transformedX - transformedWidth / 2).toString(),\n    y: (transformedY - transformedHeight / 2).toString(),\n    width: transformedWidth.toString(),\n    height: transformedHeight.toString(),\n    class: `pcb-silkscreen-rect pcb-silkscreen-${layer}`,\n    \"data-pcb-silkscreen-rect-id\": pcb_silkscreen_rect_id,\n    \"data-type\": \"pcb_silkscreen_rect\",\n    \"data-pcb-layer\": layer,\n  }\n  if (transformedCornerRadiusX > 0) {\n    attributes.rx = transformedCornerRadiusX.toString()\n  }\n\n  if (transformedCornerRadiusY > 0) {\n    attributes.ry = transformedCornerRadiusY.toString()\n  }\n\n  attributes.fill = is_filled ? color : \"none\"\n\n  let actualHasStroke: boolean\n  if (has_stroke === undefined) {\n    actualHasStroke = transformedStrokeWidth > 0\n  } else {\n    actualHasStroke = has_stroke\n  }\n\n  if (actualHasStroke) {\n    attributes.stroke = color\n    attributes[\"stroke-width\"] = transformedStrokeWidth.toString()\n    if (is_stroke_dashed) {\n      const dashLength = 0.1 * Math.abs(transform.a) // 0.1mm dash\n      const gapLength = 0.05 * Math.abs(transform.a) // 0.05mm gap\n      attributes[\"stroke-dasharray\"] = `${dashLength} ${gapLength}`\n    }\n  } else {\n    attributes.stroke = \"none\"\n  }\n\n  const svgObject: SvgObject = {\n    name: \"rect\",\n    type: \"element\",\n    attributes,\n    value: \"\",\n    children: [],\n  }\n\n  return [svgObject]\n}\n","import type { PcbSilkscreenCircle } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, toString as matrixToString } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbSilkscreenCircle(\n  pcbSilkscreenCircle: PcbSilkscreenCircle,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  const {\n    center,\n    radius,\n    layer = \"top\",\n    pcb_silkscreen_circle_id,\n    stroke_width = 1,\n  } = pcbSilkscreenCircle\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    !center ||\n    typeof center.x !== \"number\" ||\n    typeof center.y !== \"number\" ||\n    typeof radius !== \"number\"\n  ) {\n    console.error(\"Invalid PCB Silkscreen Circle data:\", { center, radius })\n    return []\n  }\n\n  const [transformedX, transformedY] = applyToPoint(transform, [\n    center.x,\n    center.y,\n  ])\n\n  const transformedRadius = radius * Math.abs(transform.a)\n\n  const transformedStrokeWidth = stroke_width * Math.abs(transform.a)\n\n  const color =\n    layer === \"bottom\" ? colorMap.silkscreen.bottom : colorMap.silkscreen.top\n\n  const svgObject: SvgObject = {\n    name: \"circle\",\n    type: \"element\",\n    attributes: {\n      cx: transformedX.toString(),\n      cy: transformedY.toString(),\n      r: transformedRadius.toString(),\n      class: `pcb-silkscreen-circle pcb-silkscreen-${layer}`,\n      stroke: color,\n      \"stroke-width\": transformedStrokeWidth.toString(),\n      \"data-pcb-silkscreen-circle-id\": pcb_silkscreen_circle_id,\n      \"data-type\": \"pcb_silkscreen_circle\",\n      \"data-pcb-layer\": layer,\n    },\n    value: \"\",\n    children: [],\n  }\n\n  return [svgObject]\n}\n","import type { PcbSilkscreenLine } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, toString as matrixToString } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbSilkscreenLine(\n  pcbSilkscreenLine: PcbSilkscreenLine,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  const {\n    x1,\n    y1,\n    x2,\n    y2,\n    stroke_width,\n    layer = \"top\",\n    pcb_silkscreen_line_id,\n  } = pcbSilkscreenLine\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    typeof x1 !== \"number\" ||\n    typeof y1 !== \"number\" ||\n    typeof x2 !== \"number\" ||\n    typeof y2 !== \"number\"\n  ) {\n    console.error(\"Invalid coordinates:\", { x1, y1, x2, y2 })\n    return []\n  }\n\n  const [transformedX1, transformedY1] = applyToPoint(transform, [x1, y1])\n  const [transformedX2, transformedY2] = applyToPoint(transform, [x2, y2])\n\n  const transformedStrokeWidth = stroke_width * Math.abs(transform.a)\n\n  const color =\n    layer === \"bottom\" ? colorMap.silkscreen.bottom : colorMap.silkscreen.top\n\n  return [\n    {\n      name: \"line\",\n      type: \"element\",\n      attributes: {\n        x1: transformedX1.toString(),\n        y1: transformedY1.toString(),\n        x2: transformedX2.toString(),\n        y2: transformedY2.toString(),\n        stroke: color,\n        \"stroke-width\": transformedStrokeWidth.toString(),\n        class: `pcb-silkscreen-line pcb-silkscreen-${layer}`,\n        \"data-pcb-silkscreen-line-id\": pcb_silkscreen_line_id,\n        \"data-type\": \"pcb_silkscreen_line\",\n        \"data-pcb-layer\": layer,\n      },\n      value: \"\",\n      children: [],\n    },\n  ]\n}\n","import type { PcbCourtyardRect } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbCourtyardRect(\n  pcbCourtyardRect: PcbCourtyardRect,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  const {\n    center,\n    width,\n    height,\n    layer = \"top\",\n    pcb_courtyard_rect_id,\n  } = pcbCourtyardRect\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    !center ||\n    typeof center.x !== \"number\" ||\n    typeof center.y !== \"number\" ||\n    typeof width !== \"number\" ||\n    typeof height !== \"number\"\n  ) {\n    console.error(\"Invalid courtyard rectangle data:\", {\n      center,\n      width,\n      height,\n    })\n    return []\n  }\n\n  const [transformedX, transformedY] = applyToPoint(transform, [\n    center.x,\n    center.y,\n  ])\n\n  const transformedWidth = width * Math.abs(transform.a)\n  const transformedHeight = height * Math.abs(transform.d)\n  const transformedStrokeWidth = 0.05 * Math.abs(transform.a)\n\n  const color = colorMap.courtyard\n\n  const attributes: { [key: string]: string } = {\n    x: (transformedX - transformedWidth / 2).toString(),\n    y: (transformedY - transformedHeight / 2).toString(),\n    width: transformedWidth.toString(),\n    height: transformedHeight.toString(),\n    class: `pcb-courtyard-rect pcb-courtyard-${layer}`,\n    \"data-pcb-courtyard-rect-id\": pcb_courtyard_rect_id,\n    \"data-type\": \"pcb_courtyard_rect\",\n    \"data-pcb-layer\": layer,\n  }\n\n  attributes.fill = \"none\"\n  attributes.stroke = color\n  attributes[\"stroke-width\"] = transformedStrokeWidth.toString()\n\n  const svgObject: SvgObject = {\n    name: \"rect\",\n    type: \"element\",\n    attributes,\n    value: \"\",\n    children: [],\n  }\n\n  return [svgObject]\n}\n","/**\n * Return pairs of adjacent elements in an array.\n */\nexport function pairs<T>(arr: Array<T>): Array<[T, T]> {\n  const result: Array<[T, T]> = []\n  for (let i = 0; i < arr.length - 1; i++) {\n    result.push([arr[i]!, arr[i + 1]!])\n  }\n  return result\n}\n","import type { PCBTrace } from \"circuit-json\"\nimport { pairs } from \"lib/utils/pairs\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport { layerNameToColor } from \"../layer-name-to-color\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbTrace(\n  trace: PCBTrace,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap, showSolderMask } = ctx\n  if (!trace.route || !Array.isArray(trace.route) || trace.route.length < 2)\n    return []\n\n  const segments = pairs(trace.route)\n  const svgObjects: SvgObject[] = []\n\n  for (const [start, end] of segments) {\n    const startPoint = applyToPoint(transform, [start.x, start.y])\n    const endPoint = applyToPoint(transform, [end.x, end.y])\n\n    const layer =\n      \"layer\" in start ? start.layer : \"layer\" in end ? end.layer : null\n    if (!layer) continue\n    if (layerFilter && layer !== layerFilter) continue\n\n    const copperColor = layerNameToColor(layer, colorMap)\n    const maskColor =\n      colorMap.soldermask[layer as keyof typeof colorMap.soldermask] ??\n      copperColor\n\n    const traceWidth =\n      \"width\" in start ? start.width : \"width\" in end ? end.width : null\n\n    const width = traceWidth\n      ? (traceWidth * Math.abs(transform.a)).toString()\n      : \"0.3\"\n\n    if (showSolderMask) {\n      const copperObject: SvgObject = {\n        name: \"path\",\n        type: \"element\",\n        value: \"\",\n        children: [],\n        attributes: {\n          class: \"pcb-trace\",\n          stroke: copperColor,\n          fill: \"none\",\n          d: `M ${startPoint[0]} ${startPoint[1]} L ${endPoint[0]} ${endPoint[1]}`,\n          \"stroke-width\": width,\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          \"shape-rendering\": \"crispEdges\",\n          \"data-type\": \"pcb_trace\",\n          \"data-pcb-layer\": layer,\n        },\n      }\n\n      const maskObject: SvgObject = {\n        name: \"path\",\n        type: \"element\",\n        value: \"\",\n        children: [],\n        attributes: {\n          class: \"pcb-soldermask\",\n          stroke: maskColor,\n          fill: \"none\",\n          d: `M ${startPoint[0]} ${startPoint[1]} L ${endPoint[0]} ${endPoint[1]}`,\n          \"stroke-width\": width,\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          \"shape-rendering\": \"crispEdges\",\n          \"data-type\": \"pcb_soldermask\",\n          \"data-pcb-layer\": layer,\n        },\n      }\n\n      svgObjects.push(maskObject, copperObject)\n    } else {\n      const maskOnlyObject: SvgObject = {\n        name: \"path\",\n        type: \"element\",\n        value: \"\",\n        children: [],\n        attributes: {\n          class: \"pcb-trace\",\n          stroke: copperColor,\n          fill: \"none\",\n          d: `M ${startPoint[0]} ${startPoint[1]} L ${endPoint[0]} ${endPoint[1]}`,\n          \"stroke-width\": width,\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          \"shape-rendering\": \"crispEdges\",\n          \"data-type\": showSolderMask ? \"pcb_soldermask\" : \"pcb_trace\",\n          \"data-pcb-layer\": layer,\n        },\n      }\n\n      svgObjects.push(maskOnlyObject)\n    }\n  }\n\n  return svgObjects\n}\n","export type CopperLayerName =\n  | \"top\"\n  | \"bottom\"\n  | \"inner1\"\n  | \"inner2\"\n  | \"inner3\"\n  | \"inner4\"\n  | \"inner5\"\n  | \"inner6\"\n\nexport type CopperColorMap = Record<CopperLayerName, string> & {\n  [layer: string]: string\n}\n\nexport interface PcbColorMap {\n  copper: CopperColorMap\n  drill: string\n  silkscreen: {\n    top: string\n    bottom: string\n  }\n  boardOutline: string\n  soldermask: {\n    top: string\n    bottom: string\n  }\n  courtyard: string\n  debugComponent: {\n    fill: string | null\n    stroke: string | null\n  }\n}\n\nexport interface PcbColorOverrides {\n  copper?: Partial<PcbColorMap[\"copper\"]>\n  drill?: string\n  silkscreen?: Partial<PcbColorMap[\"silkscreen\"]>\n  boardOutline?: string\n  soldermask?: Partial<PcbColorMap[\"soldermask\"]>\n  courtyard?: string\n  debugComponent?: Partial<PcbColorMap[\"debugComponent\"]>\n}\n\nexport const DEFAULT_PCB_COLOR_MAP: PcbColorMap = {\n  copper: {\n    top: \"rgb(200, 52, 52)\",\n    inner1: \"rgb(255, 140, 0)\",\n    inner2: \"rgb(255, 215, 0)\",\n    inner3: \"rgb(50, 205, 50)\",\n    inner4: \"rgb(64, 224, 208)\",\n    inner5: \"rgb(138, 43, 226)\",\n    inner6: \"rgb(255, 105, 180)\",\n    bottom: \"rgb(77, 127, 196)\",\n  },\n  soldermask: {\n    top: \"rgb(18, 82, 50)\",\n    bottom: \"rgb(77, 127, 196)\",\n  },\n  drill: \"#FF26E2\",\n  silkscreen: {\n    top: \"#f2eda1\",\n    bottom: \"#5da9e9\",\n  },\n  boardOutline: \"rgba(255, 255, 255, 0.5)\",\n  courtyard: \"#FF00FF\",\n  debugComponent: {\n    fill: null,\n    stroke: null,\n  },\n}\n\nexport const HOLE_COLOR = DEFAULT_PCB_COLOR_MAP.drill\nexport const SILKSCREEN_TOP_COLOR = DEFAULT_PCB_COLOR_MAP.silkscreen.top\nexport const SILKSCREEN_BOTTOM_COLOR = DEFAULT_PCB_COLOR_MAP.silkscreen.bottom // Blue color for bottom silkscreen\n","/**\n * TODO use @tscircuit/pcb-colors when it's published\n */\nimport type { PcbColorMap } from \"./colors\"\nimport { DEFAULT_PCB_COLOR_MAP } from \"./colors\"\n\nexport const LAYER_NAME_TO_COLOR: Record<string, string> = {\n  ...DEFAULT_PCB_COLOR_MAP.copper,\n}\n\nexport function layerNameToColor(\n  layerName: string,\n  colorMap: PcbColorMap = DEFAULT_PCB_COLOR_MAP,\n) {\n  return colorMap.copper[layerName as keyof typeof colorMap.copper] ?? \"white\"\n}\n\nexport const SOLDER_PASTE_LAYER_NAME_TO_COLOR = {\n  bottom: \"rgb(105, 105, 105)\",\n  top: \"rgb(105, 105, 105)\",\n}\n\nexport function solderPasteLayerNameToColor(layerName: string) {\n  return (\n    SOLDER_PASTE_LAYER_NAME_TO_COLOR[\n      layerName as keyof typeof SOLDER_PASTE_LAYER_NAME_TO_COLOR\n    ] ?? \"rgb(105, 105, 105)\"\n  )\n}\n","import type { PcbSmtPad } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { layerNameToColor } from \"../layer-name-to-color\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromSmtPad(\n  pad: PcbSmtPad,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap, showSolderMask } = ctx\n  if (layerFilter && pad.layer !== layerFilter) return []\n\n  const isCoveredWithSolderMask = Boolean(pad?.is_covered_with_solder_mask)\n  const shouldshowSolderMask = showSolderMask && isCoveredWithSolderMask\n\n  const solderMaskColor =\n    colorMap.soldermask[pad.layer as keyof typeof colorMap.soldermask] ??\n    colorMap.soldermask.top\n\n  // Positive margin: mask extends beyond pad (less copper exposed)\n  // Negative margin: mask is smaller than pad (spacing/copper visible around edges)\n  const soldermaskMargin = (pad.soldermask_margin ?? 0) * Math.abs(transform.a)\n\n  if (pad.shape === \"rect\" || pad.shape === \"rotated_rect\") {\n    const width = pad.width * Math.abs(transform.a)\n    const height = pad.height * Math.abs(transform.d)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n    const cornerRadiusValue =\n      (pad as { corner_radius?: number }).corner_radius ??\n      pad.rect_border_radius ??\n      0\n    const scaledBorderRadius = cornerRadiusValue * Math.abs(transform.a)\n\n    if (pad.shape === \"rotated_rect\" && pad.ccw_rotation) {\n      const padElement: SvgObject = {\n        name: \"rect\",\n        type: \"element\",\n        value: \"\",\n        children: [],\n        attributes: {\n          class: \"pcb-pad\",\n          fill: layerNameToColor(pad.layer, colorMap),\n          x: (-width / 2).toString(),\n          y: (-height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          transform: `translate(${x} ${y}) rotate(${-pad.ccw_rotation})`,\n          \"data-type\": \"pcb_smtpad\",\n          \"data-pcb-layer\": pad.layer,\n          ...(scaledBorderRadius\n            ? {\n                rx: scaledBorderRadius.toString(),\n                ry: scaledBorderRadius.toString(),\n              }\n            : {}),\n        },\n      }\n\n      if (!shouldshowSolderMask) {\n        return [padElement]\n      }\n\n      const maskWidth = width + 2 * soldermaskMargin\n      const maskHeight = height + 2 * soldermaskMargin\n      const maskBorderRadius = scaledBorderRadius\n        ? scaledBorderRadius + soldermaskMargin\n        : 0\n\n      const maskElement: SvgObject = {\n        name: padElement.name,\n        type: padElement.type,\n        value: \"\",\n        children: [],\n        attributes: {\n          ...padElement.attributes,\n          class: \"pcb-solder-mask\",\n          fill: solderMaskColor,\n          \"data-type\": \"pcb_soldermask\",\n          x: (-maskWidth / 2).toString(),\n          y: (-maskHeight / 2).toString(),\n          width: maskWidth.toString(),\n          height: maskHeight.toString(),\n          ...(maskBorderRadius > 0\n            ? {\n                rx: maskBorderRadius.toString(),\n                ry: maskBorderRadius.toString(),\n              }\n            : {}),\n        },\n      }\n\n      return [padElement, maskElement]\n    }\n\n    const padElement: SvgObject = {\n      name: \"rect\",\n      type: \"element\",\n      value: \"\",\n      children: [],\n      attributes: {\n        class: \"pcb-pad\",\n        fill: layerNameToColor(pad.layer, colorMap),\n        x: (x - width / 2).toString(),\n        y: (y - height / 2).toString(),\n        width: width.toString(),\n        height: height.toString(),\n        \"data-type\": \"pcb_smtpad\",\n        \"data-pcb-layer\": pad.layer,\n        ...(scaledBorderRadius\n          ? {\n              rx: scaledBorderRadius.toString(),\n              ry: scaledBorderRadius.toString(),\n            }\n          : {}),\n      },\n    }\n\n    if (!shouldshowSolderMask) {\n      return [padElement]\n    }\n\n    // Apply soldermask margin to dimensions\n    const maskWidth = width + 2 * soldermaskMargin\n    const maskHeight = height + 2 * soldermaskMargin\n    const maskBorderRadius = scaledBorderRadius\n      ? scaledBorderRadius + soldermaskMargin\n      : 0\n\n    const maskElement: SvgObject = {\n      name: padElement.name,\n      type: padElement.type,\n      value: \"\",\n      children: [],\n      attributes: {\n        ...padElement.attributes,\n        class: \"pcb-solder-mask\",\n        fill: solderMaskColor,\n        \"data-type\": \"pcb_soldermask\",\n        x: (x - maskWidth / 2).toString(),\n        y: (y - maskHeight / 2).toString(),\n        width: maskWidth.toString(),\n        height: maskHeight.toString(),\n        ...(maskBorderRadius > 0\n          ? {\n              rx: maskBorderRadius.toString(),\n              ry: maskBorderRadius.toString(),\n            }\n          : {}),\n      },\n    }\n\n    return [padElement, maskElement]\n  }\n\n  if (pad.shape === \"pill\") {\n    const width = pad.width * Math.abs(transform.a)\n    const height = pad.height * Math.abs(transform.d)\n    const radius = pad.radius * Math.abs(transform.a)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    const padElement: SvgObject = {\n      name: \"rect\",\n      type: \"element\",\n      value: \"\",\n      children: [],\n      attributes: {\n        class: \"pcb-pad\",\n        fill: layerNameToColor(pad.layer, colorMap),\n        x: (x - width / 2).toString(),\n        y: (y - height / 2).toString(),\n        width: width.toString(),\n        height: height.toString(),\n        rx: radius.toString(),\n        ry: radius.toString(),\n        \"data-type\": \"pcb_smtpad\",\n        \"data-pcb-layer\": pad.layer,\n      },\n    }\n\n    if (!shouldshowSolderMask) {\n      return [padElement]\n    }\n\n    // Apply soldermask margin to dimensions\n    const maskWidth = width + 2 * soldermaskMargin\n    const maskHeight = height + 2 * soldermaskMargin\n    const maskRadius = radius + soldermaskMargin\n\n    const maskElement: SvgObject = {\n      name: padElement.name,\n      type: padElement.type,\n      value: \"\",\n      children: [],\n      attributes: {\n        ...padElement.attributes,\n        class: \"pcb-solder-mask\",\n        fill: solderMaskColor,\n        \"data-type\": \"pcb_soldermask\",\n        x: (x - maskWidth / 2).toString(),\n        y: (y - maskHeight / 2).toString(),\n        width: maskWidth.toString(),\n        height: maskHeight.toString(),\n        rx: maskRadius.toString(),\n        ry: maskRadius.toString(),\n      },\n    }\n\n    return [padElement, maskElement]\n  }\n  if (pad.shape === \"circle\") {\n    const radius = pad.radius * Math.abs(transform.a)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    const padElement: SvgObject = {\n      name: \"circle\",\n      type: \"element\",\n      value: \"\",\n      children: [],\n      attributes: {\n        class: \"pcb-pad\",\n        fill: layerNameToColor(pad.layer, colorMap),\n        cx: x.toString(),\n        cy: y.toString(),\n        r: radius.toString(),\n        \"data-type\": \"pcb_smtpad\",\n        \"data-pcb-layer\": pad.layer,\n      },\n    }\n\n    if (!shouldshowSolderMask) {\n      return [padElement]\n    }\n\n    // Apply soldermask margin to radius\n    const maskRadius = radius + soldermaskMargin\n\n    const maskElement: SvgObject = {\n      name: padElement.name,\n      type: padElement.type,\n      value: \"\",\n      children: [],\n      attributes: {\n        ...padElement.attributes,\n        class: \"pcb-solder-mask\",\n        fill: solderMaskColor,\n        \"data-type\": \"pcb_soldermask\",\n        r: maskRadius.toString(),\n      },\n    }\n\n    return [padElement, maskElement]\n  }\n\n  if (pad.shape === \"polygon\") {\n    const points = (pad.points ?? []).map((point) =>\n      applyToPoint(transform, [point.x, point.y]),\n    )\n\n    const padElement: SvgObject = {\n      name: \"polygon\",\n      type: \"element\",\n      value: \"\",\n      children: [],\n      attributes: {\n        class: \"pcb-pad\",\n        fill: layerNameToColor(pad.layer, colorMap),\n        points: points.map((p) => p.join(\",\")).join(\" \"),\n        \"data-type\": \"pcb_smtpad\",\n        \"data-pcb-layer\": pad.layer,\n      },\n    }\n\n    if (!shouldshowSolderMask) {\n      return [padElement]\n    }\n\n    // Apply soldermask margin to polygon by offsetting each point from centroid\n    let maskPoints = points\n    if (soldermaskMargin !== 0) {\n      // Calculate centroid\n      const centroidX = points.reduce((sum, p) => sum + p[0], 0) / points.length\n      const centroidY = points.reduce((sum, p) => sum + p[1], 0) / points.length\n\n      // Offset each point away from or toward the centroid\n      maskPoints = points.map(([px, py]) => {\n        const dx = px - centroidX\n        const dy = py - centroidY\n        const distance = Math.sqrt(dx * dx + dy * dy)\n        if (distance === 0) return [px, py]\n\n        const normalizedDx = dx / distance\n        const normalizedDy = dy / distance\n        return [\n          px + normalizedDx * soldermaskMargin,\n          py + normalizedDy * soldermaskMargin,\n        ]\n      })\n    }\n\n    const maskElement: SvgObject = {\n      name: padElement.name,\n      type: padElement.type,\n      value: \"\",\n      children: [],\n      attributes: {\n        ...padElement.attributes,\n        class: \"pcb-solder-mask\",\n        fill: solderMaskColor,\n        \"data-type\": \"pcb_soldermask\",\n        points: maskPoints.map((p) => p.join(\",\")).join(\" \"),\n      },\n    }\n\n    return [padElement, maskElement]\n  }\n\n  // TODO: Implement SMT pad circles/ovals etc.\n  return []\n}\n","import type { PCBBoard, Point } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbBoard(\n  pcbBoard: PCBBoard,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, colorMap } = ctx\n  const { width, height, center, outline } = pcbBoard\n\n  let path: string\n  if (outline && Array.isArray(outline) && outline.length >= 3) {\n    path = outline\n      .map((point: Point, index: number) => {\n        const [x, y] = applyToPoint(transform, [point.x, point.y])\n        return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`\n      })\n      .join(\" \")\n  } else {\n    const halfWidth = width! / 2\n    const halfHeight = height! / 2\n\n    const topLeft = applyToPoint(transform, [\n      center.x - halfWidth,\n      center.y - halfHeight,\n    ])\n    const topRight = applyToPoint(transform, [\n      center.x + halfWidth,\n      center.y - halfHeight,\n    ])\n    const bottomRight = applyToPoint(transform, [\n      center.x + halfWidth,\n      center.y + halfHeight,\n    ])\n    const bottomLeft = applyToPoint(transform, [\n      center.x - halfWidth,\n      center.y + halfHeight,\n    ])\n\n    path =\n      `M ${topLeft[0]} ${topLeft[1]} ` +\n      `L ${topRight[0]} ${topRight[1]} ` +\n      `L ${bottomRight[0]} ${bottomRight[1]} ` +\n      `L ${bottomLeft[0]} ${bottomLeft[1]}`\n  }\n\n  path += \" Z\"\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      children: [],\n      attributes: {\n        class: \"pcb-board\",\n        d: path,\n        fill: \"none\",\n        stroke: colorMap.boardOutline,\n        \"stroke-width\": (0.1 * Math.abs(transform.a)).toString(),\n        \"data-type\": \"pcb_board\",\n        \"data-pcb-layer\": \"board\",\n      },\n    },\n  ]\n}\n","import type { PcbPanel } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbPanel(\n  pcbPanel: PcbPanel,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, colorMap, showSolderMask } = ctx\n  const width = Number(pcbPanel.width)\n  const height = Number(pcbPanel.height)\n  const center = pcbPanel.center ?? { x: width / 2, y: height / 2 }\n\n  const halfWidth = width / 2\n  const halfHeight = height / 2\n\n  const topLeft = applyToPoint(transform, [\n    center.x - halfWidth,\n    center.y - halfHeight,\n  ])\n  const topRight = applyToPoint(transform, [\n    center.x + halfWidth,\n    center.y - halfHeight,\n  ])\n  const bottomRight = applyToPoint(transform, [\n    center.x + halfWidth,\n    center.y + halfHeight,\n  ])\n  const bottomLeft = applyToPoint(transform, [\n    center.x - halfWidth,\n    center.y + halfHeight,\n  ])\n\n  const path =\n    `M ${topLeft[0]} ${topLeft[1]} ` +\n    `L ${topRight[0]} ${topRight[1]} ` +\n    `L ${bottomRight[0]} ${bottomRight[1]} ` +\n    `L ${bottomLeft[0]} ${bottomLeft[1]} Z`\n\n  const isCoveredWithSolderMask = pcbPanel.covered_with_solder_mask !== false\n  const shouldshowSolderMask = Boolean(\n    showSolderMask && isCoveredWithSolderMask,\n  )\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      children: [],\n      attributes: {\n        class: \"pcb-panel\",\n        d: path,\n        fill: \"none\",\n        stroke: colorMap.boardOutline,\n        \"stroke-width\": (0.1 * Math.abs(transform.a)).toString(),\n        \"data-type\": \"pcb_panel\",\n        \"data-pcb-layer\": \"board\",\n      },\n    },\n  ]\n}\n","import type { PCBVia } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbVia(hole: PCBVia, ctx: PcbContext): any {\n  const { transform, colorMap } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n  const scaledOuterWidth = hole.outer_diameter * Math.abs(transform.a)\n  const scaledOuterHeight = hole.outer_diameter * Math.abs(transform.a)\n  const scaledHoleWidth = hole.hole_diameter * Math.abs(transform.a)\n  const scaledHoleHeight = hole.hole_diameter * Math.abs(transform.a)\n\n  const outerRadius = Math.min(scaledOuterWidth, scaledOuterHeight) / 2\n  const innerRadius = Math.min(scaledHoleWidth, scaledHoleHeight) / 2\n  return {\n    name: \"g\",\n    type: \"element\",\n    attributes: {\n      \"data-type\": \"pcb_via\",\n      \"data-pcb-layer\": \"through\",\n    },\n    children: [\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-outer\",\n          fill: colorMap.copper.top,\n          cx: x.toString(),\n          cy: y.toString(),\n          r: outerRadius.toString(),\n          \"data-type\": \"pcb_via\",\n          \"data-pcb-layer\": \"top\",\n        },\n      },\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-inner\",\n          fill: colorMap.drill,\n\n          cx: x.toString(),\n          cy: y.toString(),\n          r: innerRadius.toString(),\n          \"data-type\": \"pcb_via\",\n          \"data-pcb-layer\": \"drill\",\n        },\n      },\n    ],\n  }\n}\n","import type { PCBHole } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbHole(\n  hole: PCBHole,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, colorMap, showSolderMask } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n\n  // Positive margin: mask extends beyond hole (less hole exposed)\n  // Negative margin: mask is smaller than hole (spacing around edges)\n  const soldermaskMargin = (hole.soldermask_margin ?? 0) * Math.abs(transform.a)\n\n  // Show soldermask if it's enabled and there's a margin defined\n  const shouldShowSolderMask = showSolderMask && soldermaskMargin !== 0\n\n  const solderMaskColor = colorMap.soldermask.top\n\n  if (hole.hole_shape === \"circle\" || hole.hole_shape === \"square\") {\n    const scaledDiameter = hole.hole_diameter * Math.abs(transform.a)\n    const radius = scaledDiameter / 2\n\n    if (hole.hole_shape === \"circle\") {\n      const holeElement: SvgObject = {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole\",\n          cx: x.toString(),\n          cy: y.toString(),\n          r: radius.toString(),\n          fill: colorMap.drill,\n          \"data-type\": \"pcb_hole\",\n          \"data-pcb-layer\": \"drill\",\n        },\n        children: [],\n        value: \"\",\n      }\n\n      if (!shouldShowSolderMask) {\n        return [holeElement]\n      }\n\n      const maskRadius = radius + soldermaskMargin\n\n      const maskElement: SvgObject = {\n        name: holeElement.name,\n        type: holeElement.type,\n        value: \"\",\n        children: [],\n        attributes: {\n          ...holeElement.attributes,\n          class: \"pcb-solder-mask\",\n          fill: solderMaskColor,\n          \"data-type\": \"pcb_soldermask\",\n          r: maskRadius.toString(),\n        },\n      }\n\n      return [holeElement, maskElement]\n    }\n    // Square hole\n    const holeElement: SvgObject = {\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        class: \"pcb-hole\",\n        x: (x - radius).toString(),\n        y: (y - radius).toString(),\n        width: scaledDiameter.toString(),\n        height: scaledDiameter.toString(),\n        fill: colorMap.drill,\n        \"data-type\": \"pcb_hole\",\n        \"data-pcb-layer\": \"drill\",\n      },\n      children: [],\n      value: \"\",\n    }\n\n    if (!shouldShowSolderMask) {\n      return [holeElement]\n    }\n\n    const maskDiameter = scaledDiameter + 2 * soldermaskMargin\n\n    const maskElement: SvgObject = {\n      name: holeElement.name,\n      type: holeElement.type,\n      value: \"\",\n      children: [],\n      attributes: {\n        ...holeElement.attributes,\n        class: \"pcb-solder-mask\",\n        fill: solderMaskColor,\n        \"data-type\": \"pcb_soldermask\",\n        x: (x - maskDiameter / 2).toString(),\n        y: (y - maskDiameter / 2).toString(),\n        width: maskDiameter.toString(),\n        height: maskDiameter.toString(),\n      },\n    }\n\n    return [holeElement, maskElement]\n  }\n  if (hole.hole_shape === \"oval\") {\n    const scaledWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHeight = hole.hole_height * Math.abs(transform.a)\n    const rx = scaledWidth / 2\n    const ry = scaledHeight / 2\n\n    const holeElement: SvgObject = {\n      name: \"ellipse\",\n      type: \"element\",\n      attributes: {\n        class: \"pcb-hole\",\n        cx: x.toString(),\n        cy: y.toString(),\n        rx: rx.toString(),\n        ry: ry.toString(),\n        fill: colorMap.drill,\n        \"data-type\": \"pcb_hole\",\n        \"data-pcb-layer\": \"drill\",\n      },\n      children: [],\n      value: \"\",\n    }\n\n    if (!shouldShowSolderMask) {\n      return [holeElement]\n    }\n\n    const maskRx = rx + soldermaskMargin\n    const maskRy = ry + soldermaskMargin\n\n    const maskElement: SvgObject = {\n      name: holeElement.name,\n      type: holeElement.type,\n      value: \"\",\n      children: [],\n      attributes: {\n        ...holeElement.attributes,\n        class: \"pcb-solder-mask\",\n        fill: solderMaskColor,\n        \"data-type\": \"pcb_soldermask\",\n        rx: maskRx.toString(),\n        ry: maskRy.toString(),\n      },\n    }\n\n    return [holeElement, maskElement]\n  }\n\n  if (hole.hole_shape === \"rect\") {\n    const scaledWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHeight = hole.hole_height * Math.abs(transform.a)\n\n    const holeElement: SvgObject = {\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        class: \"pcb-hole\",\n        x: (x - scaledWidth / 2).toString(),\n        y: (y - scaledHeight / 2).toString(),\n        width: scaledWidth.toString(),\n        height: scaledHeight.toString(),\n        fill: colorMap.drill,\n        \"data-type\": \"pcb_hole\",\n        \"data-pcb-layer\": \"drill\",\n      },\n      children: [],\n      value: \"\",\n    }\n\n    if (!shouldShowSolderMask) {\n      return [holeElement]\n    }\n\n    const maskWidth = scaledWidth + 2 * soldermaskMargin\n    const maskHeight = scaledHeight + 2 * soldermaskMargin\n\n    const maskElement: SvgObject = {\n      name: holeElement.name,\n      type: holeElement.type,\n      value: \"\",\n      children: [],\n      attributes: {\n        ...holeElement.attributes,\n        class: \"pcb-solder-mask\",\n        fill: solderMaskColor,\n        \"data-type\": \"pcb_soldermask\",\n        x: (x - maskWidth / 2).toString(),\n        y: (y - maskHeight / 2).toString(),\n        width: maskWidth.toString(),\n        height: maskHeight.toString(),\n      },\n    }\n\n    return [holeElement, maskElement]\n  }\n\n  if (hole.hole_shape === \"pill\") {\n    const scaledWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHeight = hole.hole_height * Math.abs(transform.a)\n\n    // Pill shape: two semicircles connected by straight lines\n    // If width > height, it's a horizontal pill; if height > width, it's vertical\n    const isHorizontal = scaledWidth > scaledHeight\n    const radius = Math.min(scaledWidth, scaledHeight) / 2\n    const straightLength = Math.abs(\n      isHorizontal ? scaledWidth - scaledHeight : scaledHeight - scaledWidth,\n    )\n\n    const pathD = isHorizontal\n      ? // Horizontal pill (wider than tall)\n        `M${x - straightLength / 2},${y - radius} ` +\n        `h${straightLength} ` +\n        `a${radius},${radius} 0 0 1 0,${scaledHeight} ` +\n        `h-${straightLength} ` +\n        `a${radius},${radius} 0 0 1 0,-${scaledHeight} z`\n      : // Vertical pill (taller than wide)\n        `M${x - radius},${y - straightLength / 2} ` +\n        `v${straightLength} ` +\n        `a${radius},${radius} 0 0 0 ${scaledWidth},0 ` +\n        `v-${straightLength} ` +\n        `a${radius},${radius} 0 0 0 -${scaledWidth},0 z`\n\n    const holeElement: SvgObject = {\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        class: \"pcb-hole\",\n        fill: colorMap.drill,\n        d: pathD,\n        \"data-type\": \"pcb_hole\",\n        \"data-pcb-layer\": \"drill\",\n      },\n      children: [],\n      value: \"\",\n    }\n\n    if (!shouldShowSolderMask) {\n      return [holeElement]\n    }\n\n    const maskWidth = scaledWidth + 2 * soldermaskMargin\n    const maskHeight = scaledHeight + 2 * soldermaskMargin\n    const maskIsHorizontal = maskWidth > maskHeight\n    const maskRadius = Math.min(maskWidth, maskHeight) / 2\n    const maskStraightLength = Math.abs(\n      maskIsHorizontal ? maskWidth - maskHeight : maskHeight - maskWidth,\n    )\n\n    const maskPathD = maskIsHorizontal\n      ? // Horizontal pill (wider than tall)\n        `M${x - maskStraightLength / 2},${y - maskRadius} ` +\n        `h${maskStraightLength} ` +\n        `a${maskRadius},${maskRadius} 0 0 1 0,${maskHeight} ` +\n        `h-${maskStraightLength} ` +\n        `a${maskRadius},${maskRadius} 0 0 1 0,-${maskHeight} z`\n      : // Vertical pill (taller than wide)\n        `M${x - maskRadius},${y - maskStraightLength / 2} ` +\n        `v${maskStraightLength} ` +\n        `a${maskRadius},${maskRadius} 0 0 0 ${maskWidth},0 ` +\n        `v-${maskStraightLength} ` +\n        `a${maskRadius},${maskRadius} 0 0 0 -${maskWidth},0 z`\n\n    const maskElement: SvgObject = {\n      name: holeElement.name,\n      type: holeElement.type,\n      value: \"\",\n      children: [],\n      attributes: {\n        ...holeElement.attributes,\n        class: \"pcb-solder-mask\",\n        fill: solderMaskColor,\n        \"data-type\": \"pcb_soldermask\",\n        d: maskPathD,\n      },\n    }\n\n    return [holeElement, maskElement]\n  }\n\n  if (hole.hole_shape === \"rotated_pill\") {\n    const scaledWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHeight = hole.hole_height * Math.abs(transform.a)\n\n    // PcbHoleRotatedPill uses ccw_rotation (not hole_ccw_rotation like plated holes)\n    const rotation = \"ccw_rotation\" in hole ? (hole.ccw_rotation ?? 0) : 0\n\n    // Same logic as regular pill: handle horizontal and vertical orientations\n    const isHorizontal = scaledWidth > scaledHeight\n    const radius = Math.min(scaledWidth, scaledHeight) / 2\n    const straightLength = Math.abs(\n      isHorizontal ? scaledWidth - scaledHeight : scaledHeight - scaledWidth,\n    )\n\n    const pathD = isHorizontal\n      ? // Horizontal pill (wider than tall)\n        `M${-straightLength / 2},${-radius} ` +\n        `h${straightLength} ` +\n        `a${radius},${radius} 0 0 1 0,${scaledHeight} ` +\n        `h-${straightLength} ` +\n        `a${radius},${radius} 0 0 1 0,-${scaledHeight} z`\n      : // Vertical pill (taller than wide)\n        `M${-radius},${-straightLength / 2} ` +\n        `v${straightLength} ` +\n        `a${radius},${radius} 0 0 0 ${scaledWidth},0 ` +\n        `v-${straightLength} ` +\n        `a${radius},${radius} 0 0 0 -${scaledWidth},0 z`\n\n    const holeElement: SvgObject = {\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        class: \"pcb-hole\",\n        fill: colorMap.drill,\n        d: pathD,\n        transform: `translate(${x} ${y}) rotate(${-rotation})`,\n        \"data-type\": \"pcb_hole\",\n        \"data-pcb-layer\": \"drill\",\n      },\n      children: [],\n      value: \"\",\n    }\n\n    if (!shouldShowSolderMask) {\n      return [holeElement]\n    }\n\n    const maskWidth = scaledWidth + 2 * soldermaskMargin\n    const maskHeight = scaledHeight + 2 * soldermaskMargin\n    const maskIsHorizontal = maskWidth > maskHeight\n    const maskRadius = Math.min(maskWidth, maskHeight) / 2\n    const maskStraightLength = Math.abs(\n      maskIsHorizontal ? maskWidth - maskHeight : maskHeight - maskWidth,\n    )\n\n    const maskPathD = maskIsHorizontal\n      ? // Horizontal pill (wider than tall)\n        `M${-maskStraightLength / 2},${-maskRadius} ` +\n        `h${maskStraightLength} ` +\n        `a${maskRadius},${maskRadius} 0 0 1 0,${maskHeight} ` +\n        `h-${maskStraightLength} ` +\n        `a${maskRadius},${maskRadius} 0 0 1 0,-${maskHeight} z`\n      : // Vertical pill (taller than wide)\n        `M${-maskRadius},${-maskStraightLength / 2} ` +\n        `v${maskStraightLength} ` +\n        `a${maskRadius},${maskRadius} 0 0 0 ${maskWidth},0 ` +\n        `v-${maskStraightLength} ` +\n        `a${maskRadius},${maskRadius} 0 0 0 -${maskWidth},0 z`\n\n    const maskElement: SvgObject = {\n      name: holeElement.name,\n      type: holeElement.type,\n      value: \"\",\n      children: [],\n      attributes: {\n        ...holeElement.attributes,\n        class: \"pcb-solder-mask\",\n        fill: solderMaskColor,\n        \"data-type\": \"pcb_soldermask\",\n        d: maskPathD,\n      },\n    }\n\n    return [holeElement, maskElement]\n  }\n\n  return []\n}\n","import {\n  ConnectivityMap,\n  getFullConnectivityMapFromCircuitJson,\n} from \"circuit-json-to-connectivity-map\"\nimport type { AnyCircuitElement } from \"circuit-json\"\nimport { type INode as SvgObject } from \"svgson\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport { findNearestPointInNet } from \"../create-svg-objects-from-pcb-rats-nest/find-nearest-point-in-nest\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\ninterface RatsNestLine {\n  key: string\n  startPoint: { x: number; y: number }\n  endPoint: { x: number; y: number }\n  isInNet: boolean\n}\n\nexport function createSvgObjectsForRatsNest(\n  circuitJson: AnyCircuitElement[],\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform } = ctx\n  // Compute connectivity using the helper from the imported package.\n  const connectivity: ConnectivityMap =\n    getFullConnectivityMapFromCircuitJson(circuitJson)\n\n  // Filter for ports and traces that are relevant for rats nest.\n  const pcbPorts = circuitJson.filter((elm) => elm.type === \"pcb_port\")\n  const sourceTraces = circuitJson.filter((elm) => elm.type === \"source_trace\")\n\n  const ratsNestLines: RatsNestLine[] = []\n\n  pcbPorts.forEach((port, index) => {\n    const portId = (port as any).pcb_port_id\n    if (!portId) return\n\n    const netId = connectivity.getNetConnectedToId(portId)\n    if (!netId) return\n\n    // Determine whether the port is in net via a connected source trace.\n    let isInNet = false\n    const sourcePort = su(circuitJson).source_port.getWhere({\n      pcb_port_id: portId,\n    })\n    if (sourcePort && (sourcePort as any).source_port_id) {\n      const sourcePortId = (sourcePort as any).source_port_id\n      for (const trace of sourceTraces) {\n        if (\n          Array.isArray((trace as any).connected_source_port_ids) &&\n          (trace as any).connected_source_port_ids.includes(sourcePortId) &&\n          Array.isArray((trace as any).connected_source_net_ids) &&\n          (trace as any).connected_source_net_ids.length > 0\n        ) {\n          isInNet = true\n          break\n        }\n      }\n    }\n\n    const startPoint = { x: (port as any).x, y: (port as any).y }\n\n    // Find the nearest point in the net using ConnectivityMap\n    const nearestPoint = findNearestPointInNet(\n      startPoint,\n      netId,\n      connectivity,\n      circuitJson,\n    )\n\n    if (!nearestPoint) return\n\n    ratsNestLines.push({\n      key: `${portId}-${index}`,\n      startPoint,\n      endPoint: nearestPoint,\n      isInNet,\n    })\n  })\n\n  // Create SVG <line> objects for each rats nest connection.\n  const svgObjects: SvgObject[] = []\n  for (const line of ratsNestLines) {\n    const transformedStart = applyToPoint(transform, [\n      line.startPoint.x,\n      line.startPoint.y,\n    ])\n    const transformedEnd = applyToPoint(transform, [\n      line.endPoint.x,\n      line.endPoint.y,\n    ])\n    const attributes: { [key: string]: string } = {\n      x1: transformedStart[0].toString(),\n      y1: transformedStart[1].toString(),\n      x2: transformedEnd[0].toString(),\n      y2: transformedEnd[1].toString(),\n      stroke: \"white\",\n      \"stroke-width\": \"1\",\n      \"stroke-dasharray\": \"6,6\",\n      \"data-type\": \"pcb_rats_nest\",\n      \"data-pcb-layer\": \"overlay\",\n    }\n\n    svgObjects.push({\n      name: \"line\",\n      type: \"element\",\n      attributes,\n      value: \"\",\n      children: [],\n    })\n  }\n\n  return svgObjects\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport { su } from \"@tscircuit/circuit-json-util\"\n\ninterface Position {\n  x: number\n  y: number\n}\n\nexport const getElementPosition = (\n  id: string,\n  circuitJson: AnyCircuitElement[],\n): Position | null => {\n  // Try to find the element as a pcb_smtpad\n  const pcbSmtpad = su(circuitJson).pcb_smtpad.get(id)\n  if (pcbSmtpad && \"x\" in pcbSmtpad && \"y\" in pcbSmtpad) {\n    return { x: pcbSmtpad.x, y: pcbSmtpad.y }\n  }\n\n  // Try to find the element as a pcb_plated_hole\n  const pcbPlatedHole = su(circuitJson).pcb_plated_hole.get(id)\n  if (pcbPlatedHole && \"x\" in pcbPlatedHole && \"y\" in pcbPlatedHole) {\n    return { x: pcbPlatedHole.x, y: pcbPlatedHole.y }\n  }\n\n  // If neither is found, return null\n  return null\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport { getElementPosition } from \"./get-element-position\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\n\nexport const findNearestPointInNet = (\n  sourcePoint: { x: number; y: number },\n  netId: string,\n  connectivity: ConnectivityMap,\n  circuitJson: AnyCircuitElement[],\n): { x: number; y: number } | null => {\n  const connectedIds = connectivity.getIdsConnectedToNet(netId)\n  let nearestPoint: { x: number; y: number } | null = null\n  let minDistance = Infinity\n\n  for (const id of connectedIds) {\n    const pos = getElementPosition(id, circuitJson)\n    if (pos) {\n      const dx = sourcePoint.x - pos.x\n      const dy = sourcePoint.y - pos.y\n      const distance = Math.sqrt(dx * dx + dy * dy)\n      if (distance > 0 && distance < minDistance) {\n        minDistance = distance\n        nearestPoint = pos\n      }\n    }\n  }\n\n  return nearestPoint\n}\n","import type {\n  PcbCutout,\n  PcbCutoutRect,\n  PcbCutoutCircle,\n  PcbCutoutPolygon,\n  Point,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport {\n  applyToPoint,\n  compose,\n  rotate,\n  translate,\n  toString as matrixToString,\n} from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbCutout(\n  cutout: PcbCutout,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, colorMap } = ctx\n  if (cutout.shape === \"rect\") {\n    const rectCutout = cutout as PcbCutoutRect\n    const [cx, cy] = applyToPoint(transform, [\n      rectCutout.center.x,\n      rectCutout.center.y,\n    ])\n    const scaledWidth = rectCutout.width * Math.abs(transform.a)\n    const scaledHeight = rectCutout.height * Math.abs(transform.d)\n    const svgRotation = -(rectCutout.rotation ?? 0)\n\n    const { corner_radius } = rectCutout as any\n    const baseCornerRadius =\n      typeof corner_radius === \"number\" && corner_radius > 0 ? corner_radius : 0\n    const transformedCornerRadiusX = baseCornerRadius * Math.abs(transform.a)\n    const transformedCornerRadiusY = baseCornerRadius * Math.abs(transform.d)\n\n    const attributes: { [key: string]: string } = {\n      class: \"pcb-cutout pcb-cutout-rect\",\n      x: (-scaledWidth / 2).toString(),\n      y: (-scaledHeight / 2).toString(),\n      width: scaledWidth.toString(),\n      height: scaledHeight.toString(),\n      fill: colorMap.drill,\n      transform: matrixToString(\n        compose(translate(cx, cy), rotate((svgRotation * Math.PI) / 180)),\n      ),\n      \"data-type\": \"pcb_cutout\",\n      \"data-pcb-layer\": \"drill\",\n    }\n\n    if (transformedCornerRadiusX > 0) {\n      attributes.rx = transformedCornerRadiusX.toString()\n    }\n\n    if (transformedCornerRadiusY > 0) {\n      attributes.ry = transformedCornerRadiusY.toString()\n    }\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes,\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n  if (cutout.shape === \"circle\") {\n    const circleCutout = cutout as PcbCutoutCircle\n    const [cx, cy] = applyToPoint(transform, [\n      circleCutout.center.x,\n      circleCutout.center.y,\n    ])\n    const scaledRadius = circleCutout.radius * Math.abs(transform.a)\n\n    return [\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-cutout pcb-cutout-circle\",\n          cx: cx.toString(),\n          cy: cy.toString(),\n          r: scaledRadius.toString(),\n          fill: colorMap.drill,\n          \"data-type\": \"pcb_cutout\",\n          \"data-pcb-layer\": \"drill\",\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n  if (cutout.shape === \"polygon\") {\n    const polygonCutout = cutout as PcbCutoutPolygon\n    if (!polygonCutout.points || polygonCutout.points.length === 0) return []\n\n    const transformedPoints = polygonCutout.points.map((p: Point) =>\n      applyToPoint(transform, [p.x, p.y]),\n    )\n    const pointsString = transformedPoints\n      .map((p) => `${p[0]},${p[1]}`)\n      .join(\" \")\n\n    return [\n      {\n        name: \"polygon\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-cutout pcb-cutout-polygon\",\n          points: pointsString,\n          fill: colorMap.drill,\n          \"data-type\": \"pcb_cutout\",\n          \"data-pcb-layer\": \"drill\",\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n\n  return []\n}\n","import type { PcbCopperPour } from \"circuit-json\"\nimport {\n  applyToPoint,\n  compose,\n  rotate,\n  toString as matrixToString,\n  translate,\n} from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { layerNameToColor } from \"../layer-name-to-color\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\nimport { ringToPathD } from \"lib/utils/ring-to-path-d\"\n\nexport function createSvgObjectsFromPcbCopperPour(\n  pour: PcbCopperPour,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  const { layer } = pour\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  const color = layerNameToColor(layer, colorMap)\n  const opacity = \"0.5\"\n\n  if (pour.shape === \"rect\") {\n    const [cx, cy] = applyToPoint(transform, [pour.center.x, pour.center.y])\n    const scaledWidth = pour.width * Math.abs(transform.a)\n    const scaledHeight = pour.height * Math.abs(transform.d)\n    const svgRotation = -(pour.rotation ?? 0)\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-copper-pour pcb-copper-pour-rect\",\n          x: (-scaledWidth / 2).toString(),\n          y: (-scaledHeight / 2).toString(),\n          width: scaledWidth.toString(),\n          height: scaledHeight.toString(),\n          fill: color,\n          \"fill-opacity\": opacity,\n          transform: matrixToString(\n            compose(translate(cx, cy), rotate((svgRotation * Math.PI) / 180)),\n          ),\n          \"data-type\": \"pcb_copper_pour\",\n          \"data-pcb-layer\": layer,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n\n  if (pour.shape === \"polygon\") {\n    if (!pour.points || pour.points.length === 0) return []\n\n    const transformedPoints = pour.points.map((p) =>\n      applyToPoint(transform, [p.x, p.y]),\n    )\n    const pointsString = transformedPoints\n      .map((p) => `${p[0]},${p[1]}`)\n      .join(\" \")\n\n    return [\n      {\n        name: \"polygon\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-copper-pour pcb-copper-pour-polygon\",\n          points: pointsString,\n          fill: color,\n          \"fill-opacity\": opacity,\n          \"data-type\": \"pcb_copper_pour\",\n          \"data-pcb-layer\": layer,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n\n  if (pour.shape === \"brep\") {\n    const { brep_shape } = pour\n    let d = ringToPathD(brep_shape.outer_ring.vertices, transform)\n    for (const inner_ring of brep_shape.inner_rings ?? []) {\n      d += ` ${ringToPathD(inner_ring.vertices, transform)}`\n    }\n\n    return [\n      {\n        name: \"path\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-copper-pour pcb-copper-pour-brep\",\n          d,\n          fill: color,\n          \"fill-rule\": \"evenodd\",\n          \"fill-opacity\": opacity,\n          \"data-type\": \"pcb_copper_pour\",\n          \"data-pcb-layer\": layer,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n\n  return []\n}\n","import { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport function ringToPathD(\n  vertices: Array<{ x: number; y: number; bulge?: number }>,\n  transform: Matrix,\n): string {\n  if (vertices.length === 0) return \"\"\n\n  const transformedVertices = vertices.map((v) => {\n    const [x, y] = applyToPoint(transform, [v.x, v.y])\n    return { ...v, x, y }\n  })\n\n  let d = `M ${transformedVertices[0]!.x} ${transformedVertices[0]!.y}`\n\n  for (let i = 0; i < transformedVertices.length; i++) {\n    const start = transformedVertices[i]!\n    const end = transformedVertices[(i + 1) % transformedVertices.length]!\n\n    if (start.bulge) {\n      if (Math.hypot(end.x - start.x, end.y - start.y) < 1e-9) continue\n\n      const bulge = start.bulge\n      const dx = end.x - start.x\n      const dy = end.y - start.y\n      const dist = Math.hypot(dx, dy)\n\n      const radius = Math.abs((dist / 4 / bulge) * (bulge * bulge + 1))\n      const sweepFlag = bulge < 0 ? 1 : 0\n      const largeArcFlag = Math.abs(bulge) > 1 ? 1 : 0\n      d += ` A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.x} ${end.y}`\n    } else {\n      d += ` L ${end.x} ${end.y}`\n    }\n  }\n\n  d += \" Z\"\n  return d\n}\n","import { type INode as SvgObject } from \"svgson\"\n\nexport interface PcbGridOptions {\n  cellSize: number\n  lineColor?: string\n  majorCellSize?: number\n  majorLineColor?: string\n}\n\nexport interface CreateSvgObjectsForPcbGridParams {\n  grid?: PcbGridOptions\n  svgWidth: number\n  svgHeight: number\n}\n\nexport interface PcbGridSvgObjects {\n  defs?: SvgObject\n  rect?: SvgObject\n}\n\nconst DEFAULT_GRID_LINE_COLOR = \"rgba(255, 255, 255, 0.5)\"\nconst GRID_PATTERN_ID = \"pcb-grid-pattern\"\n\nexport function createSvgObjectsForPcbGrid({\n  grid,\n  svgWidth,\n  svgHeight,\n}: CreateSvgObjectsForPcbGridParams): PcbGridSvgObjects {\n  if (!grid) {\n    return {}\n  }\n\n  const gridLineColor = grid.lineColor ?? DEFAULT_GRID_LINE_COLOR\n  const gridCellSize = grid.cellSize\n  const majorCellSize = grid.majorCellSize\n  const majorLineColor = grid.majorLineColor ?? gridLineColor\n\n  if (majorCellSize !== undefined) {\n    if (!gridCellSize || gridCellSize <= 0) {\n      throw new Error(\"grid.majorCellSize requires a positive grid.cellSize\")\n    }\n\n    if (majorCellSize <= 0) {\n      throw new Error(\n        \"grid.majorCellSize must be a positive multiple of grid.cellSize\",\n      )\n    }\n\n    const ratio = majorCellSize / gridCellSize\n    const nearestInteger = Math.round(ratio)\n\n    if (!Number.isFinite(ratio) || Math.abs(ratio - nearestInteger) > 1e-6) {\n      throw new Error(\n        \"grid.majorCellSize must be a positive multiple of grid.cellSize\",\n      )\n    }\n  }\n\n  if (!gridCellSize || gridCellSize <= 0) {\n    return {}\n  }\n\n  const hasMajorGrid = majorCellSize !== undefined\n\n  const patternChildren = hasMajorGrid\n    ? createMajorGridPatternChildren(\n        gridCellSize,\n        majorCellSize!,\n        gridLineColor,\n        majorLineColor,\n      )\n    : [\n        {\n          name: \"path\",\n          type: \"element\",\n          value: \"\",\n          attributes: {\n            d: `M ${gridCellSize} 0 L 0 0 0 ${gridCellSize}`,\n            fill: \"none\",\n            stroke: gridLineColor,\n            \"stroke-width\": \"1\",\n            \"shape-rendering\": \"crispEdges\",\n          },\n          children: [],\n        },\n      ]\n\n  const defs: SvgObject = {\n    name: \"defs\",\n    type: \"element\",\n    value: \"\",\n    attributes: {},\n    children: [\n      {\n        name: \"pattern\",\n        type: \"element\",\n        value: \"\",\n        attributes: {\n          id: GRID_PATTERN_ID,\n          width: hasMajorGrid\n            ? majorCellSize!.toString()\n            : gridCellSize.toString(),\n          height: hasMajorGrid\n            ? majorCellSize!.toString()\n            : gridCellSize.toString(),\n          patternUnits: \"userSpaceOnUse\",\n        },\n        children: patternChildren,\n      },\n    ],\n  }\n\n  const rect: SvgObject = {\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      x: \"0\",\n      y: \"0\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n      fill: `url(#${GRID_PATTERN_ID})`,\n      \"pointer-events\": \"none\",\n      \"data-type\": \"pcb_grid\",\n      \"data-pcb-layer\": \"global\",\n    },\n    children: [],\n  }\n\n  return { defs, rect }\n}\n\nfunction createMajorGridPatternChildren(\n  cellSize: number,\n  majorCellSize: number,\n  lineColor: string,\n  majorLineColor: string,\n): SvgObject[] {\n  const children: SvgObject[] = []\n  const steps = Math.round(majorCellSize / cellSize)\n\n  for (let step = 0; step < steps; step += 1) {\n    const offset = Number((step * cellSize).toFixed(6))\n    const offsetString = offset.toString()\n    const color = step === 0 ? majorLineColor : lineColor\n    const majorSizeString = majorCellSize.toString()\n\n    children.push({\n      name: \"line\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        x1: offsetString,\n        y1: \"0\",\n        x2: offsetString,\n        y2: majorSizeString,\n        stroke: color,\n        \"stroke-width\": \"1\",\n        \"shape-rendering\": \"crispEdges\",\n      },\n      children: [],\n    })\n\n    children.push({\n      name: \"line\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        x1: \"0\",\n        y1: offsetString,\n        x2: majorSizeString,\n        y2: offsetString,\n        stroke: color,\n        \"stroke-width\": \"1\",\n        \"shape-rendering\": \"crispEdges\",\n      },\n      children: [],\n    })\n  }\n\n  return children\n}\n","import { applyToPoint } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { createAnchorOffsetIndicators } from \"../../utils/create-pcb-component-anchor-offset-indicators\"\n\nexport function createSvgObjectsFromPcbComponent(\n  component: any,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, circuitJson } = ctx\n  const { center, width, height, rotation = 0 } = component\n  const [x, y] = applyToPoint(transform, [center.x, center.y])\n  const scaledWidth = width * Math.abs(transform.a)\n  const scaledHeight = height * Math.abs(transform.d)\n  const transformStr = `translate(${x}, ${y}) rotate(${-rotation}) scale(1, -1)`\n\n  const svgObjects: SvgObject[] = []\n\n  // Add anchor offset indicators if this component is positioned relative to a group\n  if (\n    ctx.showAnchorOffsets &&\n    component.positioned_relative_to_pcb_group_id &&\n    component.position_mode === \"relative\" &&\n    circuitJson\n  ) {\n    // Find the referenced PCB group\n    const pcbGroup = circuitJson.find(\n      (elm: any) =>\n        elm.type === \"pcb_group\" &&\n        elm.pcb_group_id === component.positioned_relative_to_pcb_group_id,\n    ) as any\n\n    if (pcbGroup?.center) {\n      svgObjects.push(\n        ...createAnchorOffsetIndicators({\n          groupAnchorPosition: pcbGroup.center,\n          componentPosition: center,\n          transform,\n          componentWidth: width,\n          componentHeight: height,\n        }),\n      )\n    }\n  }\n\n  if (\n    !ctx.colorMap.debugComponent?.fill &&\n    !ctx.colorMap.debugComponent?.stroke\n  ) {\n    return svgObjects\n  }\n\n  svgObjects.push({\n    name: \"g\",\n    type: \"element\",\n    attributes: {\n      transform: transformStr,\n      \"data-type\": \"pcb_component\",\n      \"data-pcb-layer\": component.layer ?? \"top\",\n    },\n    children: [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-component\",\n          x: (-scaledWidth / 2).toString(),\n          y: (-scaledHeight / 2).toString(),\n          width: scaledWidth.toString(),\n          height: scaledHeight.toString(),\n          fill: ctx.colorMap.debugComponent.fill ?? \"transparent\",\n          stroke: ctx.colorMap.debugComponent.stroke ?? \"transparent\",\n          \"data-type\": \"pcb_component\",\n          \"data-pcb-layer\": component.layer ?? \"top\",\n        },\n      } as any,\n    ],\n    value: \"\",\n  })\n\n  return svgObjects\n}\n","import type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport interface PcbComponentAnchorOffsetParams {\n  groupAnchorPosition: { x: number; y: number }\n  componentPosition: { x: number; y: number }\n  transform: Matrix\n  componentWidth?: number\n  componentHeight?: number\n}\n\ninterface HorizontalDimensionParams {\n  startX: number\n  endX: number\n  y: number\n  offsetMm: number\n  offsetY: number\n}\n\ninterface VerticalDimensionParams {\n  x: number\n  startY: number\n  endY: number\n  offsetMm: number\n  offsetX: number\n}\n\nconst OFFSET_THRESHOLD_MM = 0.01\nconst TICK_SIZE_PX = 4\nconst LABEL_GAP_PX = 8\nconst LABEL_FONT_SIZE_PX = 11\nconst STROKE_WIDTH_PX = 1\nconst ANCHOR_MARKER_SIZE_PX = 5\nconst ANCHOR_MARKER_STROKE_WIDTH_PX = 1.5\nconst COMPONENT_GAP_PX = 15\nconst COMPONENT_SIDE_GAP_PX = 10\nconst DISTANCE_MULTIPLIER = 0.2\nconst MAX_OFFSET_PX = 50\n\nexport function createAnchorOffsetIndicators(\n  params: PcbComponentAnchorOffsetParams,\n): SvgObject[] {\n  const {\n    groupAnchorPosition,\n    componentPosition,\n    transform,\n    componentWidth = 0,\n    componentHeight = 0,\n  } = params\n  const objects: SvgObject[] = []\n\n  const [screenGroupAnchorX, screenGroupAnchorY] = applyToPoint(transform, [\n    groupAnchorPosition.x,\n    groupAnchorPosition.y,\n  ])\n  const [screenComponentX, screenComponentY] = applyToPoint(transform, [\n    componentPosition.x,\n    componentPosition.y,\n  ])\n\n  const offsetX = componentPosition.x - groupAnchorPosition.x\n  const offsetY = componentPosition.y - groupAnchorPosition.y\n\n  const scale = Math.abs(transform.a)\n  const screenComponentWidth = componentWidth * scale\n  const screenComponentHeight = componentHeight * scale\n\n  objects.push(createAnchorMarker(screenGroupAnchorX, screenGroupAnchorY))\n\n  objects.push({\n    name: \"line\",\n    type: \"element\",\n    attributes: {\n      x1: screenGroupAnchorX.toString(),\n      y1: screenGroupAnchorY.toString(),\n      x2: screenComponentX.toString(),\n      y2: screenComponentY.toString(),\n      stroke: \"#ffffff\",\n      \"stroke-width\": \"0.5\",\n      \"stroke-dasharray\": \"3,3\",\n      opacity: \"0.5\",\n      class: \"anchor-offset-connector\",\n    },\n    children: [],\n    value: \"\",\n  })\n\n  objects.push({\n    name: \"circle\",\n    type: \"element\",\n    attributes: {\n      cx: screenComponentX.toString(),\n      cy: screenComponentY.toString(),\n      r: \"2\",\n      fill: \"#ffffff\",\n      opacity: \"0.7\",\n      class: \"anchor-offset-component-marker\",\n    },\n    children: [],\n    value: \"\",\n  })\n\n  const yDistance = Math.abs(screenComponentY - screenGroupAnchorY)\n  const xDistance = Math.abs(screenComponentX - screenGroupAnchorX)\n  const totalDistance = Math.sqrt(xDistance * xDistance + yDistance * yDistance)\n\n  const componentHeightOffset = screenComponentHeight / 2 + COMPONENT_GAP_PX\n  const dynamicOffset = Math.max(\n    componentHeightOffset,\n    Math.min(MAX_OFFSET_PX, totalDistance * DISTANCE_MULTIPLIER),\n  )\n\n  const horizontalLineY =\n    offsetY > 0\n      ? screenComponentY - dynamicOffset\n      : screenComponentY + dynamicOffset\n\n  const componentWidthOffset = screenComponentWidth / 2 + COMPONENT_SIDE_GAP_PX\n  const verticalLineX =\n    offsetX > 0\n      ? screenComponentX + componentWidthOffset\n      : screenComponentX - componentWidthOffset\n\n  if (Math.abs(offsetX) > OFFSET_THRESHOLD_MM) {\n    objects.push(\n      ...createHorizontalDimension({\n        startX: screenGroupAnchorX,\n        endX: screenComponentX,\n        y: horizontalLineY,\n        offsetMm: offsetX,\n        offsetY: offsetY,\n      }),\n    )\n  }\n\n  if (Math.abs(offsetY) > OFFSET_THRESHOLD_MM) {\n    objects.push(\n      ...createVerticalDimension({\n        x: verticalLineX,\n        startY: screenGroupAnchorY,\n        endY: screenComponentY,\n        offsetMm: -offsetY,\n        offsetX: offsetX,\n      }),\n    )\n  }\n\n  return objects\n}\n\nfunction createAnchorMarker(x: number, y: number): SvgObject {\n  return {\n    name: \"g\",\n    type: \"element\",\n    attributes: {\n      class: \"anchor-offset-marker\",\n      \"data-type\": \"anchor_offset_marker\",\n    },\n    children: [\n      {\n        name: \"line\",\n        type: \"element\",\n        attributes: {\n          x1: x.toString(),\n          y1: (y - ANCHOR_MARKER_SIZE_PX).toString(),\n          x2: x.toString(),\n          y2: (y + ANCHOR_MARKER_SIZE_PX).toString(),\n          stroke: \"#ffffff\",\n          \"stroke-width\": ANCHOR_MARKER_STROKE_WIDTH_PX.toString(),\n          \"stroke-linecap\": \"round\",\n        },\n        children: [],\n        value: \"\",\n      },\n      {\n        name: \"line\",\n        type: \"element\",\n        attributes: {\n          x1: (x - ANCHOR_MARKER_SIZE_PX).toString(),\n          y1: y.toString(),\n          x2: (x + ANCHOR_MARKER_SIZE_PX).toString(),\n          y2: y.toString(),\n          stroke: \"#ffffff\",\n          \"stroke-width\": ANCHOR_MARKER_STROKE_WIDTH_PX.toString(),\n          \"stroke-linecap\": \"round\",\n        },\n        children: [],\n        value: \"\",\n      },\n    ],\n    value: \"\",\n  }\n}\n\nfunction createHorizontalDimension({\n  startX,\n  endX,\n  y,\n  offsetMm,\n  offsetY,\n}: HorizontalDimensionParams): SvgObject[] {\n  const objects: SvgObject[] = []\n\n  objects.push({\n    name: \"line\",\n    type: \"element\",\n    attributes: {\n      x1: startX.toString(),\n      y1: y.toString(),\n      x2: endX.toString(),\n      y2: y.toString(),\n      stroke: \"#ffffff\",\n      \"stroke-width\": STROKE_WIDTH_PX.toString(),\n      class: \"anchor-offset-dimension-x\",\n    },\n    children: [],\n    value: \"\",\n  })\n\n  objects.push({\n    name: \"line\",\n    type: \"element\",\n    attributes: {\n      x1: startX.toString(),\n      y1: (y - TICK_SIZE_PX).toString(),\n      x2: startX.toString(),\n      y2: (y + TICK_SIZE_PX).toString(),\n      stroke: \"#ffffff\",\n      \"stroke-width\": STROKE_WIDTH_PX.toString(),\n    },\n    children: [],\n    value: \"\",\n  })\n\n  objects.push({\n    name: \"line\",\n    type: \"element\",\n    attributes: {\n      x1: endX.toString(),\n      y1: (y - TICK_SIZE_PX).toString(),\n      x2: endX.toString(),\n      y2: (y + TICK_SIZE_PX).toString(),\n      stroke: \"#ffffff\",\n      \"stroke-width\": STROKE_WIDTH_PX.toString(),\n    },\n    children: [],\n    value: \"\",\n  })\n\n  const midX = (startX + endX) / 2\n  const labelY =\n    offsetY > 0\n      ? y - TICK_SIZE_PX - LABEL_GAP_PX\n      : y + TICK_SIZE_PX + LABEL_GAP_PX\n\n  objects.push({\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      x: midX.toString(),\n      y: labelY.toString(),\n      fill: \"#ffffff\",\n      \"font-size\": LABEL_FONT_SIZE_PX.toString(),\n      \"font-family\": \"Arial, sans-serif\",\n      \"text-anchor\": \"middle\",\n      \"dominant-baseline\": offsetY > 0 ? \"baseline\" : \"hanging\",\n      class: \"anchor-offset-label\",\n    },\n    children: [\n      {\n        type: \"text\",\n        value: `X: ${offsetMm.toFixed(2)}mm`,\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  })\n\n  return objects\n}\n\nfunction createVerticalDimension({\n  x,\n  startY,\n  endY,\n  offsetMm,\n  offsetX,\n}: VerticalDimensionParams): SvgObject[] {\n  const objects: SvgObject[] = []\n\n  objects.push({\n    name: \"line\",\n    type: \"element\",\n    attributes: {\n      x1: x.toString(),\n      y1: startY.toString(),\n      x2: x.toString(),\n      y2: endY.toString(),\n      stroke: \"#ffffff\",\n      \"stroke-width\": STROKE_WIDTH_PX.toString(),\n      class: \"anchor-offset-dimension-y\",\n    },\n    children: [],\n    value: \"\",\n  })\n\n  objects.push({\n    name: \"line\",\n    type: \"element\",\n    attributes: {\n      x1: (x - TICK_SIZE_PX).toString(),\n      y1: startY.toString(),\n      x2: (x + TICK_SIZE_PX).toString(),\n      y2: startY.toString(),\n      stroke: \"#ffffff\",\n      \"stroke-width\": STROKE_WIDTH_PX.toString(),\n    },\n    children: [],\n    value: \"\",\n  })\n\n  objects.push({\n    name: \"line\",\n    type: \"element\",\n    attributes: {\n      x1: (x - TICK_SIZE_PX).toString(),\n      y1: endY.toString(),\n      x2: (x + TICK_SIZE_PX).toString(),\n      y2: endY.toString(),\n      stroke: \"#ffffff\",\n      \"stroke-width\": STROKE_WIDTH_PX.toString(),\n    },\n    children: [],\n    value: \"\",\n  })\n\n  const midY = (startY + endY) / 2\n  const labelX = offsetX < 0 ? x - TICK_SIZE_PX - 4 : x + TICK_SIZE_PX + 4\n\n  objects.push({\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      x: labelX.toString(),\n      y: midY.toString(),\n      fill: \"#ffffff\",\n      \"font-size\": LABEL_FONT_SIZE_PX.toString(),\n      \"font-family\": \"Arial, sans-serif\",\n      \"text-anchor\": offsetX < 0 ? \"end\" : \"start\",\n      \"dominant-baseline\": \"middle\",\n      class: \"anchor-offset-label\",\n    },\n    children: [\n      {\n        type: \"text\",\n        value: `Y: ${offsetMm.toFixed(2)}mm`,\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  })\n\n  return objects\n}\n","import type { PcbGroup, Point } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nconst DEFAULT_GROUP_COLOR = \"rgba(100, 200, 255, 0.6)\"\nconst DEFAULT_STROKE_WIDTH = 0.1 // 0.1mm default stroke width\n\nexport function createSvgObjectsFromPcbGroup(\n  pcbGroup: PcbGroup,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const { center, width, height } = pcbGroup\n\n  const outline = Array.isArray((pcbGroup as { outline?: Point[] }).outline)\n    ? (pcbGroup as { outline?: Point[] }).outline\n    : undefined\n\n  const transformedStrokeWidth = DEFAULT_STROKE_WIDTH * Math.abs(transform.a)\n\n  // Calculate dash length based on stroke width for consistent appearance\n  const dashLength = 0.3 * Math.abs(transform.a) // 0.3mm dash\n  const gapLength = 0.15 * Math.abs(transform.a) // 0.15mm gap\n\n  const baseAttributes: Record<string, string> = {\n    class: \"pcb-group\",\n    fill: \"none\",\n    stroke: DEFAULT_GROUP_COLOR,\n    \"stroke-width\": transformedStrokeWidth.toString(),\n    \"stroke-dasharray\": `${dashLength} ${gapLength}`,\n    \"data-type\": \"pcb_group\",\n    \"data-pcb-group-id\": pcbGroup.pcb_group_id,\n    \"data-pcb-layer\": \"overlay\",\n  }\n\n  if (pcbGroup.name) {\n    baseAttributes[\"data-group-name\"] = pcbGroup.name\n  }\n\n  if (\n    outline &&\n    outline.length >= 3 &&\n    outline.every(\n      (point) =>\n        point && typeof point.x === \"number\" && typeof point.y === \"number\",\n    )\n  ) {\n    const path = outline\n      .map((point: Point, index: number) => {\n        const [x, y] = applyToPoint(transform, [point.x, point.y])\n        return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`\n      })\n      .join(\" \")\n\n    return [\n      {\n        name: \"path\",\n        type: \"element\",\n        value: \"\",\n        children: [],\n        attributes: {\n          ...baseAttributes,\n          d: `${path} Z`,\n        },\n      },\n    ]\n  }\n\n  if (\n    !center ||\n    typeof center.x !== \"number\" ||\n    typeof center.y !== \"number\" ||\n    typeof width !== \"number\" ||\n    typeof height !== \"number\"\n  ) {\n    console.error(\"Invalid pcb_group data\", { center, width, height })\n    return []\n  }\n\n  const halfWidth = width / 2\n  const halfHeight = height / 2\n\n  const [topLeftX, topLeftY] = applyToPoint(transform, [\n    center.x - halfWidth,\n    center.y + halfHeight,\n  ])\n  const [bottomRightX, bottomRightY] = applyToPoint(transform, [\n    center.x + halfWidth,\n    center.y - halfHeight,\n  ])\n\n  const rectX = Math.min(topLeftX, bottomRightX)\n  const rectY = Math.min(topLeftY, bottomRightY)\n  const rectWidth = Math.abs(bottomRightX - topLeftX)\n  const rectHeight = Math.abs(bottomRightY - topLeftY)\n\n  const svgObject: SvgObject = {\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      ...baseAttributes,\n      x: rectX.toString(),\n      y: rectY.toString(),\n      width: rectWidth.toString(),\n      height: rectHeight.toString(),\n    },\n    children: [],\n  }\n\n  return [svgObject]\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\n\nexport function getSoftwareUsedString(\n  circuitJson: AnyCircuitElement[],\n): string | undefined {\n  const metadata = circuitJson.find(\n    (e) =>\n      (e as any).type === \"project_software_metadata\" ||\n      (e as any).type === \"source_project_metadata\",\n  ) as { software_used_string?: string } | undefined\n\n  return metadata?.software_used_string\n}\n","{\n  \"name\": \"circuit-to-svg\",\n  \"type\": \"module\",\n  \"version\": \"0.0.273\",\n  \"description\": \"Convert Circuit JSON to SVG\",\n  \"main\": \"dist/index.js\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"start\": \"cosmos\",\n    \"prepublish\": \"npm run build\",\n    \"build\": \"tsup-node ./lib/index.ts --format esm --dts --sourcemap --external tscircuit\",\n    \"format\": \"biome format . --write\",\n    \"format:check\": \"biome format .\",\n    \"cosmos\": \"cosmos\",\n    \"cosmos-export\": \"cosmos-export\"\n  },\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@biomejs/biome\": \"^1.9.4\",\n    \"@types/bun\": \"^1.2.8\",\n    \"@vitejs/plugin-react\": \"5.0.0\",\n    \"biome\": \"^0.3.3\",\n    \"bun-match-svg\": \"^0.0.12\",\n    \"esbuild\": \"^0.20.2\",\n    \"performance-now\": \"^2.1.0\",\n    \"circuit-json\": \"^0.0.317\",\n    \"react\": \"19.1.0\",\n    \"react-cosmos\": \"7.0.0\",\n    \"react-cosmos-plugin-vite\": \"7.0.0\",\n    \"react-dom\": \"19.1.0\",\n    \"tscircuit\": \"^0.0.827\",\n    \"tsup\": \"^8.0.2\",\n    \"typescript\": \"^5.4.5\",\n    \"vite-tsconfig-paths\": \"^5.0.1\"\n  },\n  \"dependencies\": {\n    \"@types/node\": \"^22.5.5\",\n    \"bun-types\": \"^1.1.40\",\n    \"calculate-elbow\": \"0.0.12\",\n    \"svgson\": \"^5.3.1\",\n    \"transformation-matrix\": \"^2.16.1\"\n  }\n}\n","import pkg from \"../package.json\" with { type: \"json\" }\n\nexport const CIRCUIT_TO_SVG_VERSION = (pkg as { version: string }).version\n","import type { SvgObject } from \"../svg-object\"\n\nconst TYPE_PRIORITY: Record<string, number> = {\n  pcb_background: 0,\n  pcb_boundary: 1,\n  pcb_panel: 5,\n  pcb_board: 10,\n  pcb_cutout: 15,\n  pcb_hole: 18,\n  pcb_plated_hole_drill: 19,\n  pcb_plated_hole: 20,\n  pcb_trace: 30,\n  pcb_smtpad: 30,\n  pcb_copper_pour: 35,\n  pcb_via: 36,\n  pcb_soldermask: 40,\n  pcb_solder_paste: 45,\n  pcb_silkscreen_text: 50,\n  pcb_silkscreen_path: 50,\n  pcb_silkscreen_rect: 50,\n  pcb_silkscreen_circle: 50,\n  pcb_silkscreen_line: 50,\n  pcb_component: 60,\n  pcb_fabrication_note_text: 70,\n  pcb_fabrication_note_path: 70,\n  pcb_fabrication_note_rect: 70,\n  pcb_fabrication_note_dimension: 70,\n  pcb_note_dimension: 70,\n  pcb_note_text: 70,\n  pcb_note_rect: 70,\n  pcb_note_path: 70,\n  pcb_note_line: 70,\n  pcb_trace_error: 80,\n  pcb_rats_nest: 85,\n}\n\nconst DEFAULT_TYPE_PRIORITY = 100\n\nexport function sortSvgObjectsByPcbLayer(objects: SvgObject[]): SvgObject[] {\n  return objects\n    .map((object, index) => ({\n      object,\n      index,\n      layerPriority: getLayerPriority(\n        object.attributes?.[\"data-pcb-layer\"] ?? undefined,\n      ),\n      typePriority: getTypePriority(\n        object.attributes?.[\"data-type\"] ?? undefined,\n      ),\n    }))\n    .sort((a, b) => {\n      if (a.layerPriority !== b.layerPriority) {\n        return a.layerPriority - b.layerPriority\n      }\n\n      if (a.typePriority !== b.typePriority) {\n        return a.typePriority - b.typePriority\n      }\n\n      return a.index - b.index\n    })\n    .map(({ object }) => object)\n}\n\nfunction getLayerPriority(layer?: string): number {\n  if (!layer) return 500\n\n  const normalized = layer.toLowerCase()\n  if (normalized === \"global\") return -100\n  if (normalized === \"bottom\") return 0\n  if (normalized === \"board\") return 2\n  if (normalized.startsWith(\"inner\")) {\n    const match = normalized.match(/\\d+/)\n    const layerIndex = match ? parseInt(match[0], 10) : 0\n    return 5 + layerIndex\n  }\n  if (normalized === \"through\") return 18\n  if (normalized === \"top\") return 17\n  if (normalized === \"drill\") return 30\n  if (normalized === \"overlay\") return 40\n\n  return 10\n}\n\nfunction getTypePriority(type?: string): number {\n  if (!type) return DEFAULT_TYPE_PRIORITY\n  return TYPE_PRIORITY[type] ?? DEFAULT_TYPE_PRIORITY\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\n\nexport function createErrorTextOverlay(\n  circuitJson: AnyCircuitElement[],\n  dataType: string = \"error_text_overlay\",\n): SvgObject | null {\n  const errorElms = circuitJson.filter((elm) =>\n    elm.type.endsWith(\"_error\"),\n  ) as Array<{ message?: string }>\n\n  if (errorElms.length === 0) {\n    return null\n  }\n\n  const errorMessages = errorElms\n    .map((e) => e.message)\n    .filter((m): m is string => !!m)\n\n  if (errorMessages.length === 0) {\n    return null\n  }\n\n  const textBlock: SvgObject = {\n    name: \"text\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      x: \"10\",\n      y: \"20\",\n      fill: \"red\",\n      \"font-family\": \"monospace\",\n      \"font-size\": \"12px\",\n      \"data-type\": dataType,\n      \"data-layer\": \"global\",\n    },\n    children: errorMessages.map((msg, i) => ({\n      name: \"tspan\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        x: \"10\",\n        dy: i === 0 ? \"0\" : \"1.2em\",\n      },\n      children: [\n        {\n          type: \"text\",\n          value: msg,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n    })),\n  }\n\n  return textBlock\n}\n","import type { Point, AnyCircuitElement } from \"circuit-json\"\nimport { type INode as SvgObject, stringify } from \"svgson\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport {\n  type Matrix,\n  applyToPoint,\n  compose,\n  scale,\n  translate,\n} from \"transformation-matrix\"\nimport { createSvgObjectsFromAssemblyBoard } from \"./svg-object-fns/create-svg-objects-from-assembly-board\"\nimport { createSvgObjectsFromAssemblyComponent } from \"./svg-object-fns/create-svg-objects-from-assembly-component\"\nimport { createSvgObjectsFromAssemblyHole } from \"./svg-object-fns/create-svg-objects-from-assembly-hole\"\nimport { createSvgObjectsFromAssemblyPlatedHole } from \"./svg-object-fns/create-svg-objects-from-assembly-plated-hole\"\nimport { createSvgObjectsFromAssemblySmtPad } from \"./svg-object-fns/create-svg-objects-from-assembly-smt-pad\"\nimport { getSoftwareUsedString } from \"../utils/get-software-used-string\"\nimport { CIRCUIT_TO_SVG_VERSION } from \"../package-version\"\nimport { createErrorTextOverlay } from \"../utils/create-error-text-overlay\"\n\nconst OBJECT_ORDER: AnyCircuitElement[\"type\"][] = [\n  \"pcb_component\",\n  \"pcb_smtpad\",\n  \"pcb_hole\",\n  \"pcb_plated_hole\",\n  \"pcb_board\",\n]\n\ninterface Options {\n  width?: number\n  height?: number\n  includeVersion?: boolean\n  showErrorsInTextOverlay?: boolean\n}\n\nexport interface AssemblySvgContext {\n  transform: Matrix\n}\n\nexport function convertCircuitJsonToAssemblySvg(\n  soup: AnyCircuitElement[],\n  options?: Options,\n): string {\n  let minX = Number.POSITIVE_INFINITY\n  let minY = Number.POSITIVE_INFINITY\n  let maxX = Number.NEGATIVE_INFINITY\n  let maxY = Number.NEGATIVE_INFINITY\n\n  // Process all elements to determine bounds\n  for (const item of soup) {\n    if (item.type === \"pcb_board\") {\n      const center = item.center\n      const width = item.width || 0\n      const height = item.height || 0\n      minX = Math.min(minX, center.x - width / 2)\n      minY = Math.min(minY, center.y - height / 2)\n      maxX = Math.max(maxX, center.x + width / 2)\n      maxY = Math.max(maxY, center.y + height / 2)\n    }\n  }\n\n  const padding = 1\n  const circuitWidth = maxX - minX + 2 * padding\n  const circuitHeight = maxY - minY + 2 * padding\n\n  const svgWidth = options?.width ?? 800\n  const svgHeight = options?.height ?? 600\n\n  const scaleX = svgWidth / circuitWidth\n  const scaleY = svgHeight / circuitHeight\n  const scaleFactor = Math.min(scaleX, scaleY)\n\n  const offsetX = (svgWidth - circuitWidth * scaleFactor) / 2\n  const offsetY = (svgHeight - circuitHeight * scaleFactor) / 2\n\n  const transform = compose(\n    translate(\n      offsetX - minX * scaleFactor + padding * scaleFactor,\n      svgHeight - offsetY + minY * scaleFactor - padding * scaleFactor,\n    ),\n    scale(scaleFactor, -scaleFactor), // Flip in y-direction\n  )\n\n  const ctx: AssemblySvgContext = { transform }\n\n  const svgObjects = soup\n    .sort(\n      (a, b) =>\n        (OBJECT_ORDER.indexOf(b.type) ?? 9999) -\n        (OBJECT_ORDER.indexOf(a.type) ?? 9999),\n    )\n    .flatMap((item) => createSvgObjects(item, ctx, soup))\n\n  const softwareUsedString = getSoftwareUsedString(soup)\n  const version = CIRCUIT_TO_SVG_VERSION\n\n  const children: SvgObject[] = [\n    {\n      name: \"style\",\n      type: \"element\",\n      children: [\n        {\n          type: \"text\",\n          value: `\n              .assembly-component { \n                fill: none; \n                stroke: #000; \n              }\n              .assembly-board { \n                fill: #f2f2f2; \n                stroke: rgb(0,0,0); \n                stroke-opacity: 0.8;\n              }\n              .assembly-component-label { \n                fill: #000; \n                font-family: Arial, serif;\n                font-weight: bold;\n                dominant-baseline: middle;\n                text-anchor: middle;\n              }\n              .assembly-boundary { \n                fill: none; \n                stroke: #fff;\n                stroke-width: 0.2; \n              }\n            `,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n      value: \"\",\n      attributes: {},\n    },\n    {\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        fill: \"#fff\",\n        x: \"0\",\n        y: \"0\",\n        width: svgWidth.toString(),\n        height: svgHeight.toString(),\n      },\n      value: \"\",\n      children: [],\n    },\n    createSvgObjectFromAssemblyBoundary(transform, minX, minY, maxX, maxY),\n    ...svgObjects,\n  ].filter((child): child is SvgObject => child !== null)\n\n  if (options?.showErrorsInTextOverlay) {\n    const errorOverlay = createErrorTextOverlay(soup)\n    if (errorOverlay) {\n      children.push(errorOverlay)\n    }\n  }\n\n  const svgObject: SvgObject = {\n    name: \"svg\",\n    type: \"element\",\n    attributes: {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n      ...(softwareUsedString && {\n        \"data-software-used-string\": softwareUsedString,\n      }),\n      ...(options?.includeVersion && {\n        \"data-circuit-to-svg-version\": version,\n      }),\n    },\n    value: \"\",\n    children,\n  }\n\n  return stringify(svgObject)\n}\n\nfunction createSvgObjects(\n  elm: AnyCircuitElement,\n  ctx: AssemblySvgContext,\n  soup: AnyCircuitElement[],\n): SvgObject[] {\n  const sourceComponents = su(soup).source_component.list()\n\n  switch (elm.type) {\n    case \"pcb_board\":\n      return createSvgObjectsFromAssemblyBoard(elm, ctx.transform)\n\n    case \"pcb_component\": {\n      const sourceComponent = sourceComponents.find(\n        (item) => item.source_component_id === elm.source_component_id,\n      )\n      const ports = su(soup)\n        .pcb_port.list()\n        .filter((port) => port.pcb_component_id === elm.pcb_component_id)\n      const firstPort = ports[0]\n\n      // Proceed only if both sourceComponent and firstPort are found\n      if (sourceComponent && firstPort) {\n        const arePinsInterchangeable = sourceComponent.are_pins_interchangeable\n        const obj = createSvgObjectsFromAssemblyComponent(\n          {\n            elm,\n            portPosition: { x: firstPort.x, y: firstPort.y },\n            name: sourceComponent.name,\n            arePinsInterchangeable,\n          },\n          ctx,\n        )\n        return obj ? [obj] : []\n      }\n\n      return []\n    }\n    case \"pcb_smtpad\":\n      return createSvgObjectsFromAssemblySmtPad(elm, ctx)\n    case \"pcb_hole\":\n      return createSvgObjectsFromAssemblyHole(elm, ctx)\n    case \"pcb_plated_hole\":\n      return createSvgObjectsFromAssemblyPlatedHole(elm, ctx)\n\n    default:\n      return []\n  }\n}\n\nfunction createSvgObjectFromAssemblyBoundary(\n  transform: Matrix,\n  minX: number,\n  minY: number,\n  maxX: number,\n  maxY: number,\n): SvgObject {\n  const [x1, y1] = applyToPoint(transform, [minX, minY])\n  const [x2, y2] = applyToPoint(transform, [maxX, maxY])\n  const width = Math.abs(x2 - x1)\n  const height = Math.abs(y2 - y1)\n  const x = Math.min(x1, x2)\n  const y = Math.min(y1, y2)\n  return {\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    children: [],\n    attributes: {\n      class: \"assembly-boundary\",\n      x: x.toString(),\n      y: y.toString(),\n      width: width.toString(),\n      height: height.toString(),\n    },\n  }\n}\n\nexport default convertCircuitJsonToAssemblySvg\n","import type { PCBBoard, Point } from \"circuit-json\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\n\ninterface BoardStyle {\n  fill: string\n  stroke: string\n  strokeOpacity: string\n  strokeWidthFactor: number\n}\n\nconst DEFAULT_BOARD_STYLE: BoardStyle = {\n  fill: \"none\",\n  stroke: \"rgb(0,0,0)\",\n  strokeOpacity: \"0.8\",\n  strokeWidthFactor: 0.2,\n}\n\nexport function createSvgObjectsFromAssemblyBoard(\n  pcbBoard: PCBBoard,\n  transform: Matrix,\n  style: Partial<BoardStyle> = {},\n): SvgObject[] {\n  const { width, height, center, outline } = pcbBoard\n\n  let path: string\n  if (outline && Array.isArray(outline) && outline.length >= 3) {\n    path = outline\n      .map((point: Point, index: number) => {\n        const [x, y] = applyToPoint(transform, [point.x, point.y])\n        return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`\n      })\n      .join(\" \")\n  } else {\n    const halfWidth = width! / 2\n    const halfHeight = height! / 2\n\n    const topLeft = applyToPoint(transform, [\n      center.x - halfWidth,\n      center.y - halfHeight,\n    ])\n    const topRight = applyToPoint(transform, [\n      center.x + halfWidth,\n      center.y - halfHeight,\n    ])\n    const bottomRight = applyToPoint(transform, [\n      center.x + halfWidth,\n      center.y + halfHeight,\n    ])\n    const bottomLeft = applyToPoint(transform, [\n      center.x - halfWidth,\n      center.y + halfHeight,\n    ])\n\n    path =\n      `M ${topLeft[0]} ${topLeft[1]} ` +\n      `L ${topRight[0]} ${topRight[1]} ` +\n      `L ${bottomRight[0]} ${bottomRight[1]} ` +\n      `L ${bottomLeft[0]} ${bottomLeft[1]}`\n  }\n\n  path += \" Z\"\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      children: [],\n      attributes: {\n        class: \"pcb-board\",\n        d: path,\n        fill: style.fill ?? DEFAULT_BOARD_STYLE.fill,\n        stroke: style.stroke ?? DEFAULT_BOARD_STYLE.stroke,\n        \"stroke-opacity\":\n          style.strokeOpacity ?? DEFAULT_BOARD_STYLE.strokeOpacity,\n        \"stroke-width\": (\n          (style.strokeWidthFactor ?? DEFAULT_BOARD_STYLE.strokeWidthFactor) *\n          Math.abs(transform.a)\n        ).toString(),\n      },\n    },\n  ]\n}\n","import type {\n  PcbComponent,\n  LayerRef,\n  Point,\n  AnyCircuitElement,\n} from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { type Matrix, applyToPoint } from \"transformation-matrix\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport type { AssemblySvgContext } from \"../convert-circuit-json-to-assembly-svg\"\n\nexport interface AssemblyComponentParams {\n  elm: AnyCircuitElement\n  portPosition: { x: number; y: number }\n  name: string\n  arePinsInterchangeable?: boolean\n}\n\ninterface ComponentProps {\n  center: Point\n  width: number\n  height: number\n  rotation?: number\n  layer?: LayerRef\n}\n\nexport function createSvgObjectsFromAssemblyComponent(\n  params: AssemblyComponentParams,\n  ctx: AssemblySvgContext,\n): SvgObject | null {\n  const { elm, portPosition, name, arePinsInterchangeable } = params\n  const { transform } = ctx\n  const { center, width, height, rotation = 0, layer = \"top\" } = elm as any\n  if (!center || typeof width !== \"number\" || typeof height !== \"number\")\n    return null\n  const [x, y] = applyToPoint(transform, [center.x, center.y])\n  const [pinX, pinY] = applyToPoint(transform, [portPosition.x, portPosition.y])\n  const scaledWidth = width * Math.abs(transform.a)\n  const scaledHeight = height * Math.abs(transform.d)\n\n  const isTopLayer = layer === \"top\"\n  const isPinTop = pinY > y\n  const isPinLeft = pinX < x\n\n  const children: SvgObject[] = [\n    createComponentPath(scaledWidth, scaledHeight, rotation, layer),\n    createComponentLabel(scaledWidth, scaledHeight, name ?? \"\", transform),\n  ]\n\n  if (!arePinsInterchangeable) {\n    children.push(\n      createPin1Indicator(\n        scaledWidth,\n        scaledHeight,\n        rotation,\n        layer,\n        isPinTop,\n        isPinLeft,\n      ),\n    )\n  }\n\n  return {\n    name: \"g\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      transform: `translate(${x}, ${y}) scale(1, -1)`,\n    },\n    children,\n  }\n}\n\nfunction createComponentPath(\n  scaledWidth: number,\n  scaledHeight: number,\n  rotation: number,\n  layer: LayerRef,\n): SvgObject {\n  const w = scaledWidth / 2\n  const h = scaledHeight / 2\n  const strokeWidth = 0.8\n  const path = getRectPathData(w, h, rotation)\n\n  return {\n    name: \"path\",\n    type: \"element\",\n    attributes: {\n      class: \"assembly-component\",\n      d: path,\n      \"stroke-width\": strokeWidth.toFixed(2),\n      transform: `rotate(${-rotation})`,\n      \"stroke-dasharray\": layer === \"bottom\" ? \"2,2\" : \"\",\n    },\n    value: \"\",\n    children: [],\n  }\n}\n\nfunction createComponentLabel(\n  scaledWidth: number,\n  scaledHeight: number,\n  name: string,\n  transform: Matrix,\n): SvgObject {\n  // Use the smaller dimension as the scale factor\n  const size = Math.min(scaledWidth, scaledHeight)\n\n  // Adjusted font sizing with smaller scale for small components\n  const minFontSize = 3\n  const maxFontSize = 58\n  const fontScale = 0.8 // Smaller scale for small components\n  const fontSize = Math.min(\n    maxFontSize,\n    Math.max(minFontSize, size * fontScale),\n  )\n\n  // Determine if component is tall (height significantly larger than width)\n  const isTall = scaledHeight > scaledWidth\n\n  return {\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      x: \"0\",\n      y: \"0\",\n      class: \"assembly-component-label\",\n      \"text-anchor\": \"middle\",\n      dy: \".10em\",\n      style: \"pointer-events: none\",\n      \"font-size\": `${fontSize.toFixed(1)}px`,\n      transform: isTall ? \"rotate(90) scale(1, -1)\" : \"scale(1, -1)\",\n    },\n    children: [\n      {\n        type: \"text\",\n        value: name || \"\",\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  }\n}\n\nfunction createPin1Indicator(\n  scaledWidth: number,\n  scaledHeight: number,\n  rotation: number,\n  layer: LayerRef,\n  isPinTop: boolean,\n  isPinLeft: boolean,\n): SvgObject {\n  const w = scaledWidth / 2\n  const h = scaledHeight / 2\n  const indicatorSize = Math.min(w, h) * 0.5\n\n  let points: [number, number][]\n\n  if (isPinTop && isPinLeft) {\n    // Top-left corner\n    points = [\n      [-w, -h], // Corner point\n      [-w + indicatorSize, -h], // Point along top edge\n      [-w, -h + indicatorSize], // Point along left edge\n    ]\n  } else if (isPinTop && !isPinLeft) {\n    // Top-right corner\n    points = [\n      [w, -h], // Corner point\n      [w - indicatorSize, -h], // Point along top edge\n      [w, -h + indicatorSize], // Point along right edge\n    ]\n  } else if (!isPinTop && isPinLeft) {\n    // Bottom-left corner\n    points = [\n      [-w, h], // Corner point\n      [-w + indicatorSize, h], // Point along bottom edge\n      [-w, h - indicatorSize], // Point along left edge\n    ]\n  } else {\n    // Bottom-right corner\n    points = [\n      [w, h], // Corner point\n      [w - indicatorSize, h], // Point along bottom edge\n      [w, h - indicatorSize], // Point along right edge\n    ]\n  }\n\n  const pointsString = points.map((p) => p.join(\",\")).join(\" \")\n\n  return {\n    name: \"polygon\",\n    type: \"element\",\n    attributes: {\n      class: \"assembly-pin1-indicator\",\n      points: pointsString,\n      fill: \"#333\",\n      stroke: \"none\",\n      transform: `rotate(${-rotation})`,\n    },\n    value: \"\",\n    children: [],\n  }\n}\n\nfunction getRectPathData(w: number, h: number, rotation: number): string {\n  const rotatePoint = (\n    x: number,\n    y: number,\n    angle: number,\n  ): [number, number] => {\n    const rad = (Math.PI / 180) * angle\n    const cos = Math.cos(rad)\n    const sin = Math.sin(rad)\n    return [x * cos - y * sin, x * sin + y * cos]\n  }\n\n  const corners: [number, number][] = [\n    [-w, -h],\n    [w, -h],\n    [w, h],\n    [-w, h],\n  ]\n\n  const rotatedCorners = corners.map(([x, y]) => rotatePoint(x, y, rotation))\n\n  const path = rotatedCorners\n    .map(([x, y], i) => (i === 0 ? `M${x},${y}` : `L${x},${y}`))\n    .join(\" \")\n  return `${path} Z`\n}\n","import type { Matrix } from \"transformation-matrix\"\nimport { applyToPoint } from \"transformation-matrix\"\n\ntype SchTextType =\n  | \"pin_number\"\n  | \"negated_pin_number\"\n  | \"reference_designator\"\n  | \"manufacturer_number\"\n  | \"net_label\"\n  | \"error\"\n\nconst fontSizeMap: Record<SchTextType, number> = {\n  pin_number: 0.15,\n  negated_pin_number: 0.15 * 0.8,\n  reference_designator: 0.18,\n  manufacturer_number: 0.18,\n  net_label: 0.18,\n  error: 0.05,\n}\n\nexport const getSchMmFontSize = (textType: SchTextType, fontSize?: number) => {\n  return fontSize ?? fontSizeMap[textType]\n}\n\nexport const getSchScreenFontSize = (\n  transform: Matrix,\n  textType: SchTextType,\n  fontSize?: number,\n) => {\n  return Math.abs(transform.a) * getSchMmFontSize(textType, fontSize)\n}\n","import type { PCBHole } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { AssemblySvgContext } from \"../convert-circuit-json-to-assembly-svg\"\n\nconst HOLE_COLOR = \"rgb(190, 190, 190)\" // Darker gray for holes\n\nexport function createSvgObjectsFromAssemblyHole(\n  hole: PCBHole,\n  ctx: AssemblySvgContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n\n  if (hole.hole_shape === \"circle\" || hole.hole_shape === \"square\") {\n    const scaledDiameter = hole.hole_diameter * Math.abs(transform.a)\n    const radius = scaledDiameter / 2\n\n    if (hole.hole_shape === \"circle\") {\n      return [\n        {\n          name: \"circle\",\n          type: \"element\",\n          attributes: {\n            class: \"assembly-hole\",\n            cx: x.toString(),\n            cy: y.toString(),\n            r: radius.toString(),\n            fill: HOLE_COLOR,\n          },\n          children: [],\n          value: \"\",\n        },\n      ]\n    }\n    // Square hole\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-hole\",\n          x: (x - radius).toString(),\n          y: (y - radius).toString(),\n          width: scaledDiameter.toString(),\n          height: scaledDiameter.toString(),\n          fill: HOLE_COLOR,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n  if (hole.hole_shape === \"oval\") {\n    const scaledWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHeight = hole.hole_height * Math.abs(transform.a)\n    const rx = scaledWidth / 2\n    const ry = scaledHeight / 2\n\n    return [\n      {\n        name: \"ellipse\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-hole\",\n          cx: x.toString(),\n          cy: y.toString(),\n          rx: rx.toString(),\n          ry: ry.toString(),\n          fill: HOLE_COLOR,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n  return []\n}\n","import type {\n  PCBPlatedHole,\n  PcbHoleCircularWithRectPad,\n  PcbHolePillWithRectPad,\n  PcbHoleRotatedPillWithRectPad,\n} from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { AssemblySvgContext } from \"../convert-circuit-json-to-assembly-svg\"\n\nconst PAD_COLOR = \"rgb(210, 210, 210)\" // Lighter gray for pads\nconst HOLE_COLOR = \"rgb(190, 190, 190)\" // Darker gray for holes\n\ntype HoleWithRectPadOffsets = {\n  hole_offset_x?: number\n  hole_offset_y?: number\n}\n\nexport function createSvgObjectsFromAssemblyPlatedHole(\n  hole: PCBPlatedHole,\n  ctx: AssemblySvgContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n\n  if (hole.shape === \"pill\") {\n    const scaledOuterWidth = hole.outer_width * Math.abs(transform.a)\n    const scaledOuterHeight = hole.outer_height * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a)\n\n    const outerRadiusX = scaledOuterWidth / 2\n    const straightLength = scaledOuterHeight - scaledOuterWidth\n    const innerRadiusX = scaledHoleWidth / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Outer pill shape\n          {\n            name: \"path\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-outer\",\n              fill: PAD_COLOR,\n              d:\n                `M${x - outerRadiusX},${y - straightLength / 2} ` +\n                `v${straightLength} ` +\n                `a${outerRadiusX},${outerRadiusX} 0 0 0 ${scaledOuterWidth},0 ` +\n                `v-${straightLength} ` +\n                `a${outerRadiusX},${outerRadiusX} 0 0 0 -${scaledOuterWidth},0 z`,\n            },\n            value: \"\",\n            children: [],\n          },\n          // Inner pill shape\n          {\n            name: \"path\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-inner\",\n              fill: HOLE_COLOR,\n              d:\n                `M${x - innerRadiusX},${y - (scaledHoleHeight - scaledHoleWidth) / 2} ` +\n                `v${scaledHoleHeight - scaledHoleWidth} ` +\n                `a${innerRadiusX},${innerRadiusX} 0 0 0 ${scaledHoleWidth},0 ` +\n                `v-${scaledHoleHeight - scaledHoleWidth} ` +\n                `a${innerRadiusX},${innerRadiusX} 0 0 0 -${scaledHoleWidth},0 z`,\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  // Fallback to circular hole if not pill-shaped\n  if (hole.shape === \"circle\") {\n    const scaledOuterWidth = hole.outer_diameter * Math.abs(transform.a)\n    const scaledOuterHeight = hole.outer_diameter * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_diameter * Math.abs(transform.a)\n    const scaledHoleHeight = hole.hole_diameter * Math.abs(transform.a)\n\n    const outerRadius = Math.min(scaledOuterWidth, scaledOuterHeight) / 2\n    const innerRadius = Math.min(scaledHoleWidth, scaledHoleHeight) / 2\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-outer\",\n              fill: PAD_COLOR,\n              cx: x.toString(),\n              cy: y.toString(),\n              r: outerRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-inner\",\n              fill: HOLE_COLOR,\n              cx: x.toString(),\n              cy: y.toString(),\n              r: innerRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  // Handle circular hole with rectangular pad (hole is circle, outer pad is rectangle)\n  if (hole.shape === \"circular_hole_with_rect_pad\") {\n    const circularHole = hole as PcbHoleCircularWithRectPad\n    const scaledHoleDiameter =\n      circularHole.hole_diameter * Math.abs(transform.a)\n    const scaledRectPadWidth =\n      circularHole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight =\n      circularHole.rect_pad_height * Math.abs(transform.a)\n    const scaledRectBorderRadius =\n      (circularHole.rect_border_radius ?? 0) * Math.abs(transform.a)\n\n    const holeRadius = scaledHoleDiameter / 2\n    const [holeCx, holeCy] = applyToPoint(transform, [\n      circularHole.x + circularHole.hole_offset_x,\n      circularHole.y + circularHole.hole_offset_y,\n    ])\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Rectangular pad (outer shape)\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-outer-pad\",\n              fill: PAD_COLOR,\n              x: (x - scaledRectPadWidth / 2).toString(),\n              y: (y - scaledRectPadHeight / 2).toString(),\n              width: scaledRectPadWidth.toString(),\n              height: scaledRectPadHeight.toString(),\n              ...(scaledRectBorderRadius\n                ? {\n                    rx: scaledRectBorderRadius.toString(),\n                    ry: scaledRectBorderRadius.toString(),\n                  }\n                : {}),\n            },\n            value: \"\",\n            children: [],\n          },\n          // Circular hole inside the rectangle\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-inner\",\n              fill: HOLE_COLOR,\n              cx: holeCx.toString(),\n              cy: holeCy.toString(),\n              r: holeRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n  if (hole.shape === \"pill_hole_with_rect_pad\") {\n    const pillHole = hole as PcbHolePillWithRectPad\n    const scaledRectPadWidth = pillHole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight = pillHole.rect_pad_height * Math.abs(transform.a)\n    const scaledRectBorderRadius =\n      (pillHole.rect_border_radius ?? 0) * Math.abs(transform.a)\n\n    const scaledHoleHeight = pillHole.hole_height * Math.abs(transform.a)\n    const scaledHoleWidth = pillHole.hole_width * Math.abs(transform.a)\n\n    const pillHoleWithOffsets = pillHole as PcbHolePillWithRectPad &\n      HoleWithRectPadOffsets\n    const holeOffsetX = pillHoleWithOffsets.hole_offset_x ?? 0\n    const holeOffsetY = pillHoleWithOffsets.hole_offset_y ?? 0\n    const [holeCenterX, holeCenterY] = applyToPoint(transform, [\n      pillHole.x + holeOffsetX,\n      pillHole.y + holeOffsetY,\n    ])\n\n    // Use the minimum of scaledHoleHeight and scaledHoleWidth for the radius\n    const holeRadius = Math.min(scaledHoleHeight, scaledHoleWidth) / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Rectangular pad (outer shape)\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-outer-pad\",\n              fill: PAD_COLOR,\n              x: (x - scaledRectPadWidth / 2).toString(),\n              y: (y - scaledRectPadHeight / 2).toString(),\n              width: scaledRectPadWidth.toString(),\n              height: scaledRectPadHeight.toString(),\n              ...(scaledRectBorderRadius\n                ? {\n                    rx: scaledRectBorderRadius.toString(),\n                    ry: scaledRectBorderRadius.toString(),\n                  }\n                : {}),\n            },\n            value: \"\",\n            children: [],\n          },\n          // pill hole inside the rectangle\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-inner\",\n              fill: HOLE_COLOR,\n              x: (holeCenterX - scaledHoleWidth / 2).toString(),\n              y: (holeCenterY - scaledHoleHeight / 2).toString(),\n              width: scaledHoleWidth.toString(),\n              height: scaledHoleHeight.toString(),\n              rx: holeRadius.toString(),\n              ry: holeRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  if (hole.shape === \"rotated_pill_hole_with_rect_pad\") {\n    const rotatedHole = hole as PcbHoleRotatedPillWithRectPad\n    const scaledRectPadWidth =\n      rotatedHole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight =\n      rotatedHole.rect_pad_height * Math.abs(transform.a)\n    const scaledRectBorderRadius =\n      (rotatedHole.rect_border_radius ?? 0) * Math.abs(transform.a)\n\n    const scaledHoleHeight = rotatedHole.hole_height * Math.abs(transform.a)\n    const scaledHoleWidth = rotatedHole.hole_width * Math.abs(transform.a)\n\n    const rotatedHoleWithOffsets =\n      rotatedHole as PcbHoleRotatedPillWithRectPad & HoleWithRectPadOffsets\n    const holeOffsetX = rotatedHoleWithOffsets.hole_offset_x ?? 0\n    const holeOffsetY = rotatedHoleWithOffsets.hole_offset_y ?? 0\n    const [holeCenterX, holeCenterY] = applyToPoint(transform, [\n      rotatedHole.x + holeOffsetX,\n      rotatedHole.y + holeOffsetY,\n    ])\n\n    const holeRadius = Math.min(scaledHoleHeight, scaledHoleWidth) / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-outer-pad\",\n              fill: PAD_COLOR,\n              x: (-scaledRectPadWidth / 2).toString(),\n              y: (-scaledRectPadHeight / 2).toString(),\n              width: scaledRectPadWidth.toString(),\n              height: scaledRectPadHeight.toString(),\n              transform: `translate(${x} ${y}) rotate(${-rotatedHole.rect_ccw_rotation})`,\n              ...(scaledRectBorderRadius\n                ? {\n                    rx: scaledRectBorderRadius.toString(),\n                    ry: scaledRectBorderRadius.toString(),\n                  }\n                : {}),\n            },\n            value: \"\",\n            children: [],\n          },\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-inner\",\n              fill: HOLE_COLOR,\n              x: (-scaledHoleWidth / 2).toString(),\n              y: (-scaledHoleHeight / 2).toString(),\n              width: scaledHoleWidth.toString(),\n              height: scaledHoleHeight.toString(),\n              rx: holeRadius.toString(),\n              ry: holeRadius.toString(),\n              transform: `translate(${holeCenterX} ${holeCenterY}) rotate(${-rotatedHole.hole_ccw_rotation})`,\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  return []\n}\n","import type { PcbSmtPad } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { AssemblySvgContext } from \"../convert-circuit-json-to-assembly-svg\"\n\nconst PAD_COLOR = \"rgb(210, 210, 210)\" // Lighter gray for pads\n\nexport function createSvgObjectsFromAssemblySmtPad(\n  pad: PcbSmtPad,\n  ctx: AssemblySvgContext,\n): SvgObject[] {\n  const { transform } = ctx\n\n  if (pad.shape === \"rect\" || pad.shape === \"rotated_rect\") {\n    const width = pad.width * Math.abs(transform.a)\n    const height = pad.height * Math.abs(transform.d)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n    const scaledBorderRadius =\n      ((pad as any).rect_border_radius ?? 0) * Math.abs(transform.a)\n\n    if (pad.shape === \"rotated_rect\" && pad.ccw_rotation) {\n      return [\n        {\n          name: \"rect\",\n          type: \"element\",\n          attributes: {\n            class: \"assembly-pad\",\n            fill: PAD_COLOR,\n            x: (-width / 2).toString(),\n            y: (-height / 2).toString(),\n            width: width.toString(),\n            height: height.toString(),\n            transform: `translate(${x} ${y}) rotate(${-pad.ccw_rotation})`,\n            \"data-layer\": pad.layer,\n            ...(scaledBorderRadius\n              ? {\n                  rx: scaledBorderRadius.toString(),\n                  ry: scaledBorderRadius.toString(),\n                }\n              : {}),\n          },\n          value: \"\",\n          children: [],\n        },\n      ]\n    }\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-pad\",\n          fill: PAD_COLOR,\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          \"data-layer\": pad.layer,\n          ...(scaledBorderRadius\n            ? {\n                rx: scaledBorderRadius.toString(),\n                ry: scaledBorderRadius.toString(),\n              }\n            : {}),\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n\n  if (pad.shape === \"pill\") {\n    const width = pad.width * Math.abs(transform.a)\n    const height = pad.height * Math.abs(transform.d)\n    const radius = pad.radius * Math.abs(transform.a)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-pad\",\n          fill: PAD_COLOR,\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          rx: radius.toString(),\n          ry: radius.toString(),\n          \"data-layer\": pad.layer,\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n  if (pad.shape === \"circle\") {\n    const radius = pad.radius * Math.abs(transform.a)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    return [\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-pad\",\n          fill: PAD_COLOR,\n          cx: x.toString(),\n          cy: y.toString(),\n          r: radius.toString(),\n          \"data-layer\": pad.layer,\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n\n  if (pad.shape === \"polygon\") {\n    const points = (pad.points ?? []).map((point) =>\n      applyToPoint(transform, [point.x, point.y]),\n    )\n\n    return [\n      {\n        name: \"polygon\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-pad\",\n          fill: PAD_COLOR,\n          points: points.map((p) => p.join(\",\")).join(\" \"),\n          \"data-layer\": pad.layer,\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n\n  return []\n}\n","import type { AnyCircuitElement, PcbPort, SourceBoard } from \"circuit-json\"\nimport { type INode as SvgObject, stringify } from \"svgson\"\nimport {\n  type Matrix,\n  compose,\n  scale as matrixScale,\n  translate,\n} from \"transformation-matrix\"\nimport { createSvgObjectsFromPinoutBoard } from \"./svg-object-fns/create-svg-objects-from-pinout-board\"\nimport { createSvgObjectsFromPinoutComponent } from \"./svg-object-fns/create-svg-objects-from-pinout-component\"\nimport { createSvgObjectsFromPinoutHole } from \"./svg-object-fns/create-svg-objects-from-pinout-hole\"\nimport { createSvgObjectsFromPinoutPlatedHole } from \"./svg-object-fns/create-svg-objects-from-pinout-plated-hole\"\nimport { createSvgObjectsFromPinoutSmtPad } from \"./svg-object-fns/create-svg-objects-from-pinout-smt-pad\"\nimport { createSvgObjectsFromPinoutPort } from \"./svg-object-fns/create-svg-objects-from-pinout-port\"\nimport { getSoftwareUsedString } from \"../utils/get-software-used-string\"\nimport { CIRCUIT_TO_SVG_VERSION } from \"../package-version\"\nimport { createErrorTextOverlay } from \"../utils/create-error-text-overlay\"\nimport {\n  calculateLabelPositions,\n  type LabelPosition,\n} from \"./calculate-label-positions\"\nimport { getClosestEdge, getPortLabelInfo } from \"./pinout-utils\"\nimport {\n  LABEL_RECT_HEIGHT_BASE_MM,\n  CHAR_WIDTH_FACTOR,\n  FONT_HEIGHT_RATIO,\n  STAGGER_OFFSET_MIN,\n  STAGGER_OFFSET_PER_PIN,\n  STAGGER_OFFSET_STEP,\n  ALIGNED_OFFSET_MARGIN,\n} from \"./constants\"\n\nconst OBJECT_ORDER: AnyCircuitElement[\"type\"][] = [\n  \"pcb_board\",\n  \"pcb_smtpad\",\n  \"pcb_hole\",\n  \"pcb_plated_hole\",\n  \"pcb_component\",\n  \"pcb_port\",\n]\n\ninterface Options {\n  width?: number\n  height?: number\n  includeVersion?: boolean\n  showErrorsInTextOverlay?: boolean\n}\n\nexport interface PinoutLabel {\n  pcb_port: PcbPort\n  aliases: string[]\n  edge: \"left\" | \"right\" | \"top\" | \"bottom\"\n}\n\nexport interface PinoutSvgContext {\n  transform: Matrix\n  soup: AnyCircuitElement[]\n  board_bounds: { minX: number; minY: number; maxX: number; maxY: number }\n  styleScale: number\n  label_positions: Map<string, LabelPosition>\n  svgWidth: number\n  svgHeight: number\n}\n\nexport function convertCircuitJsonToPinoutSvg(\n  soup: AnyCircuitElement[],\n  options?: Options,\n): string {\n  let minX = Number.POSITIVE_INFINITY\n  let minY = Number.POSITIVE_INFINITY\n  let maxX = Number.NEGATIVE_INFINITY\n  let maxY = Number.NEGATIVE_INFINITY\n\n  // Process all elements to determine bounds\n  for (const item of soup) {\n    if (item.type === \"pcb_board\") {\n      if (\n        \"outline\" in item &&\n        item.outline &&\n        Array.isArray(item.outline) &&\n        item.outline.length > 0\n      ) {\n        for (const point of item.outline) {\n          minX = Math.min(minX, point.x)\n          minY = Math.min(minY, point.y)\n          maxX = Math.max(maxX, point.x)\n          maxY = Math.max(maxY, point.y)\n        }\n      } else {\n        const center = item.center\n        const width = item.width || 0\n        const height = item.height || 0\n        minX = Math.min(minX, center.x - width / 2)\n        minY = Math.min(minY, center.y - height / 2)\n        maxX = Math.max(maxX, center.x + width / 2)\n        maxY = Math.max(maxY, center.y + height / 2)\n      }\n    }\n  }\n\n  const paddingMm = 2\n\n  let svgWidth = options?.width ?? 1200\n  let svgHeight = options?.height ?? 768\n\n  const boardTitle = soup.find(\n    (e): e is SourceBoard => e.type === \"source_board\" && !!e.title,\n  )?.title\n\n  const board_bounds = { minX, minY, maxX, maxY }\n  const pinout_ports = soup.filter(\n    (elm): elm is PcbPort =>\n      elm.type === \"pcb_port\" && (elm as any).is_board_pinout,\n  )\n\n  const pinout_labels: PinoutLabel[] = []\n  for (const pcb_port of pinout_ports) {\n    const label_info = getPortLabelInfo(pcb_port, soup)\n    if (!label_info) continue\n\n    const edge = getClosestEdge({ x: pcb_port.x, y: pcb_port.y }, board_bounds)\n\n    pinout_labels.push({\n      pcb_port,\n      aliases: [label_info.text, ...label_info.aliases],\n      edge,\n    })\n  }\n\n  const left_labels = pinout_labels.filter((p) => p.edge === \"left\")\n  const right_labels = pinout_labels.filter((p) => p.edge === \"right\")\n  const top_labels = pinout_labels.filter((p) => p.edge === \"top\")\n  const bottom_labels = pinout_labels.filter((p) => p.edge === \"bottom\")\n\n  const boardCenterX = (minX + maxX) / 2\n\n  if (top_labels.length > 0) {\n    const top_left_count = top_labels.filter(\n      (p) => p.pcb_port.x < boardCenterX,\n    ).length\n    if (top_left_count > top_labels.length / 2) {\n      left_labels.push(...top_labels)\n    } else {\n      right_labels.push(...top_labels)\n    }\n  }\n\n  if (bottom_labels.length > 0) {\n    const bottom_left_count = bottom_labels.filter(\n      (p) => p.pcb_port.x < boardCenterX,\n    ).length\n    if (bottom_left_count > bottom_labels.length / 2) {\n      left_labels.push(...bottom_labels)\n    } else {\n      right_labels.push(...bottom_labels)\n    }\n  }\n\n  // Determine visual style scale (unitless) based on typical pad size in mm.\n  const smtPads = soup.filter((e) => e.type === \"pcb_smtpad\") as any[]\n  const padMinorDimensionsMm: number[] = smtPads\n    .map((p) => {\n      if (typeof (p as any).height === \"number\")\n        return (p as any).height as number\n      if (typeof (p as any).radius === \"number\")\n        return ((p as any).radius as number) * 2\n      return undefined\n    })\n    .filter((v): v is number => Number.isFinite(v))\n\n  const averagePadMinorMm = padMinorDimensionsMm.length\n    ? padMinorDimensionsMm.reduce((a, b) => a + b, 0) /\n      padMinorDimensionsMm.length\n    : undefined\n\n  const BASELINE_PAD_MINOR_MM = 1.0\n  const styleScale = averagePadMinorMm\n    ? Math.max(0.5, Math.min(1, averagePadMinorMm / BASELINE_PAD_MINOR_MM))\n    : 1\n\n  // Compute additional horizontal space (in mm) required for labels on each side\n  const LABEL_RECT_HEIGHT_MM = LABEL_RECT_HEIGHT_BASE_MM * styleScale\n\n  function tokenize(label: PinoutLabel): string[] {\n    const tokens = [...(label.aliases ?? [])]\n    if (tokens.length === 0) return tokens\n    const m = /^pin(\\d+)$/i.exec(tokens[0]!)\n    if (m) tokens[0] = m[1]!\n    return tokens\n  }\n\n  function getTotalTokenWidthMm(tokens: string[]): number {\n    if (tokens.length === 0) return 0\n    const rectHeightMm = LABEL_RECT_HEIGHT_MM\n    const fontSizeMm = rectHeightMm * FONT_HEIGHT_RATIO\n    const bgPaddingMm = (rectHeightMm - fontSizeMm) / 2\n    const gapMm = bgPaddingMm\n\n    const tokenWidthsMm = tokens.map((t) => {\n      const safe = t ?? \"\"\n      const textWidthMm = safe.length * fontSizeMm * CHAR_WIDTH_FACTOR\n      return textWidthMm + 2 * bgPaddingMm\n    })\n\n    const totalWidthMm =\n      tokenWidthsMm.reduce((a, b) => a + b, 0) +\n      gapMm * Math.max(0, tokens.length - 1)\n\n    return totalWidthMm\n  }\n\n  function getAlignedOffsetMm(count: number): number {\n    if (count <= 0) return 0\n    const geometric_middle_index = (count - 1) / 2\n    const stagger_base =\n      (STAGGER_OFFSET_MIN + count * STAGGER_OFFSET_PER_PIN) * styleScale\n    const max_stagger =\n      stagger_base + geometric_middle_index * (STAGGER_OFFSET_STEP * styleScale)\n    return max_stagger + ALIGNED_OFFSET_MARGIN * styleScale\n  }\n\n  const leftMaxLabelWidthMm = Math.max(\n    0,\n    ...left_labels.map((l) => getTotalTokenWidthMm(tokenize(l))),\n  )\n  const rightMaxLabelWidthMm = Math.max(\n    0,\n    ...right_labels.map((l) => getTotalTokenWidthMm(tokenize(l))),\n  )\n\n  const extraLeftMm =\n    getAlignedOffsetMm(left_labels.length) + leftMaxLabelWidthMm\n  const extraRightMm =\n    getAlignedOffsetMm(right_labels.length) + rightMaxLabelWidthMm\n\n  const expandedMinX = minX - extraLeftMm\n  const expandedMaxX = maxX + extraRightMm\n\n  const circuitWidth = expandedMaxX - expandedMinX + 2 * paddingMm\n  const circuitHeight = maxY - minY + 2 * paddingMm\n\n  const pxPerMmX = svgWidth / circuitWidth\n  const pxPerMmY = svgHeight / circuitHeight\n  const pxPerMm = Math.min(pxPerMmX, pxPerMmY) // mm-to-px scale from transform\n  const offsetX = (svgWidth - circuitWidth * pxPerMm) / 2\n  const offsetY = (svgHeight - circuitHeight * pxPerMm) / 2\n\n  const transform = compose(\n    translate(\n      offsetX - expandedMinX * pxPerMm + paddingMm * pxPerMm,\n      svgHeight - offsetY + minY * pxPerMm - paddingMm * pxPerMm,\n    ),\n    matrixScale(pxPerMm, -pxPerMm),\n  )\n\n  const label_positions = calculateLabelPositions({\n    left_labels,\n    right_labels,\n    transform,\n    soup,\n    board_bounds,\n    svgWidth,\n    svgHeight,\n    styleScale,\n  })\n\n  const ctx: PinoutSvgContext = {\n    transform,\n    soup,\n    board_bounds,\n    styleScale,\n    label_positions,\n    svgWidth,\n    svgHeight,\n  }\n\n  const svgObjects = soup\n    .sort(\n      (a, b) =>\n        (OBJECT_ORDER.indexOf(a.type) ?? 9999) -\n        (OBJECT_ORDER.indexOf(b.type) ?? 9999),\n    )\n    .flatMap((item) => createSvgObjects(item, ctx, soup))\n\n  const softwareUsedString = getSoftwareUsedString(soup)\n  const version = CIRCUIT_TO_SVG_VERSION\n\n  const children: SvgObject[] = [\n    {\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        fill: \"rgb(255, 255, 255)\",\n        x: \"0\",\n        y: \"0\",\n        width: svgWidth.toString(),\n        height: svgHeight.toString(),\n      },\n      value: \"\",\n      children: [],\n    },\n    ...svgObjects,\n  ].filter((child): child is SvgObject => child !== null)\n\n  if (options?.showErrorsInTextOverlay) {\n    const errorOverlay = createErrorTextOverlay(soup)\n    if (errorOverlay) {\n      children.push(errorOverlay)\n    }\n  }\n\n  const svgObject: SvgObject = {\n    name: \"svg\",\n    type: \"element\",\n    attributes: {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n      ...(softwareUsedString && {\n        \"data-software-used-string\": softwareUsedString,\n      }),\n      ...(options?.includeVersion && {\n        \"data-circuit-to-svg-version\": version,\n      }),\n    },\n    value: \"\",\n    children,\n  }\n\n  return stringify(svgObject)\n}\n\nfunction createSvgObjects(\n  elm: AnyCircuitElement,\n  ctx: PinoutSvgContext,\n  soup: AnyCircuitElement[],\n): SvgObject[] {\n  switch (elm.type) {\n    case \"pcb_board\":\n      return createSvgObjectsFromPinoutBoard(elm, ctx)\n\n    case \"pcb_component\":\n      return createSvgObjectsFromPinoutComponent(elm, ctx)\n    case \"pcb_smtpad\":\n      return createSvgObjectsFromPinoutSmtPad(elm, ctx)\n    case \"pcb_hole\":\n      return createSvgObjectsFromPinoutHole(elm, ctx)\n    case \"pcb_plated_hole\":\n      return createSvgObjectsFromPinoutPlatedHole(elm, ctx)\n    case \"pcb_port\":\n      if ((elm as any).is_board_pinout) {\n        return createSvgObjectsFromPinoutPort(elm, ctx)\n      }\n      return []\n    default:\n      return []\n  }\n}\n\nexport default convertCircuitJsonToPinoutSvg\n","import type {\n  AnyCircuitElement,\n  PCBBoard,\n  Point,\n  SourceBoard,\n} from \"circuit-json\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport type { PinoutSvgContext } from \"../convert-circuit-json-to-pinout-svg\"\n\ninterface BoardStyle {\n  fill: string\n  stroke: string\n  strokeOpacity: string\n  strokeWidthFactor: number\n}\n\nconst BOARD_FILL_COLOR = \"rgb(26, 115, 143)\" // Nice blue/teal color\nconst BOARD_STROKE_COLOR = \"rgba(0,0,0,0.9)\"\n\nexport function createSvgObjectsFromPinoutBoard(\n  pcbBoard: PCBBoard,\n  ctx: PinoutSvgContext,\n): SvgObject[] {\n  const { transform, soup } = ctx\n  const { width, height, center, outline } = pcbBoard\n\n  const sourceBoard = soup.find(\n    (elm) => elm.type === \"source_board\" && (elm as any).title,\n  ) as SourceBoard\n  const title = sourceBoard?.title\n\n  let path: string\n  if (outline && Array.isArray(outline) && outline.length >= 3) {\n    path = outline\n      .map((point: Point, index: number) => {\n        const [x, y] = applyToPoint(transform, [point.x, point.y])\n        return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`\n      })\n      .join(\" \")\n  } else {\n    const halfWidth = width! / 2\n    const halfHeight = height! / 2\n\n    const topLeft = applyToPoint(transform, [\n      center.x - halfWidth,\n      center.y - halfHeight,\n    ])\n    const topRight = applyToPoint(transform, [\n      center.x + halfWidth,\n      center.y - halfHeight,\n    ])\n    const bottomRight = applyToPoint(transform, [\n      center.x + halfWidth,\n      center.y + halfHeight,\n    ])\n    const bottomLeft = applyToPoint(transform, [\n      center.x - halfWidth,\n      center.y + halfHeight,\n    ])\n\n    path =\n      `M ${topLeft[0]} ${topLeft[1]} ` +\n      `L ${topRight[0]} ${topRight[1]} ` +\n      `L ${bottomRight[0]} ${bottomRight[1]} ` +\n      `L ${bottomLeft[0]} ${bottomLeft[1]}`\n  }\n\n  path += \" Z\"\n\n  const cutlery = su(soup).pcb_cutout.list()\n  for (const cutout of cutlery) {\n    if (cutout.shape === \"rect\") {\n      const { x, y, width, height } = cutout.center\n        ? (() => {\n            const { x, y } = cutout.center\n            const { width, height } = cutout\n            return { x, y, width, height }\n          })()\n        : { x: 0, y: 0, width: 0, height: 0 }\n\n      const halfWidth = width / 2\n      const halfHeight = height / 2\n      const [tl, tr, br, bl] = [\n        applyToPoint(transform, [x - halfWidth, y - halfHeight]),\n        applyToPoint(transform, [x + halfWidth, y - halfHeight]),\n        applyToPoint(transform, [x + halfWidth, y + halfHeight]),\n        applyToPoint(transform, [x - halfWidth, y + halfHeight]),\n      ]\n      path += ` M ${tl[0]} ${tl[1]} L ${tr[0]} ${tr[1]} L ${br[0]} ${br[1]} L ${bl[0]} ${bl[1]} Z`\n    } else if (cutout.shape === \"circle\") {\n      // svg subtract circle from path is hard, skip for now\n    }\n  }\n\n  const svgObjects: SvgObject[] = [\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      children: [],\n      attributes: {\n        class: \"pinout-board\",\n        d: path,\n        fill: BOARD_FILL_COLOR,\n        stroke: BOARD_STROKE_COLOR,\n        \"fill-rule\": \"evenodd\",\n        \"stroke-opacity\": \"0.8\",\n        \"stroke-width\": (0.2 * Math.abs(transform.a)).toString(),\n      },\n    },\n  ]\n\n  if (title) {\n    // Position title at the top center of the SVG\n    const titleX = ctx.svgWidth / 2\n    const titleY = 30 // 30px from the top\n\n    svgObjects.push({\n      name: \"text\",\n      type: \"element\",\n      value: \"\",\n      children: [\n        { name: \"\", type: \"text\", value: title, attributes: {}, children: [] },\n      ],\n      attributes: {\n        x: titleX.toString(),\n        y: titleY.toString(),\n        \"text-anchor\": \"middle\",\n        \"font-size\": \"18px\",\n        \"font-weight\": \"bold\",\n        \"font-family\": \"Arial, sans-serif\",\n        fill: \"black\",\n        class: \"pinout-board-title\",\n      },\n    })\n  }\n\n  return svgObjects\n}\n","import type { PcbComponent, LayerRef, Point } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PinoutSvgContext } from \"../convert-circuit-json-to-pinout-svg\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport { applyToPoint } from \"transformation-matrix\"\n\nconst COMPONENT_FILL_COLOR = \"rgba(120, 120, 120, 0.6)\"\nconst COMPONENT_LABEL_COLOR = \"rgba(255, 255, 255, 0.9)\"\n\nexport function createSvgObjectsFromPinoutComponent(\n  elm: PcbComponent,\n  ctx: PinoutSvgContext,\n): SvgObject[] {\n  const { transform, soup } = ctx\n  const { center, width, height, rotation = 0, source_component_id } = elm\n  const sourceComponent = su(soup).source_component.get(source_component_id)\n\n  if (\n    !center ||\n    typeof width !== \"number\" ||\n    typeof height !== \"number\" ||\n    width === 0 ||\n    height === 0\n  ) {\n    return []\n  }\n  const [x, y] = applyToPoint(transform, [center.x, center.y])\n  const scaledWidth = width * Math.abs(transform.a)\n  const scaledHeight = height * Math.abs(transform.d)\n  const transformStr = `translate(${x}, ${y})`\n\n  const children: SvgObject[] = [\n    {\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        class: \"pinout-component-box\",\n        x: (-scaledWidth / 2).toString(),\n        y: (-scaledHeight / 2).toString(),\n        width: scaledWidth.toString(),\n        height: scaledHeight.toString(),\n        fill: COMPONENT_FILL_COLOR,\n        transform: `rotate(${rotation}deg)`,\n      },\n      value: \"\",\n      children: [],\n    },\n  ]\n\n  if (sourceComponent?.name) {\n    const labelFontSize = Math.min(scaledWidth, scaledHeight) * 0.4\n    children.push({\n      name: \"text\",\n      type: \"element\",\n      attributes: {\n        x: \"0\",\n        y: \"0\",\n        fill: COMPONENT_LABEL_COLOR,\n        \"font-size\": `${labelFontSize}px`,\n        \"font-family\": \"sans-serif\",\n        \"text-anchor\": \"middle\",\n        \"dominant-baseline\": \"middle\",\n      },\n      children: [\n        {\n          type: \"text\",\n          value: sourceComponent.name,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n      value: \"\",\n    })\n  }\n\n  return [\n    {\n      name: \"g\",\n      type: \"element\",\n      attributes: {\n        transform: transformStr,\n      },\n      children,\n      value: \"\",\n    },\n  ]\n}\n","import type { PCBHole } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PinoutSvgContext } from \"../convert-circuit-json-to-pinout-svg\"\n\nconst HOLE_COLOR = \"rgb(50, 50, 50)\"\n\nexport function createSvgObjectsFromPinoutHole(\n  hole: PCBHole,\n  ctx: PinoutSvgContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n\n  if (hole.hole_shape === \"circle\" || hole.hole_shape === \"square\") {\n    const scaledDiameter = hole.hole_diameter * Math.abs(transform.a)\n    const radius = scaledDiameter / 2\n\n    if (hole.hole_shape === \"circle\") {\n      return [\n        {\n          name: \"circle\",\n          type: \"element\",\n          attributes: {\n            class: \"pinout-hole\",\n            cx: x.toString(),\n            cy: y.toString(),\n            r: radius.toString(),\n            fill: HOLE_COLOR,\n          },\n          children: [],\n          value: \"\",\n        },\n      ]\n    }\n    // Square hole\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pinout-hole\",\n          x: (x - radius).toString(),\n          y: (y - radius).toString(),\n          width: scaledDiameter.toString(),\n          height: scaledDiameter.toString(),\n          fill: HOLE_COLOR,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n  if (hole.hole_shape === \"oval\") {\n    const scaledWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHeight = hole.hole_height * Math.abs(transform.a)\n    const rx = scaledWidth / 2\n    const ry = scaledHeight / 2\n\n    return [\n      {\n        name: \"ellipse\",\n        type: \"element\",\n        attributes: {\n          class: \"pinout-hole\",\n          cx: x.toString(),\n          cy: y.toString(),\n          rx: rx.toString(),\n          ry: ry.toString(),\n          fill: HOLE_COLOR,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n\n  return []\n}\n","import type { PCBPlatedHole } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PinoutSvgContext } from \"../convert-circuit-json-to-pinout-svg\"\n\nconst PAD_COLOR = \"rgb(218, 165, 32)\" // More vibrant gold\nconst HOLE_COLOR = \"rgb(40, 40, 40)\" // Darker gray for contrast\n\nexport function createSvgObjectsFromPinoutPlatedHole(\n  hole: PCBPlatedHole,\n  ctx: PinoutSvgContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n\n  if (hole.shape === \"pill\") {\n    const scaledOuterWidth = hole.outer_width * Math.abs(transform.a)\n    const scaledOuterHeight = hole.outer_height * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a)\n\n    const outerRadiusX = scaledOuterWidth / 2\n    const straightLength = scaledOuterHeight - scaledOuterWidth\n    const innerRadiusX = scaledHoleWidth / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Outer pill shape\n          {\n            name: \"path\",\n            type: \"element\",\n            attributes: {\n              class: \"pinout-hole-outer\",\n              fill: PAD_COLOR,\n              d:\n                `M${x - outerRadiusX},${y - straightLength / 2} ` +\n                `v${straightLength} ` +\n                `a${outerRadiusX},${outerRadiusX} 0 0 0 ${scaledOuterWidth},0 ` +\n                `v-${straightLength} ` +\n                `a${outerRadiusX},${outerRadiusX} 0 0 0 -${scaledOuterWidth},0 z`,\n            },\n            value: \"\",\n            children: [],\n          },\n          // Inner pill shape\n          {\n            name: \"path\",\n            type: \"element\",\n            attributes: {\n              class: \"pinout-hole-inner\",\n              fill: HOLE_COLOR,\n              d:\n                `M${x - innerRadiusX},${\n                  y - (scaledHoleHeight - scaledHoleWidth) / 2\n                } ` +\n                `v${scaledHoleHeight - scaledHoleWidth} ` +\n                `a${innerRadiusX},${innerRadiusX} 0 0 0 ${scaledHoleWidth},0 ` +\n                `v-${scaledHoleHeight - scaledHoleWidth} ` +\n                `a${innerRadiusX},${innerRadiusX} 0 0 0 -${scaledHoleWidth},0 z`,\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  // Fallback to circular hole if not pill-shaped\n  if (hole.shape === \"circle\") {\n    const scaledOuterWidth = hole.outer_diameter * Math.abs(transform.a)\n    const scaledOuterHeight = hole.outer_diameter * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_diameter * Math.abs(transform.a)\n    const scaledHoleHeight = hole.hole_diameter * Math.abs(transform.a)\n\n    const outerRadius = Math.min(scaledOuterWidth, scaledOuterHeight) / 2\n    const innerRadius = Math.min(scaledHoleWidth, scaledHoleHeight) / 2\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"pinout-hole-outer\",\n              fill: PAD_COLOR,\n              cx: x.toString(),\n              cy: y.toString(),\n              r: outerRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"pinout-hole-inner\",\n              fill: HOLE_COLOR,\n              cx: x.toString(),\n              cy: y.toString(),\n              r: innerRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  // Handle circular hole with rectangular pad\n  if (hole.shape === \"circular_hole_with_rect_pad\") {\n    const scaledHoleDiameter = hole.hole_diameter * Math.abs(transform.a)\n    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a)\n\n    const holeRadius = scaledHoleDiameter / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Rectangular pad (outer shape)\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"pinout-hole-outer-pad\",\n              fill: PAD_COLOR,\n              x: (x - scaledRectPadWidth / 2).toString(),\n              y: (y - scaledRectPadHeight / 2).toString(),\n              width: scaledRectPadWidth.toString(),\n              height: scaledRectPadHeight.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n          // Circular hole inside the rectangle\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"pinout-hole-inner\",\n              fill: HOLE_COLOR,\n              cx: x.toString(),\n              cy: y.toString(),\n              r: holeRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n  if (hole.shape === \"pill_hole_with_rect_pad\") {\n    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a)\n\n    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a)\n\n    // Use the minimum of scaledHoleHeight and scaledHoleWidth for the radius\n    const holeRadius = Math.min(scaledHoleHeight, scaledHoleWidth) / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Rectangular pad (outer shape)\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"pinout-hole-outer-pad\",\n              fill: PAD_COLOR,\n              x: (x - scaledRectPadWidth / 2).toString(),\n              y: (y - scaledRectPadHeight / 2).toString(),\n              width: scaledRectPadWidth.toString(),\n              height: scaledRectPadHeight.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n          // pill hole inside the rectangle\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"pinout-hole-inner\",\n              fill: HOLE_COLOR,\n              x: (x - scaledHoleWidth / 2).toString(),\n              y: (y - scaledHoleHeight / 2).toString(),\n              width: scaledHoleWidth.toString(),\n              height: scaledHoleHeight.toString(),\n              rx: holeRadius.toString(),\n              ry: holeRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  if (hole.shape === \"rotated_pill_hole_with_rect_pad\") {\n    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a)\n\n    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a)\n\n    const holeRadius = Math.min(scaledHoleHeight, scaledHoleWidth) / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"pinout-hole-outer-pad\",\n              fill: PAD_COLOR,\n              x: (-scaledRectPadWidth / 2).toString(),\n              y: (-scaledRectPadHeight / 2).toString(),\n              width: scaledRectPadWidth.toString(),\n              height: scaledRectPadHeight.toString(),\n              transform: `translate(${x} ${y}) rotate(${-hole.rect_ccw_rotation})`,\n            },\n            value: \"\",\n            children: [],\n          },\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"pinout-hole-inner\",\n              fill: HOLE_COLOR,\n              x: (-scaledHoleWidth / 2).toString(),\n              y: (-scaledHoleHeight / 2).toString(),\n              width: scaledHoleWidth.toString(),\n              height: scaledHoleHeight.toString(),\n              rx: holeRadius.toString(),\n              ry: holeRadius.toString(),\n              transform: `translate(${x} ${y}) rotate(${-hole.hole_ccw_rotation})`,\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  return []\n}\n","import type { PcbSmtPad } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PinoutSvgContext } from \"../convert-circuit-json-to-pinout-svg\"\n\nconst PAD_COLOR = \"rgb(218, 165, 32)\" // More vibrant gold\n\nexport function createSvgObjectsFromPinoutSmtPad(\n  pad: PcbSmtPad,\n  ctx: PinoutSvgContext,\n): SvgObject[] {\n  const { transform } = ctx\n\n  if (pad.shape === \"rect\" || pad.shape === \"rotated_rect\") {\n    const width = pad.width * Math.abs(transform.a)\n    const height = pad.height * Math.abs(transform.d)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    if (pad.shape === \"rotated_rect\" && pad.ccw_rotation) {\n      return [\n        {\n          name: \"rect\",\n          type: \"element\",\n          attributes: {\n            class: \"pinout-pad\",\n            fill: PAD_COLOR,\n            x: (-width / 2).toString(),\n            y: (-height / 2).toString(),\n            width: width.toString(),\n            height: height.toString(),\n            transform: `translate(${x} ${y}) rotate(${-pad.ccw_rotation})`,\n            \"data-layer\": pad.layer,\n          },\n          value: \"\",\n          children: [],\n        },\n      ]\n    }\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pinout-pad\",\n          fill: PAD_COLOR,\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          \"data-layer\": pad.layer,\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n\n  if (pad.shape === \"pill\") {\n    const width = pad.width * Math.abs(transform.a)\n    const height = pad.height * Math.abs(transform.d)\n    const radius = pad.radius * Math.abs(transform.a)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pinout-pad\",\n          fill: PAD_COLOR,\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          rx: radius.toString(),\n          ry: radius.toString(),\n          \"data-layer\": pad.layer,\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n  if (pad.shape === \"circle\") {\n    const radius = pad.radius * Math.abs(transform.a)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    return [\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pinout-pad\",\n          fill: PAD_COLOR,\n          cx: x.toString(),\n          cy: y.toString(),\n          r: radius.toString(),\n          \"data-layer\": pad.layer,\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n\n  if (pad.shape === \"polygon\") {\n    const points = (pad.points ?? []).map((point) =>\n      applyToPoint(transform, [point.x, point.y]),\n    )\n\n    return [\n      {\n        name: \"polygon\",\n        type: \"element\",\n        attributes: {\n          class: \"pinout-pad\",\n          fill: PAD_COLOR,\n          points: points.map((p) => p.join(\",\")).join(\" \"),\n          \"data-layer\": pad.layer,\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n\n  return []\n}\n","import type { PcbPort } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { PinoutSvgContext } from \"../convert-circuit-json-to-pinout-svg\"\nimport { calculateElbow } from \"calculate-elbow\"\nimport { createPinoutLabelBox } from \"./pinout-label-box\"\n\nconst LABEL_COLOR = \"rgb(255, 255, 255)\"\nconst LABEL_BACKGROUND = \"rgb(0, 0, 0)\"\nconst LINE_COLOR = \"rgba(0, 0, 0, 0.6)\"\nconst PIN_NUMBER_BACKGROUND = \"rgb(200, 200, 200)\"\nconst PIN_NUMBER_COLOR = \"rgb(0, 0, 0)\"\n\nexport type FacingDirection = \"x-\" | \"x+\" | \"y-\" | \"y+\"\n\nexport function createSvgObjectsFromPinoutPort(\n  pcb_port: PcbPort,\n  ctx: PinoutSvgContext,\n): SvgObject[] {\n  const label_info = ctx.label_positions.get(pcb_port.pcb_port_id)\n  if (!label_info) return []\n\n  const { text: label, aliases, elbow_end, label_pos, edge } = label_info\n\n  const [port_x, port_y] = applyToPoint(ctx.transform, [pcb_port.x, pcb_port.y])\n\n  const start_facing_direction: FacingDirection =\n    edge === \"left\"\n      ? \"x-\"\n      : edge === \"right\"\n        ? \"x+\"\n        : edge === \"top\"\n          ? \"y-\"\n          : \"y+\"\n\n  const end_facing_direction: FacingDirection =\n    edge === \"left\"\n      ? \"x+\"\n      : edge === \"right\"\n        ? \"x-\"\n        : edge === \"top\"\n          ? \"y+\"\n          : \"y-\"\n\n  const elbow_path = calculateElbow(\n    {\n      x: port_x,\n      y: port_y,\n      facingDirection: start_facing_direction,\n    },\n    {\n      x: elbow_end.x,\n      y: elbow_end.y,\n      facingDirection: end_facing_direction,\n    },\n    {},\n  )\n\n  // Build tokens with style; if first token is \"pin{number}\", show number with gray bg and black text\n  const numberMatch = /^pin(\\d+)$/i.exec(label)\n  const tokensWithStyle = [\n    {\n      text: numberMatch ? numberMatch[1] : label,\n      bg: numberMatch ? PIN_NUMBER_BACKGROUND : LABEL_BACKGROUND,\n      color: numberMatch ? PIN_NUMBER_COLOR : LABEL_COLOR,\n    },\n    ...aliases.map((t) => ({\n      text: t,\n      bg: LABEL_BACKGROUND,\n      color: LABEL_COLOR,\n    })),\n  ]\n\n  const pxPerMm = Math.abs(ctx.transform.a) // px per mm from transform matrix\n  const labelScale = ctx.styleScale ?? 1\n  const LABEL_RECT_HEIGHT_MM = 1.6 * labelScale\n  const rectHeight = LABEL_RECT_HEIGHT_MM * pxPerMm\n  const STROKE_WIDTH_MM = Math.max(0.08, 0.25 * labelScale)\n  const CORNER_RADIUS_MM = 0.3 * labelScale\n  const cornerRadius = CORNER_RADIUS_MM * pxPerMm\n\n  const strokeWidthPx = STROKE_WIDTH_MM * pxPerMm\n  const end_point = {\n    x: label_pos.x + (edge === \"left\" ? -strokeWidthPx / 2 : strokeWidthPx / 2),\n    y: label_pos.y,\n  }\n  const line_points = [...elbow_path, end_point]\n    .map((p) => `${p.x},${p.y}`)\n    .join(\" \")\n\n  // Derive font size and padding from rect height to keep text centered\n  // Based on original ratio of font-size 11 to rect-height 21\n  const fontSize = rectHeight * (11 / 21)\n  const bgPadding = (rectHeight - fontSize) / 2\n  const gap = bgPadding\n\n  const tokenRects = tokensWithStyle.map(({ text, bg, color }) => {\n    const safeText = text ?? \"\"\n    const textWidth = safeText.length * fontSize * 0.6\n    const rectWidth = textWidth + 2 * bgPadding\n    return { text: safeText, rectWidth, bg, color }\n  })\n\n  const text_y = label_pos.y\n\n  const objects: SvgObject[] = [\n    {\n      name: \"polyline\",\n      type: \"element\",\n      attributes: {\n        points: line_points,\n        stroke: LINE_COLOR,\n        \"stroke-width\": (STROKE_WIDTH_MM * pxPerMm).toString(),\n        fill: \"none\",\n      },\n      children: [],\n      value: \"\",\n    },\n  ]\n\n  if (edge === \"left\") {\n    // Start near the board and place boxes outward to the left\n    let currentX = label_pos.x\n    for (const { text, rectWidth, bg, color } of tokenRects) {\n      const rectX = currentX - rectWidth\n      const text_x = rectX + rectWidth / 2\n\n      objects.push(\n        ...createPinoutLabelBox({\n          rectX,\n          rectY: text_y - rectHeight / 2,\n          rectWidth,\n          rectHeight,\n          textX: text_x,\n          textY: text_y,\n          text,\n          fontSize,\n          labelBackground: bg,\n          labelColor: color,\n          rx: cornerRadius,\n          ry: cornerRadius,\n        }),\n      )\n\n      currentX = rectX - gap\n    }\n  } else if (edge === \"right\") {\n    // Start near the board and place boxes outward to the right\n    let currentX = label_pos.x\n    for (const { text, rectWidth, bg, color } of tokenRects) {\n      const rectX = currentX\n      const text_x = rectX + rectWidth / 2\n\n      objects.push(\n        ...createPinoutLabelBox({\n          rectX,\n          rectY: text_y - rectHeight / 2,\n          rectWidth,\n          rectHeight,\n          textX: text_x,\n          textY: text_y,\n          text,\n          fontSize,\n          labelBackground: bg,\n          labelColor: color,\n          rx: cornerRadius,\n          ry: cornerRadius,\n        }),\n      )\n\n      currentX = rectX + rectWidth + gap\n    }\n  } else {\n    // Fallback: center all boxes around label_pos.x\n    const totalWidth =\n      tokenRects.reduce((acc, t) => acc + t.rectWidth, 0) +\n      gap * Math.max(0, tokenRects.length - 1)\n    let currentX = label_pos.x - totalWidth / 2\n\n    for (const { text, rectWidth, bg, color } of tokenRects) {\n      const rectX = currentX\n      const text_x = rectX + rectWidth / 2\n\n      objects.push(\n        ...createPinoutLabelBox({\n          rectX,\n          rectY: text_y - rectHeight / 2,\n          rectWidth,\n          rectHeight,\n          textX: text_x,\n          textY: text_y,\n          text,\n          fontSize,\n          labelBackground: bg,\n          labelColor: color,\n          rx: cornerRadius,\n          ry: cornerRadius,\n        }),\n      )\n\n      currentX = rectX + rectWidth + gap\n    }\n  }\n\n  return objects\n}\n","import type { SvgObject } from \"lib/svg-object\"\n\nexport function createPinoutLabelBox(params: {\n  rectX: number\n  rectY: number\n  rectWidth: number\n  rectHeight: number\n  textX: number\n  textY: number\n  text: string\n  fontSize: number\n  labelBackground: string\n  labelColor: string\n  rx?: number | string\n  ry?: number | string\n  fontFamily?: string\n  fontWeight?: string\n  textAnchor?: \"start\" | \"middle\" | \"end\"\n  dominantBaseline?:\n    | \"auto\"\n    | \"text-bottom\"\n    | \"alphabetic\"\n    | \"ideographic\"\n    | \"middle\"\n    | \"central\"\n    | \"mathematical\"\n    | \"hanging\"\n    | \"text-top\"\n}): SvgObject[] {\n  const {\n    rectX,\n    rectY,\n    rectWidth,\n    rectHeight,\n    textX,\n    textY,\n    text,\n    fontSize,\n    labelBackground,\n    labelColor,\n    rx = 4,\n    ry = 4,\n    fontFamily = \"Arial, sans-serif\",\n    fontWeight = \"bold\",\n    textAnchor = \"middle\",\n    dominantBaseline = \"middle\",\n  } = params\n\n  return [\n    {\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        x: rectX.toString(),\n        y: rectY.toString(),\n        width: rectWidth.toString(),\n        height: rectHeight.toString(),\n        fill: labelBackground,\n        rx: typeof rx === \"number\" ? rx.toString() : rx,\n        ry: typeof ry === \"number\" ? ry.toString() : ry,\n        stroke: \"none\",\n      },\n      children: [],\n      value: \"\",\n    },\n    {\n      name: \"text\",\n      type: \"element\",\n      attributes: {\n        x: textX.toString(),\n        y: textY.toString(),\n        fill: labelColor,\n        \"font-size\": `${fontSize}px`,\n        \"font-family\": fontFamily,\n        \"font-weight\": fontWeight,\n        \"text-anchor\": textAnchor,\n        \"dominant-baseline\": dominantBaseline,\n      },\n      children: [\n        {\n          type: \"text\",\n          value: text,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n      value: \"\",\n    },\n  ]\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport type { PinoutLabel } from \"./convert-circuit-json-to-pinout-svg\"\nimport {\n  STAGGER_OFFSET_MIN,\n  STAGGER_OFFSET_PER_PIN,\n  STAGGER_OFFSET_STEP,\n  ALIGNED_OFFSET_MARGIN,\n  GROUP_SEPARATION_MM,\n  LABEL_RECT_HEIGHT_BASE_MM,\n} from \"./constants\"\n\nexport type LabelPosition = {\n  text: string\n  aliases: string[]\n  elbow_end: { x: number; y: number }\n  label_pos: { x: number; y: number }\n  edge: \"left\" | \"right\" | \"top\" | \"bottom\"\n}\n\nfunction calculateVerticalEdgeLabels(\n  edge: \"left\" | \"right\",\n  pinout_labels: PinoutLabel[],\n  {\n    transform,\n    soup,\n    board_bounds,\n    svgHeight,\n    styleScale,\n  }: {\n    transform: Matrix\n    soup: AnyCircuitElement[]\n    board_bounds: { minX: number; minY: number; maxX: number; maxY: number }\n    svgHeight: number\n    styleScale: number\n  },\n  label_positions: Map<string, LabelPosition>,\n) {\n  const x_coords = pinout_labels.map((l) => l.pcb_port.x)\n  const counts: { [k: string]: number } = {}\n  for (const x of x_coords) {\n    const rounded = x.toFixed(1)\n    counts[rounded] = (counts[rounded] || 0) + 1\n  }\n\n  let edge_ports\n\n  if (Object.keys(counts).length > 1 && pinout_labels.length > 2) {\n    // More than one group of x-coords, group and sort\n    const sorted_x_groups = Object.entries(counts).sort((a, b) => b[1] - a[1])\n    const primary_x = parseFloat(sorted_x_groups[0]![0])\n\n    const primary_pins = pinout_labels.filter(\n      (l) => Math.abs(l.pcb_port.x - primary_x) < 0.2,\n    )\n    const other_pins = pinout_labels.filter(\n      (l) => Math.abs(l.pcb_port.x - primary_x) >= 0.2,\n    )\n\n    const mapToEdgePort = (pinout_label: PinoutLabel) => ({\n      pcb_port: pinout_label.pcb_port,\n      y: applyToPoint(transform, [\n        pinout_label.pcb_port.x,\n        pinout_label.pcb_port.y,\n      ])[1],\n      aliases: pinout_label.aliases,\n    })\n\n    // Sort by y-descending in real-world coordinates\n    primary_pins.sort((a, b) => b.pcb_port.y - a.pcb_port.y)\n    other_pins.sort((a, b) => b.pcb_port.y - a.pcb_port.y)\n\n    // Check if other pins should be at top or bottom\n    const max_y_primary =\n      primary_pins.length > 0\n        ? Math.max(...primary_pins.map((p) => p.pcb_port.y))\n        : -Infinity\n    const max_y_other =\n      other_pins.length > 0\n        ? Math.max(...other_pins.map((p) => p.pcb_port.y))\n        : -Infinity\n\n    // A larger y-coordinate in real-world coordinates means the pin should\n    // appear higher in the pinout diagram. We place the group with the\n    // highest pin first.\n    const combined_pins =\n      max_y_other > max_y_primary\n        ? [...other_pins, ...primary_pins]\n        : [...primary_pins, ...other_pins]\n\n    edge_ports = combined_pins.map(mapToEdgePort)\n  } else {\n    edge_ports = pinout_labels\n      .map((pinout_label) => ({\n        pcb_port: pinout_label.pcb_port,\n        y: applyToPoint(transform, [\n          pinout_label.pcb_port.x,\n          pinout_label.pcb_port.y,\n        ])[1],\n        aliases: pinout_label.aliases,\n      }))\n      .sort((a, b) => a.y - b.y)\n  }\n\n  if (edge_ports.length === 0) return\n\n  const board_edge_x = applyToPoint(transform, [\n    edge === \"left\" ? board_bounds.minX : board_bounds.maxX,\n    0,\n  ])[0]\n\n  const num_labels = edge_ports.length\n\n  const x_coords_counts: { [k: string]: number } = {}\n  for (const pl of pinout_labels) {\n    const rounded = pl.pcb_port.x.toFixed(1)\n    x_coords_counts[rounded] = (x_coords_counts[rounded] || 0) + 1\n  }\n\n  let main_group_pin_port_ids = new Set<string>()\n  if (Object.keys(x_coords_counts).length > 1 && pinout_labels.length > 2) {\n    const sorted_x_groups = Object.entries(x_coords_counts).sort(\n      (a, b) => b[1] - a[1],\n    )\n    const primary_x = parseFloat(sorted_x_groups[0]![0])\n\n    const primary_pins = pinout_labels.filter(\n      (l) => Math.abs(l.pcb_port.x - primary_x) < 0.2,\n    )\n    main_group_pin_port_ids = new Set(\n      primary_pins.map((p) => p.pcb_port.pcb_port_id),\n    )\n  }\n\n  const main_group_indices = edge_ports\n    .map((ep, i) => {\n      if (main_group_pin_port_ids.has(ep.pcb_port.pcb_port_id)) {\n        return i\n      }\n      return -1 // or some other flag\n    })\n    .filter((i) => i !== -1)\n\n  const geometric_middle_index = (num_labels - 1) / 2\n\n  const pxPerMm = Math.abs(transform.a)\n  const label_rect_height = LABEL_RECT_HEIGHT_BASE_MM * styleScale * pxPerMm\n  const BASE_GAP_MM = 0.3\n  const label_margin = Math.max(\n    0.2 * pxPerMm,\n    BASE_GAP_MM * styleScale * pxPerMm,\n  )\n  const group_gap_px = GROUP_SEPARATION_MM * styleScale * pxPerMm\n\n  const stagger_offset_base =\n    (STAGGER_OFFSET_MIN + num_labels * STAGGER_OFFSET_PER_PIN) *\n    styleScale *\n    pxPerMm\n\n  const max_stagger_offset =\n    stagger_offset_base +\n    geometric_middle_index * (STAGGER_OFFSET_STEP * styleScale * pxPerMm)\n  const aligned_label_offset =\n    max_stagger_offset + ALIGNED_OFFSET_MARGIN * styleScale * pxPerMm\n\n  const num_other_pins = num_labels - main_group_indices.length\n  // If there's no main group, all pins are \"other\" pins\n  const num_pins_to_stack =\n    main_group_indices.length === 0 ? num_labels : num_other_pins\n\n  const stack_total_height =\n    num_pins_to_stack * label_rect_height +\n    Math.max(0, num_pins_to_stack - 1) * label_margin\n\n  let current_y: number\n  if (main_group_indices.length > 0 && num_other_pins > 0) {\n    const main_group_y_coords = main_group_indices.map((i) => edge_ports[i]!.y)\n    const min_main_group_y = Math.min(...main_group_y_coords)\n    const max_main_group_y = Math.max(...main_group_y_coords)\n    const main_group_top_extent = min_main_group_y - label_rect_height / 2\n    const main_group_bottom_extent = max_main_group_y + label_rect_height / 2\n\n    const other_pin_indices = edge_ports\n      .map((_, index) => index)\n      .filter((index) => !main_group_indices.includes(index))\n\n    // Assumes edge_ports is sorted top-to-bottom on screen\n    const others_are_above = other_pin_indices[0]! < main_group_indices[0]!\n\n    if (others_are_above) {\n      // Place stack above main group\n      const stack_bottom_edge =\n        main_group_top_extent - (label_margin * 2 + group_gap_px)\n      current_y = stack_bottom_edge - stack_total_height + label_rect_height / 2\n    } else {\n      // Place stack below main group\n      const stack_top_edge =\n        main_group_bottom_extent + (label_margin * 2 + group_gap_px)\n      current_y = stack_top_edge + label_rect_height / 2\n    }\n  } else {\n    // Original behavior for centering one big stack\n    current_y = (svgHeight - stack_total_height) / 2 + label_rect_height / 2\n  }\n\n  const is_all_main_group = main_group_indices.length === num_labels\n\n  edge_ports.forEach(({ pcb_port, aliases }, i) => {\n    let stagger_rank: number\n    if (main_group_indices.length > 0) {\n      if (main_group_indices.includes(i)) {\n        stagger_rank = geometric_middle_index // max stagger for main group\n      } else {\n        const min_lg_idx = Math.min(...main_group_indices)\n        const max_lg_idx = Math.max(...main_group_indices)\n        let dist_from_main_group: number\n        if (i < min_lg_idx) {\n          dist_from_main_group = min_lg_idx - i\n        } else {\n          // i > max_lg_idx\n          dist_from_main_group = i - max_lg_idx\n        }\n        stagger_rank = geometric_middle_index - dist_from_main_group\n      }\n    } else {\n      // Standard V-shape for all pins\n      const dist_from_middle = Math.abs(i - geometric_middle_index)\n      stagger_rank = geometric_middle_index - dist_from_middle\n    }\n    const stagger_offset =\n      stagger_offset_base +\n      stagger_rank * (STAGGER_OFFSET_STEP * styleScale * pxPerMm)\n    const sign = edge === \"left\" ? -1 : 1\n\n    const is_main_group_pin = main_group_indices.includes(i)\n\n    const y_pos = is_all_main_group\n      ? edge_ports[i]!.y\n      : main_group_indices.length > 0 && is_main_group_pin\n        ? edge_ports[i]!.y\n        : current_y\n\n    const elbow_end = {\n      x: board_edge_x + sign * stagger_offset,\n      y: y_pos,\n    }\n    const label_pos = {\n      x: board_edge_x + sign * aligned_label_offset,\n      y: y_pos,\n    }\n\n    label_positions.set(pcb_port.pcb_port_id, {\n      text: aliases[0]!,\n      aliases: aliases.slice(1),\n      elbow_end,\n      label_pos,\n      edge,\n    })\n\n    if (!(main_group_indices.length > 0 && is_main_group_pin)) {\n      current_y += label_rect_height + label_margin\n    }\n  })\n}\n\nexport const calculateLabelPositions = ({\n  left_labels,\n  right_labels,\n  transform,\n  soup,\n  board_bounds,\n  svgWidth,\n  svgHeight,\n  styleScale,\n}: {\n  left_labels: PinoutLabel[]\n  right_labels: PinoutLabel[]\n  transform: Matrix\n  soup: AnyCircuitElement[]\n  board_bounds: { minX: number; minY: number; maxX: number; maxY: number }\n  svgWidth: number\n  svgHeight: number\n  styleScale: number\n}): Map<string, LabelPosition> => {\n  const label_positions = new Map<string, LabelPosition>()\n\n  const shared_params = { transform, soup, board_bounds }\n\n  calculateVerticalEdgeLabels(\n    \"left\",\n    left_labels,\n    {\n      ...shared_params,\n      svgHeight,\n      styleScale,\n    },\n    label_positions,\n  )\n\n  calculateVerticalEdgeLabels(\n    \"right\",\n    right_labels,\n    {\n      ...shared_params,\n      svgHeight,\n      styleScale,\n    },\n    label_positions,\n  )\n\n  return label_positions\n}\n","/**\n * Shared pinout layout constants (in millimeters unless noted).\n * Keep these values unit-consistent and import wherever needed.\n */\nexport const LABEL_RECT_HEIGHT_BASE_MM = 1.6 // base height for label pill/rect in mm\n\n// Text sizing ratios\nexport const FONT_HEIGHT_RATIO = 11 / 21\nexport const CHAR_WIDTH_FACTOR = 0.6\n\n// Stagger geometry\nexport const STAGGER_OFFSET_MIN = 0.1 // mm\nexport const STAGGER_OFFSET_PER_PIN = 0.1 // mm\nexport const STAGGER_OFFSET_STEP = 3 // mm\nexport const ALIGNED_OFFSET_MARGIN = 0.1 // mm\n\n// Vertical gap between primary and non-primary label stacks\nexport const GROUP_SEPARATION_MM = 0.8 // mm\n","import type { AnyCircuitElement, PcbPort } from \"circuit-json\"\nimport { su } from \"@tscircuit/circuit-json-util\"\n\nexport function getPortLabelInfo(\n  port: PcbPort,\n  soup: AnyCircuitElement[],\n): { text: string; aliases: string[] } | null {\n  const source_port = su(soup).source_port.get(port.source_port_id)\n  if (!source_port) return null\n\n  const eligible_hints =\n    source_port.port_hints?.filter(\n      (h) =>\n        !/^\\d+$/.test(h) && ![\"left\", \"right\", \"top\", \"bottom\"].includes(h),\n    ) ?? []\n\n  let label = eligible_hints[0]\n  if (!label) label = source_port.name\n\n  if (!label) return null\n\n  const aliases = eligible_hints.filter((h) => h !== label)\n\n  return { text: label, aliases }\n}\n\nexport function getClosestEdge(\n  port_pos_real: { x: number; y: number },\n  board_bounds: { minX: number; minY: number; maxX: number; maxY: number },\n): \"left\" | \"right\" | \"top\" | \"bottom\" {\n  const dists = {\n    left: port_pos_real.x - board_bounds.minX,\n    right: board_bounds.maxX - port_pos_real.x,\n    top: board_bounds.maxY - port_pos_real.y,\n    bottom: port_pos_real.y - board_bounds.minY,\n  }\n\n  let closest_edge: \"left\" | \"right\" | \"top\" | \"bottom\" = \"left\"\n  let min_dist = dists.left\n\n  if (dists.right < min_dist) {\n    min_dist = dists.right\n    closest_edge = \"right\"\n  }\n  if (dists.top < min_dist) {\n    min_dist = dists.top\n    closest_edge = \"top\"\n  }\n  if (dists.bottom < min_dist) {\n    min_dist = dists.bottom\n    closest_edge = \"bottom\"\n  }\n\n  return closest_edge\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { colorMap as defaultColorMap, type ColorMap } from \"lib/utils/colors\"\nimport { stringify } from \"svgson\"\nimport {\n  applyToPoint,\n  compose,\n  scale,\n  translate,\n  fromTriangles,\n  type Matrix,\n  fromTwoMovingPoints,\n  toSVG,\n} from \"transformation-matrix\"\nimport { drawSchematicGrid } from \"./draw-schematic-grid\"\nimport { drawSchematicLabeledPoints } from \"./draw-schematic-labeled-points\"\nimport { getSchematicBoundsFromCircuitJson } from \"./get-schematic-bounds-from-circuit-json\"\nimport { createSvgObjectsFromSchematicComponent } from \"./svg-object-fns/create-svg-objects-from-sch-component\"\nimport { createSvgObjectsFromSchVoltageProbe } from \"./svg-object-fns/create-svg-objects-from-sch-voltage-probe\"\nimport { createSvgObjectsFromSchDebugObject } from \"./svg-object-fns/create-svg-objects-from-sch-debug-object\"\nimport { createSchematicTrace } from \"./svg-object-fns/create-svg-objects-from-sch-trace\"\nimport { createSvgObjectsForSchNetLabel } from \"./svg-object-fns/create-svg-objects-for-sch-net-label\"\nimport { createSvgSchText } from \"./svg-object-fns/create-svg-objects-for-sch-text\"\nimport { createSvgObjectsFromSchematicBox } from \"./svg-object-fns/create-svg-objects-from-sch-box\"\nimport { getSoftwareUsedString } from \"lib/utils/get-software-used-string\"\nimport { CIRCUIT_TO_SVG_VERSION } from \"lib/package-version\"\nimport { createSvgObjectsFromSchematicTable } from \"./svg-object-fns/create-svg-objects-from-sch-table\"\nimport { createSvgObjectsForSchComponentPortHovers } from \"./svg-object-fns/create-svg-objects-for-sch-port-hover\"\nimport { createSvgObjectsFromSchematicLine } from \"./svg-object-fns/create-svg-objects-from-sch-line\"\nimport { createSvgObjectsFromSchematicCircle } from \"./svg-object-fns/create-svg-objects-from-sch-circle\"\nimport { createSvgObjectsFromSchematicRect } from \"./svg-object-fns/create-svg-objects-from-sch-rect\"\nimport { createSvgObjectsFromSchematicArc } from \"./svg-object-fns/create-svg-objects-from-sch-arc\"\nimport { createErrorTextOverlay } from \"lib/utils/create-error-text-overlay\"\n\nexport type ColorOverrides = {\n  schematic?: Partial<ColorMap[\"schematic\"]>\n}\n\ninterface Options {\n  colorOverrides?: ColorOverrides\n  width?: number\n  height?: number\n  grid?: boolean | { cellSize?: number; labelCells?: boolean }\n  labeledPoints?: Array<{ x: number; y: number; label: string }>\n  includeVersion?: boolean\n  showErrorsInTextOverlay?: boolean\n}\n\n// Build CSS rules to highlight all traces sharing a connectivity key\n// when any corresponding trace (base or overlays) is hovered.\nfunction buildNetHoverStyles(connectivityKeys: Set<string>): string {\n  const rules: string[] = []\n  const esc = (v: string) => String(v).replace(/\"/g, '\\\\\"')\n  for (const key of connectivityKeys) {\n    const k = esc(key)\n    const keyAttr = `[data-subcircuit-connectivity-map-key=\"${k}\"]`\n    const baseSel = `g.trace${keyAttr}`\n    const overlaySel = `g.trace-overlays${keyAttr}`\n    const hovered = `:is(${baseSel}, ${overlaySel}):hover`\n    const target = `:is(${baseSel}, ${overlaySel})`\n    // Invert color for all segments in the net when any is hovered\n    rules.push(`svg:has(${hovered}) ${target} { filter: invert(1); }`)\n    // Hide crossing outline for the hovered net\n    rules.push(\n      `svg:has(${hovered}) ${overlaySel} .trace-crossing-outline { opacity: 0; }`,\n    )\n  }\n  return rules.join(\"\\n\")\n}\n\nexport function convertCircuitJsonToSchematicSvg(\n  circuitJson: AnyCircuitElement[],\n  options?: Options,\n): string {\n  // Get bounds with padding\n  const realBounds = getSchematicBoundsFromCircuitJson(circuitJson)\n  const realWidth = realBounds.maxX - realBounds.minX\n  const realHeight = realBounds.maxY - realBounds.minY\n\n  const svgWidth = options?.width ?? 1200\n  const svgHeight = options?.height ?? 600\n  const colorOverrides = options?.colorOverrides\n\n  const colorMap: ColorMap = {\n    ...defaultColorMap,\n    schematic: {\n      ...defaultColorMap.schematic,\n      ...(colorOverrides?.schematic ?? {}),\n    },\n  }\n\n  // Compute the padding such that we maintain the same aspect ratio\n  const circuitAspectRatio = realWidth / realHeight\n  const containerAspectRatio = svgWidth / svgHeight\n\n  let screenPaddingPx: { x: number; y: number }\n  if (circuitAspectRatio > containerAspectRatio) {\n    // Circuit is wider than container - fit to width\n    const newHeight = svgWidth / circuitAspectRatio\n    screenPaddingPx = {\n      x: 0,\n      y: (svgHeight - newHeight) / 2,\n    }\n  } else {\n    // Circuit is taller than container - fit to height\n    const newWidth = svgHeight * circuitAspectRatio\n    screenPaddingPx = {\n      x: (svgWidth - newWidth) / 2,\n      y: 0,\n    }\n  }\n\n  // Calculate projection using REAL points and SCREEN points\n  // We're saying to map the real bounds to the screen bounds by giving 3 points\n  // for each coordinate space\n  const transform = fromTriangles(\n    [\n      { x: realBounds.minX, y: realBounds.maxY },\n      { x: realBounds.maxX, y: realBounds.maxY },\n      { x: realBounds.maxX, y: realBounds.minY },\n    ],\n    [\n      { x: screenPaddingPx.x, y: screenPaddingPx.y },\n      { x: svgWidth - screenPaddingPx.x, y: screenPaddingPx.y },\n      { x: svgWidth - screenPaddingPx.x, y: svgHeight - screenPaddingPx.y },\n    ],\n  )\n  const svgChildren: SvgObject[] = []\n\n  // Add background rectangle\n  svgChildren.push({\n    name: \"rect\",\n    type: \"element\",\n    attributes: {\n      class: \"boundary\",\n      x: \"0\",\n      y: \"0\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n    },\n    children: [],\n    value: \"\",\n  })\n\n  // Add grid if enabled\n  if (options?.grid) {\n    const gridConfig = typeof options.grid === \"object\" ? options.grid : {}\n    svgChildren.push(\n      drawSchematicGrid({ bounds: realBounds, transform, ...gridConfig }),\n    )\n  }\n\n  const schDebugObjectSvgs: SvgObject[] = []\n  const schComponentSvgs: SvgObject[] = []\n  const schTraceSvgs: SvgObject[] = []\n  const connectivityKeys = new Set<string>()\n  const schNetLabel: SvgObject[] = []\n  const schText: SvgObject[] = []\n  const voltageProbeSvgs: SvgObject[] = []\n  const schBoxSvgs: SvgObject[] = []\n  const schTableSvgs: SvgObject[] = []\n  const schPortHoverSvgs: SvgObject[] = []\n  const schLineSvgs: SvgObject[] = []\n  const schCircleSvgs: SvgObject[] = []\n  const schRectSvgs: SvgObject[] = []\n  const schArcSvgs: SvgObject[] = []\n  for (const elm of circuitJson) {\n    if (elm.type === \"schematic_debug_object\") {\n      schDebugObjectSvgs.push(\n        ...createSvgObjectsFromSchDebugObject({\n          debugObject: elm,\n          transform,\n        }),\n      )\n    } else if (elm.type === \"schematic_component\") {\n      schComponentSvgs.push(\n        ...createSvgObjectsFromSchematicComponent({\n          component: elm,\n          transform,\n          circuitJson,\n          colorMap,\n        }),\n      )\n      schPortHoverSvgs.push(\n        ...createSvgObjectsForSchComponentPortHovers({\n          component: elm,\n          transform,\n          circuitJson,\n        }),\n      )\n    } else if (elm.type === \"schematic_box\") {\n      schBoxSvgs.push(\n        ...createSvgObjectsFromSchematicBox({\n          schematicBox: elm,\n          transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_trace\") {\n      schTraceSvgs.push(\n        ...createSchematicTrace({\n          trace: elm,\n          transform,\n          colorMap,\n        }),\n      )\n      connectivityKeys.add(elm.subcircuit_connectivity_map_key!)\n    } else if (elm.type === \"schematic_net_label\") {\n      schNetLabel.push(\n        ...createSvgObjectsForSchNetLabel({\n          schNetLabel: elm,\n          realToScreenTransform: transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_text\" && !elm.schematic_component_id) {\n      schText.push(\n        createSvgSchText({\n          elm,\n          transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_voltage_probe\") {\n      voltageProbeSvgs.push(\n        ...createSvgObjectsFromSchVoltageProbe({\n          probe: elm,\n          transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_table\") {\n      schTableSvgs.push(\n        ...createSvgObjectsFromSchematicTable({\n          schematicTable: elm,\n          transform,\n          colorMap,\n          circuitJson,\n        }),\n      )\n    } else if (elm.type === \"schematic_line\") {\n      schLineSvgs.push(\n        ...createSvgObjectsFromSchematicLine({\n          schLine: elm,\n          transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_circle\") {\n      schCircleSvgs.push(\n        ...createSvgObjectsFromSchematicCircle({\n          schCircle: elm,\n          transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_rect\") {\n      schRectSvgs.push(\n        ...createSvgObjectsFromSchematicRect({\n          schRect: elm,\n          transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_arc\") {\n      schArcSvgs.push(\n        ...createSvgObjectsFromSchematicArc({\n          schArc: elm,\n          transform,\n          colorMap,\n        }),\n      )\n    }\n  }\n\n  // Split traces into base vs overlays, ensure overlays render on top of all base wires\n  const schTraceBaseSvgs = schTraceSvgs.filter(\n    (o) => (o.attributes as any)?.[\"data-layer\"] !== \"overlay\",\n  )\n  const schTraceOverlaySvgs = schTraceSvgs.filter(\n    (o) => (o.attributes as any)?.[\"data-layer\"] === \"overlay\",\n  )\n\n  // Add elements in correct order\n  svgChildren.push(\n    ...schDebugObjectSvgs,\n    ...schTraceBaseSvgs,\n    ...schTraceOverlaySvgs,\n    ...schLineSvgs,\n    ...schCircleSvgs,\n    ...schRectSvgs,\n    ...schArcSvgs,\n    ...schComponentSvgs,\n    ...schPortHoverSvgs,\n    ...schNetLabel,\n    ...schText,\n    ...schBoxSvgs,\n    ...voltageProbeSvgs,\n    ...schTableSvgs,\n  )\n\n  // Add labeled points if provided\n  if (options?.labeledPoints) {\n    svgChildren.push(\n      drawSchematicLabeledPoints({\n        points: options.labeledPoints,\n        transform,\n      }),\n    )\n  }\n\n  const softwareUsedString = getSoftwareUsedString(circuitJson)\n  const version = CIRCUIT_TO_SVG_VERSION\n\n  if (options?.showErrorsInTextOverlay) {\n    const errorOverlay = createErrorTextOverlay(circuitJson)\n    if (errorOverlay) {\n      svgChildren.push(errorOverlay)\n    }\n  }\n\n  const svgObject: SvgObject = {\n    name: \"svg\",\n    type: \"element\",\n    attributes: {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n      style: `background-color: ${colorMap.schematic.background}`,\n      \"data-real-to-screen-transform\": toSVG(transform),\n      ...(softwareUsedString && {\n        \"data-software-used-string\": softwareUsedString,\n      }),\n      ...(options?.includeVersion && {\n        \"data-circuit-to-svg-version\": version,\n      }),\n    },\n    children: [\n      // Add styles\n      {\n        name: \"style\",\n        type: \"element\",\n        children: [\n          {\n            type: \"text\",\n\n            // DO NOT USE THESE CLASSES!!!!\n            // PUT STYLES IN THE SVG OBJECTS THEMSELVES\n            value: `\n              .boundary { fill: ${colorMap.schematic.background}; }\n              .schematic-boundary { fill: none; stroke: #fff; }\n              .component { fill: none; stroke: ${colorMap.schematic.component_outline}; }\n              .chip { fill: ${colorMap.schematic.component_body}; stroke: ${colorMap.schematic.component_outline}; }\n              .component-pin { fill: none; stroke: ${colorMap.schematic.component_outline}; }\n              /* Basic per-trace hover fallback */\n              .trace:hover {\n                filter: invert(1);\n              }\n              .trace:hover .trace-crossing-outline {\n                opacity: 0;\n              }\n              .trace:hover .trace-junction {\n                filter: invert(1);\n              }\n              /* Net-hover highlighting: when a trace or its overlays are hovered,\n                 invert color for all traces (base + overlays) sharing the same\n                 subcircuit connectivity key. Also hide crossing outline during hover. */\n              ${buildNetHoverStyles(connectivityKeys)}\n              .text { font-family: sans-serif; fill: ${colorMap.schematic.wire}; }\n              .pin-number { fill: ${colorMap.schematic.pin_number}; }\n              .port-label { fill: ${colorMap.schematic.reference}; }\n              .component-name { fill: ${colorMap.schematic.reference}; }\n            `,\n            name: \"\",\n            attributes: {},\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n      ...svgChildren,\n    ],\n    value: \"\",\n  }\n\n  return stringify(svgObject)\n}\n\n/**\n * @deprecated use `convertCircuitJsonToSchematicSvg` instead\n */\nexport const circuitJsonToSchematicSvg = convertCircuitJsonToSchematicSvg\n","import { colorMap } from \"lib/utils/colors\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport function drawSchematicGrid(params: {\n  bounds: {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n  }\n  transform: Matrix\n  cellSize?: number\n  labelCells?: boolean\n}): SvgObject {\n  const { minX, minY, maxX, maxY } = params.bounds\n  const cellSize = params.cellSize ?? 1\n  const labelCells = params.labelCells ?? false\n  const gridLines: any[] = []\n\n  // Helper function to transform points\n  const transformPoint = (x: number, y: number) => {\n    const [transformedX, transformedY] = applyToPoint(params.transform, [x, y])\n    return { x: transformedX, y: transformedY }\n  }\n\n  // Vertical lines\n  for (let x = Math.floor(minX); x <= Math.ceil(maxX); x += cellSize) {\n    const start = transformPoint(x, minY)\n    const end = transformPoint(x, maxY)\n\n    gridLines.push({\n      name: \"line\",\n      type: \"element\",\n      attributes: {\n        x1: start.x.toString(),\n        y1: start.y.toString(),\n        x2: end.x.toString(),\n        y2: end.y.toString(),\n        stroke: colorMap.schematic.grid,\n        \"stroke-width\": (0.01 * Math.abs(params.transform.a)).toString(),\n        \"stroke-opacity\": \"0.5\",\n      },\n    })\n  }\n\n  // Horizontal lines\n  for (let y = Math.floor(minY); y <= Math.ceil(maxY); y += cellSize) {\n    const start = transformPoint(minX, y)\n    const end = transformPoint(maxX, y)\n\n    gridLines.push({\n      name: \"line\",\n      type: \"element\",\n      attributes: {\n        x1: start.x.toString(),\n        y1: start.y.toString(),\n        x2: end.x.toString(),\n        y2: end.y.toString(),\n        stroke: colorMap.schematic.grid,\n        \"stroke-width\": (0.01 * Math.abs(params.transform.a)).toString(),\n        \"stroke-opacity\": \"0.5\",\n      },\n    })\n  }\n\n  // Add cell labels if enabled\n  if (labelCells) {\n    const formatPoint = (x: number, y: number) => {\n      if (cellSize <= 0.1) return `${x.toFixed(1)},${y.toFixed(1)}`\n      return `${x},${y}`\n    }\n    for (let x = Math.floor(minX); x <= Math.ceil(maxX); x += cellSize) {\n      for (let y = Math.floor(minY); y <= Math.ceil(maxY); y += cellSize) {\n        const point = transformPoint(x, y)\n\n        gridLines.push({\n          name: \"text\",\n          type: \"element\",\n          attributes: {\n            x: (point.x - 2.5).toString(),\n            y: (point.y - 5).toString(),\n            fill: colorMap.schematic.grid,\n            \"font-size\": (\n              (cellSize / 5) *\n              Math.abs(params.transform.a)\n            ).toString(),\n            \"fill-opacity\": \"0.5\",\n            \"text-anchor\": \"middle\",\n            \"dominant-baseline\": \"middle\",\n            \"font-family\": \"sans-serif\",\n          },\n          children: [\n            {\n              type: \"text\",\n              value: formatPoint(x, y),\n              name: \"\",\n              attributes: {},\n              children: [],\n            },\n          ],\n        })\n      }\n    }\n  }\n\n  return {\n    name: \"g\",\n    value: \"\",\n    type: \"element\",\n    attributes: { class: \"grid\" },\n    children: gridLines,\n  }\n}\n","import { colorMap } from \"lib/utils/colors\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\ninterface LabeledPoint {\n  x: number\n  y: number\n  label?: string\n}\n\nexport function drawSchematicLabeledPoints(params: {\n  points: LabeledPoint[]\n  transform: Matrix\n}): SvgObject {\n  const { points, transform } = params\n  const labeledPointsGroup: any[] = []\n\n  for (const point of points) {\n    // Transform offset points for X marker\n    const [x1, y1] = applyToPoint(transform, [point.x - 0.1, point.y - 0.1])\n    const [x2, y2] = applyToPoint(transform, [point.x + 0.1, point.y + 0.1])\n    const [x3, y3] = applyToPoint(transform, [point.x - 0.1, point.y + 0.1])\n    const [x4, y4] = applyToPoint(transform, [point.x + 0.1, point.y - 0.1])\n\n    // Add X marker\n    labeledPointsGroup.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: `M${x1},${y1} L${x2},${y2} M${x3},${y3} L${x4},${y4}`,\n        stroke: colorMap.schematic.grid,\n        \"stroke-width\": (0.02 * Math.abs(transform.a)).toString(),\n        \"stroke-opacity\": \"0.7\",\n      },\n    })\n\n    // Transform label position\n    const [labelX, labelY] = applyToPoint(transform, [\n      point.x + 0.15,\n      point.y - 0.15,\n    ])\n\n    // Add label\n    labeledPointsGroup.push({\n      name: \"text\",\n      type: \"element\",\n      attributes: {\n        x: labelX.toString(),\n        y: labelY.toString(),\n        fill: colorMap.schematic.grid,\n        \"font-size\": (0.1 * Math.abs(transform.a)).toString(),\n        \"fill-opacity\": \"0.7\",\n        \"text-anchor\": \"start\",\n        \"font-family\": \"sans-serif\",\n        \"dominant-baseline\": \"middle\",\n      },\n      children: [\n        {\n          type: \"text\",\n          value: point.label || `(${point.x},${point.y})`,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n    })\n  }\n\n  return {\n    name: \"g\",\n    value: \"\",\n    type: \"element\",\n    attributes: { class: \"labeled-points\" },\n    children: labeledPointsGroup,\n  }\n}\n","// https://claude.ai/share/5e327d90-627f-48d5-9a51-ba6117479007\nexport const arialTextMetrics = {\n  \"0\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"1\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -3,\n    right: 9,\n  },\n  \"2\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"3\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"4\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 12,\n  },\n  \"5\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"6\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"7\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"8\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"9\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \" \": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 0,\n  },\n  \"!\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  '\"': {\n    width: 9,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \"#\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 13,\n  },\n  $: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"%\": {\n    width: 21,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 20,\n  },\n  \"&\": {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 15,\n  },\n  \"'\": {\n    width: 5,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 3,\n  },\n  \"(\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \")\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \"*\": {\n    width: 9,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 8,\n  },\n  \"+\": {\n    width: 14,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 13,\n  },\n  \",\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  \"-\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \".\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  \"/\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 7,\n  },\n  \":\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  \";\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  \"<\": {\n    width: 14,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 13,\n  },\n  \"=\": {\n    width: 14,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 13,\n  },\n  \">\": {\n    width: 14,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 13,\n  },\n  \"?\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"@\": {\n    width: 24,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 23,\n  },\n  A: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 16,\n  },\n  B: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  C: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 16,\n  },\n  D: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 16,\n  },\n  E: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  F: {\n    width: 15,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 14,\n  },\n  G: {\n    width: 19,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 17,\n  },\n  H: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  I: {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  J: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 10,\n  },\n  K: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 16,\n  },\n  L: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  M: {\n    width: 20,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 18,\n  },\n  N: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  O: {\n    width: 19,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 18,\n  },\n  P: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  Q: {\n    width: 19,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 18,\n  },\n  R: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 17,\n  },\n  S: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 15,\n  },\n  T: {\n    width: 15,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 14,\n  },\n  U: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  V: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 16,\n  },\n  W: {\n    width: 23,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 22,\n  },\n  X: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 16,\n  },\n  Y: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 16,\n  },\n  Z: {\n    width: 15,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 14,\n  },\n  \"[\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 6,\n  },\n  \"\\\\\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 7,\n  },\n  \"]\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 5,\n  },\n  \"^\": {\n    width: 11,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 11,\n  },\n  _: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 14,\n  },\n  \"`\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 5,\n  },\n  a: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  b: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  c: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  d: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  e: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  f: {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 8,\n  },\n  g: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  h: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  i: {\n    width: 5,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 4,\n  },\n  j: {\n    width: 5,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 1,\n    right: 4,\n  },\n  k: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  l: {\n    width: 5,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 4,\n  },\n  m: {\n    width: 20,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 18,\n  },\n  n: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  o: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  p: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  q: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  r: {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 8,\n  },\n  s: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 11,\n  },\n  t: {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 6,\n  },\n  u: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  v: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 12,\n  },\n  w: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 17,\n  },\n  x: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 12,\n  },\n  y: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 12,\n  },\n  z: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 11,\n  },\n  \"{\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \"|\": {\n    width: 6,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 4,\n  },\n  \"}\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \"~\": {\n    width: 14,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 13,\n  },\n}\n","import { arialTextMetrics } from \"./arial-text-metrics\"\n\nexport const estimateTextWidth = (text: string): number => {\n  if (!text) return 0\n\n  let totalWidth = 0\n  for (const char of text) {\n    const metrics = arialTextMetrics[char as keyof typeof arialTextMetrics]\n    if (metrics) {\n      totalWidth += metrics.width\n    } else {\n      // Default width for unknown characters\n      totalWidth += arialTextMetrics[\"?\"].width\n    }\n  }\n\n  // Return width normalized to font size 1\n  return totalWidth / 27 // Normalize by font height from metrics\n}\n","import type {\n  AnyCircuitElement,\n  SchematicTable,\n  SchematicTableCell,\n} from \"circuit-json\"\nimport { getSchMmFontSize } from \"lib/utils/get-sch-font-size\"\nimport { estimateTextWidth } from \"./estimate-text-width\"\n\nexport const getTableDimensions = (\n  schematicTable: SchematicTable,\n  circuitJson: AnyCircuitElement[],\n) => {\n  if (\n    schematicTable.column_widths &&\n    schematicTable.column_widths.length > 0 &&\n    schematicTable.row_heights &&\n    schematicTable.row_heights.length > 0\n  ) {\n    const unitToMm = (v: number | string) => {\n      if (typeof v === \"number\") return v\n      if (v.endsWith(\"mm\")) return parseFloat(v)\n      if (v.endsWith(\"in\")) return parseFloat(v) * 25.4\n      return parseFloat(v)\n    }\n    return {\n      column_widths: schematicTable.column_widths.map(unitToMm),\n      row_heights: schematicTable.row_heights.map(unitToMm),\n    }\n  }\n  const cells = circuitJson.filter(\n    (elm): elm is SchematicTableCell =>\n      elm.type === \"schematic_table_cell\" &&\n      elm.schematic_table_id === schematicTable.schematic_table_id,\n  )\n\n  if (cells.length === 0) {\n    return { column_widths: [], row_heights: [] }\n  }\n\n  const numColumns =\n    cells.reduce((max, c) => Math.max(max, c.end_column_index), -1) + 1\n  const numRows =\n    cells.reduce((max, c) => Math.max(max, c.end_row_index), -1) + 1\n\n  const { cell_padding = 0.2 } = schematicTable\n\n  const column_widths = new Array(numColumns).fill(0)\n  const row_heights = new Array(numRows).fill(0)\n\n  // First pass: determine minimum size for each cell\n  const cell_widths: { [key: string]: number } = {}\n  const cell_heights: { [key: string]: number } = {}\n\n  for (const cell of cells) {\n    const fontSizeMm = getSchMmFontSize(\"reference_designator\", cell.font_size)\n    const textWidthMm = estimateTextWidth(cell.text ?? \"\") * fontSizeMm\n    const requiredWidth = textWidthMm + 2 * cell_padding\n    const requiredHeight = fontSizeMm * 1.2 + 2 * cell_padding\n\n    const key = `${cell.start_row_index}-${cell.start_column_index}`\n    cell_widths[key] = requiredWidth\n    cell_heights[key] = requiredHeight\n  }\n\n  // Second pass: set column and row sizes based on the max required\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numColumns; j++) {\n      const key = `${i}-${j}`\n      if (cell_widths[key] && cell_widths[key]! > column_widths[j]!) {\n        column_widths[j] = cell_widths[key]!\n      }\n      if (cell_heights[key] && cell_heights[key]! > row_heights[i]!) {\n        row_heights[i] = cell_heights[key]!\n      }\n    }\n  }\n\n  // Third pass: adjust for merged cells\n  for (const cell of cells) {\n    if (\n      cell.start_column_index === cell.end_column_index &&\n      cell.start_row_index === cell.end_row_index\n    )\n      continue\n\n    const key = `${cell.start_row_index}-${cell.start_column_index}`\n    const requiredWidth = cell_widths[key]\n    const requiredHeight = cell_heights[key]\n\n    if (requiredWidth === undefined || requiredHeight === undefined) continue\n\n    let currentWidth = 0\n    for (let i = cell.start_column_index; i <= cell.end_column_index; i++) {\n      currentWidth += column_widths[i]!\n    }\n\n    if (requiredWidth > currentWidth) {\n      const diff = requiredWidth - currentWidth\n      const extraPerColumn =\n        diff / (cell.end_column_index - cell.start_column_index + 1)\n      for (let i = cell.start_column_index; i <= cell.end_column_index; i++) {\n        column_widths[i] += extraPerColumn\n      }\n    }\n\n    let currentHeight = 0\n    for (let i = cell.start_row_index; i <= cell.end_row_index; i++) {\n      currentHeight += row_heights[i]!\n    }\n\n    if (requiredHeight > currentHeight) {\n      const diff = requiredHeight - currentHeight\n      const extraPerRow = diff / (cell.end_row_index - cell.start_row_index + 1)\n      for (let i = cell.start_row_index; i <= cell.end_row_index; i++) {\n        row_heights[i] += extraPerRow\n      }\n    }\n  }\n\n  return { column_widths, row_heights }\n}\n","/**\n * Given a side, gives you the unit vector you would move in if you were coming\n * towards that edge from the outside. This is the same as the unit vector from\n * a port to the edge of a schematic box. This function assumes cartesian\n * coordinates (Y positive is up)\n */\nexport const getUnitVectorFromOutsideToEdge = (\n  side: \"top\" | \"bottom\" | \"left\" | \"right\",\n) => {\n  switch (side) {\n    case \"top\":\n      return { x: 0, y: -1 }\n    case \"bottom\":\n      return { x: 0, y: 1 }\n    case \"left\":\n      return { x: 1, y: 0 }\n    case \"right\":\n      return { x: -1, y: 0 }\n  }\n  throw new Error(`Invalid side: ${side}`)\n}\n","import type { SchematicNetLabel } from \"circuit-json\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport { type Matrix } from \"transformation-matrix\"\nimport { type TextPrimitive } from \"schematic-symbols\"\n\nexport const ARROW_POINT_WIDTH_FSR = 0.3\nexport const END_PADDING_FSR = 0.3\nexport const END_PADDING_EXTRA_PER_CHARACTER_FSR = 0.06\n\nexport const ninePointAnchorToTextAnchor: Record<\n  TextPrimitive[\"anchor\"],\n  \"middle\" | \"start\" | \"end\"\n> = {\n  top_left: \"start\",\n  top_right: \"end\",\n  middle_left: \"start\",\n  middle_right: \"end\",\n  bottom_left: \"start\",\n  bottom_right: \"end\",\n  center: \"middle\",\n  middle_top: \"middle\",\n  middle_bottom: \"middle\",\n}\n\nexport const ninePointAnchorToDominantBaseline: Record<\n  TextPrimitive[\"anchor\"],\n  \"hanging\" | \"ideographic\" | \"middle\"\n> = {\n  top_left: \"hanging\",\n  top_right: \"hanging\",\n  bottom_left: \"ideographic\",\n  bottom_right: \"ideographic\",\n  center: \"middle\",\n  middle_left: \"middle\",\n  middle_right: \"middle\",\n  middle_top: \"hanging\",\n  middle_bottom: \"ideographic\",\n}\n\nexport function getPathRotation(anchorSide: string): number {\n  const rotationMap = {\n    left: 180,\n    top: 90,\n    bottom: -90,\n    right: 0,\n  }\n  return rotationMap[anchorSide as keyof typeof rotationMap] ?? 0\n}\n\nexport function getTextOffsets(pathRotation: number, transform: Matrix) {\n  const scale = Math.abs(transform.a)\n  const baseOffset = scale * 0.1\n\n  const rotationOffsetMap: Record<string, { x: number; y: number }> = {\n    \"0\": { x: baseOffset * 0.8, y: -baseOffset }, // Left\n    \"-90\": { x: baseOffset * -3.5, y: baseOffset * 2.8 }, // Top\n    \"90\": { x: -baseOffset * -3.55, y: -baseOffset * 4.2 }, // Bottom\n    \"180\": { x: -baseOffset * 0.85, y: -baseOffset * 0.2 }, // Right\n  }\n\n  return rotationOffsetMap[pathRotation.toString()] || { x: 0, y: 0 }\n}\n\nexport function calculateAnchorPosition(\n  schNetLabel: SchematicNetLabel,\n  fontSizeMm: number,\n  textWidthFSR: number,\n) {\n  const fullWidthFsr =\n    textWidthFSR +\n    ARROW_POINT_WIDTH_FSR * 2 +\n    END_PADDING_EXTRA_PER_CHARACTER_FSR * schNetLabel.text.length +\n    END_PADDING_FSR\n\n  const realTextGrowthVec = getUnitVectorFromOutsideToEdge(\n    schNetLabel.anchor_side,\n  )\n\n  return (\n    schNetLabel.anchor_position ?? {\n      x:\n        schNetLabel.center.x -\n        (realTextGrowthVec.x * fullWidthFsr * fontSizeMm) / 2,\n      y:\n        schNetLabel.center.y -\n        (realTextGrowthVec.y * fullWidthFsr * fontSizeMm) / 2,\n    }\n  )\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport { getTableDimensions } from \"./get-table-dimensions\"\nimport { getSchMmFontSize } from \"lib/utils/get-sch-font-size\"\nimport {\n  ARROW_POINT_WIDTH_FSR,\n  END_PADDING_EXTRA_PER_CHARACTER_FSR,\n  END_PADDING_FSR,\n  getPathRotation,\n  calculateAnchorPosition,\n} from \"lib/utils/net-label-utils\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport { estimateTextWidth } from \"./estimate-text-width\"\ninterface Bounds {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\nexport function getSchematicBoundsFromCircuitJson(\n  soup: AnyCircuitElement[],\n  padding = 0.5,\n): Bounds {\n  let minX = Number.POSITIVE_INFINITY\n  let minY = Number.POSITIVE_INFINITY\n  let maxX = Number.NEGATIVE_INFINITY\n  let maxY = Number.NEGATIVE_INFINITY\n\n  const portSize = 0.2\n\n  // Find the bounds\n  for (const item of soup) {\n    if (item.type === \"schematic_component\") {\n      updateBounds(item.center, item.size, 0)\n    } else if (item.type === \"schematic_port\") {\n      updateBounds(item.center, { width: portSize, height: portSize }, 0)\n    } else if (item.type === \"schematic_debug_object\") {\n      if (item.shape === \"rect\") {\n        updateBounds(item.center, item.size, 0)\n      } else if (item.shape === \"line\") {\n        updateBounds(item.start, { width: 0.1, height: 0.1 }, 0)\n        updateBounds(item.end, { width: 0.1, height: 0.1 }, 0)\n      }\n    } else if (item.type === \"schematic_net_label\") {\n      const fontSizeMm = getSchMmFontSize(\"net_label\")\n      const textWidth = estimateTextWidth(item.text || \"\")\n      const fullWidthFsr =\n        textWidth +\n        ARROW_POINT_WIDTH_FSR * 2 +\n        END_PADDING_EXTRA_PER_CHARACTER_FSR * (item.text?.length || 0) +\n        END_PADDING_FSR\n      const width = fullWidthFsr * fontSizeMm\n      const height = 1.2 * fontSizeMm\n      const rotation = (getPathRotation(item.anchor_side) / 180) * Math.PI\n\n      const anchorPosition = calculateAnchorPosition(\n        item,\n        fontSizeMm,\n        textWidth,\n      )\n      const growthVec = getUnitVectorFromOutsideToEdge(item.anchor_side)\n      const center = {\n        x: anchorPosition.x + (growthVec.x * width) / 2,\n        y: anchorPosition.y + (growthVec.y * width) / 2,\n      }\n\n      updateBounds(center, { width, height }, rotation)\n    } else if (item.type === \"schematic_trace\") {\n      for (const edge of item.edges) {\n        updateBounds(edge.from, { width: 0.1, height: 0.1 }, 0)\n        updateBounds(edge.to, { width: 0.1, height: 0.1 }, 0)\n      }\n    } else if (item.type === \"schematic_text\") {\n      const textType = \"reference_designator\"\n      const fontSize = getSchMmFontSize(textType, item.font_size) ?? 0.18\n      const text = item.text ?? \"\"\n      const width = text.length * fontSize\n      const height = fontSize\n      updateBounds(item.position, { width, height }, item.rotation ?? 0)\n    } else if (item.type === \"schematic_voltage_probe\") {\n      updateBounds(item.position, { width: 0.2, height: 0.4 }, 0) // width and height of the probe (Arrow)\n    } else if (item.type === \"schematic_box\") {\n      updateBounds(\n        {\n          x: item.x + item.width / 2,\n          y: item.y + item.height / 2,\n        },\n        { width: item.width, height: item.height },\n        0,\n      )\n    } else if (item.type === \"schematic_table\") {\n      const { column_widths, row_heights } = getTableDimensions(item, soup)\n      const totalWidth = column_widths.reduce((a, b) => a + b, 0)\n      const totalHeight = row_heights.reduce((a, b) => a + b, 0)\n      const anchor = item.anchor ?? \"center\"\n\n      let topLeftX = item.anchor_position.x\n      let topLeftY = item.anchor_position.y\n\n      // Horizontal alignment\n      if (anchor.includes(\"center\")) {\n        topLeftX -= totalWidth / 2\n      } else if (anchor.includes(\"right\")) {\n        topLeftX -= totalWidth\n      }\n\n      // Vertical alignment\n      if (anchor.includes(\"center\")) {\n        topLeftY += totalHeight / 2\n      } else if (anchor.includes(\"bottom\")) {\n        topLeftY += totalHeight\n      }\n\n      const centerX = topLeftX + totalWidth / 2\n      const centerY = topLeftY - totalHeight / 2\n\n      updateBounds(\n        { x: centerX, y: centerY },\n        { width: totalWidth, height: totalHeight },\n        0,\n      )\n    } else if (item.type === \"schematic_line\") {\n      updateBounds({ x: item.x1, y: item.y1 }, { width: 0.02, height: 0.02 }, 0)\n      updateBounds({ x: item.x2, y: item.y2 }, { width: 0.02, height: 0.02 }, 0)\n    } else if (item.type === \"schematic_circle\") {\n      updateBounds(\n        item.center,\n        { width: item.radius * 2, height: item.radius * 2 },\n        0,\n      )\n    } else if (item.type === \"schematic_rect\") {\n      updateBounds(\n        item.center,\n        { width: item.width, height: item.height },\n        item.rotation,\n      )\n    } else if (item.type === \"schematic_arc\") {\n      updateBounds(\n        item.center,\n        { width: item.radius * 2, height: item.radius * 2 },\n        0,\n      )\n    }\n  }\n\n  // Add padding to bounds\n  minX -= padding\n  minY -= padding\n  maxX += padding\n  maxY += padding\n\n  return { minX, minY, maxX, maxY }\n\n  function updateBounds(center: any, size: any, rotation: number) {\n    const corners = [\n      { x: -size.width / 2, y: -size.height / 2 },\n      { x: size.width / 2, y: -size.height / 2 },\n      { x: size.width / 2, y: size.height / 2 },\n      { x: -size.width / 2, y: size.height / 2 },\n    ]\n\n    for (const corner of corners) {\n      const rotatedX =\n        corner.x * Math.cos(rotation) - corner.y * Math.sin(rotation) + center.x\n      const rotatedY =\n        corner.x * Math.sin(rotation) + corner.y * Math.cos(rotation) + center.y\n      minX = Math.min(minX, rotatedX)\n      minY = Math.min(minY, rotatedY)\n      maxX = Math.max(maxX, rotatedX)\n      maxY = Math.max(maxY, rotatedY)\n    }\n  }\n}\n","import { su } from \"@tscircuit/circuit-json-util\"\nimport type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSvg, symbols, type SchSymbol } from \"schematic-symbols\"\nimport { parseSync } from \"svgson\"\nimport {\n  applyToPoint,\n  compose,\n  translate,\n  type Matrix,\n} from \"transformation-matrix\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { matchSchPortsToSymbolPorts } from \"lib/utils/match-sch-ports-with-symbol-ports\"\nimport { pointPairsToMatrix } from \"lib/utils/point-pairs-to-matrix\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport type { TextPrimitive } from \"schematic-symbols\"\nimport { createSvgSchErrorText } from \"./create-svg-error-text\"\nimport { isSourcePortConnected } from \"lib/utils/is-source-port-connected\"\n\nconst ninePointAnchorToTextAnchor: Record<\n  TextPrimitive[\"anchor\"],\n  \"middle\" | \"start\" | \"end\"\n> = {\n  top_left: \"start\",\n  top_right: \"end\",\n  middle_left: \"start\",\n  middle_right: \"end\",\n  bottom_left: \"start\",\n  bottom_right: \"end\",\n  center: \"middle\",\n  middle_top: \"middle\",\n  middle_bottom: \"middle\",\n}\n\nconst ninePointAnchorToDominantBaseline: Record<\n  TextPrimitive[\"anchor\"],\n  \"hanging\" | \"ideographic\" | \"middle\"\n> = {\n  top_left: \"hanging\",\n  top_right: \"hanging\",\n  bottom_left: \"ideographic\",\n  bottom_right: \"ideographic\",\n  center: \"middle\",\n  middle_left: \"middle\",\n  middle_right: \"middle\",\n  middle_top: \"hanging\",\n  middle_bottom: \"ideographic\",\n}\n\nexport const createSvgObjectsFromSchematicComponentWithSymbol = ({\n  component: schComponent,\n  transform: realToScreenTransform,\n  circuitJson,\n  colorMap,\n}: {\n  component: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n  colorMap: ColorMap\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n\n  const symbol: SchSymbol = (symbols as any)[schComponent.symbol_name!]\n\n  if (!symbol) {\n    return [\n      createSvgSchErrorText({\n        text: `Symbol not found: ${schComponent.symbol_name}`,\n        realCenter: schComponent.center,\n        realToScreenTransform,\n      }),\n    ]\n  }\n\n  const schPorts = su(circuitJson as any).schematic_port.list({\n    schematic_component_id: schComponent.schematic_component_id,\n  }) as SchematicPort[]\n\n  const srcComponent = su(circuitJson as any).source_component.get(\n    schComponent.source_component_id!,\n  )\n  // Match schPorts to symbol ports using angle from schematic component center\n  const schPortsWithSymbolPorts = matchSchPortsToSymbolPorts({\n    schPorts,\n    symbol,\n    schComponent,\n  })\n\n  if (!schPortsWithSymbolPorts[0]) {\n    return [\n      createSvgSchErrorText({\n        text: `Could not match ports for symbol ${schComponent.symbol_name}`,\n        realCenter: schComponent.center,\n        realToScreenTransform,\n      }),\n    ]\n  }\n\n  const transformFromSymbolToReal = pointPairsToMatrix(\n    schPortsWithSymbolPorts[1]?.symbolPort ?? symbol.center,\n    schPortsWithSymbolPorts[1]?.schPort.center ?? schComponent.center,\n    schPortsWithSymbolPorts[0].symbolPort,\n    schPortsWithSymbolPorts[0].schPort.center,\n  )\n\n  const paths = symbol.primitives.filter((p) => p.type === \"path\")\n  const texts = symbol.primitives.filter((p) => p.type === \"text\")\n  const circles = symbol.primitives.filter((p) => p.type === \"circle\")\n  const boxes = symbol.primitives.filter((p) => p.type === \"box\")\n\n  const connectedSymbolPorts = new Set<SchSymbol[\"ports\"][number]>()\n  for (const match of schPortsWithSymbolPorts) {\n    if (isSourcePortConnected(circuitJson, match.schPort.source_port_id)) {\n      connectedSymbolPorts.add(match.symbolPort)\n    }\n  }\n\n  const bounds = {\n    minX: Math.min(...paths.flatMap((p) => p.points.map((pt) => pt.x))),\n    maxX: Math.max(...paths.flatMap((p) => p.points.map((pt) => pt.x))),\n    minY: Math.min(...paths.flatMap((p) => p.points.map((pt) => pt.y))),\n    maxY: Math.max(...paths.flatMap((p) => p.points.map((pt) => pt.y))),\n  }\n  const [screenMinX, screenMinY] = applyToPoint(\n    compose(realToScreenTransform, transformFromSymbolToReal),\n    [bounds.minX, bounds.minY],\n  )\n\n  const [screenMaxX, screenMaxY] = applyToPoint(\n    compose(realToScreenTransform, transformFromSymbolToReal),\n    [bounds.maxX, bounds.maxY],\n  )\n  const rectHeight = Math.abs(screenMaxY - screenMinY)\n  const rectY = Math.min(screenMinY, screenMaxY)\n  const rectWidth = Math.abs(screenMaxX - screenMinX)\n  const rectX = Math.min(screenMinX, screenMaxX)\n  svgObjects.push({\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      class: \"component-overlay\",\n      x: rectX.toString(),\n      y: rectY.toString(),\n      width: rectWidth.toString(),\n      height: rectHeight.toString(),\n      fill: \"transparent\",\n    },\n    children: [],\n  })\n  for (const path of paths) {\n    const { points, color, closed, fill } = path\n    svgObjects.push({\n      type: \"element\",\n      name: \"path\",\n      attributes: {\n        d:\n          points\n            .map((p, i) => {\n              const [x, y] = applyToPoint(\n                compose(realToScreenTransform, transformFromSymbolToReal),\n                [p.x, p.y],\n              )\n              return `${i === 0 ? \"M\" : \"L\"} ${x} ${y}`\n            })\n            .join(\" \") + (closed ? \" Z\" : \"\"),\n        stroke: colorMap.schematic.component_outline,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n        \"stroke-linecap\": \"round\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  for (const text of texts) {\n    const screenTextPos = applyToPoint(\n      compose(realToScreenTransform, transformFromSymbolToReal),\n      text,\n    )\n\n    let textValue = \"\"\n    if (text.text === \"{REF}\") {\n      textValue = srcComponent?.name ?? \"\"\n    } else if (text.text === \"{VAL}\") {\n      textValue = schComponent.symbol_display_value ?? \"\"\n    }\n\n    const symbolHeight = Math.abs(bounds.maxY - bounds.minY)\n    const offsetFactor = 0.1\n    const baseOffset = symbolHeight * offsetFactor\n    const transformScale = Math.abs(transformFromSymbolToReal.a)\n\n    let verticalOffset = 0\n\n    if (text.anchor.includes(\"bottom\")) {\n      verticalOffset = baseOffset * transformScale\n    } else if (text.anchor.includes(\"top\")) {\n      verticalOffset = -baseOffset * transformScale\n    }\n\n    const dominantBaseline = text.anchor.includes(\"bottom\")\n      ? \"auto\"\n      : text.anchor.includes(\"top\")\n        ? \"hanging\"\n        : \"middle\"\n    const isReferenceText = text.text === \"{REF}\"\n    svgObjects.push({\n      name: \"text\",\n      type: \"element\",\n      attributes: {\n        x: screenTextPos.x.toString(),\n        y: (screenTextPos.y + verticalOffset).toString(),\n        ...(isReferenceText\n          ? {\n              stroke: colorMap.schematic.background,\n              \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n              \"paint-order\": \"stroke\",\n            }\n          : {}),\n        fill: colorMap.schematic.label_local,\n        \"font-family\": \"sans-serif\",\n        \"text-anchor\": ninePointAnchorToTextAnchor[text.anchor],\n        \"dominant-baseline\": dominantBaseline,\n        \"font-size\": `${getSchScreenFontSize(realToScreenTransform, \"reference_designator\")}px`,\n      },\n      value: \"\",\n      children: [\n        {\n          type: \"text\",\n          value: textValue,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n    })\n  }\n\n  // Draw Boxes\n\n  for (const box of boxes) {\n    const screenBoxPos = applyToPoint(\n      compose(realToScreenTransform, transformFromSymbolToReal),\n      box,\n    )\n    const symbolToScreenScale = compose(\n      realToScreenTransform,\n      transformFromSymbolToReal,\n    ).a\n\n    svgObjects.push({\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        x: screenBoxPos.x.toString(),\n        y: screenBoxPos.y.toString(),\n        width: (box.width * symbolToScreenScale).toString(),\n        height: (box.height * symbolToScreenScale).toString(),\n        fill: \"red\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  // Draw Ports for debugging\n  for (const port of symbol.ports) {\n    if (connectedSymbolPorts.has(port)) continue\n    const screenPortPos = applyToPoint(\n      compose(realToScreenTransform, transformFromSymbolToReal),\n      port,\n    )\n    svgObjects.push({\n      type: \"element\",\n      name: \"circle\",\n      attributes: {\n        cx: screenPortPos.x.toString(),\n        cy: screenPortPos.y.toString(),\n        r: `${Math.abs(realToScreenTransform.a) * 0.02}px`,\n        \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n        fill: \"none\",\n        stroke: colorMap.schematic.component_outline,\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  for (const circle of circles) {\n    const screenCirclePos = applyToPoint(\n      compose(realToScreenTransform, transformFromSymbolToReal),\n      circle,\n    )\n    const screenRadius = Math.abs(circle.radius * realToScreenTransform.a)\n    svgObjects.push({\n      type: \"element\",\n      name: \"circle\",\n      attributes: {\n        cx: screenCirclePos.x.toString(),\n        cy: screenCirclePos.y.toString(),\n        r: `${screenRadius}px`,\n        \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n        fill: \"none\",\n        stroke: colorMap.schematic.component_outline,\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n  return svgObjects\n}\n","import type { Matrix } from \"transformation-matrix\"\n\n// 0.02mm -> 2px\nexport const getSchStrokeSize = (transform: Matrix) => {\n  return Math.abs(transform.a) * 0.02\n}\n","import type { SchematicComponent, SchematicPort } from \"circuit-json\"\nimport type { SchSymbol } from \"schematic-symbols\"\n\n// export const matchSchPortsToSymbolPorts = ({\n//   schPorts,\n//   symbol,\n//   schComponent,\n// }: {\n//   schPorts: SchematicPort[]\n//   schComponent: SchematicComponent\n//   symbol: SchSymbol\n// }): Array<{\n//   schPort: SchematicPort\n//   symbolPort: SchSymbol[\"ports\"][number]\n// }> => {\n//   // schPorts is Array<{ center: { x: number; y: number } }>\n//   // schComponent.center is { x: number; y: number }\n//   // symbol.ports is Array<{ x: number; y: number }>\n//   // symbol.center is { x: number; y: number }\n//   // Use the angles from the schComponent center to the schPorts to match with the angles from the symbol center to the symbol ports\n//   // If a port isn't matched because there are more schPorts than symbolPorts (or vice versa), then the unmatched ports should be ignored (not returned)\n// }\n\n// Helper function to calculate smallest angular difference accounting for wraparound\nconst getAngularDifference = (angle1: number, angle2: number): number => {\n  // Convert from [-, ] to [0, 2] for easier comparison\n  const a1 = angle1 < 0 ? angle1 + 2 * Math.PI : angle1\n  const a2 = angle2 < 0 ? angle2 + 2 * Math.PI : angle2\n\n  // Calculate direct difference\n  let diff = Math.abs(a1 - a2)\n  // If the difference is greater than , then the smaller angle is going the other way around\n  if (diff > Math.PI) {\n    diff = 2 * Math.PI - diff\n  }\n  return diff\n}\n\nexport const matchSchPortsToSymbolPorts = ({\n  schPorts,\n  symbol,\n  schComponent,\n}: {\n  schPorts: SchematicPort[]\n  schComponent: SchematicComponent\n  symbol: SchSymbol\n}): Array<{\n  schPort: SchematicPort\n  symbolPort: SchSymbol[\"ports\"][number]\n}> => {\n  // Calculate angles for schematic ports\n  const schPortAngles = schPorts.map((port) => {\n    const dx = port.center.x - schComponent.center.x\n    const dy = port.center.y - schComponent.center.y\n    return {\n      port,\n      angle: Math.atan2(dy, dx),\n    }\n  })\n\n  // Calculate angles for symbol ports\n  const symbolPortAngles = symbol.ports.map((port) => {\n    const dx = port.x - symbol.center.x\n    const dy = port.y - symbol.center.y\n    return {\n      port,\n      angle: Math.atan2(dy, dx),\n    }\n  })\n\n  // Sort both arrays by angle to help with initial matching\n  // Note: The sorting is less critical now that we handle wraparound properly\n  schPortAngles.sort((a, b) => a.angle - b.angle)\n  symbolPortAngles.sort((a, b) => a.angle - b.angle)\n\n  const matches: Array<{\n    schPort: SchematicPort\n    symbolPort: SchSymbol[\"ports\"][number]\n  }> = []\n\n  // Keep track of used symbol ports to avoid duplicate matches\n  const usedSymbolPorts = new Set<SchSymbol[\"ports\"][number]>()\n\n  // For each schematic port, find the best matching symbol port\n  for (const schPortAngle of schPortAngles) {\n    let bestMatch: {\n      symbolPort: SchSymbol[\"ports\"][number]\n      angleDiff: number\n    } | null = null\n\n    // Compare against all available symbol ports\n    for (const symbolPortAngle of symbolPortAngles) {\n      // Skip if this symbol port is already matched\n      if (usedSymbolPorts.has(symbolPortAngle.port)) continue\n\n      const angleDiff = getAngularDifference(\n        schPortAngle.angle,\n        symbolPortAngle.angle,\n      )\n\n      if (bestMatch === null || angleDiff < bestMatch.angleDiff) {\n        bestMatch = {\n          symbolPort: symbolPortAngle.port,\n          angleDiff,\n        }\n      }\n    }\n\n    // If we found a match and the angular difference is reasonable (e.g., less than 45 degrees)\n    if (bestMatch && bestMatch.angleDiff < Math.PI / 4) {\n      matches.push({\n        schPort: schPortAngle.port,\n        symbolPort: bestMatch.symbolPort,\n      })\n      usedSymbolPorts.add(bestMatch.symbolPort)\n    }\n  }\n\n  return matches\n}\n","import { type Matrix, compose, scale, translate } from \"transformation-matrix\"\n\ntype Point = { x: number; y: number }\n\nexport function pointPairsToMatrix(\n  a1: Point,\n  a2: Point,\n  b1: Point,\n  b2: Point,\n): Matrix {\n  // Calculate the translation based on the first point pair (A -> A')\n  const tx = a2.x - a1.x\n  const ty = a2.y - a1.y\n\n  // Calculate scaling factors using the distances between points\n  const originalDistance = Math.sqrt((b1.x - a1.x) ** 2 + (b1.y - a1.y) ** 2)\n  const transformedDistance = Math.sqrt((b2.x - a2.x) ** 2 + (b2.y - a2.y) ** 2)\n\n  const a = transformedDistance / originalDistance\n\n  // Create and compose the transformations\n  const translateMatrix = translate(tx, ty)\n  const scaleMatrix = scale(a, a)\n\n  return compose(translateMatrix, scaleMatrix)\n}\n","import type { SvgObject } from \"lib/svg-object\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { applyToPoint, type Point, type Matrix } from \"transformation-matrix\"\n\nexport const createSvgSchErrorText = ({\n  text,\n  realCenter,\n  realToScreenTransform,\n}: {\n  text: string\n  realCenter: { x: number; y: number }\n  realToScreenTransform: Matrix\n}): SvgObject => {\n  const screenCenter = applyToPoint(realToScreenTransform, realCenter)\n\n  return {\n    type: \"element\",\n    name: \"text\",\n    value: \"\",\n    attributes: {\n      x: screenCenter.x.toString(),\n      y: screenCenter.y.toString(),\n      fill: \"red\",\n      \"text-anchor\": \"middle\",\n      \"dominant-baseline\": \"middle\",\n      \"font-family\": \"sans-serif\",\n      \"font-size\": `${getSchScreenFontSize(realToScreenTransform, \"error\")}px`,\n    },\n    children: [\n      {\n        type: \"text\",\n        value: text,\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n  }\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\n\nexport const isSourcePortConnected = (\n  circuitJson: AnyCircuitElement[],\n  sourcePortId: string,\n): boolean => {\n  for (const elm of circuitJson) {\n    if (elm.type !== \"source_trace\") continue\n    const trace = elm as any\n    if (\n      Array.isArray(trace.connected_source_port_ids) &&\n      trace.connected_source_port_ids.includes(sourcePortId)\n    ) {\n      return true\n    }\n  }\n  return false\n}\n","import { su } from \"@tscircuit/circuit-json-util\"\nimport type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n  SourceSimpleChip,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSvg, symbols } from \"schematic-symbols\"\nimport { parseSync } from \"svgson\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport { createSvgObjectsFromSchematicComponentWithSymbol } from \"./create-svg-objects-from-sch-component-with-symbol\"\nimport { createSvgObjectsFromSchPortOnBox } from \"./create-svg-objects-from-sch-port-on-box\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { createSvgSchText } from \"./create-svg-objects-for-sch-text\"\n\nexport const createSvgObjectsFromSchematicComponentWithBox = ({\n  component: schComponent,\n  transform,\n  circuitJson,\n  colorMap,\n}: {\n  component: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n  colorMap: ColorMap\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n\n  const componentScreenTopLeft = applyToPoint(transform, {\n    x: schComponent.center.x - schComponent.size.width / 2,\n    y: schComponent.center.y + schComponent.size.height / 2,\n  })\n  const componentScreenBottomRight = applyToPoint(transform, {\n    x: schComponent.center.x + schComponent.size.width / 2,\n    y: schComponent.center.y - schComponent.size.height / 2,\n  })\n  const componentScreenWidth =\n    componentScreenBottomRight.x - componentScreenTopLeft.x\n  const componentScreenHeight =\n    componentScreenBottomRight.y - componentScreenTopLeft.y\n\n  // Add basic rectangle for component body\n  svgObjects.push({\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      class: \"component chip\",\n      x: componentScreenTopLeft.x.toString(),\n      y: componentScreenTopLeft.y.toString(),\n      width: componentScreenWidth.toString(),\n      height: componentScreenHeight.toString(),\n      \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n      fill: colorMap.schematic.component_body,\n      stroke: colorMap.schematic.component_outline,\n    },\n    children: [],\n  })\n\n  svgObjects.push({\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      class: \"component-overlay\",\n      x: componentScreenTopLeft.x.toString(),\n      y: componentScreenTopLeft.y.toString(),\n      width: componentScreenWidth.toString(),\n      height: componentScreenHeight.toString(),\n      fill: \"transparent\",\n    },\n    children: [],\n  })\n\n  const schTexts = su(circuitJson as any).schematic_text.list()\n\n  for (const schText of schTexts) {\n    if (\n      schText.schematic_component_id === schComponent.schematic_component_id\n    ) {\n      svgObjects.push(\n        createSvgSchText({\n          elm: schText,\n          transform,\n          colorMap,\n        }),\n      )\n    }\n  }\n  // // Process ports\n  const schematicPorts = su(circuitJson as any).schematic_port.list({\n    schematic_component_id: schComponent.schematic_component_id,\n  }) as SchematicPort[]\n\n  for (const schPort of schematicPorts) {\n    svgObjects.push(\n      ...createSvgObjectsFromSchPortOnBox({\n        schPort,\n        schComponent,\n        transform,\n        circuitJson,\n      }),\n    )\n  }\n\n  return svgObjects\n}\n","import type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport { createSvgObjectsForSchPortBoxLine } from \"./create-svg-objects-for-sch-port-box-line\"\nimport { createSvgObjectsForSchPortPinNumberText } from \"./create-svg-objects-for-sch-port-pin-number-text\"\nimport { createSvgObjectsForSchPortPinLabel } from \"./create-svg-objects-for-sch-port-pin-label\"\n\nexport const createSvgObjectsFromSchPortOnBox = (params: {\n  schPort: SchematicPort\n  schComponent: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n  const { schPort, schComponent, transform, circuitJson } = params\n\n  svgObjects.push(...createSvgObjectsForSchPortBoxLine(params))\n  svgObjects.push(...createSvgObjectsForSchPortPinNumberText(params))\n  svgObjects.push(...createSvgObjectsForSchPortPinLabel(params))\n\n  return svgObjects\n}\n","import type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport { isSourcePortConnected } from \"lib/utils/is-source-port-connected\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { colorMap } from \"lib/utils/colors\"\n\nconst PIN_CIRCLE_RADIUS_MM = 0.02\n\nconst createArrow = (\n  tip: { x: number; y: number },\n  angle: number,\n  size: number,\n  color: string,\n  strokeWidth: number,\n): SvgObject => {\n  const arrowAngle = Math.PI / 6 // 30 degrees\n  const p1 = {\n    x: tip.x - size * Math.cos(angle - arrowAngle),\n    y: tip.y - size * Math.sin(angle - arrowAngle),\n  }\n  const p2 = {\n    x: tip.x - size * Math.cos(angle + arrowAngle),\n    y: tip.y - size * Math.sin(angle + arrowAngle),\n  }\n\n  return {\n    name: \"polygon\",\n    type: \"element\",\n    attributes: {\n      points: `${tip.x},${tip.y} ${p1.x},${p1.y} ${p2.x},${p2.y}`,\n      fill: \"white\",\n      stroke: color,\n      \"stroke-width\": `${strokeWidth}px`,\n    },\n    value: \"\",\n    children: [],\n  }\n}\n\n/**\n * The schematic port box line is the line and circle that goes from the edge\n * of the component box to the port.\n */\nexport const createSvgObjectsForSchPortBoxLine = ({\n  schPort,\n  schComponent,\n  transform,\n  circuitJson,\n}: {\n  schPort: SchematicPort\n  schComponent: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n\n  const srcPort = su(circuitJson as any).source_port.get(schPort.source_port_id)\n\n  const realEdgePos = {\n    x: schPort.center.x,\n    y: schPort.center.y,\n  }\n\n  // schPort.distance_from_component_edge is currently calculated incorrectly\n  // in core\n  const realPinLineLength = schPort.distance_from_component_edge ?? 0.4\n\n  switch (schPort.side_of_component) {\n    case \"left\":\n      realEdgePos.x += realPinLineLength\n      break\n    case \"right\":\n      realEdgePos.x -= realPinLineLength\n      break\n    case \"top\":\n      realEdgePos.y -= realPinLineLength\n      break\n    case \"bottom\":\n      realEdgePos.y += realPinLineLength\n      break\n  }\n\n  const screenSchPortPos = applyToPoint(transform, schPort.center)\n  const screenRealEdgePos = applyToPoint(transform, realEdgePos)\n\n  const isConnected = isSourcePortConnected(circuitJson, schPort.source_port_id)\n\n  // For connected pins, line goes to center. For unconnected pins, stop short by circle radius\n  const realLineEnd = { ...schPort.center }\n\n  if (!isConnected) {\n    // Subtract the pin circle radius from the pin line length for unconnected pins\n    switch (schPort.side_of_component) {\n      case \"left\":\n        realLineEnd.x += PIN_CIRCLE_RADIUS_MM\n        break\n      case \"right\":\n        realLineEnd.x -= PIN_CIRCLE_RADIUS_MM\n        break\n      case \"top\":\n        realLineEnd.y -= PIN_CIRCLE_RADIUS_MM\n        break\n      case \"bottom\":\n        realLineEnd.y += PIN_CIRCLE_RADIUS_MM\n        break\n    }\n  }\n\n  const screenLineEnd = applyToPoint(transform, realLineEnd)\n\n  // Add port line\n  svgObjects.push({\n    name: \"line\",\n    type: \"element\",\n    attributes: {\n      class: \"component-pin\",\n      x1: screenRealEdgePos.x.toString(),\n      y1: screenRealEdgePos.y.toString(),\n      x2: screenLineEnd.x.toString(),\n      y2: screenLineEnd.y.toString(),\n      \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n    },\n    value: \"\",\n    children: [],\n  })\n  const pinRadiusPx = Math.abs(transform.a) * PIN_CIRCLE_RADIUS_MM\n\n  const pinChildren: SvgObject[] = []\n\n  if (!isConnected) {\n    pinChildren.push({\n      name: \"circle\",\n      type: \"element\",\n      attributes: {\n        class: \"component-pin\",\n        cx: screenSchPortPos.x.toString(),\n        cy: screenSchPortPos.y.toString(),\n        r: pinRadiusPx.toString(),\n        \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  pinChildren.push({\n    name: \"rect\",\n    type: \"element\",\n    attributes: {\n      x: (screenSchPortPos.x - pinRadiusPx).toString(),\n      y: (screenSchPortPos.y - pinRadiusPx).toString(),\n      width: (pinRadiusPx * 2).toString(),\n      height: (pinRadiusPx * 2).toString(),\n      opacity: \"0\",\n    },\n    value: \"\",\n    children: [],\n  })\n\n  svgObjects.push({\n    name: \"g\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      \"data-schematic-port-id\": schPort.source_port_id,\n    },\n    children: pinChildren,\n  })\n\n  const { has_input_arrow, has_output_arrow } = schPort as any\n\n  if ((has_input_arrow || has_output_arrow) && schPort.side_of_component) {\n    const arrowSize = Math.abs(transform.a) * 0.1\n    const arrowColor = colorMap.schematic.component_outline\n    const arrowAxialLength = arrowSize * Math.cos(Math.PI / 6)\n    const strokeWidth = getSchStrokeSize(transform) / 3\n\n    let inputAngleRads: number = 0\n    let outputAngleRads: number = 0\n\n    if (schPort.side_of_component === \"left\") {\n      inputAngleRads = 0\n      outputAngleRads = Math.PI\n    } else if (schPort.side_of_component === \"right\") {\n      inputAngleRads = Math.PI\n      outputAngleRads = 0\n    } else if (schPort.side_of_component === \"top\") {\n      inputAngleRads = Math.PI / 2\n      outputAngleRads = -Math.PI / 2\n    } else if (schPort.side_of_component === \"bottom\") {\n      inputAngleRads = -Math.PI / 2\n      outputAngleRads = Math.PI / 2\n    }\n\n    const both = has_input_arrow && has_output_arrow\n    let inputArrowTip = { ...screenRealEdgePos }\n    let outputArrowBase = { ...screenRealEdgePos }\n\n    if (both) {\n      const offset = arrowAxialLength\n      if (schPort.side_of_component === \"left\") {\n        outputArrowBase.x -= offset\n      } else if (schPort.side_of_component === \"right\") {\n        outputArrowBase.x += offset\n      } else if (schPort.side_of_component === \"top\") {\n        outputArrowBase.y -= offset\n      } else if (schPort.side_of_component === \"bottom\") {\n        outputArrowBase.y += offset\n      }\n    }\n\n    if (has_input_arrow) {\n      svgObjects.push(\n        createArrow(\n          inputArrowTip,\n          inputAngleRads,\n          arrowSize,\n          arrowColor,\n          strokeWidth,\n        ),\n      )\n    }\n    if (has_output_arrow) {\n      const outputArrowTip = {\n        x: outputArrowBase.x + arrowSize * Math.cos(outputAngleRads),\n        y: outputArrowBase.y + arrowSize * Math.sin(outputAngleRads),\n      }\n      svgObjects.push(\n        createArrow(\n          outputArrowTip,\n          outputAngleRads,\n          arrowSize,\n          arrowColor,\n          strokeWidth,\n        ),\n      )\n    }\n  }\n\n  return svgObjects\n}\n","import type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { colorMap } from \"lib/utils/colors\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport const createSvgObjectsForSchPortPinNumberText = (params: {\n  schPort: SchematicPort\n  schComponent: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n  const { schPort, schComponent, transform, circuitJson } = params\n\n  const realPinNumberPos = {\n    x: schPort.center.x,\n    y: schPort.center.y,\n  }\n\n  if (!schPort.side_of_component) return []\n  const vecToEdge = getUnitVectorFromOutsideToEdge(schPort.side_of_component)\n\n  const realPinEdgeDistance = schPort.distance_from_component_edge ?? 0.4\n\n  // Move the pin number halfway to the edge of the box component so it sits\n  // between the edge and the port, exactly in the middle\n  realPinNumberPos.x += (vecToEdge.x * realPinEdgeDistance) / 2\n  realPinNumberPos.y += (vecToEdge.y * realPinEdgeDistance) / 2\n\n  if (\n    schPort.side_of_component === \"top\" ||\n    schPort.side_of_component === \"bottom\"\n  ) {\n    // Move the pin number text to the left a bit so it doesn't hit the port line\n    realPinNumberPos.x -= 0.02 //mm\n  } else {\n    // Move the pin number text up a bit so it doesn't hit the port line\n    realPinNumberPos.y += 0.02 //mm\n  }\n\n  // Transform the pin position from local to global coordinates\n  const screenPinNumberTextPos = applyToPoint(transform, realPinNumberPos)\n\n  svgObjects.push({\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      class: \"pin-number\",\n      x: screenPinNumberTextPos.x.toString(),\n      y: screenPinNumberTextPos.y.toString(),\n      style: \"font-family: sans-serif;\",\n      fill: colorMap.schematic.pin_number,\n      \"text-anchor\": \"middle\",\n      \"dominant-baseline\": \"auto\",\n      \"font-size\": `${getSchScreenFontSize(transform, \"pin_number\")}px`,\n      transform:\n        schPort.side_of_component === \"top\" ||\n        schPort.side_of_component === \"bottom\"\n          ? `rotate(-90 ${screenPinNumberTextPos.x} ${screenPinNumberTextPos.y})`\n          : \"\",\n    },\n    children: [\n      {\n        type: \"text\",\n        value: schPort.pin_number?.toString() || \"\",\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  })\n\n  return svgObjects\n}\n","import type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { colorMap } from \"lib/utils/colors\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nconst LABEL_DIST_FROM_EDGE_MM = 0.1\n\nexport const createSvgObjectsForSchPortPinLabel = (params: {\n  schPort: SchematicPort\n  schComponent: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n  const { schPort, schComponent, transform, circuitJson } = params\n\n  const realPinNumberPos = {\n    x: schPort.center.x,\n    y: schPort.center.y,\n  }\n\n  if (!schPort.side_of_component) return []\n  const vecToEdge = getUnitVectorFromOutsideToEdge(schPort.side_of_component)\n\n  const realPinEdgeDistance = schPort.distance_from_component_edge ?? 0.4\n\n  // Move the pin number halfway to the edge of the box component so it sits\n  // between the edge and the port, exactly in the middle\n  realPinNumberPos.x +=\n    vecToEdge.x * (realPinEdgeDistance + LABEL_DIST_FROM_EDGE_MM)\n  realPinNumberPos.y +=\n    vecToEdge.y * (realPinEdgeDistance + LABEL_DIST_FROM_EDGE_MM)\n\n  // Transform the pin position from local to global coordinates\n  const screenPinNumberTextPos = applyToPoint(transform, realPinNumberPos)\n\n  const label =\n    schPort.display_pin_label ??\n    schComponent.port_labels?.[`${schPort.pin_number}`]\n\n  if (!label) return []\n\n  const isNegated = label.startsWith(\"N_\")\n  const displayLabel = isNegated ? label.slice(2) : label\n\n  let fontSizePx = getSchScreenFontSize(\n    transform,\n    isNegated ? \"negated_pin_number\" : \"pin_number\",\n  )\n\n  svgObjects.push({\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      class: \"pin-number\",\n      x: screenPinNumberTextPos.x.toString(),\n      y: screenPinNumberTextPos.y.toString(),\n      style: `font-family: sans-serif;${isNegated ? \" text-decoration: overline;\" : \"\"}`,\n      fill: colorMap.schematic.pin_number,\n      \"text-anchor\":\n        schPort.side_of_component === \"left\" ||\n        schPort.side_of_component === \"bottom\"\n          ? \"start\"\n          : \"end\",\n      \"dominant-baseline\": \"middle\",\n      \"font-size\": `${fontSizePx}px`,\n      transform:\n        schPort.side_of_component === \"top\" ||\n        schPort.side_of_component === \"bottom\"\n          ? `rotate(-90 ${screenPinNumberTextPos.x} ${screenPinNumberTextPos.y})`\n          : \"\",\n    },\n    children: [\n      {\n        type: \"text\",\n        value: displayLabel || \"\",\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  })\n\n  return svgObjects\n}\n","import type { SchematicText } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport const createSvgSchText = ({\n  elm,\n  transform,\n  colorMap,\n}: {\n  elm: SchematicText\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject => {\n  // Apply transformation\n  const center = applyToPoint(transform, elm.position)\n\n  const textAnchorMap: Record<\n    | \"center\"\n    | \"left\"\n    | \"right\"\n    | \"top\"\n    | \"bottom\"\n    | \"top_left\"\n    | \"top_center\"\n    | \"top_right\"\n    | \"center_left\"\n    | \"center_right\"\n    | \"bottom_left\"\n    | \"bottom_center\"\n    | \"bottom_right\",\n    string\n  > = {\n    center: \"middle\",\n    center_right: \"end\",\n    bottom_left: \"start\",\n    bottom_center: \"middle\",\n    bottom_right: \"end\",\n    left: \"start\",\n    right: \"end\",\n    top: \"middle\",\n    bottom: \"middle\",\n    top_left: \"start\",\n    top_center: \"middle\",\n    top_right: \"end\",\n    center_left: \"start\",\n  }\n\n  const dominantBaselineMap: Record<\n    | \"center\"\n    | \"left\"\n    | \"right\"\n    | \"top\"\n    | \"bottom\"\n    | \"top_left\"\n    | \"top_center\"\n    | \"top_right\"\n    | \"center_left\"\n    | \"center_right\"\n    | \"bottom_left\"\n    | \"bottom_center\"\n    | \"bottom_right\",\n    string\n  > = {\n    center: \"middle\",\n    center_right: \"middle\",\n    bottom_left: \"ideographic\",\n    bottom_center: \"ideographic\",\n    bottom_right: \"ideographic\",\n    left: \"middle\",\n    right: \"middle\",\n    top: \"hanging\",\n    bottom: \"ideographic\",\n    top_left: \"hanging\",\n    top_center: \"hanging\",\n    top_right: \"hanging\",\n    center_left: \"middle\",\n  }\n\n  const lines = elm.text.split(\"\\n\")\n\n  const children: SvgObject[] =\n    lines.length === 1\n      ? [\n          {\n            type: \"text\",\n            value: elm.text,\n            name: elm.schematic_text_id,\n            attributes: {},\n            children: [],\n          },\n        ]\n      : lines.map((line, idx) => ({\n          type: \"element\",\n          name: \"tspan\",\n          value: \"\",\n          attributes: {\n            x: center.x.toString(),\n            ...(idx > 0 ? { dy: \"1em\" } : {}),\n          },\n          children: [\n            {\n              type: \"text\",\n              value: line,\n              name: idx === 0 ? elm.schematic_text_id : \"\",\n              attributes: {},\n              children: [],\n            },\n          ],\n        }))\n\n  return {\n    type: \"element\",\n    name: \"text\",\n    value: \"\",\n    attributes: {\n      x: center.x.toString(),\n      y: center.y.toString(),\n      fill: elm.color ?? colorMap.schematic.sheet_label,\n      \"text-anchor\": textAnchorMap[elm.anchor],\n      \"dominant-baseline\": dominantBaselineMap[elm.anchor],\n      \"font-family\": \"sans-serif\",\n      \"font-size\": `${getSchScreenFontSize(transform, \"reference_designator\", elm.font_size)}px`,\n      transform: `rotate(${elm.rotation}, ${center.x}, ${center.y})`,\n    },\n    children,\n  }\n}\n","import type { AnyCircuitElement, SchematicComponent } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { createSvgObjectsFromSchematicComponentWithSymbol } from \"./create-svg-objects-from-sch-component-with-symbol\"\nimport { createSvgObjectsFromSchematicComponentWithBox } from \"./create-svg-objects-from-sch-component-with-box\"\nimport type { Matrix } from \"transformation-matrix\"\n\nexport function createSvgObjectsFromSchematicComponent(params: {\n  component: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n  colorMap: ColorMap\n}): SvgObject[] {\n  const { component } = params\n\n  if (component.is_box_with_pins === false) {\n    return []\n  }\n\n  const innerElements = component.symbol_name\n    ? createSvgObjectsFromSchematicComponentWithSymbol(params)\n    : createSvgObjectsFromSchematicComponentWithBox(params)\n\n  return [\n    {\n      type: \"element\",\n      name: \"g\",\n      attributes: {\n        \"data-circuit-json-type\": \"schematic_component\",\n        \"data-schematic-component-id\": component.schematic_component_id,\n      },\n      children: innerElements,\n      value: \"\",\n    },\n  ]\n}\n","import type { SchematicVoltageProbe } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport function createSvgObjectsFromSchVoltageProbe({\n  probe,\n  transform,\n  colorMap,\n}: {\n  probe: SchematicVoltageProbe\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] {\n  const [screenX, screenY] = applyToPoint(transform, [\n    probe.position.x,\n    probe.position.y,\n  ])\n\n  const probeColor = probe.color ?? colorMap.schematic.reference\n\n  const arrowLength = Math.abs(transform.a) * 0.6\n  const arrowWidth = Math.abs(transform.a) * 0.28\n\n  const baseX = screenX + arrowLength * Math.cos((-50 * Math.PI) / 180)\n  const baseY = screenY + arrowLength * Math.sin((-50 * Math.PI) / 180)\n\n  const tipX = screenX\n  const tipY = screenY\n\n  const arrowPath = [\n    `M ${baseX},${baseY}`,\n    `L ${tipX},${tipY}`,\n    `M ${tipX},${tipY}`,\n    `L ${tipX - arrowWidth * Math.cos(((-50 + 150) * Math.PI) / 180)},${tipY - arrowWidth * Math.sin(((-50 + 150) * Math.PI) / 180)}`,\n    `L ${tipX - arrowWidth * Math.cos(((-50 + 210) * Math.PI) / 180)},${tipY - arrowWidth * Math.sin(((-50 + 210) * Math.PI) / 180)}`,\n    \"Z\",\n  ].join(\" \")\n\n  const x = (baseX + 8 - (baseX - baseX)).toString()\n  const textChildren: SvgObject[] = []\n\n  if (probe.name && probe.voltage !== undefined) {\n    textChildren.push({\n      type: \"element\",\n      name: \"tspan\",\n      value: \"\",\n      attributes: {\n        x,\n      },\n      children: [\n        {\n          type: \"text\",\n          value: probe.name,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n    })\n    textChildren.push({\n      type: \"element\",\n      name: \"tspan\",\n      value: \"\",\n      attributes: {\n        x,\n        dy: \"1.2em\",\n      },\n      children: [\n        {\n          type: \"text\",\n          value: `${probe.voltage}V`,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n    })\n  } else {\n    const textParts: string[] = []\n    if (probe.name) {\n      textParts.push(probe.name)\n    }\n    if (probe.voltage !== undefined) {\n      textParts.push(`${probe.voltage}V`)\n    }\n    textChildren.push({\n      type: \"text\",\n      value: textParts.join(\" \"),\n      name: \"\",\n      attributes: {},\n      children: [],\n    })\n  }\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: arrowPath,\n        stroke: probeColor,\n        fill: probeColor,\n        \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n      },\n      value: \"\",\n      children: [],\n    },\n    {\n      type: \"element\",\n      name: \"text\",\n      value: \"\",\n      attributes: {\n        x,\n        y: baseY.toString(),\n        fill: probeColor,\n        \"text-anchor\": \"start\",\n        \"dominant-baseline\": \"middle\",\n        \"font-family\": \"sans-serif\",\n        \"font-size\": `${getSchScreenFontSize(transform, \"reference_designator\")}px`,\n        \"font-weight\": \"bold\",\n        \"data-schematic-voltage-probe-id\": probe.schematic_voltage_probe_id,\n      },\n      children: textChildren,\n    },\n  ]\n}\n","import type { SchematicDebugObject } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport function createSvgObjectsFromSchDebugObject({\n  debugObject,\n  transform,\n}: {\n  debugObject: SchematicDebugObject\n  transform: Matrix\n}): SvgObject[] {\n  if (debugObject.shape === \"rect\") {\n    // Transform all corners\n    let [screenLeft, screenTop] = applyToPoint(transform, [\n      debugObject.center.x - debugObject.size.width / 2,\n      debugObject.center.y - debugObject.size.height / 2,\n    ])\n    let [screenRight, screenBottom] = applyToPoint(transform, [\n      debugObject.center.x + debugObject.size.width / 2,\n      debugObject.center.y + debugObject.size.height / 2,\n    ])\n    ;[screenTop, screenBottom] = [\n      Math.min(screenTop, screenBottom),\n      Math.max(screenTop, screenBottom),\n    ]\n\n    // Calculate screen width and height\n    const width = Math.abs(screenRight - screenLeft)\n    const height = Math.abs(screenBottom - screenTop)\n\n    const [screenCenterX, screenCenterY] = applyToPoint(transform, [\n      debugObject.center.x,\n      debugObject.center.y,\n    ])\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        value: \"\",\n        attributes: {\n          x: screenLeft.toString(),\n          y: screenTop.toString(),\n          width: width.toString(),\n          height: height.toString(),\n          fill: \"none\",\n          stroke: \"red\",\n          \"stroke-width\": (0.02 * Math.abs(transform.a)).toString(),\n          \"stroke-dasharray\": \"5,5\",\n        },\n        children: debugObject.label\n          ? [\n              {\n                name: \"text\",\n                type: \"element\",\n                value: \"\",\n                attributes: {\n                  x: screenCenterX.toString(),\n                  y: (screenCenterY - 10).toString(),\n                  \"text-anchor\": \"middle\",\n                  \"font-size\": (0.2 * Math.abs(transform.a)).toString(),\n                  fill: \"red\",\n                },\n                children: [\n                  {\n                    type: \"text\",\n                    value: debugObject.label,\n                    name: \"\",\n                    attributes: {},\n                    children: [],\n                  },\n                ],\n              },\n            ]\n          : [],\n      },\n    ]\n  }\n  if (debugObject.shape === \"line\") {\n    // Transform start and end points - flip Y coordinates\n    const [screenStartX, screenStartY] = applyToPoint(transform, [\n      debugObject.start.x,\n      debugObject.start.y,\n    ])\n    const [screenEndX, screenEndY] = applyToPoint(transform, [\n      debugObject.end.x,\n      debugObject.end.y,\n    ])\n\n    // Calculate midpoint for label\n    const screenMidX = (screenStartX + screenEndX) / 2\n    const screenMidY = (screenStartY + screenEndY) / 2\n\n    return [\n      {\n        name: \"line\",\n        type: \"element\",\n        value: \"\",\n        attributes: {\n          x1: screenStartX.toString(),\n          y1: screenStartY.toString(),\n          x2: screenEndX.toString(),\n          y2: screenEndY.toString(),\n          stroke: \"red\",\n          \"stroke-width\": (0.02 * Math.abs(transform.a)).toString(),\n          \"stroke-dasharray\": \"5,5\",\n        },\n        children: debugObject.label\n          ? [\n              {\n                name: \"text\",\n                type: \"element\",\n                value: \"\",\n                attributes: {\n                  x: screenMidX.toString(),\n                  y: (screenMidY - 10).toString(),\n                  \"text-anchor\": \"middle\",\n                  \"font-size\": (0.2 * Math.abs(transform.a)).toString(),\n                  fill: \"red\",\n                },\n                children: [\n                  {\n                    type: \"text\",\n                    value: debugObject.label,\n                    name: \"\",\n                    attributes: {},\n                    children: [],\n                  },\n                ],\n              },\n            ]\n          : [],\n      },\n    ]\n  }\n  return []\n}\n","import type { SchematicTrace } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport function createSchematicTrace({\n  trace,\n  transform,\n  colorMap,\n}: {\n  trace: SchematicTrace\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] {\n  const edges = trace.edges\n  if (edges.length === 0) return []\n  // Split into base vs overlay to control global z-order\n  const baseObjects: SvgObject[] = []\n  const overlayObjects: SvgObject[] = []\n\n  let path = \"\"\n\n  // Process edges into an SVG path\n  for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n    const edge = edges[edgeIndex]!\n\n    if (edge.is_crossing) continue\n\n    // Transform the points using the matrix\n    const [screenFromX, screenFromY] = applyToPoint(transform, [\n      edge.from.x,\n      edge.from.y,\n    ])\n    const [screenToX, screenToY] = applyToPoint(transform, [\n      edge.to.x,\n      edge.to.y,\n    ])\n\n    // Regular straight line for non-crossing traces\n    if (edgeIndex === 0 || edges[edgeIndex - 1]?.is_crossing) {\n      path += `M ${screenFromX} ${screenFromY} L ${screenToX} ${screenToY}`\n    } else {\n      path += ` L ${screenToX} ${screenToY}`\n    }\n  }\n\n  // Note: draw the base wire first (below), then draw\n  // the crossing outline + hop on top for correct z-ordering.\n\n  if (path) {\n    // Makes hovering over trace (which inverts the colors) easier\n    baseObjects.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: path,\n        class: \"trace-invisible-hover-outline\",\n        stroke: colorMap.schematic.wire,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(transform) * 8}px`,\n        \"stroke-linecap\": \"round\",\n        opacity: \"0\",\n        \"stroke-linejoin\": \"round\",\n      },\n      value: \"\",\n      children: [],\n    })\n    baseObjects.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: path,\n        stroke: colorMap.schematic.wire,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n        \"stroke-linecap\": \"round\",\n        \"stroke-linejoin\": \"round\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  // Process wire crossings with little \"hops\" or arcs\n  // These must be added AFTER the base wire so they render on top.\n  for (const edge of edges) {\n    if (!edge.is_crossing) continue\n\n    // Transform the points using the matrix\n    const [screenFromX, screenFromY] = applyToPoint(transform, [\n      edge.from.x,\n      edge.from.y,\n    ])\n    const [screenToX, screenToY] = applyToPoint(transform, [\n      edge.to.x,\n      edge.to.y,\n    ])\n    // For crossing traces, create a small arc/hop\n    const midX = (screenFromX + screenToX) / 2\n    const midY = (screenFromY + screenToY) / 2\n\n    // Calculate perpendicular offset for the arc\n    const dx = screenToX - screenFromX\n    const dy = screenToY - screenFromY\n    const len = Math.sqrt(dx * dx + dy * dy)\n    const hopHeight = len * 0.7\n\n    // Perpendicular vector\n    const perpX = (-dy / len) * hopHeight\n    const perpY = (dx / len) * hopHeight\n\n    // Control point for the quadratic curve\n    const controlX = midX + perpX\n    const controlY = midY - Math.abs(perpY)\n\n    // Arc Shadow (masking the underlying wire under the hop)\n    // Arc Shadow (masking the underlying wire under the hop)\n    overlayObjects.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        class: \"trace-crossing-outline\",\n        d: `M ${screenFromX} ${screenFromY} Q ${controlX} ${controlY} ${screenToX} ${screenToY}`,\n        stroke: colorMap.schematic.background,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(transform) * 1.5}px`,\n        \"stroke-linecap\": \"butt\",\n      },\n      value: \"\",\n      children: [],\n    })\n    // Hop stroke on top\n    overlayObjects.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: `M ${screenFromX} ${screenFromY} Q ${controlX} ${controlY} ${screenToX} ${screenToY}`,\n        stroke: colorMap.schematic.wire,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n        \"stroke-linecap\": \"round\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  // Add junction circles\n  if (trace.junctions) {\n    for (const junction of trace.junctions) {\n      const [screenX, screenY] = applyToPoint(transform, [\n        junction.x,\n        junction.y,\n      ])\n      // Draw junctions above wires\n      overlayObjects.push({\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          cx: screenX.toString(),\n          cy: screenY.toString(),\n          r: (Math.abs(transform.a) * 0.03).toString(),\n          class: \"trace-junction\",\n          fill: colorMap.schematic.junction,\n        },\n        value: \"\",\n        children: [],\n      })\n    }\n  }\n\n  // Return separate groups for base and overlays\n  return [\n    {\n      name: \"g\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        class: \"trace\",\n        \"data-layer\": \"base\",\n        \"data-circuit-json-type\": \"schematic_trace\",\n        \"data-schematic-trace-id\": trace.schematic_trace_id,\n        ...(trace.subcircuit_connectivity_map_key && {\n          \"data-subcircuit-connectivity-map-key\":\n            trace.subcircuit_connectivity_map_key,\n        }),\n      },\n      children: baseObjects,\n    },\n    {\n      name: \"g\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        class: \"trace-overlays\",\n        \"data-layer\": \"overlay\",\n        \"data-circuit-json-type\": \"schematic_trace\",\n        \"data-schematic-trace-id\": trace.schematic_trace_id,\n        ...(trace.subcircuit_connectivity_map_key && {\n          \"data-subcircuit-connectivity-map-key\":\n            trace.subcircuit_connectivity_map_key,\n        }),\n      },\n      children: overlayObjects,\n    },\n  ]\n}\n","import type { SchematicNetLabel } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport {\n  getSchMmFontSize,\n  getSchScreenFontSize,\n} from \"lib/utils/get-sch-font-size\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport {\n  applyToPoint,\n  compose,\n  rotate,\n  scale,\n  translate,\n  type Matrix,\n} from \"transformation-matrix\"\nimport { estimateTextWidth } from \"../estimate-text-width\"\nimport { createSvgObjectsForSchNetLabelWithSymbol } from \"./create-svg-objects-for-sch-net-label-with-symbol\"\nimport {\n  ARROW_POINT_WIDTH_FSR,\n  END_PADDING_FSR,\n  END_PADDING_EXTRA_PER_CHARACTER_FSR,\n} from \"../../utils/net-label-utils\"\n\nexport const createSvgObjectsForSchNetLabel = ({\n  schNetLabel,\n  realToScreenTransform,\n  colorMap,\n}: {\n  schNetLabel: SchematicNetLabel\n  realToScreenTransform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] => {\n  if (!schNetLabel.text) return []\n\n  const labelText = schNetLabel.text\n\n  // If symbol_name is provided, use the symbol renderer\n  if (schNetLabel.symbol_name) {\n    return createSvgObjectsForSchNetLabelWithSymbol({\n      schNetLabel,\n      realToScreenTransform,\n      colorMap,\n    })\n  }\n\n  const svgObjects: SvgObject[] = []\n\n  const fontSizePx = getSchScreenFontSize(realToScreenTransform, \"net_label\")\n  const fontSizeMm = getSchMmFontSize(\"net_label\")\n  const textWidthFSR = estimateTextWidth(labelText || \"\")\n\n  // Transform the center position to screen coordinates\n  const screenCenter = applyToPoint(realToScreenTransform, schNetLabel.center)\n\n  const realTextGrowthVec = getUnitVectorFromOutsideToEdge(\n    schNetLabel.anchor_side,\n  )\n\n  const screenTextGrowthVec = { ...realTextGrowthVec }\n  screenTextGrowthVec.y *= -1 // Invert y direction because anchor_side is pre-transform\n\n  const fullWidthFsr =\n    textWidthFSR +\n    ARROW_POINT_WIDTH_FSR * 2 +\n    END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length +\n    END_PADDING_FSR\n  const screenAnchorPosition = schNetLabel.anchor_position\n    ? applyToPoint(realToScreenTransform, schNetLabel.anchor_position)\n    : {\n        x:\n          screenCenter.x -\n          (screenTextGrowthVec.x * fullWidthFsr * fontSizePx) / 2,\n        y:\n          screenCenter.y -\n          (screenTextGrowthVec.y * fullWidthFsr * fontSizePx) / 2,\n      }\n  const realAnchorPosition = schNetLabel.anchor_position ?? {\n    x:\n      schNetLabel.center.x -\n      (realTextGrowthVec.x * fullWidthFsr * fontSizeMm) / 2,\n    y:\n      schNetLabel.center.y -\n      (realTextGrowthVec.y * fullWidthFsr * fontSizeMm) / 2,\n  }\n\n  // Get rotation angle based on anchor_side\n  const pathRotation = {\n    left: 0,\n    top: -90,\n    bottom: 90,\n    right: 180,\n  }[schNetLabel.anchor_side]\n\n  // Calculate the points for the outline\n  const screenOutlinePoints: Array<{ x: number; y: number }> = [\n    // Arrow point in font-relative coordinates\n    {\n      x: 0,\n      y: 0,\n    },\n    // Top left corner in font-relative coordinates\n    {\n      x: ARROW_POINT_WIDTH_FSR,\n      y: 0.6,\n    },\n    // Top right corner in font-relative coordinates\n    {\n      x:\n        ARROW_POINT_WIDTH_FSR * 2 +\n        END_PADDING_FSR +\n        END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length +\n        textWidthFSR,\n      y: 0.6,\n    },\n    // Bottom right corner in font-relative coordinates\n    {\n      x:\n        ARROW_POINT_WIDTH_FSR * 2 +\n        END_PADDING_FSR +\n        END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length +\n        textWidthFSR,\n      y: -0.6,\n    },\n    // Bottom left corner in font-relative coordinates\n    {\n      x: ARROW_POINT_WIDTH_FSR,\n      y: -0.6,\n    },\n  ].map((fontRelativePoint) =>\n    applyToPoint(\n      compose(\n        realToScreenTransform,\n        translate(realAnchorPosition.x, realAnchorPosition.y),\n        scale(fontSizeMm),\n        rotate((pathRotation / 180) * Math.PI),\n      ),\n      fontRelativePoint,\n    ),\n  )\n\n  // Create the label path\n  const pathD = `\n    M ${screenOutlinePoints[0]!.x},${screenOutlinePoints[0]!.y}\n    L ${screenOutlinePoints[1]!.x},${screenOutlinePoints[1]!.y}\n    L ${screenOutlinePoints[2]!.x},${screenOutlinePoints[2]!.y}\n    L ${screenOutlinePoints[3]!.x},${screenOutlinePoints[3]!.y}\n    L ${screenOutlinePoints[4]!.x},${screenOutlinePoints[4]!.y}\n    Z\n  `\n\n  // Add the label container path\n  svgObjects.push({\n    name: \"path\",\n    type: \"element\",\n    attributes: {\n      class: \"net-label\",\n      d: pathD,\n      fill: colorMap.schematic.label_background,\n      stroke: colorMap.schematic.label_global,\n      \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n    },\n    value: \"\",\n    children: [],\n  })\n\n  const screenTextPos = {\n    x: screenAnchorPosition.x + screenTextGrowthVec.x * fontSizePx * 0.5,\n    y: screenAnchorPosition.y + screenTextGrowthVec.y * fontSizePx * 0.5,\n  }\n\n  const textAnchor = {\n    left: \"start\",\n    top: \"start\",\n    bottom: \"start\",\n    right: \"end\",\n  }[schNetLabel.anchor_side]\n\n  const textTransformString = {\n    left: \"\",\n    right: \"\",\n    top: `rotate(90 ${screenTextPos.x} ${screenTextPos.y})`,\n    bottom: `rotate(-90 ${screenTextPos.x} ${screenTextPos.y})`,\n  }[schNetLabel.anchor_side]\n\n  // Add the label text\n  svgObjects.push({\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      class: \"net-label-text\",\n      x: screenTextPos.x.toString(),\n      y: screenTextPos.y.toString(),\n      fill: colorMap.schematic.label_global,\n      \"text-anchor\": textAnchor,\n      \"dominant-baseline\": \"central\",\n      \"font-family\": \"sans-serif\",\n      \"font-variant-numeric\": \"tabular-nums\",\n      \"font-size\": `${fontSizePx}px`,\n      transform: textTransformString,\n    },\n    children: [\n      {\n        type: \"text\",\n        value: labelText || \"\",\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  })\n\n  return svgObjects\n}\n","import type { SchematicNetLabel } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport {\n  getSchMmFontSize,\n  getSchScreenFontSize,\n} from \"lib/utils/get-sch-font-size\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport {\n  applyToPoint,\n  compose,\n  rotate,\n  scale,\n  translate,\n  type Matrix,\n} from \"transformation-matrix\"\nimport { estimateTextWidth } from \"../estimate-text-width\"\nimport { symbols } from \"schematic-symbols\"\nimport { createSvgSchErrorText } from \"./create-svg-error-text\"\nimport {\n  ninePointAnchorToTextAnchor,\n  ninePointAnchorToDominantBaseline,\n  ARROW_POINT_WIDTH_FSR,\n  END_PADDING_EXTRA_PER_CHARACTER_FSR,\n  END_PADDING_FSR,\n  getTextOffsets,\n} from \"../../utils/net-label-utils\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport type { ColorMap } from \"lib/utils/colors\"\n\nexport const createSvgObjectsForSchNetLabelWithSymbol = ({\n  schNetLabel,\n  realToScreenTransform,\n  colorMap,\n}: {\n  schNetLabel: SchematicNetLabel\n  realToScreenTransform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] => {\n  if (!schNetLabel.text) return []\n  const isNegated = schNetLabel.text.startsWith(\"N_\")\n  const labelText = isNegated ? schNetLabel.text.slice(2) : schNetLabel.text\n  const svgObjects: SvgObject[] = []\n\n  // If symbol name is provided, draw the symbol\n  const symbol = symbols[schNetLabel.symbol_name as keyof typeof symbols]\n  if (!symbol) {\n    svgObjects.push(\n      createSvgSchErrorText({\n        text: `Symbol not found: ${schNetLabel.symbol_name}`,\n        realCenter: schNetLabel.center,\n        realToScreenTransform,\n      }),\n    )\n    return svgObjects\n  }\n  const symbolPaths = symbol.primitives.filter((p) => p.type === \"path\")\n  const symbolTexts = symbol.primitives.filter((p) => p.type === \"text\")\n  const symbolCircles = symbol.primitives.filter((p) => p.type === \"circle\")\n  const symbolBoxes = symbol.primitives.filter((p) => p.type === \"box\")\n\n  // Calculate symbol bounds for overlay\n  const bounds = {\n    minX: Math.min(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.x))),\n    maxX: Math.max(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.x))),\n    minY: Math.min(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.y))),\n    maxY: Math.max(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.y))),\n  }\n\n  // Use the same positioning logic as the net label text\n  const fontSizeMm = getSchMmFontSize(\"net_label\")\n  const textWidthFSR = estimateTextWidth(labelText || \"\")\n\n  const fullWidthFsr =\n    textWidthFSR +\n    ARROW_POINT_WIDTH_FSR * 2 +\n    END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length +\n    END_PADDING_FSR\n\n  const realTextGrowthVec = getUnitVectorFromOutsideToEdge(\n    schNetLabel.anchor_side,\n  )\n\n  const realAnchorPosition = schNetLabel.anchor_position ?? {\n    x:\n      schNetLabel.center.x -\n      (realTextGrowthVec.x * fullWidthFsr * fontSizeMm) / 2,\n    y:\n      schNetLabel.center.y -\n      (realTextGrowthVec.y * fullWidthFsr * fontSizeMm) / 2,\n  }\n\n  // Symbols referenced by name already encode their orientation, so\n  // no additional rotation should be applied based on `anchor_side`.\n  const pathRotation = 0\n\n  // Create transformation matrix that matches net label positioning\n  // Calculate the rotation matrix based on the path rotation\n  const rotationMatrix = rotate((pathRotation / 180) * Math.PI)\n\n  // Calculate the symbol's end point after rotation\n  const symbolBounds = {\n    minX: Math.min(\n      ...symbol.primitives.flatMap((p) =>\n        p.type === \"path\" ? p.points.map((pt) => pt.x) : [],\n      ),\n    ),\n    maxX: Math.max(\n      ...symbol.primitives.flatMap((p) =>\n        p.type === \"path\" ? p.points.map((pt) => pt.x) : [],\n      ),\n    ),\n    minY: Math.min(\n      ...symbol.primitives.flatMap((p) =>\n        p.type === \"path\" ? p.points.map((pt) => pt.y) : [],\n      ),\n    ),\n    maxY: Math.max(\n      ...symbol.primitives.flatMap((p) =>\n        p.type === \"path\" ? p.points.map((pt) => pt.y) : [],\n      ),\n    ),\n  }\n\n  // Use the first port as the connection point when available. This\n  // accounts for symbols whose anchor is not the leftmost edge (e.g.\n  // vertically oriented ground/VCC symbols).\n  const symbolEndPoint = symbol.ports?.[0]\n    ? { x: symbol.ports[0].x, y: symbol.ports[0].y }\n    : {\n        x: symbolBounds.minX,\n        y: (symbolBounds.minY + symbolBounds.maxY) / 2,\n      }\n\n  const rotatedSymbolEnd = applyToPoint(rotationMatrix, symbolEndPoint)\n\n  // Adjust the translation to account for rotated symbol end\n  const symbolToRealTransform = compose(\n    translate(\n      realAnchorPosition.x - rotatedSymbolEnd.x,\n      realAnchorPosition.y - rotatedSymbolEnd.y,\n    ),\n    rotationMatrix,\n    scale(1), // Use full symbol size\n  )\n\n  // Calculate screen bounds\n  const [screenMinX, screenMinY] = applyToPoint(\n    compose(realToScreenTransform, symbolToRealTransform),\n    [bounds.minX, bounds.minY],\n  )\n  const [screenMaxX, screenMaxY] = applyToPoint(\n    compose(realToScreenTransform, symbolToRealTransform),\n    [bounds.maxX, bounds.maxY],\n  )\n\n  const rectHeight = Math.abs(screenMaxY - screenMinY)\n  const rectY = Math.min(screenMinY, screenMaxY)\n  const rectWidth = Math.abs(screenMaxX - screenMinX)\n  const rectX = Math.min(screenMinX, screenMaxX)\n\n  // Add overlay rectangle\n  svgObjects.push({\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      class: \"component-overlay\",\n      x: rectX.toString(),\n      y: rectY.toString(),\n      width: rectWidth.toString(),\n      height: rectHeight.toString(),\n      fill: \"transparent\",\n    },\n    children: [],\n  })\n\n  // Draw symbol paths\n  for (const path of symbolPaths) {\n    const symbolPath = path.points\n      .map((p, i) => {\n        const [x, y] = applyToPoint(\n          compose(realToScreenTransform, symbolToRealTransform),\n          [p.x, p.y],\n        )\n        return `${i === 0 ? \"M\" : \"L\"} ${x} ${y}`\n      })\n      .join(\" \")\n\n    svgObjects.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: symbolPath + (path.closed ? \" Z\" : \"\"),\n        stroke: colorMap.schematic.component_outline,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n        \"stroke-linecap\": \"round\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  // Draw symbol texts\n  for (const text of symbolTexts) {\n    const screenTextPos = applyToPoint(\n      compose(realToScreenTransform, symbolToRealTransform),\n      text,\n    )\n\n    let textValue = text.text\n    if (textValue === \"{REF}\") {\n      textValue = labelText || \"\"\n    } else if (textValue === \"{VAL}\") {\n      textValue = \"\" // You can modify this if needed\n    }\n\n    // Adjust vertical positioning for left anchor side\n\n    // Calculate scale-adjusted text offset based on transform\n    const scale = Math.abs(realToScreenTransform.a)\n    const baseOffset = scale * 0.1 // Base offset unit in screen coordinates\n\n    // Symbols define their own text placement, so no additional\n    // offsets should be applied based on path rotation.\n    const offsetScreenPos = {\n      x: screenTextPos.x,\n      y: screenTextPos.y,\n    }\n\n    svgObjects.push({\n      name: \"text\",\n      type: \"element\",\n      attributes: {\n        x: offsetScreenPos.x.toString(),\n        y: offsetScreenPos.y.toString(),\n        fill: colorMap.schematic.label_local,\n        \"font-family\": \"sans-serif\",\n        \"text-anchor\": ninePointAnchorToTextAnchor[text.anchor],\n        \"dominant-baseline\": ninePointAnchorToDominantBaseline[text.anchor],\n        \"font-size\": `${getSchScreenFontSize(realToScreenTransform, \"reference_designator\")}px`,\n        ...(isNegated && textValue === labelText\n          ? { style: \"text-decoration: overline;\" }\n          : {}),\n      },\n      children: [\n        {\n          type: \"text\",\n          value: textValue,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n      value: \"\",\n    })\n  }\n  // Draw symbol boxes\n  for (const box of symbolBoxes) {\n    const screenBoxPos = applyToPoint(\n      compose(realToScreenTransform, symbolToRealTransform),\n      box,\n    )\n    const symbolToScreenScale = compose(\n      realToScreenTransform,\n      symbolToRealTransform,\n    ).a\n\n    svgObjects.push({\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        x: screenBoxPos.x.toString(),\n        y: screenBoxPos.y.toString(),\n        width: (box.width * symbolToScreenScale).toString(),\n        height: (box.height * symbolToScreenScale).toString(),\n        fill: \"red\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  // Draw symbol circles\n  for (const circle of symbolCircles) {\n    const screenCirclePos = applyToPoint(\n      compose(realToScreenTransform, symbolToRealTransform),\n      circle,\n    )\n    const symbolToScreenScale = compose(\n      realToScreenTransform,\n      symbolToRealTransform,\n    ).a\n\n    svgObjects.push({\n      name: \"circle\",\n      type: \"element\",\n      attributes: {\n        cx: screenCirclePos.x.toString(),\n        cy: screenCirclePos.y.toString(),\n        r: (circle.radius * symbolToScreenScale).toString(),\n        fill: \"none\",\n        stroke: colorMap.schematic.component_outline,\n        \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  return svgObjects\n}\n","import { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport type { SchematicBox } from \"circuit-json\"\n\nexport const createSvgObjectsFromSchematicBox = ({\n  schematicBox,\n  transform,\n  colorMap,\n}: {\n  schematicBox: SchematicBox\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] => {\n  const topLeft = applyToPoint(transform, {\n    x: schematicBox.x,\n    y: schematicBox.y,\n  })\n  const bottomRight = applyToPoint(transform, {\n    x: schematicBox.x + schematicBox.width,\n    y: schematicBox.y + schematicBox.height,\n  })\n\n  const yTop = Math.min(topLeft.y, bottomRight.y)\n  const yBottom = Math.max(topLeft.y, bottomRight.y)\n  const xLeft = Math.min(topLeft.x, bottomRight.x)\n  const xRight = Math.max(topLeft.x, bottomRight.x)\n\n  const strokeWidthPx = getSchStrokeSize(transform)\n  const attributes: Record<string, string> = {\n    class: \"schematic-box\",\n    x: xLeft.toString(),\n    y: yTop.toString(),\n    width: (xRight - xLeft).toString(),\n    height: (yBottom - yTop).toString(),\n    \"stroke-width\": `${strokeWidthPx}px`,\n    stroke: colorMap.schematic.component_outline || \"black\",\n    fill: \"transparent\",\n  }\n\n  if (schematicBox.is_dashed) {\n    // Scale dash length according to zoom level\n    const dashLength = 8 * strokeWidthPx\n    const gapLength = 4 * strokeWidthPx\n    attributes[\"stroke-dasharray\"] = `${dashLength} ${gapLength}`\n  }\n\n  return [\n    {\n      name: \"rect\",\n      type: \"element\",\n      value: \"\",\n      attributes,\n      children: [],\n    },\n  ]\n}\n","import type {\n  AnyCircuitElement,\n  SchematicTable,\n  SchematicTableCell,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport { getTableDimensions } from \"../get-table-dimensions\"\n\nexport const createSvgObjectsFromSchematicTable = ({\n  schematicTable,\n  transform,\n  colorMap,\n  circuitJson,\n}: {\n  schematicTable: SchematicTable\n  transform: Matrix\n  colorMap: ColorMap\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const {\n    anchor_position,\n    border_width = 0.05,\n    anchor = \"center\",\n  } = schematicTable\n\n  const { column_widths, row_heights } = getTableDimensions(\n    schematicTable,\n    circuitJson,\n  )\n\n  const totalWidth = column_widths.reduce((a, b) => a + b, 0)\n  const totalHeight = row_heights.reduce((a, b) => a + b, 0)\n\n  let topLeftX = anchor_position.x\n  let topLeftY = anchor_position.y\n\n  // Horizontal alignment\n  if (anchor.includes(\"center\")) {\n    topLeftX -= totalWidth / 2\n  } else if (anchor.includes(\"right\")) {\n    topLeftX -= totalWidth\n  }\n\n  // Vertical alignment\n  if (anchor.includes(\"center\")) {\n    topLeftY += totalHeight / 2\n  } else if (anchor.includes(\"bottom\")) {\n    topLeftY += totalHeight\n  }\n\n  const svgObjects: SvgObject[] = []\n  const borderStrokeWidth = border_width * Math.abs(transform.a)\n  const gridStrokeWidth = getSchStrokeSize(transform)\n\n  // Draw border\n  const [screenTopLeftX, screenTopLeftY] = applyToPoint(transform, [\n    topLeftX,\n    topLeftY,\n  ])\n  const [screenBottomRightX, screenBottomRightY] = applyToPoint(transform, [\n    topLeftX + totalWidth,\n    topLeftY - totalHeight,\n  ])\n\n  svgObjects.push({\n    name: \"rect\",\n    type: \"element\",\n    attributes: {\n      x: screenTopLeftX.toString(),\n      y: screenTopLeftY.toString(),\n      width: (screenBottomRightX - screenTopLeftX).toString(),\n      height: (screenBottomRightY - screenTopLeftY).toString(),\n      fill: \"none\",\n      stroke: colorMap.schematic.table,\n      \"stroke-width\": borderStrokeWidth.toString(),\n    },\n    children: [],\n    value: \"\",\n  })\n\n  // Draw grid lines\n  const cells = circuitJson.filter(\n    (elm): elm is SchematicTableCell =>\n      elm.type === \"schematic_table_cell\" &&\n      elm.schematic_table_id === schematicTable.schematic_table_id,\n  )\n\n  let currentX = topLeftX\n  for (let i = 0; i < column_widths.length - 1; i++) {\n    currentX += column_widths[i]!\n    let segmentStartY = topLeftY\n    for (let j = 0; j < row_heights.length; j++) {\n      const segmentEndY = segmentStartY - row_heights[j]!\n      const isMerged = cells.some(\n        (cell) =>\n          cell.start_column_index <= i &&\n          cell.end_column_index > i &&\n          cell.start_row_index <= j &&\n          cell.end_row_index >= j,\n      )\n\n      if (!isMerged) {\n        const start = applyToPoint(transform, { x: currentX, y: segmentStartY })\n        const end = applyToPoint(transform, { x: currentX, y: segmentEndY })\n        svgObjects.push({\n          name: \"line\",\n          type: \"element\",\n          attributes: {\n            x1: start.x.toString(),\n            y1: start.y.toString(),\n            x2: end.x.toString(),\n            y2: end.y.toString(),\n            stroke: colorMap.schematic.table,\n            \"stroke-width\": gridStrokeWidth.toString(),\n          },\n          children: [],\n          value: \"\",\n        })\n      }\n      segmentStartY = segmentEndY\n    }\n  }\n\n  let currentY = topLeftY\n  for (let i = 0; i < row_heights.length - 1; i++) {\n    currentY -= row_heights[i]!\n    let segmentStartX = topLeftX\n    for (let j = 0; j < column_widths.length; j++) {\n      const segmentEndX = segmentStartX + column_widths[j]!\n      const isMerged = cells.some(\n        (cell) =>\n          cell.start_row_index <= i &&\n          cell.end_row_index > i &&\n          cell.start_column_index <= j &&\n          cell.end_column_index >= j,\n      )\n\n      if (!isMerged) {\n        const start = applyToPoint(transform, {\n          x: segmentStartX,\n          y: currentY,\n        })\n        const end = applyToPoint(transform, { x: segmentEndX, y: currentY })\n        svgObjects.push({\n          name: \"line\",\n          type: \"element\",\n          attributes: {\n            x1: start.x.toString(),\n            y1: start.y.toString(),\n            x2: end.x.toString(),\n            y2: end.y.toString(),\n            stroke: colorMap.schematic.table,\n            \"stroke-width\": gridStrokeWidth.toString(),\n          },\n          children: [],\n          value: \"\",\n        })\n      }\n      segmentStartX = segmentEndX\n    }\n  }\n\n  // Draw cells\n\n  for (const cell of cells) {\n    if (cell.text) {\n      // Calculate cell dimensions\n      const cellWidth = column_widths\n        .slice(cell.start_column_index, cell.end_column_index + 1)\n        .reduce((a, b) => a + b, 0)\n      const cellHeight = row_heights\n        .slice(cell.start_row_index, cell.end_row_index + 1)\n        .reduce((a, b) => a + b, 0)\n\n      // Calculate cell top-left position\n      const cellTopLeftX =\n        topLeftX +\n        column_widths\n          .slice(0, cell.start_column_index)\n          .reduce((a, b) => a + b, 0)\n      const cellTopLeftY =\n        topLeftY -\n        row_heights.slice(0, cell.start_row_index).reduce((a, b) => a + b, 0)\n\n      const { cell_padding = 0.2 } = schematicTable\n      const horizontal_align = cell.horizontal_align ?? \"center\"\n      const vertical_align = cell.vertical_align ?? \"middle\"\n\n      let realTextAnchorPos = {\n        x: cellTopLeftX + cellWidth / 2,\n        y: cellTopLeftY - cellHeight / 2,\n      }\n\n      if (horizontal_align === \"left\") {\n        realTextAnchorPos.x = cellTopLeftX + cell_padding\n      } else if (horizontal_align === \"right\") {\n        realTextAnchorPos.x = cellTopLeftX + cellWidth - cell_padding\n      }\n\n      if (vertical_align === \"top\") {\n        realTextAnchorPos.y = cellTopLeftY - cell_padding\n      } else if (vertical_align === \"bottom\") {\n        realTextAnchorPos.y = cellTopLeftY - cellHeight + cell_padding\n      }\n\n      const screenTextAnchorPos = applyToPoint(transform, realTextAnchorPos)\n\n      const fontSize = getSchScreenFontSize(\n        transform,\n        \"reference_designator\",\n        cell.font_size,\n      )\n\n      const textAnchorMap: Record<\n        \"left\" | \"center\" | \"right\",\n        \"start\" | \"middle\" | \"end\"\n      > = {\n        left: \"start\",\n        center: \"middle\",\n        right: \"end\",\n      }\n\n      const dominantBaselineMap: Record<\n        \"top\" | \"middle\" | \"bottom\",\n        \"hanging\" | \"middle\" | \"ideographic\"\n      > = {\n        top: \"hanging\",\n        middle: \"middle\",\n        bottom: \"ideographic\",\n      }\n\n      svgObjects.push({\n        name: \"text\",\n        type: \"element\",\n        attributes: {\n          x: screenTextAnchorPos.x.toString(),\n          y: screenTextAnchorPos.y.toString(),\n          \"font-size\": `${fontSize}px`,\n          \"text-anchor\": textAnchorMap[horizontal_align],\n          \"dominant-baseline\": dominantBaselineMap[vertical_align],\n          fill: colorMap.schematic.table,\n          \"font-family\": \"sans-serif\",\n        },\n        children: [\n          {\n            type: \"text\",\n            value: cell.text,\n            name: \"\",\n            attributes: {},\n            children: [],\n          },\n        ],\n        value: \"\",\n      })\n    }\n  }\n\n  return [\n    {\n      name: \"g\",\n      type: \"element\",\n      attributes: {\n        \"data-schematic-table-id\": schematicTable.schematic_table_id,\n      },\n      children: svgObjects,\n      value: \"\",\n    },\n  ]\n}\n","import type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nconst PIN_CIRCLE_RADIUS_MM = 0.02\n\nexport const createSvgObjectsForSchPortHover = ({\n  schPort,\n  transform,\n}: {\n  schPort: SchematicPort\n  transform: Matrix\n}): SvgObject[] => {\n  const screenSchPortPos = applyToPoint(transform, schPort.center)\n  const pinRadiusPx = Math.abs(transform.a) * PIN_CIRCLE_RADIUS_MM * 2\n\n  return [\n    {\n      name: \"g\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        class: \"schematic-port-hover\",\n        \"data-schematic-port-id\": schPort.source_port_id,\n      },\n      children: [\n        {\n          name: \"circle\",\n          type: \"element\",\n          value: \"\",\n          attributes: {\n            cx: screenSchPortPos.x.toString(),\n            cy: screenSchPortPos.y.toString(),\n            r: pinRadiusPx.toString(),\n            fill: \"red\",\n            opacity: \"0\",\n          },\n          children: [],\n        },\n      ],\n    },\n  ]\n}\n\nexport const createSvgObjectsForSchComponentPortHovers = ({\n  component,\n  transform,\n  circuitJson,\n}: {\n  component: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const schematicPorts = su(circuitJson as any).schematic_port.list({\n    schematic_component_id: component.schematic_component_id,\n  }) as SchematicPort[]\n\n  const svgs: SvgObject[] = []\n  for (const schPort of schematicPorts) {\n    svgs.push(...createSvgObjectsForSchPortHover({ schPort, transform }))\n  }\n\n  return svgs\n}\n","import type { SchematicLine } from \"circuit-json\"\nimport type { Matrix } from \"transformation-matrix\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\n\nexport function createSvgObjectsFromSchematicLine({\n  schLine,\n  transform,\n  colorMap,\n}: {\n  schLine: SchematicLine\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] {\n  const p1 = applyToPoint(transform, { x: schLine.x1, y: schLine.y1 })\n  const p2 = applyToPoint(transform, { x: schLine.x2, y: schLine.y2 })\n\n  const strokeWidth = schLine.stroke_width ?? 0.02\n  const transformedStrokeWidth = Math.abs(transform.a) * strokeWidth\n\n  return [\n    {\n      name: \"line\",\n      type: \"element\",\n      attributes: {\n        x1: p1.x.toString(),\n        y1: p1.y.toString(),\n        x2: p2.x.toString(),\n        y2: p2.y.toString(),\n        stroke: schLine.color,\n        \"stroke-width\": transformedStrokeWidth.toString(),\n        ...(schLine.is_dashed && {\n          \"stroke-dasharray\": (transformedStrokeWidth * 3).toString(),\n        }),\n        \"data-schematic-line-id\": schLine.schematic_line_id,\n        ...(schLine.schematic_component_id && {\n          \"data-schematic-component-id\": schLine.schematic_component_id,\n        }),\n      },\n      children: [],\n      value: \"\",\n    },\n  ]\n}\n","import type { SchematicCircle } from \"circuit-json\"\nimport type { Matrix } from \"transformation-matrix\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\n\nexport function createSvgObjectsFromSchematicCircle({\n  schCircle,\n  transform,\n  colorMap,\n}: {\n  schCircle: SchematicCircle\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] {\n  const center = applyToPoint(transform, schCircle.center)\n  const transformedRadius = Math.abs(transform.a) * schCircle.radius\n\n  const strokeWidth = schCircle.stroke_width ?? 0.02\n  const transformedStrokeWidth = Math.abs(transform.a) * strokeWidth\n\n  return [\n    {\n      name: \"circle\",\n      type: \"element\",\n      attributes: {\n        cx: center.x.toString(),\n        cy: center.y.toString(),\n        r: transformedRadius.toString(),\n        fill: schCircle.is_filled\n          ? (schCircle.fill_color ?? schCircle.color)\n          : \"none\",\n        stroke: schCircle.color,\n        \"stroke-width\": transformedStrokeWidth.toString(),\n        ...(schCircle.is_dashed && {\n          \"stroke-dasharray\": (transformedStrokeWidth * 3).toString(),\n        }),\n        \"data-schematic-circle-id\": schCircle.schematic_circle_id,\n        ...(schCircle.schematic_component_id && {\n          \"data-schematic-component-id\": schCircle.schematic_component_id,\n        }),\n      },\n      children: [],\n      value: \"\",\n    },\n  ]\n}\n","import type { SchematicRect } from \"circuit-json\"\nimport type { Matrix } from \"transformation-matrix\"\nimport { applyToPoint, compose, translate, rotate } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\n\nexport function createSvgObjectsFromSchematicRect({\n  schRect,\n  transform,\n  colorMap,\n}: {\n  schRect: SchematicRect\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] {\n  const center = applyToPoint(transform, schRect.center)\n  const transformedWidth = Math.abs(transform.a) * schRect.width\n  const transformedHeight = Math.abs(transform.d) * schRect.height\n\n  const strokeWidth = schRect.stroke_width ?? 0.02\n  const transformedStrokeWidth = Math.abs(transform.a) * strokeWidth\n\n  // Calculate top-left position of rectangle\n  const x = center.x - transformedWidth / 2\n  const y = center.y - transformedHeight / 2\n\n  const svgRect: SvgObject = {\n    name: \"rect\",\n    type: \"element\",\n    attributes: {\n      x: x.toString(),\n      y: y.toString(),\n      width: transformedWidth.toString(),\n      height: transformedHeight.toString(),\n      fill: schRect.is_filled ? (schRect.fill_color ?? schRect.color) : \"none\",\n      stroke: schRect.color,\n      \"stroke-width\": transformedStrokeWidth.toString(),\n      ...(schRect.is_dashed && {\n        \"stroke-dasharray\": (transformedStrokeWidth * 3).toString(),\n      }),\n      ...(schRect.rotation !== 0 && {\n        transform: `rotate(${schRect.rotation} ${center.x} ${center.y})`,\n      }),\n      \"data-schematic-rect-id\": schRect.schematic_rect_id,\n      ...(schRect.schematic_component_id && {\n        \"data-schematic-component-id\": schRect.schematic_component_id,\n      }),\n    },\n    children: [],\n    value: \"\",\n  }\n\n  return [svgRect]\n}\n","import type { SchematicArc } from \"circuit-json\"\nimport type { Matrix } from \"transformation-matrix\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\n\nexport function createSvgObjectsFromSchematicArc({\n  schArc,\n  transform,\n  colorMap,\n}: {\n  schArc: SchematicArc\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] {\n  const center = applyToPoint(transform, schArc.center)\n  const transformedRadius = Math.abs(transform.a) * schArc.radius\n\n  const strokeWidth = schArc.stroke_width ?? 0.02\n  const transformedStrokeWidth = Math.abs(transform.a) * strokeWidth\n\n  // Convert angles to radians\n  const startAngleRad = (schArc.start_angle_degrees * Math.PI) / 180\n  const endAngleRad = (schArc.end_angle_degrees * Math.PI) / 180\n\n  // Calculate start and end points\n  const startX = center.x + transformedRadius * Math.cos(startAngleRad)\n  const startY = center.y + transformedRadius * Math.sin(startAngleRad)\n  const endX = center.x + transformedRadius * Math.cos(endAngleRad)\n  const endY = center.y + transformedRadius * Math.sin(endAngleRad)\n\n  // Calculate if arc is large (> 180 degrees)\n  let angleDiff = schArc.end_angle_degrees - schArc.start_angle_degrees\n  if (schArc.direction === \"clockwise\") {\n    angleDiff = -angleDiff\n  }\n  if (angleDiff < 0) {\n    angleDiff += 360\n  }\n  const largeArcFlag = angleDiff > 180 ? 1 : 0\n\n  // Sweep flag: 1 for clockwise, 0 for counterclockwise\n  const sweepFlag = schArc.direction === \"clockwise\" ? 1 : 0\n\n  // Create SVG path for the arc\n  const pathData = `M ${startX} ${startY} A ${transformedRadius} ${transformedRadius} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: pathData,\n        fill: \"none\",\n        stroke: schArc.color,\n        \"stroke-width\": transformedStrokeWidth.toString(),\n        ...(schArc.is_dashed && {\n          \"stroke-dasharray\": (transformedStrokeWidth * 3).toString(),\n        }),\n        \"data-schematic-arc-id\": schArc.schematic_arc_id,\n        ...(schArc.schematic_component_id && {\n          \"data-schematic-component-id\": schArc.schematic_component_id,\n        }),\n      },\n      children: [],\n      value: \"\",\n    },\n  ]\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport { stringify, parseSync } from \"svgson\"\nimport { convertCircuitJsonToSchematicSvg } from \"./sch/convert-circuit-json-to-schematic-svg\"\nimport { convertCircuitJsonToSimulationGraphSvg } from \"./sim/convert-circuit-json-to-simulation-graph-svg\"\nimport {\n  type CircuitJsonWithSimulation,\n  isSimulationExperiment,\n  isSimulationTransientVoltageGraph,\n} from \"./sim/types\"\nimport { CIRCUIT_TO_SVG_VERSION } from \"./package-version\"\nimport { getSoftwareUsedString } from \"./utils/get-software-used-string\"\nimport type { SvgObject } from \"./svg-object\"\n\ninterface ConvertSchematicSimulationParams {\n  circuitJson: CircuitJsonWithSimulation[]\n  simulation_experiment_id: string\n  simulation_transient_voltage_graph_ids?: string[]\n  width?: number\n  height?: number\n  schematicHeightRatio?: number\n  schematicOptions?: Omit<\n    Parameters<typeof convertCircuitJsonToSchematicSvg>[1],\n    \"width\" | \"height\" | \"includeVersion\"\n  >\n  includeVersion?: boolean\n  showErrorsInTextOverlay?: boolean\n}\n\nconst DEFAULT_WIDTH = 1200\nconst DEFAULT_HEIGHT = 1200\nconst DEFAULT_SCHEMATIC_RATIO = 0.55\n\nexport function convertCircuitJsonToSchematicSimulationSvg({\n  circuitJson,\n  simulation_experiment_id,\n  simulation_transient_voltage_graph_ids,\n  width = DEFAULT_WIDTH,\n  height = DEFAULT_HEIGHT,\n  schematicHeightRatio = DEFAULT_SCHEMATIC_RATIO,\n  schematicOptions,\n  includeVersion,\n  showErrorsInTextOverlay,\n}: ConvertSchematicSimulationParams): string {\n  const schematicElements = circuitJson.filter(\n    (element): element is AnyCircuitElement =>\n      !isSimulationExperiment(element) &&\n      !isSimulationTransientVoltageGraph(element),\n  )\n\n  const clampedRatio = clamp01(schematicHeightRatio)\n  const rawSchematicHeight = Math.max(1, height * clampedRatio)\n  const rawSimulationHeight = Math.max(1, height - rawSchematicHeight)\n  const totalRawHeight = rawSchematicHeight + rawSimulationHeight\n  const scale = totalRawHeight === 0 ? 1 : height / totalRawHeight\n  const schematicHeight = rawSchematicHeight * scale\n  const simulationHeight = rawSimulationHeight * scale\n\n  const schematicSvg = convertCircuitJsonToSchematicSvg(schematicElements, {\n    ...schematicOptions,\n    width,\n    height: schematicHeight,\n    includeVersion: false,\n    showErrorsInTextOverlay,\n  })\n\n  const simulationSvg = convertCircuitJsonToSimulationGraphSvg({\n    circuitJson,\n    simulation_experiment_id,\n    simulation_transient_voltage_graph_ids,\n    width,\n    height: simulationHeight,\n    includeVersion: false,\n  })\n\n  const schematicNode = ensureElementNode(parseSync(schematicSvg))\n  const simulationNode = ensureElementNode(parseSync(simulationSvg))\n\n  const combinedChildren: SvgObject[] = []\n  combinedChildren.push(\n    translateNestedSvg(schematicNode, 0, 0, width, schematicHeight),\n  )\n  combinedChildren.push(\n    translateNestedSvg(\n      simulationNode,\n      0,\n      schematicHeight,\n      width,\n      simulationHeight,\n    ),\n  )\n\n  const softwareUsedString = getSoftwareUsedString(schematicElements)\n\n  const svgObject: SvgObject = {\n    name: \"svg\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: formatNumber(width),\n      height: formatNumber(height),\n      viewBox: `0 0 ${formatNumber(width)} ${formatNumber(height)}`,\n      \"data-simulation-experiment-id\": simulation_experiment_id,\n      ...(softwareUsedString && {\n        \"data-software-used-string\": softwareUsedString,\n      }),\n      ...(includeVersion && {\n        \"data-circuit-to-svg-version\": CIRCUIT_TO_SVG_VERSION,\n      }),\n    },\n    children: combinedChildren,\n  }\n\n  return stringify(svgObject)\n}\n\nfunction translateNestedSvg(\n  node: SvgObject,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n): SvgObject {\n  const clone = cloneSvgObject(node)\n  clone.attributes = {\n    ...clone.attributes,\n    x: formatNumber(x),\n    y: formatNumber(y),\n    width: formatNumber(width),\n    height: formatNumber(height),\n  }\n\n  delete clone.attributes.xmlns\n  return clone\n}\n\nfunction ensureElementNode(node: SvgObject): SvgObject {\n  if (node.type !== \"element\") {\n    throw new Error(\"Expected SVG root element to be of type 'element'\")\n  }\n  return node\n}\n\nfunction cloneSvgObject(node: SvgObject): SvgObject {\n  return {\n    ...node,\n    attributes: { ...(node.attributes ?? {}) },\n    children: node.children?.map(cloneSvgObject) ?? [],\n  }\n}\n\nfunction clamp01(value: number): number {\n  if (!Number.isFinite(value)) return DEFAULT_SCHEMATIC_RATIO\n  if (value <= 0) return 0\n  if (value >= 1) return 1\n  return value\n}\n\nfunction formatNumber(value: number): string {\n  if (!Number.isFinite(value)) return \"0\"\n  const rounded = Number.parseFloat(value.toFixed(6))\n  if (Number.isInteger(rounded)) return rounded.toString()\n  return rounded.toString()\n}\n","import type {\n  AnyCircuitElement,\n  SimulationExperiment,\n  SimulationTransientVoltageGraph,\n} from \"circuit-json\"\nimport { stringify } from \"svgson\"\nimport { CIRCUIT_TO_SVG_VERSION } from \"lib/package-version\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { colorMap } from \"lib/utils/colors\"\nimport { getSoftwareUsedString } from \"lib/utils/get-software-used-string\"\nimport {\n  type CircuitJsonWithSimulation,\n  isSimulationExperiment,\n  isSimulationTransientVoltageGraph,\n  isSimulationVoltageProbe,\n} from \"./types\"\n\ninterface ConvertSimulationGraphParams {\n  circuitJson: CircuitJsonWithSimulation[]\n  simulation_experiment_id: string\n  simulation_transient_voltage_graph_ids?: string[]\n  width?: number\n  height?: number\n  includeVersion?: boolean\n}\n\ninterface PreparedSimulationGraph {\n  graph: SimulationTransientVoltageGraph\n  points: Array<{ timeMs: number; voltage: number }>\n  color: string\n  label: string\n}\n\ninterface AxisInfo {\n  domainMin: number\n  domainMax: number\n  ticks: number[]\n}\n\ntype ScaleFn = (value: number) => number\n\nconst DEFAULT_WIDTH = 1200\nconst DEFAULT_HEIGHT = 600\nconst MARGIN = { top: 64, right: 100, bottom: 80, left: 100 }\nconst FALLBACK_LINE_COLOR = \"#1f77b4\"\n\nexport function convertCircuitJsonToSimulationGraphSvg({\n  circuitJson,\n  simulation_experiment_id,\n  simulation_transient_voltage_graph_ids,\n  width = DEFAULT_WIDTH,\n  height = DEFAULT_HEIGHT,\n  includeVersion,\n}: ConvertSimulationGraphParams): string {\n  const selectedIds = simulation_transient_voltage_graph_ids\n    ? new Set(simulation_transient_voltage_graph_ids)\n    : null\n\n  const experiment = circuitJson.find(\n    (element): element is SimulationExperiment =>\n      isSimulationExperiment(element) &&\n      element.simulation_experiment_id === simulation_experiment_id,\n  )\n\n  const graphs = circuitJson.filter(\n    (element): element is SimulationTransientVoltageGraph =>\n      isSimulationTransientVoltageGraph(element) &&\n      element.simulation_experiment_id === simulation_experiment_id &&\n      (!selectedIds ||\n        selectedIds.has(element.simulation_transient_voltage_graph_id)),\n  )\n\n  if (graphs.length === 0) {\n    throw new Error(\n      `No simulation_transient_voltage_graph elements found for simulation_experiment_id \"${simulation_experiment_id}\"`,\n    )\n  }\n\n  const preparedGraphs = prepareSimulationGraphs(graphs, circuitJson)\n  const allPoints = preparedGraphs.flatMap((entry) => entry.points)\n\n  if (allPoints.length === 0) {\n    throw new Error(\n      `simulation_transient_voltage_graph elements for simulation_experiment_id \"${simulation_experiment_id}\" do not contain any datapoints`,\n    )\n  }\n\n  const timeAxis = buildAxisInfo(allPoints.map((point) => point.timeMs))\n  const voltageAxis = buildAxisInfo(allPoints.map((point) => point.voltage))\n\n  const plotWidth = Math.max(1, width - MARGIN.left - MARGIN.right)\n  const plotHeight = Math.max(1, height - MARGIN.top - MARGIN.bottom)\n\n  const scaleX = createLinearScale(\n    timeAxis.domainMin,\n    timeAxis.domainMax,\n    MARGIN.left,\n    MARGIN.left + plotWidth,\n  )\n  const scaleY = createLinearScale(\n    voltageAxis.domainMin,\n    voltageAxis.domainMax,\n    MARGIN.top + plotHeight,\n    MARGIN.top,\n  )\n\n  const clipPathId = createClipPathId(simulation_experiment_id)\n  const softwareUsedString = getSoftwareUsedString(\n    circuitJson as AnyCircuitElement[],\n  )\n  const version = CIRCUIT_TO_SVG_VERSION\n\n  const titleNode = createTitleNode(experiment, width)\n\n  const svgChildren: SvgObject[] = [\n    createStyleNode(),\n    createBackgroundRect(width, height),\n    createDefsNode(clipPathId, plotWidth, plotHeight),\n    createPlotBackground(plotWidth, plotHeight),\n    createGridLines({\n      timeAxis,\n      voltageAxis,\n      scaleX,\n      scaleY,\n      plotWidth,\n      plotHeight,\n    }),\n    createDataGroup(preparedGraphs, clipPathId, scaleX, scaleY),\n    createAxes({\n      timeAxis,\n      voltageAxis,\n      scaleX,\n      scaleY,\n      plotWidth,\n      plotHeight,\n    }),\n    createLegend(preparedGraphs, width),\n    ...(titleNode ? [titleNode] : []),\n  ]\n\n  const svgObject: SvgObject = svgElement(\n    \"svg\",\n    {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: width.toString(),\n      height: height.toString(),\n      viewBox: `0 0 ${formatNumber(width)} ${formatNumber(height)}`,\n      \"data-simulation-experiment-id\": simulation_experiment_id,\n      ...(experiment?.name && {\n        \"data-simulation-experiment-name\": experiment.name,\n      }),\n      ...(softwareUsedString && {\n        \"data-software-used-string\": softwareUsedString,\n      }),\n      ...(includeVersion && {\n        \"data-circuit-to-svg-version\": version,\n      }),\n    },\n    svgChildren,\n  )\n\n  return stringify(svgObject)\n}\n\nfunction prepareSimulationGraphs(\n  graphs: SimulationTransientVoltageGraph[],\n  circuitJson: CircuitJsonWithSimulation[],\n): PreparedSimulationGraph[] {\n  const palette = Array.isArray(colorMap.palette) ? colorMap.palette : []\n\n  const voltageProbes = circuitJson.filter(isSimulationVoltageProbe)\n  const sourceComponentIdToProbeName = new Map<string, string>()\n  const sourceComponentIdToProbeColor = new Map<string, string>()\n  for (const probe of voltageProbes) {\n    if (probe.name && probe.source_component_id) {\n      sourceComponentIdToProbeName.set(probe.source_component_id, probe.name)\n    }\n    if (probe.color && probe.source_component_id) {\n      sourceComponentIdToProbeColor.set(probe.source_component_id, probe.color)\n    }\n  }\n\n  return graphs\n    .map((graph, index) => {\n      const points = createGraphPoints(graph)\n      const paletteColor =\n        palette.length > 0\n          ? palette[index % palette.length]\n          : FALLBACK_LINE_COLOR\n\n      const probeColor = graph.source_component_id\n        ? sourceComponentIdToProbeColor.get(graph.source_component_id)\n        : undefined\n\n      const color =\n        graph.color ?? probeColor ?? paletteColor ?? FALLBACK_LINE_COLOR\n\n      const probeName = graph.source_component_id\n        ? sourceComponentIdToProbeName.get(graph.source_component_id)\n        : undefined\n\n      const label = probeName\n        ? `V(${probeName})`\n        : graph.name ||\n          (graph.source_component_id\n            ? `Probe ${graph.source_component_id}`\n            : graph.simulation_transient_voltage_graph_id)\n      return { graph, points, color, label }\n    })\n    .filter((entry) => entry.points.length > 0)\n}\n\nfunction createGraphPoints(\n  graph: SimulationTransientVoltageGraph,\n): Array<{ timeMs: number; voltage: number }> {\n  const timestamps = getTimestamps(graph)\n  const length = Math.min(timestamps.length, graph.voltage_levels.length)\n  const points: Array<{ timeMs: number; voltage: number }> = []\n\n  for (let index = 0; index < length; index++) {\n    const timeMs = Number(timestamps[index] ?? Number.NaN)\n    const voltage = Number(graph.voltage_levels[index] ?? Number.NaN)\n\n    if (!Number.isFinite(timeMs) || !Number.isFinite(voltage)) continue\n\n    points.push({ timeMs, voltage })\n  }\n\n  return points\n}\n\nfunction getTimestamps(graph: SimulationTransientVoltageGraph): number[] {\n  if (\n    Array.isArray(graph.timestamps_ms) &&\n    graph.timestamps_ms.length === graph.voltage_levels.length\n  ) {\n    return graph.timestamps_ms.map((value: number) => Number(value))\n  }\n\n  const count = graph.voltage_levels.length\n  if (count === 0) return []\n\n  const timestamps: number[] = []\n  for (let index = 0; index < count; index++) {\n    timestamps.push(graph.start_time_ms + graph.time_per_step * index)\n  }\n\n  const lastTimestamp =\n    timestamps.length > 0 ? timestamps[timestamps.length - 1] : undefined\n  if (\n    lastTimestamp !== undefined &&\n    Number.isFinite(graph.end_time_ms) &&\n    Number.isFinite(lastTimestamp) &&\n    Math.abs(lastTimestamp - graph.end_time_ms) > graph.time_per_step / 2\n  ) {\n    timestamps.push(graph.end_time_ms)\n  }\n\n  return timestamps\n}\n\nfunction buildAxisInfo(values: number[]): AxisInfo {\n  if (values.length === 0) {\n    return {\n      domainMin: 0,\n      domainMax: 1,\n      ticks: [0, 1],\n    }\n  }\n\n  const min = Math.min(...values)\n  const max = Math.max(...values)\n\n  if (min === max) {\n    const offset = min === 0 ? 1 : Math.abs(min) * 0.1 || 1\n    return {\n      domainMin: min - offset,\n      domainMax: min + offset,\n      ticks: [min - offset, min, min + offset],\n    }\n  }\n\n  const ticks = generateTickValues(min, max)\n  const safeTicks = ticks.length > 0 ? ticks : [min, max]\n  const domainMin = safeTicks[0]!\n  const domainMax = safeTicks[safeTicks.length - 1]!\n\n  return { domainMin, domainMax, ticks: safeTicks }\n}\n\nfunction generateTickValues(min: number, max: number, desired = 6): number[] {\n  const span = max - min\n  if (!Number.isFinite(span) || span <= Number.EPSILON) {\n    return [min, max]\n  }\n\n  const step = niceStep(span / Math.max(1, desired - 1))\n  const niceMin = Math.floor(min / step) * step\n  const niceMax = Math.ceil(max / step) * step\n  const values: number[] = []\n\n  for (let value = niceMin; value <= niceMax + step / 2; value += step) {\n    values.push(Number.parseFloat(value.toPrecision(12)))\n  }\n\n  return values\n}\n\nfunction niceStep(step: number): number {\n  if (!Number.isFinite(step) || step <= 0) return 1\n\n  const exponent = Math.floor(Math.log10(step))\n  const fraction = step / Math.pow(10, exponent)\n\n  let niceFraction: number\n  if (fraction <= 1) niceFraction = 1\n  else if (fraction <= 2) niceFraction = 2\n  else if (fraction <= 5) niceFraction = 5\n  else niceFraction = 10\n\n  return niceFraction * Math.pow(10, exponent)\n}\n\nfunction createLinearScale(\n  domainMin: number,\n  domainMax: number,\n  rangeMin: number,\n  rangeMax: number,\n): ScaleFn {\n  if (!Number.isFinite(domainMin) || !Number.isFinite(domainMax)) {\n    const midpoint = (rangeMin + rangeMax) / 2\n    return () => midpoint\n  }\n\n  const span = domainMax - domainMin\n  if (Math.abs(span) < Number.EPSILON) {\n    const midpoint = (rangeMin + rangeMax) / 2\n    return () => midpoint\n  }\n\n  return (value: number) =>\n    rangeMin + ((value - domainMin) / span) * (rangeMax - rangeMin)\n}\n\nfunction createStyleNode(): SvgObject {\n  const content = `\n:root { color-scheme: light; }\nsvg { font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif; }\n.background { fill: ${colorMap.schematic.background}; }\n.plot-background { fill: #ffffff; }\n.grid-line { stroke: rgba(0, 0, 0, 0.08); stroke-width: 1; }\n.axis { stroke: rgba(0, 0, 0, 0.6); stroke-width: 1.5; }\n.axis-tick { stroke: rgba(0, 0, 0, 0.6); stroke-width: 1; }\n.axis-label { fill: rgba(0, 0, 0, 0.75); font-size: 12px; }\n.axis-title { fill: rgba(0, 0, 0, 0.9); font-size: 14px; font-weight: 600; }\n.legend-label { fill: rgba(0, 0, 0, 0.75); font-size: 11px; }\n.legend-line { stroke-width: 3; }\n.simulation-line { fill: none; stroke-width: 2.5; }\n.simulation-point { stroke-width: 0; }\n.chart-title { fill: rgba(0, 0, 0, 0.85); font-size: 18px; font-weight: 600; }\n`\n\n  return svgElement(\"style\", {}, [textNode(content)])\n}\n\nfunction createBackgroundRect(width: number, height: number): SvgObject {\n  return svgElement(\"rect\", {\n    class: \"background\",\n    x: \"0\",\n    y: \"0\",\n    width: formatNumber(width),\n    height: formatNumber(height),\n  })\n}\n\nfunction createDefsNode(\n  clipPathId: string,\n  plotWidth: number,\n  plotHeight: number,\n): SvgObject {\n  return svgElement(\"defs\", {}, [\n    svgElement(\"clipPath\", { id: clipPathId }, [\n      svgElement(\"rect\", {\n        x: formatNumber(MARGIN.left),\n        y: formatNumber(MARGIN.top),\n        width: formatNumber(plotWidth),\n        height: formatNumber(plotHeight),\n      }),\n    ]),\n  ])\n}\n\nfunction createPlotBackground(\n  plotWidth: number,\n  plotHeight: number,\n): SvgObject {\n  return svgElement(\"rect\", {\n    class: \"plot-background\",\n    x: formatNumber(MARGIN.left),\n    y: formatNumber(MARGIN.top),\n    width: formatNumber(plotWidth),\n    height: formatNumber(plotHeight),\n  })\n}\n\ninterface GridLinesOptions {\n  timeAxis: AxisInfo\n  voltageAxis: AxisInfo\n  scaleX: ScaleFn\n  scaleY: ScaleFn\n  plotWidth: number\n  plotHeight: number\n}\n\nfunction createGridLines({\n  timeAxis,\n  voltageAxis,\n  scaleX,\n  scaleY,\n  plotWidth,\n  plotHeight,\n}: GridLinesOptions): SvgObject {\n  const top = MARGIN.top\n  const bottom = MARGIN.top + plotHeight\n  const left = MARGIN.left\n  const right = MARGIN.left + plotWidth\n\n  const children: SvgObject[] = []\n\n  for (const tick of timeAxis.ticks) {\n    const x = formatNumber(scaleX(tick))\n    children.push(\n      svgElement(\"line\", {\n        class: \"grid-line grid-line-x\",\n        x1: x,\n        y1: formatNumber(top),\n        x2: x,\n        y2: formatNumber(bottom),\n      }),\n    )\n  }\n\n  for (const tick of voltageAxis.ticks) {\n    const y = formatNumber(scaleY(tick))\n    children.push(\n      svgElement(\"line\", {\n        class: \"grid-line grid-line-y\",\n        x1: formatNumber(left),\n        y1: y,\n        x2: formatNumber(right),\n        y2: y,\n      }),\n    )\n  }\n\n  return svgElement(\"g\", { class: \"grid\" }, children)\n}\n\ninterface AxesOptions {\n  timeAxis: AxisInfo\n  voltageAxis: AxisInfo\n  scaleX: ScaleFn\n  scaleY: ScaleFn\n  plotWidth: number\n  plotHeight: number\n}\n\nfunction createAxes({\n  timeAxis,\n  voltageAxis,\n  scaleX,\n  scaleY,\n  plotWidth,\n  plotHeight,\n}: AxesOptions): SvgObject {\n  const bottom = MARGIN.top + plotHeight\n  const left = MARGIN.left\n  const right = MARGIN.left + plotWidth\n\n  const children: SvgObject[] = [\n    svgElement(\"line\", {\n      class: \"axis axis-x\",\n      x1: formatNumber(left),\n      y1: formatNumber(bottom),\n      x2: formatNumber(right),\n      y2: formatNumber(bottom),\n    }),\n    svgElement(\"line\", {\n      class: \"axis axis-y\",\n      x1: formatNumber(left),\n      y1: formatNumber(MARGIN.top),\n      x2: formatNumber(left),\n      y2: formatNumber(bottom),\n    }),\n  ]\n\n  for (const tick of timeAxis.ticks) {\n    const x = formatNumber(scaleX(tick))\n    children.push(\n      svgElement(\"line\", {\n        class: \"axis-tick axis-tick-x\",\n        x1: x,\n        y1: formatNumber(bottom),\n        x2: x,\n        y2: formatNumber(bottom + 6),\n      }),\n    )\n    children.push(\n      svgElement(\n        \"text\",\n        {\n          class: \"axis-label axis-label-x\",\n          x,\n          y: formatNumber(bottom + 22),\n          \"text-anchor\": \"middle\",\n        },\n        [textNode(formatTickLabel(tick, timeAxis.ticks))],\n      ),\n    )\n  }\n\n  for (const tick of voltageAxis.ticks) {\n    const y = formatNumber(scaleY(tick))\n    children.push(\n      svgElement(\"line\", {\n        class: \"axis-tick axis-tick-y\",\n        x1: formatNumber(left - 6),\n        y1: y,\n        x2: formatNumber(left),\n        y2: y,\n      }),\n    )\n    children.push(\n      svgElement(\n        \"text\",\n        {\n          class: \"axis-label axis-label-y\",\n          x: formatNumber(left - 10),\n          y,\n          \"text-anchor\": \"end\",\n          \"dominant-baseline\": \"middle\",\n        },\n        [textNode(formatTickLabel(tick, voltageAxis.ticks))],\n      ),\n    )\n  }\n\n  children.push(\n    svgElement(\n      \"text\",\n      {\n        class: \"axis-title axis-title-x\",\n        x: formatNumber(left + plotWidth / 2),\n        y: formatNumber(bottom + 48),\n        \"text-anchor\": \"middle\",\n      },\n      [textNode(\"Time (ms)\")],\n    ),\n    svgElement(\n      \"text\",\n      {\n        class: \"axis-title axis-title-y\",\n        x: formatNumber(left - 64),\n        y: formatNumber(MARGIN.top + plotHeight / 2),\n        transform: `rotate(-90 ${formatNumber(left - 64)} ${formatNumber(\n          MARGIN.top + plotHeight / 2,\n        )})`,\n        \"text-anchor\": \"middle\",\n      },\n      [textNode(\"Voltage (V)\")],\n    ),\n  )\n\n  return svgElement(\"g\", { class: \"axes\" }, children)\n}\n\nconst MAX_LEGEND_LINE_LENGTH = 15\nconst LEGEND_LINE_HEIGHT = 16\nconst LEGEND_MIN_SPACING = 24\n\nfunction createLegend(\n  graphs: PreparedSimulationGraph[],\n  width: number,\n): SvgObject {\n  let currentY = MARGIN.top\n\n  const children = graphs.map((entry) => {\n    const x = width - MARGIN.right + 10\n    const lines = wrapLegendText(entry.label)\n    const legendItem = createLegendItem(entry, x, currentY, lines)\n\n    // Calculate height of this legend item (line count * line height)\n    const itemHeight = lines.length * LEGEND_LINE_HEIGHT\n    currentY += Math.max(itemHeight, LEGEND_MIN_SPACING)\n\n    return legendItem\n  })\n\n  return svgElement(\"g\", { class: \"legend\" }, children)\n}\n\nfunction wrapLegendText(label: string): string[] {\n  // Split on underscores for wrapping\n  const parts = label.split(\"_\")\n\n  if (parts.length <= 1) {\n    return [label]\n  }\n\n  const lines: string[] = []\n  let currentLine = parts[0] ?? \"\"\n\n  for (let i = 1; i < parts.length; i++) {\n    const part = parts[i] ?? \"\"\n    const testLine = currentLine + \"_\" + part\n\n    // If line would be too long, start new line\n    // Note: Individual parts longer than MAX_LEGEND_LINE_LENGTH won't wrap\n    if (testLine.length > MAX_LEGEND_LINE_LENGTH) {\n      lines.push(currentLine)\n      currentLine = part\n    } else {\n      currentLine = testLine\n    }\n  }\n\n  if (currentLine) {\n    lines.push(currentLine)\n  }\n\n  return lines\n}\n\nfunction createLegendItem(\n  entry: PreparedSimulationGraph,\n  x: number,\n  y: number,\n  lines: string[],\n): SvgObject {\n  // Lines are pre-calculated to avoid duplicate work\n\n  // Create tspan elements for each line\n  const textChildren = lines.map((line, index) => {\n    return svgElement(\n      \"tspan\",\n      {\n        x: \"20\",\n        dy: index === 0 ? \"0\" : String(LEGEND_LINE_HEIGHT),\n      },\n      [textNode(line)],\n    )\n  })\n\n  return svgElement(\n    \"g\",\n    {\n      class: \"legend-item\",\n      transform: `translate(${formatNumber(x)} ${formatNumber(y)})`,\n    },\n    [\n      svgElement(\"line\", {\n        class: \"legend-line\",\n        x1: \"0\",\n        y1: \"0\",\n        x2: \"16\",\n        y2: \"0\",\n        stroke: entry.color,\n      }),\n      svgElement(\n        \"text\",\n        {\n          class: \"legend-label\",\n          x: \"20\",\n          y: \"0\",\n          \"dominant-baseline\": \"middle\",\n        },\n        textChildren,\n      ),\n    ],\n  )\n}\n\nfunction createDataGroup(\n  graphs: PreparedSimulationGraph[],\n  clipPathId: string,\n  scaleX: ScaleFn,\n  scaleY: ScaleFn,\n): SvgObject {\n  const LINE_REPEAT_COUNT = 3\n  const DASH_PATTERN = [4, 8]\n  const dashArrayString = DASH_PATTERN.map((value) => formatNumber(value)).join(\n    \" \",\n  )\n  const dashCycleLength = DASH_PATTERN.reduce((sum, value) => sum + value, 0)\n  const dashOffsetStep = dashCycleLength / LINE_REPEAT_COUNT\n\n  interface GraphRenderingInfo {\n    entry: PreparedSimulationGraph\n    graphIndex: number\n    pathAttributes: Record<string, string>\n    pointElements: SvgObject[]\n  }\n\n  const processedGraphs: GraphRenderingInfo[] = []\n\n  graphs.forEach((entry, graphIndex) => {\n    if (entry.points.length === 0) return\n\n    const commands: string[] = []\n    entry.points.forEach((point, index) => {\n      const x = formatNumber(scaleX(point.timeMs))\n      const y = formatNumber(scaleY(point.voltage))\n      commands.push(`${index === 0 ? \"M\" : \"L\"} ${x} ${y}`)\n    })\n\n    const baseAttributes: Record<string, string> = {\n      class: \"simulation-line\",\n      d: commands.join(\" \"),\n      stroke: entry.color,\n      \"clip-path\": `url(#${clipPathId})`,\n      \"data-simulation-transient-voltage-graph-id\":\n        entry.graph.simulation_transient_voltage_graph_id,\n    }\n\n    if (entry.graph.source_component_id) {\n      baseAttributes[\"data-source-component-id\"] =\n        entry.graph.source_component_id\n    }\n\n    if (entry.graph.subcircuit_connectivity_map_key) {\n      baseAttributes[\"data-subcircuit-connectivity-map-key\"] =\n        entry.graph.subcircuit_connectivity_map_key\n    }\n\n    const pointElements = entry.points.map((point) => {\n      const cx = formatNumber(scaleX(point.timeMs))\n      const cy = formatNumber(scaleY(point.voltage))\n      return svgElement(\"circle\", {\n        class: \"simulation-point\",\n        cx,\n        cy,\n        r: \"2.5\",\n        fill: entry.color,\n        \"clip-path\": `url(#${clipPathId})`,\n      })\n    })\n\n    processedGraphs.push({\n      entry,\n      graphIndex,\n      pathAttributes: baseAttributes,\n      pointElements,\n    })\n  })\n\n  const lineElements: SvgObject[] = []\n\n  for (let cycle = 0; cycle < LINE_REPEAT_COUNT; cycle++) {\n    processedGraphs.forEach((graphInfo) => {\n      const offsetIndex = (graphInfo.graphIndex + cycle) % LINE_REPEAT_COUNT\n      const dashOffset = formatNumber(offsetIndex * dashOffsetStep)\n      lineElements.push(\n        svgElement(\"path\", {\n          ...graphInfo.pathAttributes,\n          \"stroke-dasharray\": dashArrayString,\n          \"stroke-dashoffset\": dashOffset,\n        }),\n      )\n    })\n  }\n\n  const pointElements = processedGraphs.flatMap(\n    (graphInfo) => graphInfo.pointElements,\n  )\n\n  return svgElement(\"g\", { class: \"data-series\" }, [\n    ...lineElements,\n    ...pointElements,\n  ])\n}\n\nfunction createTitleNode(\n  experiment: SimulationExperiment | undefined,\n  width: number,\n): SvgObject | null {\n  if (!experiment?.name) return null\n\n  return svgElement(\n    \"text\",\n    {\n      class: \"chart-title\",\n      x: formatNumber(width / 2),\n      y: formatNumber(MARGIN.top - 40),\n      \"text-anchor\": \"middle\",\n    },\n    [textNode(experiment.name)],\n  )\n}\n\nfunction createClipPathId(simulationExperimentId: string): string {\n  const sanitized = simulationExperimentId.replace(/[^a-zA-Z0-9_-]+/g, \"-\")\n  return `simulation-graph-${sanitized}`\n}\n\nfunction formatNumber(value: number): string {\n  if (!Number.isFinite(value)) return \"0\"\n  const rounded = Number.parseFloat(value.toFixed(6))\n  if (Number.isInteger(rounded)) return rounded.toString()\n  return rounded.toString()\n}\n\nfunction formatTickLabel(value: number, ticks: number[]): string {\n  if (ticks.length <= 1) return formatNumber(value)\n  const span = ticks[ticks.length - 1]! - ticks[0]!\n  if (!Number.isFinite(span) || span === 0) return formatNumber(value)\n\n  const precision = span >= 100 ? 0 : span >= 10 ? 1 : span >= 1 ? 2 : 3\n  const factor = Math.pow(10, precision)\n  const rounded = Math.round(value * factor) / factor\n  const fixed = rounded.toFixed(precision)\n  return fixed\n    .replace(/\\.0+$/, \"\")\n    .replace(/(\\.\\d*?)0+$/, \"$1\")\n    .replace(/\\.$/, \"\")\n}\n\nfunction svgElement(\n  name: string,\n  attributes: Record<string, string>,\n  children: SvgObject[] = [],\n): SvgObject {\n  return {\n    name,\n    type: \"element\",\n    value: \"\",\n    attributes,\n    children,\n  }\n}\n\nfunction textNode(value: string): SvgObject {\n  return {\n    name: \"\",\n    type: \"text\",\n    value,\n    attributes: {},\n    children: [],\n  }\n}\n","import type {\n  AnyCircuitElement,\n  SimulationExperiment,\n  SimulationTransientVoltageGraph,\n  SimulationVoltageProbe,\n} from \"circuit-json\"\n\nexport type CircuitJsonWithSimulation =\n  | AnyCircuitElement\n  | SimulationExperiment\n  | SimulationTransientVoltageGraph\n  | SimulationVoltageProbe\n\nexport function isSimulationTransientVoltageGraph(\n  value: CircuitJsonWithSimulation,\n): value is SimulationTransientVoltageGraph {\n  return value?.type === \"simulation_transient_voltage_graph\"\n}\n\nexport function isSimulationExperiment(\n  value: CircuitJsonWithSimulation,\n): value is SimulationExperiment {\n  return value?.type === \"simulation_experiment\"\n}\n\nexport function isSimulationVoltageProbe(\n  value: CircuitJsonWithSimulation,\n): value is SimulationVoltageProbe {\n  return value?.type === \"simulation_voltage_probe\"\n}\n","import type { Point, AnyCircuitElement, PcbPanel } from \"circuit-json\"\nimport { distance } from \"circuit-json\"\nimport { type INode as SvgObject, stringify } from \"svgson\"\nimport {\n  applyToPoint,\n  compose,\n  scale,\n  translate,\n  type Matrix,\n} from \"transformation-matrix\"\nimport { createSvgObjectsFromPcbBoard } from \"./svg-object-fns/create-svg-objects-from-pcb-board\"\nimport { createSvgObjectsFromSolderPaste } from \"./svg-object-fns/convert-circuit-json-to-solder-paste-mask\"\nimport type { PcbContext } from \"./convert-circuit-json-to-pcb-svg\"\nimport { DEFAULT_PCB_COLOR_MAP } from \"./colors\"\nimport { getSoftwareUsedString } from \"../utils/get-software-used-string\"\nimport { CIRCUIT_TO_SVG_VERSION } from \"../package-version\"\nimport { createErrorTextOverlay } from \"../utils/create-error-text-overlay\"\n\nconst OBJECT_ORDER: AnyCircuitElement[\"type\"][] = [\n  \"pcb_board\",\n  \"pcb_solder_paste\",\n]\n\ninterface Options {\n  layer: \"top\" | \"bottom\"\n  width?: number\n  height?: number\n  includeVersion?: boolean\n  showErrorsInTextOverlay?: boolean\n}\n\nexport function convertCircuitJsonToSolderPasteMask(\n  circuitJson: AnyCircuitElement[],\n  options: Options,\n): string {\n  let minX = Number.POSITIVE_INFINITY\n  let minY = Number.POSITIVE_INFINITY\n  let maxX = Number.NEGATIVE_INFINITY\n  let maxY = Number.NEGATIVE_INFINITY\n\n  // Filter to include only pcb_board and pcb_solder_paste elements for the specified layer\n  const filteredCircuitJson = circuitJson.filter(\n    (elm) =>\n      elm.type === \"pcb_board\" ||\n      elm.type === \"pcb_panel\" ||\n      (elm.type === \"pcb_solder_paste\" && elm.layer === options.layer),\n  )\n\n  // Process filtered elements to determine bounds\n  for (const item of filteredCircuitJson) {\n    if (item.type === \"pcb_board\") {\n      if (\n        item.outline &&\n        Array.isArray(item.outline) &&\n        item.outline.length >= 3\n      ) {\n        updateBoundsToIncludeOutline(item.outline)\n      } else if (\"center\" in item && \"width\" in item && \"height\" in item) {\n        updateBounds(item.center, item.width, item.height)\n      }\n    } else if (item.type === \"pcb_panel\") {\n      const panel = item as PcbPanel\n      const width = distance.parse(panel.width)\n      const height = distance.parse(panel.height)\n      if (width !== undefined && height !== undefined) {\n        const center = panel.center ?? { x: width / 2, y: height / 2 }\n        updateBounds(center, width, height)\n      }\n    } else if (item.type === \"pcb_solder_paste\" && \"x\" in item && \"y\" in item) {\n      updateBounds({ x: item.x, y: item.y }, 0, 0)\n    }\n  }\n\n  const padding = 1 // Consistent with reference code\n  const circuitWidth = maxX - minX + 2 * padding\n  const circuitHeight = maxY - minY + 2 * padding\n\n  const svgWidth = options.width ?? 800\n  const svgHeight = options.height ?? 600\n\n  // Calculate scale factor to fit the circuit within the SVG, maintaining aspect ratio\n  const scaleX = svgWidth / circuitWidth\n  const scaleY = svgHeight / circuitHeight\n  const scaleFactor = Math.min(scaleX, scaleY)\n\n  // Calculate centering offsets\n  const offsetX = (svgWidth - circuitWidth * scaleFactor) / 2\n  const offsetY = (svgHeight - circuitHeight * scaleFactor) / 2\n\n  const transform = compose(\n    translate(\n      offsetX - minX * scaleFactor + padding * scaleFactor,\n      svgHeight - offsetY + minY * scaleFactor - padding * scaleFactor,\n    ),\n    scale(scaleFactor, -scaleFactor), // Flip in y-direction\n  )\n\n  const ctx: PcbContext = {\n    transform,\n    layer: options.layer,\n    colorMap: DEFAULT_PCB_COLOR_MAP,\n  }\n\n  // Sort elements by OBJECT_ORDER and convert to SVG objects\n  const svgObjects = filteredCircuitJson\n    .sort(\n      (a, b) =>\n        (OBJECT_ORDER.indexOf(b.type) ?? 9999) -\n        (OBJECT_ORDER.indexOf(a.type) ?? 9999),\n    )\n    .flatMap((item) => createSvgObjects({ elm: item, ctx }))\n\n  const softwareUsedString = getSoftwareUsedString(circuitJson)\n  const version = CIRCUIT_TO_SVG_VERSION\n\n  const children: SvgObject[] = [\n    {\n      name: \"style\",\n      type: \"element\",\n      children: [\n        {\n          type: \"text\",\n          value: \"\",\n        },\n      ],\n    },\n    {\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        class: \"boundary\",\n        x: \"0\",\n        y: \"0\",\n        fill: \"#000\",\n        width: svgWidth.toString(),\n        height: svgHeight.toString(),\n      },\n    },\n    createSvgObjectFromPcbBoundary(transform, minX, minY, maxX, maxY),\n    ...svgObjects,\n  ].filter((child): child is SvgObject => child !== null)\n\n  if (options?.showErrorsInTextOverlay) {\n    const errorOverlay = createErrorTextOverlay(circuitJson)\n    if (errorOverlay) {\n      children.push(errorOverlay)\n    }\n  }\n\n  const svgObject: SvgObject = {\n    name: \"svg\",\n    type: \"element\",\n    attributes: {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n      ...(softwareUsedString && {\n        \"data-software-used-string\": softwareUsedString,\n      }),\n      ...(options.includeVersion && {\n        \"data-circuit-to-svg-version\": version,\n      }),\n    },\n    value: \"\",\n    children,\n  }\n\n  try {\n    return stringify(svgObject)\n  } catch (error) {\n    console.error(\"Error stringifying SVG object:\", error)\n    throw error\n  }\n\n  function updateBounds(center: any, width: any, height: any) {\n    const halfWidth = width / 2\n    const halfHeight = height / 2\n    minX = Math.min(minX, center.x - halfWidth)\n    minY = Math.min(minY, center.y - halfHeight)\n    maxX = Math.max(maxX, center.x + halfWidth)\n    maxY = Math.max(maxY, center.y + halfHeight)\n  }\n\n  function updateBoundsToIncludeOutline(outline: Point[]) {\n    for (const point of outline) {\n      minX = Math.min(minX, point.x)\n      minY = Math.min(minY, point.y)\n      maxX = Math.max(maxX, point.x)\n      maxY = Math.max(maxY, point.y)\n    }\n  }\n}\n\ninterface CreateSvgObjectsParams {\n  elm: AnyCircuitElement\n  ctx: PcbContext\n}\n\nfunction createSvgObjects({ elm, ctx }: CreateSvgObjectsParams): SvgObject[] {\n  const { transform } = ctx\n  switch (elm.type) {\n    case \"pcb_board\":\n      return createSvgObjectsFromPcbBoard(elm, ctx)\n    case \"pcb_solder_paste\":\n      return createSvgObjectsFromSolderPaste(elm, ctx)\n    default:\n      return []\n  }\n}\n\nfunction createSvgObjectFromPcbBoundary(\n  transform: Matrix,\n  minX: number,\n  minY: number,\n  maxX: number,\n  maxY: number,\n): SvgObject {\n  const [x1, y1] = applyToPoint(transform, [minX, minY])\n  const [x2, y2] = applyToPoint(transform, [maxX, maxY])\n  const width = Math.abs(x2 - x1)\n  const height = Math.abs(y2 - y1)\n  const x = Math.min(x1, x2)\n  const y = Math.min(y1, y2)\n  return {\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    children: [],\n    attributes: {\n      class: \"pcb-boundary\",\n      fill: \"none\",\n      stroke: \"#fff\",\n      \"stroke-width\": \"0.3\",\n      x: x.toString(),\n      y: y.toString(),\n      width: width.toString(),\n      height: height.toString(),\n    },\n  }\n}\n","import type { PcbSolderPaste } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport { solderPasteLayerNameToColor } from \"../layer-name-to-color\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromSolderPaste(\n  solderPaste: PcbSolderPaste,\n  ctx: PcbContext,\n): any {\n  const { transform, layer: layerFilter } = ctx\n  if (layerFilter && solderPaste.layer !== layerFilter) return []\n  const [x, y] = applyToPoint(transform, [solderPaste.x, solderPaste.y])\n\n  if (solderPaste.shape === \"rect\" || solderPaste.shape === \"rotated_rect\") {\n    const width = solderPaste.width * Math.abs(transform.a)\n    const height = solderPaste.height * Math.abs(transform.d)\n\n    if (solderPaste.shape === \"rotated_rect\" && solderPaste.ccw_rotation) {\n      return [\n        {\n          name: \"rect\",\n          type: \"element\",\n          attributes: {\n            class: \"pcb-solder-paste\",\n            fill: solderPasteLayerNameToColor(solderPaste.layer),\n            x: (-width / 2).toString(),\n            y: (-height / 2).toString(),\n            width: width.toString(),\n            height: height.toString(),\n            transform: `translate(${x} ${y}) rotate(${-solderPaste.ccw_rotation})`,\n            \"data-type\": \"pcb_solder_paste\",\n            \"data-pcb-layer\": solderPaste.layer,\n          },\n        },\n      ]\n    }\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-solder-paste\",\n          fill: solderPasteLayerNameToColor(solderPaste.layer),\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          \"data-type\": \"pcb_solder_paste\",\n          \"data-pcb-layer\": solderPaste.layer,\n        },\n      },\n    ]\n  }\n  // Implement pill-shaped SMT pad\n  if (solderPaste.shape === \"pill\") {\n    const width = solderPaste.width * Math.abs(transform.a)\n    const height = solderPaste.height * Math.abs(transform.d)\n    const radius = solderPaste.radius * Math.abs(transform.a)\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-solder-paste\",\n          fill: solderPasteLayerNameToColor(solderPaste.layer),\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          rx: radius.toString(),\n          \"data-type\": \"pcb_solder_paste\",\n          \"data-pcb-layer\": solderPaste.layer,\n        },\n      },\n    ]\n  }\n  // Implement circle-shaped SMT pad\n  if (solderPaste.shape === \"circle\") {\n    const radius = solderPaste.radius * Math.abs(transform.a)\n\n    return [\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-solder-paste\",\n          fill: solderPasteLayerNameToColor(solderPaste.layer),\n          cx: x.toString(),\n          cy: y.toString(),\n          r: radius.toString(),\n          \"data-type\": \"pcb_solder_paste\",\n          \"data-pcb-layer\": solderPaste.layer,\n        },\n      },\n    ]\n  }\n}\n"],"mappings":"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","names":["applyToPoint","compose","scale","translate","applyToPoint","applyToPoint","applyToPoint","applyToPoint","applyToPoint","applyToPoint","normalize","toPath","applyToPoint","applyToPoint","applyToPoint","applyToPoint","DEFAULT_OVERLAY_COLOR","applyToPoint","applyToPoint","DEFAULT_OVERLAY_COLOR","applyToPoint","applyToPoint","DEFAULT_OVERLAY_COLOR","applyToPoint","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","compose","rotate","translate","matrixToString","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","colorMap","applyToPoint","applyToPoint","colorMap","applyToPoint","padElement","maskWidth","maskHeight","maskBorderRadius","maskElement","distance","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","holeElement","maskElement","applyToPoint","distance","su","applyToPoint","applyToPoint","compose","rotate","translate","matrixToString","colorMap","applyToPoint","compose","rotate","matrixToString","translate","applyToPoint","colorMap","applyToPoint","matrixToString","compose","translate","rotate","applyToPoint","applyToPoint","scale","applyToPoint","applyToPoint","colorMap","compose","translate","scale","applyToPoint","stringify","su","applyToPoint","compose","scale","translate","applyToPoint","applyToPoint","applyToPoint","applyToPoint","HOLE_COLOR","applyToPoint","HOLE_COLOR","applyToPoint","PAD_COLOR","compose","translate","scale","createSvgObjects","stringify","su","applyToPoint","stringify","compose","translate","applyToPoint","su","width","height","x","y","su","applyToPoint","applyToPoint","HOLE_COLOR","applyToPoint","PAD_COLOR","HOLE_COLOR","applyToPoint","PAD_COLOR","applyToPoint","applyToPoint","applyToPoint","applyToPoint","su","OBJECT_ORDER","compose","translate","createSvgObjects","stringify","stringify","applyToPoint","applyToPoint","su","applyToPoint","compose","compose","scale","translate","applyToPoint","ninePointAnchorToTextAnchor","colorMap","su","applyToPoint","compose","ninePointAnchorToTextAnchor","su","applyToPoint","applyToPoint","su","su","applyToPoint","applyToPoint","applyToPoint","applyToPoint","colorMap","colorMap","applyToPoint","su","applyToPoint","colorMap","applyToPoint","applyToPoint","colorMap","applyToPoint","compose","rotate","scale","translate","applyToPoint","compose","rotate","scale","translate","symbols","colorMap","symbols","rotate","applyToPoint","compose","translate","scale","colorMap","applyToPoint","compose","translate","scale","rotate","applyToPoint","colorMap","applyToPoint","applyToPoint","colorMap","applyToPoint","su","applyToPoint","PIN_CIRCLE_RADIUS_MM","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","colorMap","stringify","stringify","parseSync","stringify","stringify","pointElements","DEFAULT_WIDTH","DEFAULT_HEIGHT","scale","parseSync","formatNumber","stringify","distance","stringify","applyToPoint","compose","scale","translate","applyToPoint","applyToPoint","OBJECT_ORDER","distance","compose","translate","scale","createSvgObjects","createSvgObjectFromPcbBoundary","stringify","applyToPoint"]}