// src/utils/convert-si-unit-to-number.ts
var unitMappings = {
  Hz: {
    baseUnit: "Hz",
    variants: {
      MHz: 1e6,
      kHz: 1e3,
      Hz: 1
    }
  },
  g: {
    baseUnit: "g",
    variants: {
      kg: 1e3,
      g: 1
    }
  },
  \u03A9: {
    baseUnit: "\u03A9",
    variants: {
      m\u03A9: 1e-3,
      \u03A9: 1,
      k\u03A9: 1e3,
      K\u03A9: 1e3,
      kohm: 1e3,
      M\u03A9: 1e6,
      G\u03A9: 1e9,
      T\u03A9: 1e12
    }
  },
  V: {
    baseUnit: "V",
    variants: {
      mV: 1e-3,
      V: 1,
      kV: 1e3,
      KV: 1e3,
      MV: 1e6,
      GV: 1e9,
      TV: 1e12
    }
  },
  A: {
    baseUnit: "A",
    variants: {
      \u00B5A: 1e-6,
      mA: 1e-3,
      ma: 1e-3,
      A: 1,
      kA: 1e3,
      MA: 1e6
    }
  },
  F: {
    baseUnit: "F",
    variants: {
      pF: 1e-12,
      nF: 1e-9,
      \u00B5F: 1e-6,
      uF: 1e-6,
      mF: 1e-3,
      F: 1
    }
  },
  ml: {
    baseUnit: "ml",
    variants: {
      ml: 1,
      mL: 1,
      l: 1e3,
      L: 1e3
    }
  },
  deg: {
    baseUnit: "deg",
    variants: {
      rad: 180 / Math.PI
    }
  },
  ms: {
    baseUnit: "ms",
    variants: {
      fs: 1e-12,
      ps: 1e-9,
      ns: 1e-6,
      us: 1e-3,
      \u00B5s: 1e-3,
      ms: 1,
      s: 1e3
    }
  },
  mm: {
    baseUnit: "mm",
    variants: {
      nm: 1e-6,
      \u00B5m: 1e-3,
      um: 1e-3,
      mm: 1,
      cm: 10,
      dm: 100,
      m: 1e3,
      km: 1e6,
      in: 25.4,
      ft: 304.8,
      IN: 25.4,
      FT: 304.8,
      yd: 914.4,
      mi: 1609344,
      mil: 0.0254
    }
  }
};
var unitMappingAndVariantSuffixes = /* @__PURE__ */ new Set();
for (const [baseUnit, info] of Object.entries(unitMappings)) {
  unitMappingAndVariantSuffixes.add(baseUnit);
  for (const variant of Object.keys(info.variants)) {
    unitMappingAndVariantSuffixes.add(variant);
  }
}
function getBaseTscircuitUnit(unit) {
  for (const [baseUnit, info] of Object.entries(unitMappings)) {
    if (unit in info.variants) {
      return {
        baseUnit: info.baseUnit,
        conversionFactor: info.variants[unit]
      };
    }
  }
  return {
    baseUnit: unit,
    conversionFactor: 1
  };
}
var si_prefix_multiplier = {
  tera: 1e12,
  T: 1e12,
  giga: 1e9,
  G: 1e9,
  mega: 1e6,
  M: 1e6,
  kilo: 1e3,
  k: 1e3,
  deci: 0.1,
  d: 0.1,
  centi: 0.01,
  c: 0.01,
  milli: 1e-3,
  m: 1e-3,
  micro: 1e-6,
  u: 1e-6,
  \u00B5: 1e-6,
  nano: 1e-9,
  n: 1e-9,
  pico: 1e-12,
  p: 1e-12
};
function parseAndConvertSiUnit(v) {
  if (v === void 0 || v === null)
    return { parsedUnit: null, unitOfValue: null, value: null };
  if (typeof v === "string" && v.match(/^-?[\d\.]+$/))
    return {
      value: Number.parseFloat(v),
      parsedUnit: null,
      unitOfValue: null
    };
  if (typeof v === "number")
    return { value: v, parsedUnit: null, unitOfValue: null };
  if (typeof v === "object" && "x" in v && "y" in v) {
    const { parsedUnit, unitOfValue } = parseAndConvertSiUnit(v.x);
    const xResult = parseAndConvertSiUnit(v.x);
    const yResult = parseAndConvertSiUnit(v.y);
    if (xResult.value === null || yResult.value === null) {
      return { parsedUnit: null, unitOfValue: null, value: null };
    }
    return {
      parsedUnit,
      unitOfValue,
      value: {
        x: xResult.value,
        y: yResult.value
      }
    };
  }
  const reversed_input_string = v.toString().split("").reverse().join("");
  const unit_reversed = reversed_input_string.match(/[^\d\s]+/)?.[0];
  if (!unit_reversed) {
    throw new Error(`Could not determine unit: "${v}"`);
  }
  const unit = unit_reversed.split("").reverse().join("");
  const numberPart = v.slice(0, -unit.length);
  if (unit in si_prefix_multiplier && !unitMappingAndVariantSuffixes.has(unit)) {
    const siMultiplier = si_prefix_multiplier[unit];
    return {
      parsedUnit: null,
      unitOfValue: null,
      value: Number.parseFloat(numberPart) * siMultiplier
    };
  }
  const { baseUnit, conversionFactor } = getBaseTscircuitUnit(unit);
  return {
    parsedUnit: unit,
    unitOfValue: baseUnit,
    value: conversionFactor * Number.parseFloat(numberPart)
  };
}

// src/units/index.ts
import { z } from "zod";
var resistance = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var capacitance = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value).transform((value) => {
  return Number.parseFloat(value.toPrecision(12));
});
var inductance = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var voltage = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var length = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var frequency = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var distance = length;
var current = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var duration_ms = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var time = duration_ms;
var ms = duration_ms;
var timestamp = z.string().datetime();
var rotation = z.string().or(z.number()).transform((arg) => {
  if (typeof arg === "number") return arg;
  if (arg.endsWith("deg")) {
    return Number.parseFloat(arg.split("deg")[0]);
  }
  if (arg.endsWith("rad")) {
    return Number.parseFloat(arg.split("rad")[0]) * 180 / Math.PI;
  }
  return Number.parseFloat(arg);
});
var battery_capacity = z.number().or(z.string().endsWith("mAh")).transform((v) => {
  if (typeof v === "string") {
    const valString = v.replace("mAh", "");
    const num = Number.parseFloat(valString);
    if (Number.isNaN(num)) {
      throw new Error("Invalid capacity");
    }
    return num;
  }
  return v;
}).describe("Battery capacity in mAh");

// src/common/point.ts
import { z as z2 } from "zod";

// src/utils/expect-types-match.ts
var expectTypesMatch = (shouldBe) => {
};
expectTypesMatch("extra props b");
expectTypesMatch("missing props b");
expectTypesMatch(true);
expectTypesMatch("mismatched prop types: a");
var expectStringUnionsMatch = (shouldBe) => {
};
expectStringUnionsMatch(true);
expectStringUnionsMatch(
  'T1 has extra: "c", T2 has extra: "d"'
);
expectStringUnionsMatch('T1 has extra: "c"');
expectStringUnionsMatch('T2 has extra: "c"');
expectStringUnionsMatch(
  'T1 has extra: "d", T2 has extra: "c"'
);
expectStringUnionsMatch(true);

// src/common/point.ts
var point = z2.object({
  x: distance,
  y: distance
});
var position = point;
expectTypesMatch(true);
expectTypesMatch(true);

// src/common/point3.ts
import { z as z3 } from "zod";
var point3 = z3.object({
  x: distance,
  y: distance,
  z: distance
});
var position3 = point3;
expectTypesMatch(true);

// src/common/size.ts
import { z as z4 } from "zod";
var size = z4.object({
  width: z4.number(),
  height: z4.number()
});
expectTypesMatch(true);

// src/common/getZodPrefixedIdWithDefault.ts
import { z as z5 } from "zod";
var randomId = (length3) => {
  const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  return Array.from(
    { length: length3 },
    () => chars[Math.floor(Math.random() * chars.length)]
  ).join("");
};
var getZodPrefixedIdWithDefault = (prefix) => {
  return z5.string().optional().default(() => `${prefix}_${randomId(10)}`);
};

// src/common/NinePointAnchor.ts
import { z as z6 } from "zod";
var ninePointAnchor = z6.enum([
  "top_left",
  "top_center",
  "top_right",
  "center_left",
  "center",
  "center_right",
  "bottom_left",
  "bottom_center",
  "bottom_right"
]);
expectTypesMatch(true);

// src/source/source_simple_capacitor.ts
import { z as z9 } from "zod";

// src/pcb/properties/supplier_name.ts
import { z as z7 } from "zod";
var supplier_name = z7.enum([
  "jlcpcb",
  "macrofab",
  "pcbway",
  "digikey",
  "mouser",
  "lcsc"
]);
expectTypesMatch(true);

// src/source/base/source_component_base.ts
import { z as z8 } from "zod";
var source_component_base = z8.object({
  type: z8.literal("source_component"),
  ftype: z8.string().optional(),
  source_component_id: z8.string(),
  name: z8.string(),
  manufacturer_part_number: z8.string().optional(),
  supplier_part_numbers: z8.record(supplier_name, z8.array(z8.string())).optional(),
  display_value: z8.string().optional(),
  are_pins_interchangeable: z8.boolean().optional(),
  internally_connected_source_port_ids: z8.array(z8.array(z8.string())).optional(),
  source_group_id: z8.string().optional(),
  subcircuit_id: z8.string().optional()
});
expectTypesMatch(true);

// src/source/source_simple_capacitor.ts
var source_simple_capacitor = source_component_base.extend({
  ftype: z9.literal("simple_capacitor"),
  capacitance,
  max_voltage_rating: voltage.optional(),
  display_capacitance: z9.string().optional(),
  max_decoupling_trace_length: distance.optional()
});
expectTypesMatch(true);

// src/source/source_simple_resistor.ts
import { z as z10 } from "zod";
var source_simple_resistor = source_component_base.extend({
  ftype: z10.literal("simple_resistor"),
  resistance,
  display_resistance: z10.string().optional()
});
expectTypesMatch(true);

// src/source/source_simple_diode.ts
import { z as z11 } from "zod";
var source_simple_diode = source_component_base.extend({
  ftype: z11.literal("simple_diode")
});
expectTypesMatch(true);

// src/source/source_simple_led.ts
import { z as z12 } from "zod";
var source_simple_led = source_simple_diode.extend({
  ftype: z12.literal("simple_led"),
  color: z12.string().optional(),
  wavelength: z12.string().optional()
});
expectTypesMatch(true);

// src/source/source_simple_ground.ts
import { z as z13 } from "zod";
var source_simple_ground = source_component_base.extend({
  ftype: z13.literal("simple_ground")
});
expectTypesMatch(true);

// src/source/source_simple_chip.ts
import { z as z14 } from "zod";
var source_simple_chip = source_component_base.extend({
  ftype: z14.literal("simple_chip")
});
expectTypesMatch(true);

// src/source/source_simple_power_source.ts
import { z as z15 } from "zod";
var source_simple_power_source = source_component_base.extend({
  ftype: z15.literal("simple_power_source"),
  voltage
});
expectTypesMatch(true);

// src/source/any_source_component.ts
import { z as z36 } from "zod";

// src/source/source_simple_fuse.ts
import { z as z16 } from "zod";
var source_simple_fuse = source_component_base.extend({
  ftype: z16.literal("simple_fuse"),
  current_rating_amps: z16.number().describe("Nominal current in amps the fuse is rated for"),
  voltage_rating_volts: z16.number().describe("Voltage rating in volts, e.g. \xB15V would be 5")
});
expectTypesMatch(true);

// src/source/source_simple_battery.ts
import { z as z17 } from "zod";
var source_simple_battery = source_component_base.extend({
  ftype: z17.literal("simple_battery"),
  capacity: battery_capacity
});
expectTypesMatch(true);

// src/source/source_simple_inductor.ts
import { z as z18 } from "zod";
var source_simple_inductor = source_component_base.extend({
  ftype: z18.literal("simple_inductor"),
  inductance,
  max_current_rating: z18.number().optional()
});
expectTypesMatch(true);

// src/source/source_simple_push_button.ts
import { z as z19 } from "zod";
var source_simple_push_button = source_component_base.extend({
  ftype: z19.literal("simple_push_button")
});
expectTypesMatch(true);

// src/source/source_simple_potentiometer.ts
import { z as z20 } from "zod";
var source_simple_potentiometer = source_component_base.extend({
  ftype: z20.literal("simple_potentiometer"),
  max_resistance: resistance
});
expectTypesMatch(
  true
);

// src/source/source_simple_crystal.ts
import { z as z21 } from "zod";
var source_simple_crystal = source_component_base.extend({
  ftype: z21.literal("simple_crystal"),
  frequency: z21.number().describe("Frequency in Hz"),
  load_capacitance: z21.number().optional().describe("Load capacitance in pF")
});
expectTypesMatch(true);

// src/source/source_simple_pin_header.ts
import { z as z22 } from "zod";
var source_simple_pin_header = source_component_base.extend({
  ftype: z22.literal("simple_pin_header"),
  pin_count: z22.number(),
  gender: z22.enum(["male", "female"]).optional().default("male")
});
expectTypesMatch(true);

// src/source/source_simple_pinout.ts
import { z as z23 } from "zod";
var source_simple_pinout = source_component_base.extend({
  ftype: z23.literal("simple_pinout")
});
expectTypesMatch(true);

// src/source/source_simple_resonator.ts
import { z as z24 } from "zod";
var source_simple_resonator = source_component_base.extend({
  ftype: z24.literal("simple_resonator"),
  load_capacitance: capacitance,
  equivalent_series_resistance: resistance.optional(),
  frequency
});
expectTypesMatch(true);

// src/source/source_simple_transistor.ts
import { z as z25 } from "zod";
var source_simple_transistor = source_component_base.extend({
  ftype: z25.literal("simple_transistor"),
  transistor_type: z25.enum(["npn", "pnp"])
});
expectTypesMatch(true);

// src/source/source_simple_test_point.ts
import { z as z26 } from "zod";
var source_simple_test_point = source_component_base.extend({
  ftype: z26.literal("simple_test_point"),
  footprint_variant: z26.enum(["pad", "through_hole"]).optional(),
  pad_shape: z26.enum(["rect", "circle"]).optional(),
  pad_diameter: z26.union([z26.number(), z26.string()]).optional(),
  hole_diameter: z26.union([z26.number(), z26.string()]).optional(),
  width: z26.union([z26.number(), z26.string()]).optional(),
  height: z26.union([z26.number(), z26.string()]).optional()
});
expectTypesMatch(true);

// src/source/source_simple_mosfet.ts
import { z as z27 } from "zod";
var source_simple_mosfet = source_component_base.extend({
  ftype: z27.literal("simple_mosfet"),
  channel_type: z27.enum(["n", "p"]),
  mosfet_mode: z27.enum(["enhancement", "depletion"])
});
expectTypesMatch(true);

// src/source/source_simple_switch.ts
import { z as z28 } from "zod";
var source_simple_switch = source_component_base.extend({
  ftype: z28.literal("simple_switch")
});
expectTypesMatch(true);

// src/source/source_project_metadata.ts
import { z as z29 } from "zod";
var source_project_metadata = z29.object({
  type: z29.literal("source_project_metadata"),
  name: z29.string().optional(),
  software_used_string: z29.string().optional(),
  project_url: z29.string().optional(),
  created_at: timestamp.optional()
});
expectTypesMatch(true);

// src/source/source_missing_property_error.ts
import { z as z30 } from "zod";
var source_missing_property_error = z30.object({
  type: z30.literal("source_missing_property_error"),
  source_missing_property_error_id: getZodPrefixedIdWithDefault(
    "source_missing_property_error"
  ),
  source_component_id: z30.string(),
  property_name: z30.string(),
  subcircuit_id: z30.string().optional(),
  error_type: z30.literal("source_missing_property_error").default("source_missing_property_error"),
  message: z30.string()
}).describe("The source code is missing a property");
expectTypesMatch(true);

// src/source/source_failed_to_create_component_error.ts
import { z as z31 } from "zod";
var source_failed_to_create_component_error = z31.object({
  type: z31.literal("source_failed_to_create_component_error"),
  source_failed_to_create_component_error_id: getZodPrefixedIdWithDefault(
    "source_failed_to_create_component_error"
  ),
  error_type: z31.literal("source_failed_to_create_component_error").default("source_failed_to_create_component_error"),
  component_name: z31.string().optional(),
  subcircuit_id: z31.string().optional(),
  parent_source_component_id: z31.string().optional(),
  message: z31.string(),
  pcb_center: z31.object({
    x: z31.number().optional(),
    y: z31.number().optional()
  }).optional(),
  schematic_center: z31.object({
    x: z31.number().optional(),
    y: z31.number().optional()
  }).optional()
}).describe("Error emitted when a component fails to be constructed");
expectTypesMatch(true);

// src/source/source_trace_not_connected_error.ts
import { z as z32 } from "zod";
var source_trace_not_connected_error = z32.object({
  type: z32.literal("source_trace_not_connected_error"),
  source_trace_not_connected_error_id: getZodPrefixedIdWithDefault(
    "source_trace_not_connected_error"
  ),
  error_type: z32.literal("source_trace_not_connected_error").default("source_trace_not_connected_error"),
  message: z32.string(),
  subcircuit_id: z32.string().optional(),
  source_group_id: z32.string().optional(),
  source_trace_id: z32.string().optional(),
  connected_source_port_ids: z32.array(z32.string()).optional(),
  selectors_not_found: z32.array(z32.string()).optional()
}).describe("Occurs when a source trace selector does not match any ports");
expectTypesMatch(true);

// src/source/source_property_ignored_warning.ts
import { z as z33 } from "zod";
var source_property_ignored_warning = z33.object({
  type: z33.literal("source_property_ignored_warning"),
  source_property_ignored_warning_id: getZodPrefixedIdWithDefault(
    "source_property_ignored_warning"
  ),
  source_component_id: z33.string(),
  property_name: z33.string(),
  subcircuit_id: z33.string().optional(),
  error_type: z33.literal("source_property_ignored_warning").default("source_property_ignored_warning"),
  message: z33.string()
}).describe("The source property was ignored");
expectTypesMatch(true);

// src/source/source_pin_missing_trace_warning.ts
import { z as z34 } from "zod";
var source_pin_missing_trace_warning = z34.object({
  type: z34.literal("source_pin_missing_trace_warning"),
  source_pin_missing_trace_warning_id: getZodPrefixedIdWithDefault(
    "source_pin_missing_trace_warning"
  ),
  warning_type: z34.literal("source_pin_missing_trace_warning").default("source_pin_missing_trace_warning"),
  message: z34.string(),
  source_component_id: z34.string(),
  source_port_id: z34.string(),
  subcircuit_id: z34.string().optional()
}).describe(
  "Warning emitted when a source component pin is missing a trace connection"
);
expectTypesMatch(true);

// src/source/source_simple_voltage_probe.ts
import { z as z35 } from "zod";
var source_simple_voltage_probe = source_component_base.extend({
  ftype: z35.literal("simple_voltage_probe")
});
expectTypesMatch(
  true
);

// src/source/any_source_component.ts
var any_source_component = z36.union([
  source_simple_resistor,
  source_simple_capacitor,
  source_simple_diode,
  source_simple_led,
  source_simple_ground,
  source_simple_chip,
  source_simple_power_source,
  source_simple_battery,
  source_simple_inductor,
  source_simple_push_button,
  source_simple_potentiometer,
  source_simple_crystal,
  source_simple_pin_header,
  source_simple_pinout,
  source_simple_resonator,
  source_simple_switch,
  source_simple_transistor,
  source_simple_test_point,
  source_simple_mosfet,
  source_simple_fuse,
  source_simple_voltage_probe,
  source_project_metadata,
  source_missing_property_error,
  source_failed_to_create_component_error,
  source_trace_not_connected_error,
  source_property_ignored_warning,
  source_pin_missing_trace_warning
]);
expectTypesMatch(true);

// src/source/source_port.ts
import { z as z37 } from "zod";
var source_port = z37.object({
  type: z37.literal("source_port"),
  pin_number: z37.number().optional(),
  port_hints: z37.array(z37.string()).optional(),
  name: z37.string(),
  source_port_id: z37.string(),
  source_component_id: z37.string().optional(),
  source_group_id: z37.string().optional(),
  subcircuit_id: z37.string().optional(),
  subcircuit_connectivity_map_key: z37.string().optional()
});
expectTypesMatch(true);

// src/source/source_trace.ts
import { z as z38 } from "zod";
var source_trace = z38.object({
  type: z38.literal("source_trace"),
  source_trace_id: z38.string(),
  connected_source_port_ids: z38.array(z38.string()),
  connected_source_net_ids: z38.array(z38.string()),
  subcircuit_id: z38.string().optional(),
  subcircuit_connectivity_map_key: z38.string().optional(),
  max_length: z38.number().optional(),
  min_trace_thickness: z38.number().optional(),
  display_name: z38.string().optional()
});
expectTypesMatch(true);

// src/source/source_group.ts
import { z as z39 } from "zod";
var source_group = z39.object({
  type: z39.literal("source_group"),
  source_group_id: z39.string(),
  subcircuit_id: z39.string().optional(),
  parent_subcircuit_id: z39.string().optional(),
  parent_source_group_id: z39.string().optional(),
  is_subcircuit: z39.boolean().optional(),
  show_as_schematic_box: z39.boolean().optional(),
  name: z39.string().optional(),
  was_automatically_named: z39.boolean().optional()
});
expectTypesMatch(true);

// src/source/source_net.ts
import { z as z40 } from "zod";
var source_net = z40.object({
  type: z40.literal("source_net"),
  source_net_id: z40.string(),
  name: z40.string(),
  member_source_group_ids: z40.array(z40.string()),
  is_power: z40.boolean().optional(),
  is_ground: z40.boolean().optional(),
  is_digital_signal: z40.boolean().optional(),
  is_analog_signal: z40.boolean().optional(),
  is_positive_voltage_source: z40.boolean().optional(),
  trace_width: z40.number().optional(),
  subcircuit_id: z40.string().optional(),
  subcircuit_connectivity_map_key: z40.string().optional()
});
expectTypesMatch(true);

// src/source/source_board.ts
import { z as z41 } from "zod";
var source_board = z41.object({
  type: z41.literal("source_board"),
  source_board_id: z41.string(),
  source_group_id: z41.string(),
  title: z41.string().optional()
}).describe("Defines a board in the source domain");
expectTypesMatch(true);

// src/source/source_pcb_ground_plane.ts
import { z as z42 } from "zod";
var source_pcb_ground_plane = z42.object({
  type: z42.literal("source_pcb_ground_plane"),
  source_pcb_ground_plane_id: z42.string(),
  source_group_id: z42.string(),
  source_net_id: z42.string(),
  subcircuit_id: z42.string().optional()
}).describe("Defines a ground plane in the source domain");
expectTypesMatch(true);

// src/source/source_manually_placed_via.ts
import { z as z44 } from "zod";

// src/pcb/properties/layer_ref.ts
import { z as z43 } from "zod";
var all_layers = [
  "top",
  "bottom",
  "inner1",
  "inner2",
  "inner3",
  "inner4",
  "inner5",
  "inner6"
];
var layer_string = z43.enum(all_layers);
var layer_ref = layer_string.or(
  z43.object({
    name: layer_string
  })
).transform((layer) => {
  if (typeof layer === "string") {
    return layer;
  }
  return layer.name;
});
expectTypesMatch(true);
var visible_layer = z43.enum(["top", "bottom"]);

// src/source/source_manually_placed_via.ts
var source_manually_placed_via = z44.object({
  type: z44.literal("source_manually_placed_via"),
  source_manually_placed_via_id: z44.string(),
  source_group_id: z44.string(),
  source_net_id: z44.string(),
  subcircuit_id: z44.string().optional(),
  source_trace_id: z44.string().optional()
}).describe("Defines a via that is manually placed in the source domain");
expectTypesMatch(true);

// src/source/unknown_error_finding_part.ts
import { z as z45 } from "zod";
var unknown_error_finding_part = z45.object({
  type: z45.literal("unknown_error_finding_part"),
  unknown_error_finding_part_id: getZodPrefixedIdWithDefault(
    "unknown_error_finding_part"
  ),
  error_type: z45.literal("unknown_error_finding_part").default("unknown_error_finding_part"),
  message: z45.string(),
  source_component_id: z45.string().optional(),
  subcircuit_id: z45.string().optional()
}).describe(
  "Error emitted when an unexpected error occurs while finding a part"
);
expectTypesMatch(true);

// src/schematic/schematic_box.ts
import { z as z46 } from "zod";
var schematic_box = z46.object({
  type: z46.literal("schematic_box"),
  schematic_component_id: z46.string().optional(),
  width: distance,
  height: distance,
  is_dashed: z46.boolean().default(false),
  x: distance,
  y: distance,
  subcircuit_id: z46.string().optional()
}).describe("Draws a box on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_path.ts
import { z as z47 } from "zod";
var schematic_path = z47.object({
  type: z47.literal("schematic_path"),
  schematic_component_id: z47.string(),
  fill_color: z47.enum(["red", "blue"]).optional(),
  is_filled: z47.boolean().optional(),
  points: z47.array(point),
  subcircuit_id: z47.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_component.ts
import { z as z48 } from "zod";
var schematic_pin_styles = z48.record(
  z48.object({
    left_margin: length.optional(),
    right_margin: length.optional(),
    top_margin: length.optional(),
    bottom_margin: length.optional()
  })
);
var schematic_component_port_arrangement_by_size = z48.object({
  left_size: z48.number(),
  right_size: z48.number(),
  top_size: z48.number().optional(),
  bottom_size: z48.number().optional()
});
expectTypesMatch(true);
var schematic_component_port_arrangement_by_sides = z48.object({
  left_side: z48.object({
    pins: z48.array(z48.number()),
    // @ts-ignore
    direction: z48.enum(["top-to-bottom", "bottom-to-top"]).optional()
  }).optional(),
  right_side: z48.object({
    pins: z48.array(z48.number()),
    // @ts-ignore
    direction: z48.enum(["top-to-bottom", "bottom-to-top"]).optional()
  }).optional(),
  top_side: z48.object({
    pins: z48.array(z48.number()),
    // @ts-ignore
    direction: z48.enum(["left-to-right", "right-to-left"]).optional()
  }).optional(),
  bottom_side: z48.object({
    pins: z48.array(z48.number()),
    // @ts-ignore
    direction: z48.enum(["left-to-right", "right-to-left"]).optional()
  }).optional()
});
expectTypesMatch(true);
var port_arrangement = z48.union([
  schematic_component_port_arrangement_by_size,
  schematic_component_port_arrangement_by_sides
]);
var schematic_component = z48.object({
  type: z48.literal("schematic_component"),
  size,
  center: point,
  source_component_id: z48.string().optional(),
  schematic_component_id: z48.string(),
  pin_spacing: length.optional(),
  pin_styles: schematic_pin_styles.optional(),
  box_width: length.optional(),
  symbol_name: z48.string().optional(),
  port_arrangement: port_arrangement.optional(),
  port_labels: z48.record(z48.string()).optional(),
  symbol_display_value: z48.string().optional(),
  subcircuit_id: z48.string().optional(),
  schematic_group_id: z48.string().optional(),
  is_schematic_group: z48.boolean().optional(),
  source_group_id: z48.string().optional(),
  is_box_with_pins: z48.boolean().optional().default(true)
});
expectTypesMatch(true);

// src/schematic/schematic_line.ts
import { z as z49 } from "zod";
var schematic_line = z49.object({
  type: z49.literal("schematic_line"),
  schematic_line_id: getZodPrefixedIdWithDefault("schematic_line"),
  schematic_component_id: z49.string(),
  x1: distance,
  y1: distance,
  x2: distance,
  y2: distance,
  stroke_width: distance.nullable().optional(),
  color: z49.string().default("#000000"),
  is_dashed: z49.boolean().default(false),
  subcircuit_id: z49.string().optional()
}).describe("Draws a styled line on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_rect.ts
import { z as z50 } from "zod";
var schematic_rect = z50.object({
  type: z50.literal("schematic_rect"),
  schematic_rect_id: getZodPrefixedIdWithDefault("schematic_rect"),
  schematic_component_id: z50.string(),
  center: point,
  width: distance,
  height: distance,
  rotation: rotation.default(0),
  stroke_width: distance.nullable().optional(),
  color: z50.string().default("#000000"),
  is_filled: z50.boolean().default(false),
  fill_color: z50.string().optional(),
  is_dashed: z50.boolean().default(false),
  subcircuit_id: z50.string().optional()
}).describe("Draws a styled rectangle on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_circle.ts
import { z as z51 } from "zod";
var schematic_circle = z51.object({
  type: z51.literal("schematic_circle"),
  schematic_circle_id: getZodPrefixedIdWithDefault("schematic_circle"),
  schematic_component_id: z51.string(),
  center: point,
  radius: distance,
  stroke_width: distance.nullable().optional(),
  color: z51.string().default("#000000"),
  is_filled: z51.boolean().default(false),
  fill_color: z51.string().optional(),
  is_dashed: z51.boolean().default(false),
  subcircuit_id: z51.string().optional()
}).describe("Draws a styled circle on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_arc.ts
import { z as z52 } from "zod";
var schematic_arc = z52.object({
  type: z52.literal("schematic_arc"),
  schematic_arc_id: getZodPrefixedIdWithDefault("schematic_arc"),
  schematic_component_id: z52.string(),
  center: point,
  radius: distance,
  start_angle_degrees: rotation,
  end_angle_degrees: rotation,
  direction: z52.enum(["clockwise", "counterclockwise"]).default("counterclockwise"),
  stroke_width: distance.nullable().optional(),
  color: z52.string().default("#000000"),
  is_dashed: z52.boolean().default(false),
  subcircuit_id: z52.string().optional()
}).describe("Draws a styled arc on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_trace.ts
import { z as z53 } from "zod";
var schematic_trace = z53.object({
  type: z53.literal("schematic_trace"),
  schematic_trace_id: z53.string(),
  source_trace_id: z53.string().optional(),
  junctions: z53.array(
    z53.object({
      x: z53.number(),
      y: z53.number()
    })
  ),
  edges: z53.array(
    z53.object({
      from: z53.object({
        x: z53.number(),
        y: z53.number()
      }),
      to: z53.object({
        x: z53.number(),
        y: z53.number()
      }),
      is_crossing: z53.boolean().optional(),
      from_schematic_port_id: z53.string().optional(),
      to_schematic_port_id: z53.string().optional()
    })
  ),
  subcircuit_id: z53.string().optional(),
  // TODO: make required in a future release
  subcircuit_connectivity_map_key: z53.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_text.ts
import { z as z55 } from "zod";

// src/common/FivePointAnchor.ts
import { z as z54 } from "zod";
var fivePointAnchor = z54.enum([
  "center",
  "left",
  "right",
  "top",
  "bottom"
]);
expectTypesMatch(true);

// src/schematic/schematic_text.ts
var schematic_text = z55.object({
  type: z55.literal("schematic_text"),
  schematic_component_id: z55.string().optional(),
  schematic_text_id: z55.string(),
  text: z55.string(),
  font_size: z55.number().default(0.18),
  position: z55.object({
    x: distance,
    y: distance
  }),
  rotation: z55.number().default(0),
  anchor: z55.union([fivePointAnchor.describe("legacy"), ninePointAnchor]).default("center"),
  color: z55.string().default("#000000"),
  subcircuit_id: z55.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_port.ts
import { z as z56 } from "zod";
var schematic_port = z56.object({
  type: z56.literal("schematic_port"),
  schematic_port_id: z56.string(),
  source_port_id: z56.string(),
  schematic_component_id: z56.string().optional(),
  center: point,
  facing_direction: z56.enum(["up", "down", "left", "right"]).optional(),
  distance_from_component_edge: z56.number().optional(),
  side_of_component: z56.enum(["top", "bottom", "left", "right"]).optional(),
  true_ccw_index: z56.number().optional(),
  pin_number: z56.number().optional(),
  display_pin_label: z56.string().optional(),
  subcircuit_id: z56.string().optional(),
  is_connected: z56.boolean().optional(),
  has_input_arrow: z56.boolean().optional(),
  has_output_arrow: z56.boolean().optional()
}).describe("Defines a port on a schematic component");
expectTypesMatch(true);

// src/schematic/schematic_net_label.ts
import { z as z57 } from "zod";
var schematic_net_label = z57.object({
  type: z57.literal("schematic_net_label"),
  schematic_net_label_id: getZodPrefixedIdWithDefault("schematic_net_label"),
  schematic_trace_id: z57.string().optional(),
  source_trace_id: z57.string().optional(),
  source_net_id: z57.string(),
  center: point,
  anchor_position: point.optional(),
  anchor_side: z57.enum(["top", "bottom", "left", "right"]),
  text: z57.string(),
  symbol_name: z57.string().optional(),
  is_movable: z57.boolean().optional(),
  subcircuit_id: z57.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_error.ts
import { z as z58 } from "zod";
var schematic_error = z58.object({
  type: z58.literal("schematic_error"),
  schematic_error_id: z58.string(),
  // eventually each error type should be broken out into a dir of files
  error_type: z58.literal("schematic_port_not_found").default("schematic_port_not_found"),
  message: z58.string(),
  subcircuit_id: z58.string().optional()
}).describe("Defines a schematic error on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_layout_error.ts
import { z as z59 } from "zod";
var schematic_layout_error = z59.object({
  type: z59.literal("schematic_layout_error"),
  schematic_layout_error_id: getZodPrefixedIdWithDefault(
    "schematic_layout_error"
  ),
  error_type: z59.literal("schematic_layout_error").default("schematic_layout_error"),
  message: z59.string(),
  source_group_id: z59.string(),
  schematic_group_id: z59.string(),
  subcircuit_id: z59.string().optional()
}).describe("Error emitted when schematic layout fails for a group");
expectTypesMatch(true);

// src/schematic/schematic_debug_object.ts
import { z as z60 } from "zod";
var schematic_debug_object_base = z60.object({
  type: z60.literal("schematic_debug_object"),
  label: z60.string().optional(),
  subcircuit_id: z60.string().optional()
});
var schematic_debug_rect = schematic_debug_object_base.extend({
  shape: z60.literal("rect"),
  center: point,
  size
});
var schematic_debug_line = schematic_debug_object_base.extend({
  shape: z60.literal("line"),
  start: point,
  end: point
});
var schematic_debug_point = schematic_debug_object_base.extend({
  shape: z60.literal("point"),
  center: point
});
var schematic_debug_object = z60.discriminatedUnion("shape", [
  schematic_debug_rect,
  schematic_debug_line,
  schematic_debug_point
]);
expectTypesMatch(true);

// src/schematic/schematic_voltage_probe.ts
import { z as z61 } from "zod";
var schematic_voltage_probe = z61.object({
  type: z61.literal("schematic_voltage_probe"),
  schematic_voltage_probe_id: z61.string(),
  source_component_id: z61.string().optional(),
  name: z61.string().optional(),
  position: point,
  schematic_trace_id: z61.string(),
  voltage: voltage.optional(),
  subcircuit_id: z61.string().optional(),
  color: z61.string().optional()
}).describe("Defines a voltage probe measurement point on a schematic trace");
expectTypesMatch(true);

// src/schematic/schematic_manual_edit_conflict_warning.ts
import { z as z62 } from "zod";
var schematic_manual_edit_conflict_warning = z62.object({
  type: z62.literal("schematic_manual_edit_conflict_warning"),
  schematic_manual_edit_conflict_warning_id: getZodPrefixedIdWithDefault(
    "schematic_manual_edit_conflict_warning"
  ),
  warning_type: z62.literal("schematic_manual_edit_conflict_warning").default("schematic_manual_edit_conflict_warning"),
  message: z62.string(),
  schematic_component_id: z62.string(),
  schematic_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  source_component_id: z62.string()
}).describe(
  "Warning emitted when a component has both manual placement and explicit schX/schY coordinates"
);
expectTypesMatch(true);

// src/schematic/schematic_group.ts
import { z as z63 } from "zod";
var schematic_group = z63.object({
  type: z63.literal("schematic_group"),
  schematic_group_id: getZodPrefixedIdWithDefault("schematic_group"),
  source_group_id: z63.string(),
  is_subcircuit: z63.boolean().optional(),
  subcircuit_id: z63.string().optional(),
  width: length,
  height: length,
  center: point,
  schematic_component_ids: z63.array(z63.string()),
  show_as_schematic_box: z63.boolean().optional(),
  name: z63.string().optional(),
  description: z63.string().optional()
}).describe("Defines a group of components on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_table.ts
import { z as z64 } from "zod";
var schematic_table = z64.object({
  type: z64.literal("schematic_table"),
  schematic_table_id: getZodPrefixedIdWithDefault("schematic_table"),
  anchor_position: point,
  column_widths: z64.array(distance),
  row_heights: z64.array(distance),
  cell_padding: distance.optional(),
  border_width: distance.optional(),
  subcircuit_id: z64.string().optional(),
  schematic_component_id: z64.string().optional(),
  anchor: ninePointAnchor.optional()
}).describe("Defines a table on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_table_cell.ts
import { z as z65 } from "zod";
var schematic_table_cell = z65.object({
  type: z65.literal("schematic_table_cell"),
  schematic_table_cell_id: getZodPrefixedIdWithDefault(
    "schematic_table_cell"
  ),
  schematic_table_id: z65.string(),
  start_row_index: z65.number(),
  end_row_index: z65.number(),
  start_column_index: z65.number(),
  end_column_index: z65.number(),
  text: z65.string().optional(),
  center: point,
  width: distance,
  height: distance,
  horizontal_align: z65.enum(["left", "center", "right"]).optional(),
  vertical_align: z65.enum(["top", "middle", "bottom"]).optional(),
  font_size: distance.optional(),
  subcircuit_id: z65.string().optional()
}).describe("Defines a cell within a schematic_table");
expectTypesMatch(true);

// src/schematic/schematic_sheet.ts
import { z as z66 } from "zod";
var schematic_sheet = z66.object({
  type: z66.literal("schematic_sheet"),
  schematic_sheet_id: getZodPrefixedIdWithDefault("schematic_sheet"),
  name: z66.string().optional(),
  subcircuit_id: z66.string().optional()
}).describe(
  "Defines a schematic sheet or page that components can be placed on"
);
expectTypesMatch(true);

// src/pcb/properties/brep.ts
import { z as z67 } from "zod";
var point_with_bulge = z67.object({
  x: distance,
  y: distance,
  bulge: z67.number().optional()
});
expectTypesMatch(true);
var ring = z67.object({
  vertices: z67.array(point_with_bulge)
});
expectTypesMatch(true);
var brep_shape = z67.object({
  outer_ring: ring,
  inner_rings: z67.array(ring).default([])
});
expectTypesMatch(true);

// src/pcb/properties/pcb_route_hints.ts
import { z as z68 } from "zod";
var pcb_route_hint = z68.object({
  x: distance,
  y: distance,
  via: z68.boolean().optional(),
  via_to_layer: layer_ref.optional()
});
var pcb_route_hints = z68.array(pcb_route_hint);
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/properties/route_hint_point.ts
import { z as z69 } from "zod";
var route_hint_point = z69.object({
  x: distance,
  y: distance,
  via: z69.boolean().optional(),
  to_layer: layer_ref.optional(),
  trace_width: distance.optional()
});
expectTypesMatch(true);

// src/pcb/pcb_component.ts
import { z as z70 } from "zod";
var pcb_component = z70.object({
  type: z70.literal("pcb_component"),
  pcb_component_id: getZodPrefixedIdWithDefault("pcb_component"),
  source_component_id: z70.string(),
  center: point,
  layer: layer_ref,
  rotation,
  width: length,
  height: length,
  do_not_place: z70.boolean().optional(),
  subcircuit_id: z70.string().optional(),
  pcb_group_id: z70.string().optional(),
  position_mode: z70.enum(["packed", "relative_to_group_anchor", "none"]).optional(),
  positioned_relative_to_pcb_group_id: z70.string().optional(),
  obstructs_within_bounds: z70.boolean().default(true).describe(
    "Does this component take up all the space within its bounds on a layer. This is generally true except for when separated pin headers are being represented by a single component (in which case, chips can be placed between the pin headers) or for tall modules where chips fit underneath"
  )
}).describe("Defines a component on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_hole.ts
import { z as z71 } from "zod";
var pcb_hole_circle = z71.object({
  type: z71.literal("pcb_hole"),
  pcb_hole_id: getZodPrefixedIdWithDefault("pcb_hole"),
  pcb_group_id: z71.string().optional(),
  subcircuit_id: z71.string().optional(),
  hole_shape: z71.literal("circle"),
  hole_diameter: z71.number(),
  x: distance,
  y: distance,
  soldermask_margin: z71.number().optional()
});
var pcb_hole_circle_shape = pcb_hole_circle.describe(
  "Defines a circular hole on the PCB"
);
expectTypesMatch(true);
var pcb_hole_rect = z71.object({
  type: z71.literal("pcb_hole"),
  pcb_hole_id: getZodPrefixedIdWithDefault("pcb_hole"),
  pcb_group_id: z71.string().optional(),
  subcircuit_id: z71.string().optional(),
  hole_shape: z71.literal("rect"),
  hole_width: z71.number(),
  hole_height: z71.number(),
  x: distance,
  y: distance,
  soldermask_margin: z71.number().optional()
});
var pcb_hole_rect_shape = pcb_hole_rect.describe(
  "Defines a rectangular (square-capable) hole on the PCB. Use equal width/height for square."
);
expectTypesMatch(true);
var pcb_hole_circle_or_square = z71.object({
  type: z71.literal("pcb_hole"),
  pcb_hole_id: getZodPrefixedIdWithDefault("pcb_hole"),
  pcb_group_id: z71.string().optional(),
  subcircuit_id: z71.string().optional(),
  hole_shape: z71.enum(["circle", "square"]),
  hole_diameter: z71.number(),
  x: distance,
  y: distance,
  soldermask_margin: z71.number().optional()
});
var pcb_hole_circle_or_square_shape = pcb_hole_circle_or_square.describe(
  "Defines a circular or square hole on the PCB"
);
expectTypesMatch(true);
var pcb_hole_oval = z71.object({
  type: z71.literal("pcb_hole"),
  pcb_hole_id: getZodPrefixedIdWithDefault("pcb_hole"),
  pcb_group_id: z71.string().optional(),
  subcircuit_id: z71.string().optional(),
  hole_shape: z71.literal("oval"),
  hole_width: z71.number(),
  hole_height: z71.number(),
  x: distance,
  y: distance,
  soldermask_margin: z71.number().optional()
});
var pcb_hole_oval_shape = pcb_hole_oval.describe(
  "Defines an oval hole on the PCB"
);
expectTypesMatch(true);
var pcb_hole_pill = z71.object({
  type: z71.literal("pcb_hole"),
  pcb_hole_id: getZodPrefixedIdWithDefault("pcb_hole"),
  pcb_group_id: z71.string().optional(),
  subcircuit_id: z71.string().optional(),
  hole_shape: z71.literal("pill"),
  hole_width: z71.number(),
  hole_height: z71.number(),
  x: distance,
  y: distance,
  soldermask_margin: z71.number().optional()
});
var pcb_hole_pill_shape = pcb_hole_pill.describe(
  "Defines a pill-shaped hole on the PCB"
);
expectTypesMatch(true);
var pcb_hole_rotated_pill = z71.object({
  type: z71.literal("pcb_hole"),
  pcb_hole_id: getZodPrefixedIdWithDefault("pcb_hole"),
  pcb_group_id: z71.string().optional(),
  subcircuit_id: z71.string().optional(),
  hole_shape: z71.literal("rotated_pill"),
  hole_width: z71.number(),
  hole_height: z71.number(),
  x: distance,
  y: distance,
  ccw_rotation: rotation,
  soldermask_margin: z71.number().optional()
});
var pcb_hole_rotated_pill_shape = pcb_hole_rotated_pill.describe(
  "Defines a rotated pill-shaped hole on the PCB"
);
expectTypesMatch(true);
var pcb_hole = pcb_hole_circle_or_square.or(pcb_hole_oval).or(pcb_hole_pill).or(pcb_hole_rotated_pill).or(pcb_hole_circle).or(pcb_hole_rect);

// src/pcb/pcb_plated_hole.ts
import { z as z72 } from "zod";
var pcb_plated_hole_circle = z72.object({
  type: z72.literal("pcb_plated_hole"),
  shape: z72.literal("circle"),
  pcb_group_id: z72.string().optional(),
  subcircuit_id: z72.string().optional(),
  outer_diameter: z72.number(),
  hole_diameter: z72.number(),
  x: distance,
  y: distance,
  layers: z72.array(layer_ref),
  port_hints: z72.array(z72.string()).optional(),
  pcb_component_id: z72.string().optional(),
  pcb_port_id: z72.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole"),
  soldermask_margin: z72.number().optional()
});
var pcb_plated_hole_oval = z72.object({
  type: z72.literal("pcb_plated_hole"),
  shape: z72.enum(["oval", "pill"]),
  pcb_group_id: z72.string().optional(),
  subcircuit_id: z72.string().optional(),
  outer_width: z72.number(),
  outer_height: z72.number(),
  hole_width: z72.number(),
  hole_height: z72.number(),
  x: distance,
  y: distance,
  ccw_rotation: rotation,
  layers: z72.array(layer_ref),
  port_hints: z72.array(z72.string()).optional(),
  pcb_component_id: z72.string().optional(),
  pcb_port_id: z72.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole"),
  soldermask_margin: z72.number().optional()
});
var pcb_circular_hole_with_rect_pad = z72.object({
  type: z72.literal("pcb_plated_hole"),
  shape: z72.literal("circular_hole_with_rect_pad"),
  pcb_group_id: z72.string().optional(),
  subcircuit_id: z72.string().optional(),
  hole_shape: z72.literal("circle"),
  pad_shape: z72.literal("rect"),
  hole_diameter: z72.number(),
  rect_pad_width: z72.number(),
  rect_pad_height: z72.number(),
  rect_border_radius: z72.number().optional(),
  hole_offset_x: distance.default(0),
  hole_offset_y: distance.default(0),
  x: distance,
  y: distance,
  layers: z72.array(layer_ref),
  port_hints: z72.array(z72.string()).optional(),
  pcb_component_id: z72.string().optional(),
  pcb_port_id: z72.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole"),
  soldermask_margin: z72.number().optional()
});
var pcb_pill_hole_with_rect_pad = z72.object({
  type: z72.literal("pcb_plated_hole"),
  shape: z72.literal("pill_hole_with_rect_pad"),
  pcb_group_id: z72.string().optional(),
  subcircuit_id: z72.string().optional(),
  hole_shape: z72.literal("pill"),
  pad_shape: z72.literal("rect"),
  hole_width: z72.number(),
  hole_height: z72.number(),
  rect_pad_width: z72.number(),
  rect_pad_height: z72.number(),
  rect_border_radius: z72.number().optional(),
  hole_offset_x: distance.default(0),
  hole_offset_y: distance.default(0),
  x: distance,
  y: distance,
  layers: z72.array(layer_ref),
  port_hints: z72.array(z72.string()).optional(),
  pcb_component_id: z72.string().optional(),
  pcb_port_id: z72.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole"),
  soldermask_margin: z72.number().optional()
});
var pcb_rotated_pill_hole_with_rect_pad = z72.object({
  type: z72.literal("pcb_plated_hole"),
  shape: z72.literal("rotated_pill_hole_with_rect_pad"),
  pcb_group_id: z72.string().optional(),
  subcircuit_id: z72.string().optional(),
  hole_shape: z72.literal("rotated_pill"),
  pad_shape: z72.literal("rect"),
  hole_width: z72.number(),
  hole_height: z72.number(),
  hole_ccw_rotation: rotation,
  rect_pad_width: z72.number(),
  rect_pad_height: z72.number(),
  rect_border_radius: z72.number().optional(),
  rect_ccw_rotation: rotation,
  hole_offset_x: distance.default(0),
  hole_offset_y: distance.default(0),
  x: distance,
  y: distance,
  layers: z72.array(layer_ref),
  port_hints: z72.array(z72.string()).optional(),
  pcb_component_id: z72.string().optional(),
  pcb_port_id: z72.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole"),
  soldermask_margin: z72.number().optional()
});
var pcb_hole_with_polygon_pad = z72.object({
  type: z72.literal("pcb_plated_hole"),
  shape: z72.literal("hole_with_polygon_pad"),
  pcb_group_id: z72.string().optional(),
  subcircuit_id: z72.string().optional(),
  hole_shape: z72.enum(["circle", "oval", "pill", "rotated_pill"]),
  hole_diameter: z72.number().optional(),
  hole_width: z72.number().optional(),
  hole_height: z72.number().optional(),
  pad_outline: z72.array(
    z72.object({
      x: distance,
      y: distance
    })
  ).min(3),
  hole_offset_x: distance.default(0),
  hole_offset_y: distance.default(0),
  x: distance,
  y: distance,
  layers: z72.array(layer_ref),
  port_hints: z72.array(z72.string()).optional(),
  pcb_component_id: z72.string().optional(),
  pcb_port_id: z72.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole"),
  soldermask_margin: z72.number().optional()
});
var pcb_plated_hole = z72.union([
  pcb_plated_hole_circle,
  pcb_plated_hole_oval,
  pcb_circular_hole_with_rect_pad,
  pcb_pill_hole_with_rect_pad,
  pcb_rotated_pill_hole_with_rect_pad,
  pcb_hole_with_polygon_pad
]);
expectTypesMatch(
  true
);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/pcb_port.ts
import { z as z73 } from "zod";
var pcb_port = z73.object({
  type: z73.literal("pcb_port"),
  pcb_port_id: getZodPrefixedIdWithDefault("pcb_port"),
  pcb_group_id: z73.string().optional(),
  subcircuit_id: z73.string().optional(),
  source_port_id: z73.string(),
  pcb_component_id: z73.string().optional(),
  x: distance,
  y: distance,
  layers: z73.array(layer_ref),
  is_board_pinout: z73.boolean().optional()
}).describe("Defines a port on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_smtpad.ts
import { z as z74 } from "zod";
var pcb_smtpad_circle = z74.object({
  type: z74.literal("pcb_smtpad"),
  shape: z74.literal("circle"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z74.string().optional(),
  subcircuit_id: z74.string().optional(),
  x: distance,
  y: distance,
  radius: z74.number(),
  layer: layer_ref,
  port_hints: z74.array(z74.string()).optional(),
  pcb_component_id: z74.string().optional(),
  pcb_port_id: z74.string().optional(),
  is_covered_with_solder_mask: z74.boolean().optional(),
  soldermask_margin: z74.number().optional()
});
var pcb_smtpad_rect = z74.object({
  type: z74.literal("pcb_smtpad"),
  shape: z74.literal("rect"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z74.string().optional(),
  subcircuit_id: z74.string().optional(),
  x: distance,
  y: distance,
  width: z74.number(),
  height: z74.number(),
  rect_border_radius: z74.number().optional(),
  corner_radius: z74.number().optional(),
  layer: layer_ref,
  port_hints: z74.array(z74.string()).optional(),
  pcb_component_id: z74.string().optional(),
  pcb_port_id: z74.string().optional(),
  is_covered_with_solder_mask: z74.boolean().optional(),
  soldermask_margin: z74.number().optional()
});
var pcb_smtpad_rotated_rect = z74.object({
  type: z74.literal("pcb_smtpad"),
  shape: z74.literal("rotated_rect"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z74.string().optional(),
  subcircuit_id: z74.string().optional(),
  x: distance,
  y: distance,
  width: z74.number(),
  height: z74.number(),
  rect_border_radius: z74.number().optional(),
  corner_radius: z74.number().optional(),
  ccw_rotation: rotation,
  layer: layer_ref,
  port_hints: z74.array(z74.string()).optional(),
  pcb_component_id: z74.string().optional(),
  pcb_port_id: z74.string().optional(),
  is_covered_with_solder_mask: z74.boolean().optional(),
  soldermask_margin: z74.number().optional()
});
var pcb_smtpad_pill = z74.object({
  type: z74.literal("pcb_smtpad"),
  shape: z74.literal("pill"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z74.string().optional(),
  subcircuit_id: z74.string().optional(),
  x: distance,
  y: distance,
  width: z74.number(),
  height: z74.number(),
  radius: z74.number(),
  layer: layer_ref,
  port_hints: z74.array(z74.string()).optional(),
  pcb_component_id: z74.string().optional(),
  pcb_port_id: z74.string().optional(),
  is_covered_with_solder_mask: z74.boolean().optional(),
  soldermask_margin: z74.number().optional()
});
var pcb_smtpad_rotated_pill = z74.object({
  type: z74.literal("pcb_smtpad"),
  shape: z74.literal("rotated_pill"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z74.string().optional(),
  subcircuit_id: z74.string().optional(),
  x: distance,
  y: distance,
  width: z74.number(),
  height: z74.number(),
  radius: z74.number(),
  ccw_rotation: rotation,
  layer: layer_ref,
  port_hints: z74.array(z74.string()).optional(),
  pcb_component_id: z74.string().optional(),
  pcb_port_id: z74.string().optional(),
  is_covered_with_solder_mask: z74.boolean().optional(),
  soldermask_margin: z74.number().optional()
});
var pcb_smtpad_polygon = z74.object({
  type: z74.literal("pcb_smtpad"),
  shape: z74.literal("polygon"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z74.string().optional(),
  subcircuit_id: z74.string().optional(),
  points: z74.array(point),
  layer: layer_ref,
  port_hints: z74.array(z74.string()).optional(),
  pcb_component_id: z74.string().optional(),
  pcb_port_id: z74.string().optional(),
  is_covered_with_solder_mask: z74.boolean().optional(),
  soldermask_margin: z74.number().optional()
});
var pcb_smtpad = z74.discriminatedUnion("shape", [
  pcb_smtpad_circle,
  pcb_smtpad_rect,
  pcb_smtpad_rotated_rect,
  pcb_smtpad_rotated_pill,
  pcb_smtpad_pill,
  pcb_smtpad_polygon
]).describe("Defines an SMT pad on the PCB");
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/pcb_solder_paste.ts
import { z as z75 } from "zod";
var pcb_solder_paste_circle = z75.object({
  type: z75.literal("pcb_solder_paste"),
  shape: z75.literal("circle"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z75.string().optional(),
  subcircuit_id: z75.string().optional(),
  x: distance,
  y: distance,
  radius: z75.number(),
  layer: layer_ref,
  pcb_component_id: z75.string().optional(),
  pcb_smtpad_id: z75.string().optional()
});
var pcb_solder_paste_rect = z75.object({
  type: z75.literal("pcb_solder_paste"),
  shape: z75.literal("rect"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z75.string().optional(),
  subcircuit_id: z75.string().optional(),
  x: distance,
  y: distance,
  width: z75.number(),
  height: z75.number(),
  layer: layer_ref,
  pcb_component_id: z75.string().optional(),
  pcb_smtpad_id: z75.string().optional()
});
var pcb_solder_paste_pill = z75.object({
  type: z75.literal("pcb_solder_paste"),
  shape: z75.literal("pill"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z75.string().optional(),
  subcircuit_id: z75.string().optional(),
  x: distance,
  y: distance,
  width: z75.number(),
  height: z75.number(),
  radius: z75.number(),
  layer: layer_ref,
  pcb_component_id: z75.string().optional(),
  pcb_smtpad_id: z75.string().optional()
});
var pcb_solder_paste_rotated_rect = z75.object({
  type: z75.literal("pcb_solder_paste"),
  shape: z75.literal("rotated_rect"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z75.string().optional(),
  subcircuit_id: z75.string().optional(),
  x: distance,
  y: distance,
  width: z75.number(),
  height: z75.number(),
  ccw_rotation: distance,
  layer: layer_ref,
  pcb_component_id: z75.string().optional(),
  pcb_smtpad_id: z75.string().optional()
});
var pcb_solder_paste_oval = z75.object({
  type: z75.literal("pcb_solder_paste"),
  shape: z75.literal("oval"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z75.string().optional(),
  subcircuit_id: z75.string().optional(),
  x: distance,
  y: distance,
  width: z75.number(),
  height: z75.number(),
  layer: layer_ref,
  pcb_component_id: z75.string().optional(),
  pcb_smtpad_id: z75.string().optional()
});
var pcb_solder_paste = z75.union([
  pcb_solder_paste_circle,
  pcb_solder_paste_rect,
  pcb_solder_paste_pill,
  pcb_solder_paste_rotated_rect,
  pcb_solder_paste_oval
]).describe("Defines solderpaste on the PCB");
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(
  true
);
expectTypesMatch(true);

// src/pcb/pcb_text.ts
import { z as z76 } from "zod";
var pcb_text = z76.object({
  type: z76.literal("pcb_text"),
  pcb_text_id: getZodPrefixedIdWithDefault("pcb_text"),
  pcb_group_id: z76.string().optional(),
  subcircuit_id: z76.string().optional(),
  text: z76.string(),
  center: point,
  layer: layer_ref,
  width: length,
  height: length,
  lines: z76.number(),
  // @ts-ignore
  align: z76.enum(["bottom-left"])
}).describe("Defines text on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_trace.ts
import { z as z77 } from "zod";
var pcb_trace_route_point_wire = z77.object({
  route_type: z77.literal("wire"),
  x: distance,
  y: distance,
  width: distance,
  start_pcb_port_id: z77.string().optional(),
  end_pcb_port_id: z77.string().optional(),
  layer: layer_ref
});
var pcb_trace_route_point_via = z77.object({
  route_type: z77.literal("via"),
  x: distance,
  y: distance,
  hole_diameter: distance.optional(),
  outer_diameter: distance.optional(),
  from_layer: z77.string(),
  to_layer: z77.string()
});
var pcb_trace_route_point = z77.union([
  pcb_trace_route_point_wire,
  pcb_trace_route_point_via
]);
var pcb_trace = z77.object({
  type: z77.literal("pcb_trace"),
  source_trace_id: z77.string().optional(),
  pcb_component_id: z77.string().optional(),
  pcb_trace_id: getZodPrefixedIdWithDefault("pcb_trace"),
  pcb_group_id: z77.string().optional(),
  subcircuit_id: z77.string().optional(),
  route_thickness_mode: z77.enum(["constant", "interpolated"]).default("constant").optional(),
  route_order_index: z77.number().optional(),
  should_round_corners: z77.boolean().optional(),
  trace_length: z77.number().optional(),
  highlight_color: z77.string().optional(),
  route: z77.array(pcb_trace_route_point)
}).describe("Defines a trace on the PCB");
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/pcb_trace_error.ts
import { z as z78 } from "zod";
var pcb_trace_error = z78.object({
  type: z78.literal("pcb_trace_error"),
  pcb_trace_error_id: getZodPrefixedIdWithDefault("pcb_trace_error"),
  error_type: z78.literal("pcb_trace_error").default("pcb_trace_error"),
  message: z78.string(),
  center: point.optional(),
  pcb_trace_id: z78.string(),
  source_trace_id: z78.string(),
  pcb_component_ids: z78.array(z78.string()),
  pcb_port_ids: z78.array(z78.string()),
  subcircuit_id: z78.string().optional()
}).describe("Defines a trace error on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_trace_missing_error.ts
import { z as z79 } from "zod";
var pcb_trace_missing_error = z79.object({
  type: z79.literal("pcb_trace_missing_error"),
  pcb_trace_missing_error_id: getZodPrefixedIdWithDefault(
    "pcb_trace_missing_error"
  ),
  error_type: z79.literal("pcb_trace_missing_error").default("pcb_trace_missing_error"),
  message: z79.string(),
  center: point.optional(),
  source_trace_id: z79.string(),
  pcb_component_ids: z79.array(z79.string()),
  pcb_port_ids: z79.array(z79.string()),
  subcircuit_id: z79.string().optional()
}).describe(
  "Defines an error when a source trace has no corresponding PCB trace"
);
expectTypesMatch(true);

// src/pcb/pcb_port_not_matched_error.ts
import { z as z80 } from "zod";
var pcb_port_not_matched_error = z80.object({
  type: z80.literal("pcb_port_not_matched_error"),
  pcb_error_id: getZodPrefixedIdWithDefault("pcb_error"),
  error_type: z80.literal("pcb_port_not_matched_error").default("pcb_port_not_matched_error"),
  message: z80.string(),
  pcb_component_ids: z80.array(z80.string()),
  subcircuit_id: z80.string().optional()
}).describe("Defines a trace error on the PCB where a port is not matched");
expectTypesMatch(true);

// src/pcb/pcb_port_not_connected_error.ts
import { z as z81 } from "zod";
var pcb_port_not_connected_error = z81.object({
  type: z81.literal("pcb_port_not_connected_error"),
  pcb_port_not_connected_error_id: getZodPrefixedIdWithDefault(
    "pcb_port_not_connected_error"
  ),
  error_type: z81.literal("pcb_port_not_connected_error").default("pcb_port_not_connected_error"),
  message: z81.string(),
  pcb_port_ids: z81.array(z81.string()),
  pcb_component_ids: z81.array(z81.string()),
  subcircuit_id: z81.string().optional()
}).describe("Defines an error when a pcb port is not connected to any trace");
expectTypesMatch(
  true
);

// src/pcb/pcb_net.ts
import { z as z82 } from "zod";
var pcb_net = z82.object({
  type: z82.literal("pcb_net"),
  pcb_net_id: getZodPrefixedIdWithDefault("pcb_net"),
  source_net_id: z82.string().optional(),
  highlight_color: z82.string().optional()
}).describe("Defines a net on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_via.ts
import { z as z83 } from "zod";
var pcb_via = z83.object({
  type: z83.literal("pcb_via"),
  pcb_via_id: getZodPrefixedIdWithDefault("pcb_via"),
  pcb_group_id: z83.string().optional(),
  subcircuit_id: z83.string().optional(),
  subcircuit_connectivity_map_key: z83.string().optional(),
  x: distance,
  y: distance,
  outer_diameter: distance.default("0.6mm"),
  hole_diameter: distance.default("0.25mm"),
  /** @deprecated */
  from_layer: layer_ref.optional(),
  /** @deprecated */
  to_layer: layer_ref.optional(),
  layers: z83.array(layer_ref),
  pcb_trace_id: z83.string().optional(),
  net_is_assignable: z83.boolean().optional(),
  net_assigned: z83.boolean().optional()
}).describe("Defines a via on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_board.ts
import { z as z84 } from "zod";
var pcb_board = z84.object({
  type: z84.literal("pcb_board"),
  pcb_board_id: getZodPrefixedIdWithDefault("pcb_board"),
  pcb_panel_id: z84.string().optional(),
  is_subcircuit: z84.boolean().optional(),
  subcircuit_id: z84.string().optional(),
  width: length.optional(),
  height: length.optional(),
  center: point,
  thickness: length.optional().default(1.4),
  num_layers: z84.number().optional().default(4),
  outline: z84.array(point).optional(),
  shape: z84.enum(["rect", "polygon"]).optional(),
  material: z84.enum(["fr4", "fr1"]).default("fr4")
}).describe("Defines the board outline of the PCB");
expectTypesMatch(true);

// src/pcb/pcb_panel.ts
import { z as z85 } from "zod";
var pcb_panel = z85.object({
  type: z85.literal("pcb_panel"),
  pcb_panel_id: getZodPrefixedIdWithDefault("pcb_panel"),
  width: length,
  height: length,
  center: point,
  covered_with_solder_mask: z85.boolean().optional().default(true)
}).describe("Defines a PCB panel that can contain multiple boards");
expectTypesMatch(true);

// src/pcb/pcb_placement_error.ts
import { z as z86 } from "zod";
var pcb_placement_error = z86.object({
  type: z86.literal("pcb_placement_error"),
  pcb_placement_error_id: getZodPrefixedIdWithDefault("pcb_placement_error"),
  error_type: z86.literal("pcb_placement_error").default("pcb_placement_error"),
  message: z86.string(),
  subcircuit_id: z86.string().optional()
}).describe("Defines a placement error on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_trace_hint.ts
import { z as z87 } from "zod";
var pcb_trace_hint = z87.object({
  type: z87.literal("pcb_trace_hint"),
  pcb_trace_hint_id: getZodPrefixedIdWithDefault("pcb_trace_hint"),
  pcb_port_id: z87.string(),
  pcb_component_id: z87.string(),
  route: z87.array(route_hint_point),
  subcircuit_id: z87.string().optional()
}).describe("A hint that can be used during generation of a PCB trace");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_line.ts
import { z as z88 } from "zod";
var pcb_silkscreen_line = z88.object({
  type: z88.literal("pcb_silkscreen_line"),
  pcb_silkscreen_line_id: getZodPrefixedIdWithDefault("pcb_silkscreen_line"),
  pcb_component_id: z88.string(),
  pcb_group_id: z88.string().optional(),
  subcircuit_id: z88.string().optional(),
  stroke_width: distance.default("0.1mm"),
  x1: distance,
  y1: distance,
  x2: distance,
  y2: distance,
  layer: visible_layer
}).describe("Defines a silkscreen line on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_path.ts
import { z as z89 } from "zod";
var pcb_silkscreen_path = z89.object({
  type: z89.literal("pcb_silkscreen_path"),
  pcb_silkscreen_path_id: getZodPrefixedIdWithDefault("pcb_silkscreen_path"),
  pcb_component_id: z89.string(),
  pcb_group_id: z89.string().optional(),
  subcircuit_id: z89.string().optional(),
  layer: visible_layer,
  route: z89.array(point),
  stroke_width: length
}).describe("Defines a silkscreen path on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_text.ts
import { z as z90 } from "zod";
var pcb_silkscreen_text = z90.object({
  type: z90.literal("pcb_silkscreen_text"),
  pcb_silkscreen_text_id: getZodPrefixedIdWithDefault("pcb_silkscreen_text"),
  pcb_group_id: z90.string().optional(),
  subcircuit_id: z90.string().optional(),
  font: z90.literal("tscircuit2024").default("tscircuit2024"),
  font_size: distance.default("0.2mm"),
  pcb_component_id: z90.string(),
  text: z90.string(),
  is_knockout: z90.boolean().default(false).optional(),
  knockout_padding: z90.object({
    left: length,
    top: length,
    bottom: length,
    right: length
  }).default({
    left: "0.2mm",
    top: "0.2mm",
    bottom: "0.2mm",
    right: "0.2mm"
  }).optional(),
  ccw_rotation: z90.number().optional(),
  layer: layer_ref,
  is_mirrored: z90.boolean().default(false).optional(),
  anchor_position: point.default({ x: 0, y: 0 }),
  anchor_alignment: ninePointAnchor.default("center")
}).describe("Defines silkscreen text on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_copper_text.ts
import { z as z91 } from "zod";
var pcb_copper_text = z91.object({
  type: z91.literal("pcb_copper_text"),
  pcb_copper_text_id: getZodPrefixedIdWithDefault("pcb_copper_text"),
  pcb_group_id: z91.string().optional(),
  subcircuit_id: z91.string().optional(),
  font: z91.literal("tscircuit2024").default("tscircuit2024"),
  font_size: distance.default("0.2mm"),
  pcb_component_id: z91.string(),
  text: z91.string(),
  is_knockout: z91.boolean().default(false).optional(),
  knockout_padding: z91.object({
    left: length,
    top: length,
    bottom: length,
    right: length
  }).default({
    left: "0.2mm",
    top: "0.2mm",
    bottom: "0.2mm",
    right: "0.2mm"
  }).optional(),
  ccw_rotation: z91.number().optional(),
  layer: layer_ref,
  is_mirrored: z91.boolean().default(false).optional(),
  anchor_position: point.default({ x: 0, y: 0 }),
  anchor_alignment: ninePointAnchor.default("center")
}).describe("Defines copper text on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_rect.ts
import { z as z92 } from "zod";
var pcb_silkscreen_rect = z92.object({
  type: z92.literal("pcb_silkscreen_rect"),
  pcb_silkscreen_rect_id: getZodPrefixedIdWithDefault("pcb_silkscreen_rect"),
  pcb_component_id: z92.string(),
  pcb_group_id: z92.string().optional(),
  subcircuit_id: z92.string().optional(),
  center: point,
  width: length,
  height: length,
  layer: layer_ref,
  stroke_width: length.default("1mm"),
  corner_radius: length.optional(),
  is_filled: z92.boolean().default(true).optional(),
  has_stroke: z92.boolean().optional(),
  is_stroke_dashed: z92.boolean().optional()
}).describe("Defines a silkscreen rect on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_circle.ts
import { z as z93 } from "zod";
var pcb_silkscreen_circle = z93.object({
  type: z93.literal("pcb_silkscreen_circle"),
  pcb_silkscreen_circle_id: getZodPrefixedIdWithDefault(
    "pcb_silkscreen_circle"
  ),
  pcb_component_id: z93.string(),
  pcb_group_id: z93.string().optional(),
  subcircuit_id: z93.string().optional(),
  center: point,
  radius: length,
  layer: visible_layer,
  stroke_width: length.default("1mm")
}).describe("Defines a silkscreen circle on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_oval.ts
import { z as z94 } from "zod";
var pcb_silkscreen_oval = z94.object({
  type: z94.literal("pcb_silkscreen_oval"),
  pcb_silkscreen_oval_id: getZodPrefixedIdWithDefault("pcb_silkscreen_oval"),
  pcb_component_id: z94.string(),
  pcb_group_id: z94.string().optional(),
  subcircuit_id: z94.string().optional(),
  center: point,
  radius_x: distance,
  radius_y: distance,
  layer: visible_layer
}).describe("Defines a silkscreen oval on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_fabrication_note_text.ts
import { z as z95 } from "zod";
var pcb_fabrication_note_text = z95.object({
  type: z95.literal("pcb_fabrication_note_text"),
  pcb_fabrication_note_text_id: getZodPrefixedIdWithDefault(
    "pcb_fabrication_note_text"
  ),
  subcircuit_id: z95.string().optional(),
  pcb_group_id: z95.string().optional(),
  font: z95.literal("tscircuit2024").default("tscircuit2024"),
  font_size: distance.default("1mm"),
  pcb_component_id: z95.string(),
  text: z95.string(),
  layer: visible_layer,
  anchor_position: point.default({ x: 0, y: 0 }),
  anchor_alignment: z95.enum(["center", "top_left", "top_right", "bottom_left", "bottom_right"]).default("center"),
  color: z95.string().optional()
}).describe(
  "Defines a fabrication note in text on the PCB, useful for leaving notes for assemblers or fabricators"
);
expectTypesMatch(true);

// src/pcb/pcb_fabrication_note_path.ts
import { z as z96 } from "zod";
var pcb_fabrication_note_path = z96.object({
  type: z96.literal("pcb_fabrication_note_path"),
  pcb_fabrication_note_path_id: getZodPrefixedIdWithDefault(
    "pcb_fabrication_note_path"
  ),
  pcb_component_id: z96.string(),
  subcircuit_id: z96.string().optional(),
  layer: layer_ref,
  route: z96.array(point),
  stroke_width: length,
  color: z96.string().optional()
}).describe(
  "Defines a fabrication path on the PCB for fabricators or assemblers"
);
expectTypesMatch(true);

// src/pcb/pcb_fabrication_note_rect.ts
import { z as z97 } from "zod";
var pcb_fabrication_note_rect = z97.object({
  type: z97.literal("pcb_fabrication_note_rect"),
  pcb_fabrication_note_rect_id: getZodPrefixedIdWithDefault(
    "pcb_fabrication_note_rect"
  ),
  pcb_component_id: z97.string(),
  pcb_group_id: z97.string().optional(),
  subcircuit_id: z97.string().optional(),
  center: point,
  width: length,
  height: length,
  layer: visible_layer,
  stroke_width: length.default("0.1mm"),
  corner_radius: length.optional(),
  is_filled: z97.boolean().optional(),
  has_stroke: z97.boolean().optional(),
  is_stroke_dashed: z97.boolean().optional(),
  color: z97.string().optional()
}).describe("Defines a fabrication note rectangle on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_fabrication_note_dimension.ts
import { z as z98 } from "zod";
var pcb_fabrication_note_dimension = z98.object({
  type: z98.literal("pcb_fabrication_note_dimension"),
  pcb_fabrication_note_dimension_id: getZodPrefixedIdWithDefault(
    "pcb_fabrication_note_dimension"
  ),
  pcb_component_id: z98.string(),
  pcb_group_id: z98.string().optional(),
  subcircuit_id: z98.string().optional(),
  layer: visible_layer,
  from: point,
  to: point,
  text: z98.string().optional(),
  text_ccw_rotation: z98.number().optional(),
  offset: length.optional(),
  offset_distance: length.optional(),
  offset_direction: z98.object({
    x: z98.number(),
    y: z98.number()
  }).optional(),
  font: z98.literal("tscircuit2024").default("tscircuit2024"),
  font_size: length.default("1mm"),
  color: z98.string().optional(),
  arrow_size: length.default("1mm")
}).describe("Defines a measurement annotation within PCB fabrication notes");
expectTypesMatch(true);

// src/pcb/pcb_note_text.ts
import { z as z99 } from "zod";
var pcb_note_text = z99.object({
  type: z99.literal("pcb_note_text"),
  pcb_note_text_id: getZodPrefixedIdWithDefault("pcb_note_text"),
  pcb_component_id: z99.string().optional(),
  pcb_group_id: z99.string().optional(),
  subcircuit_id: z99.string().optional(),
  name: z99.string().optional(),
  font: z99.literal("tscircuit2024").default("tscircuit2024"),
  font_size: distance.default("1mm"),
  text: z99.string().optional(),
  anchor_position: point.default({ x: 0, y: 0 }),
  anchor_alignment: z99.enum(["center", "top_left", "top_right", "bottom_left", "bottom_right"]).default("center"),
  color: z99.string().optional()
}).describe("Defines a documentation note in text on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_note_rect.ts
import { z as z100 } from "zod";
var pcb_note_rect = z100.object({
  type: z100.literal("pcb_note_rect"),
  pcb_note_rect_id: getZodPrefixedIdWithDefault("pcb_note_rect"),
  pcb_component_id: z100.string().optional(),
  pcb_group_id: z100.string().optional(),
  subcircuit_id: z100.string().optional(),
  name: z100.string().optional(),
  text: z100.string().optional(),
  center: point,
  width: length,
  height: length,
  stroke_width: length.default("0.1mm"),
  corner_radius: length.optional(),
  is_filled: z100.boolean().optional(),
  has_stroke: z100.boolean().optional(),
  is_stroke_dashed: z100.boolean().optional(),
  color: z100.string().optional()
}).describe("Defines a rectangular documentation note on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_note_path.ts
import { z as z101 } from "zod";
var pcb_note_path = z101.object({
  type: z101.literal("pcb_note_path"),
  pcb_note_path_id: getZodPrefixedIdWithDefault("pcb_note_path"),
  pcb_component_id: z101.string().optional(),
  pcb_group_id: z101.string().optional(),
  subcircuit_id: z101.string().optional(),
  name: z101.string().optional(),
  text: z101.string().optional(),
  route: z101.array(point),
  stroke_width: length.default("0.1mm"),
  color: z101.string().optional()
}).describe("Defines a polyline documentation note on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_note_line.ts
import { z as z102 } from "zod";
var pcb_note_line = z102.object({
  type: z102.literal("pcb_note_line"),
  pcb_note_line_id: getZodPrefixedIdWithDefault("pcb_note_line"),
  pcb_component_id: z102.string().optional(),
  pcb_group_id: z102.string().optional(),
  subcircuit_id: z102.string().optional(),
  name: z102.string().optional(),
  text: z102.string().optional(),
  x1: distance,
  y1: distance,
  x2: distance,
  y2: distance,
  stroke_width: distance.default("0.1mm"),
  color: z102.string().optional(),
  is_dashed: z102.boolean().optional()
}).describe("Defines a straight documentation note line on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_note_dimension.ts
import { z as z103 } from "zod";
var pcb_note_dimension = z103.object({
  type: z103.literal("pcb_note_dimension"),
  pcb_note_dimension_id: getZodPrefixedIdWithDefault("pcb_note_dimension"),
  pcb_component_id: z103.string().optional(),
  pcb_group_id: z103.string().optional(),
  subcircuit_id: z103.string().optional(),
  name: z103.string().optional(),
  from: point,
  to: point,
  text: z103.string().optional(),
  text_ccw_rotation: z103.number().optional(),
  offset_distance: length.optional(),
  offset_direction: z103.object({
    x: z103.number(),
    y: z103.number()
  }).optional(),
  font: z103.literal("tscircuit2024").default("tscircuit2024"),
  font_size: length.default("1mm"),
  color: z103.string().optional(),
  arrow_size: length.default("1mm")
}).describe("Defines a measurement annotation within PCB documentation notes");
expectTypesMatch(true);

// src/pcb/pcb_footprint_overlap_error.ts
import { z as z104 } from "zod";
var pcb_footprint_overlap_error = z104.object({
  type: z104.literal("pcb_footprint_overlap_error"),
  pcb_error_id: getZodPrefixedIdWithDefault("pcb_error"),
  error_type: z104.literal("pcb_footprint_overlap_error").default("pcb_footprint_overlap_error"),
  message: z104.string(),
  pcb_smtpad_ids: z104.array(z104.string()).optional(),
  pcb_plated_hole_ids: z104.array(z104.string()).optional(),
  pcb_hole_ids: z104.array(z104.string()).optional(),
  pcb_keepout_ids: z104.array(z104.string()).optional()
}).describe("Error emitted when a pcb footprint overlaps with another element");
expectTypesMatch(
  true
);

// src/pcb/pcb_keepout.ts
import { z as z105 } from "zod";
var pcb_keepout = z105.object({
  type: z105.literal("pcb_keepout"),
  shape: z105.literal("rect"),
  pcb_group_id: z105.string().optional(),
  subcircuit_id: z105.string().optional(),
  center: point,
  width: distance,
  height: distance,
  pcb_keepout_id: z105.string(),
  layers: z105.array(z105.string()),
  // Specify layers where the keepout applies
  description: z105.string().optional()
  // Optional description of the keepout
}).or(
  z105.object({
    type: z105.literal("pcb_keepout"),
    shape: z105.literal("circle"),
    pcb_group_id: z105.string().optional(),
    subcircuit_id: z105.string().optional(),
    center: point,
    radius: distance,
    pcb_keepout_id: z105.string(),
    layers: z105.array(z105.string()),
    // Specify layers where the keepout applies
    description: z105.string().optional()
    // Optional description of the keepout
  })
);
expectTypesMatch(true);

// src/pcb/pcb_cutout.ts
import { z as z106 } from "zod";
var pcb_cutout_base = z106.object({
  type: z106.literal("pcb_cutout"),
  pcb_cutout_id: getZodPrefixedIdWithDefault("pcb_cutout"),
  pcb_group_id: z106.string().optional(),
  subcircuit_id: z106.string().optional(),
  pcb_board_id: z106.string().optional(),
  pcb_panel_id: z106.string().optional()
});
var pcb_cutout_rect = pcb_cutout_base.extend({
  shape: z106.literal("rect"),
  center: point,
  width: length,
  height: length,
  rotation: rotation.optional(),
  corner_radius: length.optional()
});
expectTypesMatch(true);
var pcb_cutout_circle = pcb_cutout_base.extend({
  shape: z106.literal("circle"),
  center: point,
  radius: length
});
expectTypesMatch(true);
var pcb_cutout_polygon = pcb_cutout_base.extend({
  shape: z106.literal("polygon"),
  points: z106.array(point)
});
expectTypesMatch(true);
var pcb_cutout_path = pcb_cutout_base.extend({
  shape: z106.literal("path"),
  route: z106.array(point),
  slot_width: length,
  slot_length: length.optional(),
  space_between_slots: length.optional(),
  slot_corner_radius: length.optional()
});
expectTypesMatch(true);
var pcb_cutout = z106.discriminatedUnion("shape", [
  pcb_cutout_rect,
  pcb_cutout_circle,
  pcb_cutout_polygon,
  pcb_cutout_path
]).describe("Defines a cutout on the PCB, removing board material.");
expectTypesMatch(true);

// src/pcb/pcb_missing_footprint_error.ts
import { z as z107 } from "zod";
var pcb_missing_footprint_error = z107.object({
  type: z107.literal("pcb_missing_footprint_error"),
  pcb_missing_footprint_error_id: getZodPrefixedIdWithDefault(
    "pcb_missing_footprint_error"
  ),
  pcb_group_id: z107.string().optional(),
  subcircuit_id: z107.string().optional(),
  error_type: z107.literal("pcb_missing_footprint_error").default("pcb_missing_footprint_error"),
  source_component_id: z107.string(),
  message: z107.string()
}).describe("Defines a missing footprint error on the PCB");
expectTypesMatch(
  true
);

// src/pcb/external_footprint_load_error.ts
import { z as z108 } from "zod";
var external_footprint_load_error = z108.object({
  type: z108.literal("external_footprint_load_error"),
  external_footprint_load_error_id: getZodPrefixedIdWithDefault(
    "external_footprint_load_error"
  ),
  pcb_component_id: z108.string(),
  source_component_id: z108.string(),
  pcb_group_id: z108.string().optional(),
  subcircuit_id: z108.string().optional(),
  footprinter_string: z108.string().optional(),
  error_type: z108.literal("external_footprint_load_error").default("external_footprint_load_error"),
  message: z108.string()
}).describe("Defines an error when an external footprint fails to load");
expectTypesMatch(true);

// src/pcb/circuit_json_footprint_load_error.ts
import { z as z109 } from "zod";
var circuit_json_footprint_load_error = z109.object({
  type: z109.literal("circuit_json_footprint_load_error"),
  circuit_json_footprint_load_error_id: getZodPrefixedIdWithDefault(
    "circuit_json_footprint_load_error"
  ),
  pcb_component_id: z109.string(),
  source_component_id: z109.string(),
  pcb_group_id: z109.string().optional(),
  subcircuit_id: z109.string().optional(),
  error_type: z109.literal("circuit_json_footprint_load_error").default("circuit_json_footprint_load_error"),
  message: z109.string(),
  circuit_json: z109.array(z109.any()).optional()
}).describe("Defines an error when a circuit JSON footprint fails to load");
expectTypesMatch(true);

// src/pcb/pcb_group.ts
import { z as z110 } from "zod";
var pcb_group = z110.object({
  type: z110.literal("pcb_group"),
  pcb_group_id: getZodPrefixedIdWithDefault("pcb_group"),
  source_group_id: z110.string(),
  is_subcircuit: z110.boolean().optional(),
  subcircuit_id: z110.string().optional(),
  width: length.optional(),
  height: length.optional(),
  center: point,
  outline: z110.array(point).optional(),
  anchor_position: point.optional(),
  anchor_alignment: z110.enum(["center", "top_left", "top_right", "bottom_left", "bottom_right"]).optional(),
  pcb_component_ids: z110.array(z110.string()),
  child_layout_mode: z110.enum(["packed", "none"]).optional(),
  name: z110.string().optional(),
  description: z110.string().optional(),
  layout_mode: z110.string().optional(),
  autorouter_configuration: z110.object({
    trace_clearance: length
  }).optional(),
  autorouter_used_string: z110.string().optional()
}).describe("Defines a group of components on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_autorouting_error.ts
import { z as z111 } from "zod";
var pcb_autorouting_error = z111.object({
  type: z111.literal("pcb_autorouting_error"),
  pcb_error_id: getZodPrefixedIdWithDefault("pcb_autorouting_error"),
  error_type: z111.literal("pcb_autorouting_error").default("pcb_autorouting_error"),
  message: z111.string(),
  subcircuit_id: z111.string().optional()
}).describe("The autorouting has failed to route a portion of the board");
expectTypesMatch(true);

// src/pcb/pcb_manual_edit_conflict_warning.ts
import { z as z112 } from "zod";
var pcb_manual_edit_conflict_warning = z112.object({
  type: z112.literal("pcb_manual_edit_conflict_warning"),
  pcb_manual_edit_conflict_warning_id: getZodPrefixedIdWithDefault(
    "pcb_manual_edit_conflict_warning"
  ),
  warning_type: z112.literal("pcb_manual_edit_conflict_warning").default("pcb_manual_edit_conflict_warning"),
  message: z112.string(),
  pcb_component_id: z112.string(),
  pcb_group_id: z112.string().optional(),
  subcircuit_id: z112.string().optional(),
  source_component_id: z112.string()
}).describe(
  "Warning emitted when a component has both manual placement and explicit pcbX/pcbY coordinates"
);
expectTypesMatch(true);

// src/pcb/pcb_breakout_point.ts
import { z as z113 } from "zod";
var pcb_breakout_point = z113.object({
  type: z113.literal("pcb_breakout_point"),
  pcb_breakout_point_id: getZodPrefixedIdWithDefault("pcb_breakout_point"),
  pcb_group_id: z113.string(),
  subcircuit_id: z113.string().optional(),
  source_trace_id: z113.string().optional(),
  source_port_id: z113.string().optional(),
  source_net_id: z113.string().optional(),
  x: distance,
  y: distance
}).describe(
  "Defines a routing target within a pcb_group for a source_trace or source_net"
);
expectTypesMatch(true);

// src/pcb/pcb_ground_plane.ts
import { z as z114 } from "zod";
var pcb_ground_plane = z114.object({
  type: z114.literal("pcb_ground_plane"),
  pcb_ground_plane_id: getZodPrefixedIdWithDefault("pcb_ground_plane"),
  source_pcb_ground_plane_id: z114.string(),
  source_net_id: z114.string(),
  pcb_group_id: z114.string().optional(),
  subcircuit_id: z114.string().optional()
}).describe("Defines a ground plane on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_ground_plane_region.ts
import { z as z115 } from "zod";
var pcb_ground_plane_region = z115.object({
  type: z115.literal("pcb_ground_plane_region"),
  pcb_ground_plane_region_id: getZodPrefixedIdWithDefault(
    "pcb_ground_plane_region"
  ),
  pcb_ground_plane_id: z115.string(),
  pcb_group_id: z115.string().optional(),
  subcircuit_id: z115.string().optional(),
  layer: layer_ref,
  points: z115.array(point)
}).describe("Defines a polygon region of a ground plane");
expectTypesMatch(true);

// src/pcb/pcb_thermal_spoke.ts
import { z as z116 } from "zod";
var pcb_thermal_spoke = z116.object({
  type: z116.literal("pcb_thermal_spoke"),
  pcb_thermal_spoke_id: getZodPrefixedIdWithDefault("pcb_thermal_spoke"),
  pcb_ground_plane_id: z116.string(),
  shape: z116.string(),
  spoke_count: z116.number(),
  spoke_thickness: distance,
  spoke_inner_diameter: distance,
  spoke_outer_diameter: distance,
  pcb_plated_hole_id: z116.string().optional(),
  subcircuit_id: z116.string().optional()
}).describe("Pattern for connecting a ground plane to a plated hole");
expectTypesMatch(true);

// src/pcb/pcb_copper_pour.ts
import { z as z117 } from "zod";
var pcb_copper_pour_base = z117.object({
  type: z117.literal("pcb_copper_pour"),
  pcb_copper_pour_id: getZodPrefixedIdWithDefault("pcb_copper_pour"),
  pcb_group_id: z117.string().optional(),
  subcircuit_id: z117.string().optional(),
  layer: layer_ref,
  source_net_id: z117.string().optional(),
  covered_with_solder_mask: z117.boolean().optional().default(true)
});
var pcb_copper_pour_rect = pcb_copper_pour_base.extend({
  shape: z117.literal("rect"),
  center: point,
  width: length,
  height: length,
  rotation: rotation.optional()
});
expectTypesMatch(true);
var pcb_copper_pour_brep = pcb_copper_pour_base.extend({
  shape: z117.literal("brep"),
  brep_shape
});
expectTypesMatch(true);
var pcb_copper_pour_polygon = pcb_copper_pour_base.extend({
  shape: z117.literal("polygon"),
  points: z117.array(point)
});
expectTypesMatch(true);
var pcb_copper_pour = z117.discriminatedUnion("shape", [
  pcb_copper_pour_rect,
  pcb_copper_pour_brep,
  pcb_copper_pour_polygon
]).describe("Defines a copper pour on the PCB.");
expectTypesMatch(true);

// src/pcb/pcb_component_outside_board_error.ts
import { z as z118 } from "zod";
var pcb_component_outside_board_error = z118.object({
  type: z118.literal("pcb_component_outside_board_error"),
  pcb_component_outside_board_error_id: getZodPrefixedIdWithDefault(
    "pcb_component_outside_board_error"
  ),
  error_type: z118.literal("pcb_component_outside_board_error").default("pcb_component_outside_board_error"),
  message: z118.string(),
  pcb_component_id: z118.string(),
  pcb_board_id: z118.string(),
  component_center: point,
  component_bounds: z118.object({
    min_x: z118.number(),
    max_x: z118.number(),
    min_y: z118.number(),
    max_y: z118.number()
  }),
  subcircuit_id: z118.string().optional(),
  source_component_id: z118.string().optional()
}).describe(
  "Error emitted when a PCB component is placed outside the board boundaries"
);
expectTypesMatch(true);

// src/pcb/pcb_component_invalid_layer_error.ts
import { z as z119 } from "zod";
var pcb_component_invalid_layer_error = z119.object({
  type: z119.literal("pcb_component_invalid_layer_error"),
  pcb_component_invalid_layer_error_id: getZodPrefixedIdWithDefault(
    "pcb_component_invalid_layer_error"
  ),
  error_type: z119.literal("pcb_component_invalid_layer_error").default("pcb_component_invalid_layer_error"),
  message: z119.string(),
  pcb_component_id: z119.string().optional(),
  source_component_id: z119.string(),
  layer: layer_ref,
  subcircuit_id: z119.string().optional()
}).describe(
  "Error emitted when a component is placed on an invalid layer (components can only be on 'top' or 'bottom' layers)"
);
expectTypesMatch(true);

// src/pcb/pcb_via_clearance_error.ts
import { z as z120 } from "zod";
var pcb_via_clearance_error = z120.object({
  type: z120.literal("pcb_via_clearance_error"),
  pcb_error_id: getZodPrefixedIdWithDefault("pcb_error"),
  error_type: z120.literal("pcb_via_clearance_error").default("pcb_via_clearance_error"),
  message: z120.string(),
  pcb_via_ids: z120.array(z120.string()).min(2),
  minimum_clearance: distance.optional(),
  actual_clearance: distance.optional(),
  pcb_center: z120.object({
    x: z120.number().optional(),
    y: z120.number().optional()
  }).optional(),
  subcircuit_id: z120.string().optional()
}).describe("Error emitted when vias are closer than the allowed clearance");
expectTypesMatch(true);

// src/pcb/pcb_courtyard_rect.ts
import { z as z121 } from "zod";
var pcb_courtyard_rect = z121.object({
  type: z121.literal("pcb_courtyard_rect"),
  pcb_courtyard_rect_id: getZodPrefixedIdWithDefault("pcb_courtyard_rect"),
  pcb_component_id: z121.string(),
  pcb_group_id: z121.string().optional(),
  subcircuit_id: z121.string().optional(),
  center: point,
  width: length,
  height: length,
  layer: visible_layer,
  color: z121.string().optional()
}).describe("Defines a courtyard rectangle on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_courtyard_outline.ts
import { z as z122 } from "zod";
var pcb_courtyard_outline = z122.object({
  type: z122.literal("pcb_courtyard_outline"),
  pcb_courtyard_outline_id: getZodPrefixedIdWithDefault(
    "pcb_courtyard_outline"
  ),
  pcb_component_id: z122.string(),
  pcb_group_id: z122.string().optional(),
  subcircuit_id: z122.string().optional(),
  layer: visible_layer,
  outline: z122.array(point).min(2),
  stroke_width: length.default("0.1mm"),
  is_closed: z122.boolean().optional(),
  is_stroke_dashed: z122.boolean().optional(),
  color: z122.string().optional()
}).describe("Defines a courtyard outline on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_courtyard_polygon.ts
import { z as z123 } from "zod";
var pcb_courtyard_polygon = z123.object({
  type: z123.literal("pcb_courtyard_polygon"),
  pcb_courtyard_polygon_id: getZodPrefixedIdWithDefault(
    "pcb_courtyard_polygon"
  ),
  pcb_component_id: z123.string(),
  pcb_group_id: z123.string().optional(),
  subcircuit_id: z123.string().optional(),
  layer: visible_layer,
  points: z123.array(point).min(3),
  color: z123.string().optional()
}).describe("Defines a courtyard polygon on the PCB");
expectTypesMatch(true);

// src/cad/cad_component.ts
import { z as z124 } from "zod";
var cad_component = z124.object({
  type: z124.literal("cad_component"),
  cad_component_id: z124.string(),
  pcb_component_id: z124.string(),
  source_component_id: z124.string(),
  position: point3,
  rotation: point3.optional(),
  size: point3.optional(),
  layer: layer_ref.optional(),
  subcircuit_id: z124.string().optional(),
  // These are all ways to generate/load the 3d model
  footprinter_string: z124.string().optional(),
  model_obj_url: z124.string().optional(),
  model_stl_url: z124.string().optional(),
  model_3mf_url: z124.string().optional(),
  model_gltf_url: z124.string().optional(),
  model_glb_url: z124.string().optional(),
  model_step_url: z124.string().optional(),
  model_wrl_url: z124.string().optional(),
  model_unit_to_mm_scale_factor: z124.number().optional(),
  model_jscad: z124.any().optional()
}).describe("Defines a component on the PCB");
expectTypesMatch(true);

// src/simulation/simulation_voltage_source.ts
import { z as z125 } from "zod";
var wave_shape = z125.enum(["sinewave", "square", "triangle", "sawtooth"]);
var percentage = z125.union([z125.string(), z125.number()]).transform((val) => {
  if (typeof val === "string") {
    if (val.endsWith("%")) {
      return parseFloat(val.slice(0, -1)) / 100;
    }
    return parseFloat(val);
  }
  return val;
}).pipe(
  z125.number().min(0, "Duty cycle must be non-negative").max(1, "Duty cycle cannot be greater than 100%")
);
var simulation_dc_voltage_source = z125.object({
  type: z125.literal("simulation_voltage_source"),
  simulation_voltage_source_id: getZodPrefixedIdWithDefault(
    "simulation_voltage_source"
  ),
  is_dc_source: z125.literal(true).optional().default(true),
  positive_source_port_id: z125.string().optional(),
  negative_source_port_id: z125.string().optional(),
  positive_source_net_id: z125.string().optional(),
  negative_source_net_id: z125.string().optional(),
  voltage
}).describe("Defines a DC voltage source for simulation");
var simulation_ac_voltage_source = z125.object({
  type: z125.literal("simulation_voltage_source"),
  simulation_voltage_source_id: getZodPrefixedIdWithDefault(
    "simulation_voltage_source"
  ),
  is_dc_source: z125.literal(false),
  terminal1_source_port_id: z125.string().optional(),
  terminal2_source_port_id: z125.string().optional(),
  terminal1_source_net_id: z125.string().optional(),
  terminal2_source_net_id: z125.string().optional(),
  voltage: voltage.optional(),
  frequency: frequency.optional(),
  peak_to_peak_voltage: voltage.optional(),
  wave_shape: wave_shape.optional(),
  phase: rotation.optional(),
  duty_cycle: percentage.optional()
}).describe("Defines an AC voltage source for simulation");
var simulation_voltage_source = z125.union([simulation_dc_voltage_source, simulation_ac_voltage_source]).describe("Defines a voltage source for simulation");
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);

// src/simulation/simulation_experiment.ts
import { z as z126 } from "zod";
var experiment_type = z126.union([
  z126.literal("spice_dc_sweep"),
  z126.literal("spice_dc_operating_point"),
  z126.literal("spice_transient_analysis"),
  z126.literal("spice_ac_analysis")
]);
var simulation_experiment = z126.object({
  type: z126.literal("simulation_experiment"),
  simulation_experiment_id: getZodPrefixedIdWithDefault(
    "simulation_experiment"
  ),
  name: z126.string(),
  experiment_type,
  time_per_step: duration_ms.optional(),
  start_time_ms: ms.optional(),
  end_time_ms: ms.optional()
}).describe("Defines a simulation experiment configuration");
expectTypesMatch(true);

// src/simulation/simulation_transient_voltage_graph.ts
import { z as z127 } from "zod";
var simulation_transient_voltage_graph = z127.object({
  type: z127.literal("simulation_transient_voltage_graph"),
  simulation_transient_voltage_graph_id: getZodPrefixedIdWithDefault(
    "simulation_transient_voltage_graph"
  ),
  simulation_experiment_id: z127.string(),
  timestamps_ms: z127.array(z127.number()).optional(),
  voltage_levels: z127.array(z127.number()),
  source_component_id: z127.string().optional(),
  subcircuit_connectivity_map_key: z127.string().optional(),
  time_per_step: duration_ms,
  start_time_ms: ms,
  end_time_ms: ms,
  name: z127.string().optional(),
  color: z127.string().optional()
}).describe("Stores voltage measurements over time for a simulation");
expectTypesMatch(true);

// src/simulation/simulation_switch.ts
import { z as z128 } from "zod";
var simulation_switch = z128.object({
  type: z128.literal("simulation_switch"),
  simulation_switch_id: getZodPrefixedIdWithDefault("simulation_switch"),
  source_component_id: z128.string().optional(),
  closes_at: ms.optional(),
  opens_at: ms.optional(),
  starts_closed: z128.boolean().optional(),
  switching_frequency: frequency.optional()
}).describe("Defines a switch for simulation timing control");
expectTypesMatch(true);

// src/simulation/simulation_voltage_probe.ts
import { z as z129 } from "zod";
var simulation_voltage_probe = z129.object({
  type: z129.literal("simulation_voltage_probe"),
  simulation_voltage_probe_id: getZodPrefixedIdWithDefault(
    "simulation_voltage_probe"
  ),
  source_component_id: z129.string().optional(),
  name: z129.string().optional(),
  source_port_id: z129.string().optional(),
  source_net_id: z129.string().optional(),
  subcircuit_id: z129.string().optional(),
  color: z129.string().optional()
}).describe(
  "Defines a voltage probe for simulation, connected to a port or a net"
).refine(
  (data) => Boolean(data.source_port_id) !== Boolean(data.source_net_id),
  {
    message: "Exactly one of source_port_id or source_net_id must be provided to simulation_voltage_probe"
  }
);
expectTypesMatch(true);

// src/simulation/simulation_unknown_experiment_error.ts
import { z as z130 } from "zod";
var simulation_unknown_experiment_error = z130.object({
  type: z130.literal("simulation_unknown_experiment_error"),
  simulation_unknown_experiment_error_id: getZodPrefixedIdWithDefault(
    "simulation_unknown_experiment_error"
  ),
  error_type: z130.literal("simulation_unknown_experiment_error").default("simulation_unknown_experiment_error"),
  message: z130.string(),
  simulation_experiment_id: z130.string().optional(),
  subcircuit_id: z130.string().optional()
}).describe("An unknown error occurred during the simulation experiment.");
expectTypesMatch(true);

// src/any_circuit_element.ts
import { z as z131 } from "zod";
var any_circuit_element = z131.union([
  source_trace,
  source_port,
  any_source_component,
  source_net,
  source_group,
  source_simple_chip,
  source_simple_capacitor,
  source_simple_diode,
  source_simple_led,
  source_simple_resistor,
  source_simple_power_source,
  source_simple_battery,
  source_simple_inductor,
  source_simple_pin_header,
  source_simple_pinout,
  source_simple_resonator,
  source_simple_switch,
  source_simple_transistor,
  source_simple_test_point,
  source_simple_mosfet,
  source_simple_potentiometer,
  source_simple_push_button,
  source_pcb_ground_plane,
  source_manually_placed_via,
  source_board,
  source_project_metadata,
  source_trace_not_connected_error,
  source_pin_missing_trace_warning,
  unknown_error_finding_part,
  pcb_component,
  pcb_hole,
  pcb_missing_footprint_error,
  external_footprint_load_error,
  circuit_json_footprint_load_error,
  pcb_manual_edit_conflict_warning,
  pcb_plated_hole,
  pcb_keepout,
  pcb_port,
  pcb_net,
  pcb_text,
  pcb_trace,
  pcb_via,
  pcb_smtpad,
  pcb_solder_paste,
  pcb_board,
  pcb_panel,
  pcb_group,
  pcb_trace_hint,
  pcb_silkscreen_line,
  pcb_silkscreen_path,
  pcb_silkscreen_text,
  pcb_copper_text,
  pcb_silkscreen_rect,
  pcb_silkscreen_circle,
  pcb_silkscreen_oval,
  pcb_trace_error,
  pcb_trace_missing_error,
  pcb_placement_error,
  pcb_port_not_matched_error,
  pcb_port_not_connected_error,
  pcb_via_clearance_error,
  pcb_fabrication_note_path,
  pcb_fabrication_note_text,
  pcb_fabrication_note_rect,
  pcb_fabrication_note_dimension,
  pcb_note_text,
  pcb_note_rect,
  pcb_note_path,
  pcb_note_line,
  pcb_note_dimension,
  pcb_autorouting_error,
  pcb_footprint_overlap_error,
  pcb_breakout_point,
  pcb_cutout,
  pcb_ground_plane,
  pcb_ground_plane_region,
  pcb_thermal_spoke,
  pcb_copper_pour,
  pcb_component_outside_board_error,
  pcb_component_invalid_layer_error,
  pcb_courtyard_rect,
  pcb_courtyard_outline,
  pcb_courtyard_polygon,
  schematic_box,
  schematic_text,
  schematic_line,
  schematic_rect,
  schematic_circle,
  schematic_arc,
  schematic_component,
  schematic_port,
  schematic_trace,
  schematic_path,
  schematic_error,
  schematic_layout_error,
  schematic_net_label,
  schematic_debug_object,
  schematic_voltage_probe,
  schematic_manual_edit_conflict_warning,
  schematic_group,
  schematic_sheet,
  schematic_table,
  schematic_table_cell,
  cad_component,
  simulation_voltage_source,
  simulation_experiment,
  simulation_transient_voltage_graph,
  simulation_switch,
  simulation_voltage_probe,
  simulation_unknown_experiment_error
]);
var any_soup_element = any_circuit_element;
expectTypesMatch(true);
expectStringUnionsMatch(true);
export {
  all_layers,
  any_circuit_element,
  any_soup_element,
  any_source_component,
  battery_capacity,
  brep_shape,
  cad_component,
  capacitance,
  circuit_json_footprint_load_error,
  current,
  distance,
  duration_ms,
  experiment_type,
  external_footprint_load_error,
  frequency,
  getZodPrefixedIdWithDefault,
  inductance,
  layer_ref,
  layer_string,
  length,
  ms,
  ninePointAnchor,
  pcb_autorouting_error,
  pcb_board,
  pcb_breakout_point,
  pcb_component,
  pcb_component_invalid_layer_error,
  pcb_component_outside_board_error,
  pcb_copper_pour,
  pcb_copper_pour_brep,
  pcb_copper_pour_polygon,
  pcb_copper_pour_rect,
  pcb_copper_text,
  pcb_courtyard_outline,
  pcb_courtyard_polygon,
  pcb_courtyard_rect,
  pcb_cutout,
  pcb_cutout_circle,
  pcb_cutout_path,
  pcb_cutout_polygon,
  pcb_cutout_rect,
  pcb_fabrication_note_dimension,
  pcb_fabrication_note_path,
  pcb_fabrication_note_rect,
  pcb_fabrication_note_text,
  pcb_footprint_overlap_error,
  pcb_ground_plane,
  pcb_ground_plane_region,
  pcb_group,
  pcb_hole,
  pcb_hole_circle_or_square_shape,
  pcb_hole_circle_shape,
  pcb_hole_oval_shape,
  pcb_hole_pill_shape,
  pcb_hole_rect_shape,
  pcb_hole_rotated_pill_shape,
  pcb_keepout,
  pcb_manual_edit_conflict_warning,
  pcb_missing_footprint_error,
  pcb_net,
  pcb_note_dimension,
  pcb_note_line,
  pcb_note_path,
  pcb_note_rect,
  pcb_note_text,
  pcb_panel,
  pcb_placement_error,
  pcb_plated_hole,
  pcb_port,
  pcb_port_not_connected_error,
  pcb_port_not_matched_error,
  pcb_route_hint,
  pcb_route_hints,
  pcb_silkscreen_circle,
  pcb_silkscreen_line,
  pcb_silkscreen_oval,
  pcb_silkscreen_path,
  pcb_silkscreen_rect,
  pcb_silkscreen_text,
  pcb_smtpad,
  pcb_smtpad_pill,
  pcb_solder_paste,
  pcb_text,
  pcb_thermal_spoke,
  pcb_trace,
  pcb_trace_error,
  pcb_trace_hint,
  pcb_trace_missing_error,
  pcb_trace_route_point,
  pcb_trace_route_point_via,
  pcb_trace_route_point_wire,
  pcb_via,
  pcb_via_clearance_error,
  point,
  point3,
  point_with_bulge,
  port_arrangement,
  position,
  position3,
  resistance,
  ring,
  rotation,
  route_hint_point,
  schematic_arc,
  schematic_box,
  schematic_circle,
  schematic_component,
  schematic_component_port_arrangement_by_sides,
  schematic_component_port_arrangement_by_size,
  schematic_debug_line,
  schematic_debug_object,
  schematic_debug_object_base,
  schematic_debug_point,
  schematic_debug_rect,
  schematic_error,
  schematic_group,
  schematic_layout_error,
  schematic_line,
  schematic_manual_edit_conflict_warning,
  schematic_net_label,
  schematic_path,
  schematic_pin_styles,
  schematic_port,
  schematic_rect,
  schematic_sheet,
  schematic_table,
  schematic_table_cell,
  schematic_text,
  schematic_trace,
  schematic_voltage_probe,
  simulation_ac_voltage_source,
  simulation_dc_voltage_source,
  simulation_experiment,
  simulation_switch,
  simulation_transient_voltage_graph,
  simulation_unknown_experiment_error,
  simulation_voltage_probe,
  simulation_voltage_source,
  size,
  source_board,
  source_component_base,
  source_failed_to_create_component_error,
  source_group,
  source_manually_placed_via,
  source_missing_property_error,
  source_net,
  source_pcb_ground_plane,
  source_pin_missing_trace_warning,
  source_port,
  source_project_metadata,
  source_property_ignored_warning,
  source_simple_battery,
  source_simple_capacitor,
  source_simple_chip,
  source_simple_crystal,
  source_simple_diode,
  source_simple_ground,
  source_simple_inductor,
  source_simple_led,
  source_simple_mosfet,
  source_simple_pin_header,
  source_simple_pinout,
  source_simple_potentiometer,
  source_simple_power_source,
  source_simple_push_button,
  source_simple_resistor,
  source_simple_resonator,
  source_simple_switch,
  source_simple_test_point,
  source_simple_transistor,
  source_simple_voltage_probe,
  source_trace,
  source_trace_not_connected_error,
  supplier_name,
  time,
  timestamp,
  unknown_error_finding_part,
  visible_layer,
  voltage,
  wave_shape
};
//# sourceMappingURL=index.mjs.map