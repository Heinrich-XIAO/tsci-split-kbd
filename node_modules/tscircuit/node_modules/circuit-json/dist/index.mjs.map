{"version":3,"sources":["../src/utils/convert-si-unit-to-number.ts","../src/units/index.ts","../src/common/point.ts","../src/utils/expect-types-match.ts","../src/common/point3.ts","../src/common/size.ts","../src/common/getZodPrefixedIdWithDefault.ts","../src/common/NinePointAnchor.ts","../src/source/source_simple_capacitor.ts","../src/pcb/properties/supplier_name.ts","../src/source/base/source_component_base.ts","../src/source/source_simple_resistor.ts","../src/source/source_simple_diode.ts","../src/source/source_simple_led.ts","../src/source/source_simple_ground.ts","../src/source/source_simple_chip.ts","../src/source/source_simple_power_source.ts","../src/source/any_source_component.ts","../src/source/source_simple_fuse.ts","../src/source/source_simple_battery.ts","../src/source/source_simple_inductor.ts","../src/source/source_simple_push_button.ts","../src/source/source_simple_potentiometer.ts","../src/source/source_simple_crystal.ts","../src/source/source_simple_pin_header.ts","../src/source/source_simple_pinout.ts","../src/source/source_simple_resonator.ts","../src/source/source_simple_transistor.ts","../src/source/source_simple_test_point.ts","../src/source/source_simple_mosfet.ts","../src/source/source_simple_switch.ts","../src/source/source_project_metadata.ts","../src/source/source_missing_property_error.ts","../src/source/source_failed_to_create_component_error.ts","../src/source/source_trace_not_connected_error.ts","../src/source/source_property_ignored_warning.ts","../src/source/source_pin_missing_trace_warning.ts","../src/source/source_simple_voltage_probe.ts","../src/source/source_port.ts","../src/source/source_trace.ts","../src/source/source_group.ts","../src/source/source_net.ts","../src/source/source_board.ts","../src/source/source_pcb_ground_plane.ts","../src/source/source_manually_placed_via.ts","../src/pcb/properties/layer_ref.ts","../src/source/unknown_error_finding_part.ts","../src/schematic/schematic_box.ts","../src/schematic/schematic_path.ts","../src/schematic/schematic_component.ts","../src/schematic/schematic_line.ts","../src/schematic/schematic_rect.ts","../src/schematic/schematic_circle.ts","../src/schematic/schematic_arc.ts","../src/schematic/schematic_trace.ts","../src/schematic/schematic_text.ts","../src/common/FivePointAnchor.ts","../src/schematic/schematic_port.ts","../src/schematic/schematic_net_label.ts","../src/schematic/schematic_error.ts","../src/schematic/schematic_layout_error.ts","../src/schematic/schematic_debug_object.ts","../src/schematic/schematic_voltage_probe.ts","../src/schematic/schematic_manual_edit_conflict_warning.ts","../src/schematic/schematic_group.ts","../src/schematic/schematic_table.ts","../src/schematic/schematic_table_cell.ts","../src/schematic/schematic_sheet.ts","../src/pcb/properties/brep.ts","../src/pcb/properties/pcb_route_hints.ts","../src/pcb/properties/route_hint_point.ts","../src/pcb/pcb_component.ts","../src/pcb/pcb_hole.ts","../src/pcb/pcb_plated_hole.ts","../src/pcb/pcb_port.ts","../src/pcb/pcb_smtpad.ts","../src/pcb/pcb_solder_paste.ts","../src/pcb/pcb_text.ts","../src/pcb/pcb_trace.ts","../src/pcb/pcb_trace_error.ts","../src/pcb/pcb_trace_missing_error.ts","../src/pcb/pcb_port_not_matched_error.ts","../src/pcb/pcb_port_not_connected_error.ts","../src/pcb/pcb_net.ts","../src/pcb/pcb_via.ts","../src/pcb/pcb_board.ts","../src/pcb/pcb_panel.ts","../src/pcb/pcb_placement_error.ts","../src/pcb/pcb_trace_hint.ts","../src/pcb/pcb_silkscreen_line.ts","../src/pcb/pcb_silkscreen_path.ts","../src/pcb/pcb_silkscreen_text.ts","../src/pcb/pcb_copper_text.ts","../src/pcb/pcb_silkscreen_rect.ts","../src/pcb/pcb_silkscreen_circle.ts","../src/pcb/pcb_silkscreen_oval.ts","../src/pcb/pcb_fabrication_note_text.ts","../src/pcb/pcb_fabrication_note_path.ts","../src/pcb/pcb_fabrication_note_rect.ts","../src/pcb/pcb_fabrication_note_dimension.ts","../src/pcb/pcb_note_text.ts","../src/pcb/pcb_note_rect.ts","../src/pcb/pcb_note_path.ts","../src/pcb/pcb_note_line.ts","../src/pcb/pcb_note_dimension.ts","../src/pcb/pcb_footprint_overlap_error.ts","../src/pcb/pcb_keepout.ts","../src/pcb/pcb_cutout.ts","../src/pcb/pcb_missing_footprint_error.ts","../src/pcb/external_footprint_load_error.ts","../src/pcb/circuit_json_footprint_load_error.ts","../src/pcb/pcb_group.ts","../src/pcb/pcb_autorouting_error.ts","../src/pcb/pcb_manual_edit_conflict_warning.ts","../src/pcb/pcb_breakout_point.ts","../src/pcb/pcb_ground_plane.ts","../src/pcb/pcb_ground_plane_region.ts","../src/pcb/pcb_thermal_spoke.ts","../src/pcb/pcb_copper_pour.ts","../src/pcb/pcb_component_outside_board_error.ts","../src/pcb/pcb_component_invalid_layer_error.ts","../src/pcb/pcb_via_clearance_error.ts","../src/pcb/pcb_courtyard_rect.ts","../src/pcb/pcb_courtyard_outline.ts","../src/pcb/pcb_courtyard_polygon.ts","../src/cad/cad_component.ts","../src/simulation/simulation_voltage_source.ts","../src/simulation/simulation_experiment.ts","../src/simulation/simulation_transient_voltage_graph.ts","../src/simulation/simulation_switch.ts","../src/simulation/simulation_voltage_probe.ts","../src/simulation/simulation_unknown_experiment_error.ts","../src/any_circuit_element.ts"],"sourcesContent":["type UnitInfo = {\n  baseUnit: BaseTscircuitUnit\n  conversionFactor: number\n}\n\nconst unitMappings: Record<\n  string,\n  { baseUnit: BaseTscircuitUnit; variants: Record<string, number> }\n> = {\n  Hz: {\n    baseUnit: \"Hz\",\n    variants: {\n      MHz: 1e6,\n      kHz: 1e3,\n      Hz: 1,\n    },\n  },\n  g: {\n    baseUnit: \"g\",\n    variants: {\n      kg: 1e3,\n      g: 1,\n    },\n  },\n  Ω: {\n    baseUnit: \"Ω\",\n    variants: {\n      mΩ: 1e-3,\n      Ω: 1,\n      kΩ: 1e3,\n      KΩ: 1e3,\n      kohm: 1e3,\n      MΩ: 1e6,\n      GΩ: 1e9,\n      TΩ: 1e12,\n    },\n  },\n  V: {\n    baseUnit: \"V\",\n    variants: {\n      mV: 1e-3,\n      V: 1,\n      kV: 1e3,\n      KV: 1e3,\n      MV: 1e6,\n      GV: 1e9,\n      TV: 1e12,\n    },\n  },\n  A: {\n    baseUnit: \"A\",\n    variants: {\n      µA: 1e-6,\n      mA: 1e-3,\n      ma: 1e-3,\n      A: 1,\n      kA: 1e3,\n      MA: 1e6,\n    },\n  },\n  F: {\n    baseUnit: \"F\",\n    variants: {\n      pF: 1e-12,\n      nF: 1e-9,\n      µF: 1e-6,\n      uF: 1e-6,\n      mF: 1e-3,\n      F: 1,\n    },\n  },\n  ml: {\n    baseUnit: \"ml\",\n    variants: {\n      ml: 1,\n      mL: 1,\n      l: 1e3,\n      L: 1e3,\n    },\n  },\n  deg: {\n    baseUnit: \"deg\",\n    variants: {\n      rad: 180 / Math.PI,\n    },\n  },\n  ms: {\n    baseUnit: \"ms\",\n    variants: {\n      fs: 1e-12,\n      ps: 1e-9,\n      ns: 1e-6,\n      us: 1e-3,\n      µs: 1e-3,\n      ms: 1,\n      s: 1000,\n    },\n  },\n  mm: {\n    baseUnit: \"mm\",\n    variants: {\n      nm: 1e-6,\n      µm: 1e-3,\n      um: 1e-3,\n      mm: 1,\n      cm: 10,\n      dm: 100,\n      m: 1000,\n      km: 1e6,\n      in: 25.4,\n      ft: 304.8,\n      IN: 25.4,\n      FT: 304.8,\n      yd: 914.4,\n      mi: 1.609344e6,\n      mil: 0.0254,\n    },\n  },\n}\n\nconst unitMappingAndVariantSuffixes = new Set()\nfor (const [baseUnit, info] of Object.entries(unitMappings)) {\n  unitMappingAndVariantSuffixes.add(baseUnit)\n  for (const variant of Object.keys(info.variants)) {\n    unitMappingAndVariantSuffixes.add(variant)\n  }\n}\n\nfunction getBaseTscircuitUnit(unit: string): UnitInfo {\n  for (const [baseUnit, info] of Object.entries(unitMappings)) {\n    if (unit in info.variants) {\n      return {\n        baseUnit: info.baseUnit,\n        conversionFactor: info.variants[unit]!,\n      }\n    }\n  }\n  return {\n    baseUnit: unit as BaseTscircuitUnit,\n    conversionFactor: 1,\n  }\n}\n\nconst si_prefix_multiplier = {\n  tera: 1e12,\n  T: 1e12,\n  giga: 1e9,\n  G: 1e9,\n  mega: 1e6,\n  M: 1e6,\n  kilo: 1e3,\n  k: 1e3,\n  deci: 1e-1,\n  d: 1e-1,\n  centi: 1e-2,\n  c: 1e-2,\n  milli: 1e-3,\n  m: 1e-3,\n  micro: 1e-6,\n  u: 1e-6,\n  µ: 1e-6,\n  nano: 1e-9,\n  n: 1e-9,\n  pico: 1e-12,\n  p: 1e-12,\n}\ntype BaseTscircuitUnit =\n  | \"ms\"\n  | \"mm\"\n  | \"g\"\n  | \"deg\"\n  | \"Hz\"\n  | \"ml\"\n  | \"V\"\n  | \"A\"\n  | \"Ω\"\n  | \"F\"\n  | \"H\"\n\nexport function parseAndConvertSiUnit(v: {\n  x: string | number\n  y: string | number\n}): {\n  parsedUnit: string | null\n  unitOfValue: BaseTscircuitUnit | null\n  value: { x: number; y: number } | null\n}\nexport function parseAndConvertSiUnit(v: string | number | undefined | null): {\n  parsedUnit: string | null\n  unitOfValue: BaseTscircuitUnit | null\n  value: number | null\n}\nexport function parseAndConvertSiUnit(\n  v:\n    | string\n    | number\n    | undefined\n    | null\n    | { x: string | number; y: string | number },\n): {\n  parsedUnit: string | null\n  unitOfValue: BaseTscircuitUnit | null\n  value: null | number | { x: number; y: number }\n} {\n  if (v === undefined || v === null)\n    return { parsedUnit: null, unitOfValue: null, value: null }\n  if (typeof v === \"string\" && v.match(/^-?[\\d\\.]+$/))\n    return {\n      value: Number.parseFloat(v),\n      parsedUnit: null,\n      unitOfValue: null,\n    }\n  if (typeof v === \"number\")\n    return { value: v, parsedUnit: null, unitOfValue: null }\n  if (typeof v === \"object\" && \"x\" in v && \"y\" in v) {\n    const { parsedUnit, unitOfValue } = parseAndConvertSiUnit(v.x)\n    const xResult = parseAndConvertSiUnit(v.x)\n    const yResult = parseAndConvertSiUnit(v.y)\n    if (xResult.value === null || yResult.value === null) {\n      return { parsedUnit: null, unitOfValue: null, value: null }\n    }\n    return {\n      parsedUnit: parsedUnit,\n      unitOfValue: unitOfValue,\n      value: {\n        x: xResult.value,\n        y: yResult.value,\n      },\n    }\n  }\n  const reversed_input_string = v.toString().split(\"\").reverse().join(\"\")\n  const unit_reversed = reversed_input_string.match(/[^\\d\\s]+/)?.[0]\n  if (!unit_reversed) {\n    throw new Error(`Could not determine unit: \"${v}\"`)\n  }\n  const unit = unit_reversed.split(\"\").reverse().join(\"\")\n\n  const numberPart = v.slice(0, -unit.length)\n  if (\n    unit in si_prefix_multiplier &&\n    !unitMappingAndVariantSuffixes.has(unit)\n  ) {\n    const siMultiplier =\n      si_prefix_multiplier[unit as keyof typeof si_prefix_multiplier]\n    return {\n      parsedUnit: null,\n      unitOfValue: null,\n      value: Number.parseFloat(numberPart) * siMultiplier,\n    }\n  }\n\n  const { baseUnit, conversionFactor } = getBaseTscircuitUnit(unit)\n\n  return {\n    parsedUnit: unit,\n    unitOfValue: baseUnit,\n    value: conversionFactor * Number.parseFloat(numberPart),\n  }\n}\n","import { parseAndConvertSiUnit } from \"src/utils/convert-si-unit-to-number\"\nimport { z } from \"zod\"\n\n// // Currently, removing uncommon SI Prefixes for type simplicity.\n// export type SIPrefix =\n//   // | \"y\"\n//   // | \"yocto\"\n//   // | \"z\"\n//   // | \"zepto\"\n//   // | \"atto\"\n//   // | \"a\"\n//   | \"femto\"\n//   | \"f\"\n//   | \"u\"\n//   | \"micro\"\n//   // | \"d\"\n//   // | \"deci\"\n//   | \"c\"\n//   | \"centi\"\n//   | \"m\"\n//   | \"milli\"\n//   | \"k\"\n//   | \"kilo\"\n//   | \"M\"\n//   | \"mega\"\n// // | \"G\"\n// // | \"T\"\n// // | \"P\"\n// // | \"E\"\n// // | \"Z\"\n// // | \"Y\"\n\n// export type UnitAbbreviations = {\n//   farad: \"F\"\n//   ohm: \"Ω\"\n//   henry: \"H\"\n//   meter: \"m\"\n//   volt: \"V\"\n//   inch: \"in\"\n//   foot: \"ft\"\n// }\n\n// export type Unit = keyof UnitAbbreviations\n// export type NumberWithUnit<T extends Unit> =\n//   | `${number}${T | UnitAbbreviations[T]}`\n//   | `${number} ${T | UnitAbbreviations[T]}`\n//   | `${number}${SIPrefix}${T | UnitAbbreviations[T]}`\n//   | `${number} ${SIPrefix}${T | UnitAbbreviations[T]}`\n// export type NumberWithAnyUnit =\n//   | `${number}${UnitOrAbbreviation}`\n//   | `${number} ${UnitOrAbbreviation}`\n//   | `${number}${SIPrefix}${UnitOrAbbreviation}`\n//   | `${number} ${SIPrefix}${UnitOrAbbreviation}`\n\n// TODO lots of validation to make sure the unit is valid etc.\nexport const resistance = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\nexport const capacitance = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n  .transform((value) => {\n    return Number.parseFloat(value.toPrecision(12)) // Round to 12 significant digits\n  })\n\nexport const inductance = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\nexport const voltage = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\nexport const length = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\nexport const frequency = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\n/**\n * Length in meters\n */\nexport type Length = number\nexport type Distance = number\n\nexport const distance = length\n\nexport const current = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\nexport const duration_ms = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\nexport const time = duration_ms\n\nexport const ms = duration_ms\n\nexport const timestamp = z.string().datetime()\n\n/**\n * Rotation is always converted to degrees\n */\nexport const rotation = z\n  .string()\n  .or(z.number())\n  .transform((arg): number => {\n    if (typeof arg === \"number\") return arg\n    if (arg.endsWith(\"deg\")) {\n      return Number.parseFloat(arg.split(\"deg\")[0]!)\n    }\n    if (arg.endsWith(\"rad\")) {\n      return (Number.parseFloat(arg.split(\"rad\")[0]!) * 180) / Math.PI\n    }\n    return Number.parseFloat(arg)\n  })\n\nexport const battery_capacity = z\n  .number()\n  .or(z.string().endsWith(\"mAh\"))\n  .transform((v) => {\n    if (typeof v === \"string\") {\n      const valString = v.replace(\"mAh\", \"\")\n      const num = Number.parseFloat(valString)\n      if (Number.isNaN(num)) {\n        throw new Error(\"Invalid capacity\")\n      }\n      return num\n    }\n    return v\n  })\n  .describe(\"Battery capacity in mAh\")\n\nexport type InputRotation = number | string\nexport type Rotation = number\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const point = z.object({\n  x: distance,\n  y: distance,\n})\n\nexport const position = point\n\nexport type InputPoint = z.input<typeof point>\nexport type InputPosition = z.input<typeof position>\ntype InferredPoint = z.infer<typeof point>\ntype InferredPosition = z.infer<typeof position>\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport interface Position {\n  x: number\n  y: number\n}\n\nexpectTypesMatch<Point, InferredPoint>(true)\nexpectTypesMatch<Position, InferredPosition>(true)\n","import type { TypeEqual } from \"ts-expect\"\n\ntype IsNever<T> = [T] extends [never] ? true : false\n\ntype GetMismatchedProps<T1, T2> = {\n  [K in keyof T1 & keyof T2]: T1[K] extends T2[K]\n    ? T2[K] extends T1[K]\n      ? never\n      : K\n    : K\n}[keyof T1 & keyof T2]\n\nexport const expectTypesMatch = <\n  const T1,\n  const T2,\n  T3 = Exclude<keyof T1, keyof T2>,\n  T4 = Exclude<keyof T2, keyof T1>,\n  T5 = GetMismatchedProps<T1, T2>,\n>(\n  shouldBe: IsNever<T3> extends true\n    ? IsNever<T4> extends true\n      ? IsNever<T5> extends true\n        ? TypeEqual<T1, T2>\n        : `mismatched prop types: ${T5 extends string ? T5 : \"\"}`\n      : `extra props ${T4 extends string ? T4 : \"\"}`\n    : `missing props ${T3 extends string ? T3 : \"\"}`,\n): void => {}\n\n// ------ TESTS -------\n\nexpectTypesMatch<\n  {\n    a: number\n  },\n  {\n    a: number\n    b: number\n  }\n>(\"extra props b\")\n\nexpectTypesMatch<\n  {\n    a: number\n    b: number\n  },\n  {\n    a: number\n  }\n>(\"missing props b\")\n\nexpectTypesMatch<\n  {\n    a: number\n  },\n  {\n    a: number\n  }\n>(true)\n\nexpectTypesMatch<\n  {\n    a: number\n  },\n  {\n    a: string\n  }\n>(\"mismatched prop types: a\")\n\n// ------ String Union Matching -------\n\nexport type ExpectStringUnionsMatch<\n  T1 extends string,\n  T2 extends string,\n  Diff1 = Exclude<T1, T2>,\n  Diff2 = Exclude<T2, T1>,\n> = IsNever<Diff1> extends true\n  ? IsNever<Diff2> extends true\n    ? true // Unions are identical\n    : `T2 has extra: \"${Diff2 extends string ? Diff2 : \"\"}\"` // T2 has elements not in T1\n  : IsNever<Diff2> extends true\n    ? `T1 has extra: \"${Diff1 extends string ? Diff1 : \"\"}\"` // T1 has elements not in T2\n    : `T1 has extra: \"${Diff1 extends string\n        ? Diff1\n        : \"\"}\", T2 has extra: \"${Diff2 extends string ? Diff2 : \"\"}\"` // Both have differences\n\nexport const expectStringUnionsMatch = <\n  const T1 extends string,\n  const T2 extends string,\n  ShouldBeTrue = ExpectStringUnionsMatch<T1, T2>,\n>(\n  shouldBe: ShouldBeTrue,\n): void => {}\n\n// ------ TESTS -------\n\ntype TestUnion1 = \"a\" | \"b\" | \"c\"\ntype TestUnion2 = \"a\" | \"b\" | \"c\"\ntype TestUnion3 = \"a\" | \"b\" | \"d\"\ntype TestUnion4 = \"a\" | \"b\"\n\nexpectStringUnionsMatch<TestUnion1, TestUnion2>(true)\nexpectStringUnionsMatch<TestUnion1, TestUnion3>(\n  'T1 has extra: \"c\", T2 has extra: \"d\"',\n)\nexpectStringUnionsMatch<TestUnion1, TestUnion4>('T1 has extra: \"c\"')\nexpectStringUnionsMatch<TestUnion4, TestUnion1>('T2 has extra: \"c\"')\nexpectStringUnionsMatch<TestUnion3, TestUnion1>(\n  'T1 has extra: \"d\", T2 has extra: \"c\"',\n)\n\n// Example of using @ts-expect-error for expected failures\n// @ts-expect-error Type '\"T2 has extra: \\\"d\\\"\"' is not assignable to type 'true'.\nexpectStringUnionsMatch<TestUnion1, TestUnion3>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const point3 = z.object({\n  x: distance,\n  y: distance,\n  z: distance,\n})\n\nexport const position3 = point3\n\ntype InferredPoint3 = z.infer<typeof point3>\n\nexport interface Point3 {\n  x: number\n  y: number\n  z: number\n}\n\nexpectTypesMatch<Point3, InferredPoint3>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const size = z.object({\n  width: z.number(),\n  height: z.number(),\n})\n\nexport type SizeInput = z.input<typeof size>\ntype InferredSize = z.infer<typeof size>\n\nexport interface Size {\n  width: number\n  height: number\n}\n\nexpectTypesMatch<Size, InferredSize>(true)\n","import { z } from \"zod\"\n\n// Generates a random string ID of specified length using alphanumeric characters\nconst randomId = (length: number): string => {\n  const chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n  return Array.from(\n    { length },\n    () => chars[Math.floor(Math.random() * chars.length)],\n  ).join(\"\")\n}\n/**\n * Use this for primary keys for any circuit element\n */\nexport const getZodPrefixedIdWithDefault = (prefix: string) => {\n  return z\n    .string()\n    .optional()\n    .default(() => `${prefix}_${randomId(10)}`)\n}\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport type NinePointAnchor =\n  | \"top_left\"\n  | \"top_center\"\n  | \"top_right\"\n  | \"center_left\"\n  | \"center\"\n  | \"center_right\"\n  | \"bottom_left\"\n  | \"bottom_center\"\n  | \"bottom_right\"\n\nexport const ninePointAnchor = z.enum([\n  \"top_left\",\n  \"top_center\",\n  \"top_right\",\n  \"center_left\",\n  \"center\",\n  \"center_right\",\n  \"bottom_left\",\n  \"bottom_center\",\n  \"bottom_right\",\n])\n\ntype InferredNinePointAnchor = z.infer<typeof ninePointAnchor>\n\nexpectTypesMatch<NinePointAnchor, InferredNinePointAnchor>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { capacitance, distance, voltage } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_capacitor = source_component_base.extend({\n  ftype: z.literal(\"simple_capacitor\"),\n  capacitance,\n  max_voltage_rating: voltage.optional(),\n  display_capacitance: z.string().optional(),\n  max_decoupling_trace_length: distance.optional(),\n})\n\nexport type SourceSimpleCapacitorInput = z.input<typeof source_simple_capacitor>\ntype InferredSourceSimpleCapacitor = z.infer<typeof source_simple_capacitor>\n\n/**\n * Defines a simple capacitor component\n */\nexport interface SourceSimpleCapacitor extends SourceComponentBase {\n  ftype: \"simple_capacitor\"\n  capacitance: number\n  max_voltage_rating?: number\n  display_capacitance?: string\n  max_decoupling_trace_length?: number\n}\n\nexpectTypesMatch<SourceSimpleCapacitor, InferredSourceSimpleCapacitor>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const supplier_name = z.enum([\n  \"jlcpcb\",\n  \"macrofab\",\n  \"pcbway\",\n  \"digikey\",\n  \"mouser\",\n  \"lcsc\",\n])\n\ntype InferredSupplierName = z.infer<typeof supplier_name>\n\nexport type SupplierName =\n  | \"jlcpcb\"\n  | \"macrofab\"\n  | \"pcbway\"\n  | \"digikey\"\n  | \"mouser\"\n  | \"lcsc\"\n\nexpectTypesMatch<SupplierName, InferredSupplierName>(true)\n","import {\n  supplier_name,\n  type SupplierName,\n} from \"src/pcb/properties/supplier_name\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { z } from \"zod\"\n\nexport interface SourceComponentBase {\n  type: \"source_component\"\n  ftype?: string\n  source_component_id: string\n  name: string\n  manufacturer_part_number?: string\n  supplier_part_numbers?: Partial<Record<SupplierName, string[]>>\n  display_value?: string\n  are_pins_interchangeable?: boolean\n  internally_connected_source_port_ids?: string[][]\n  source_group_id?: string\n  subcircuit_id?: string\n}\n\nexport const source_component_base = z.object({\n  type: z.literal(\"source_component\"),\n  ftype: z.string().optional(),\n  source_component_id: z.string(),\n  name: z.string(),\n  manufacturer_part_number: z.string().optional(),\n  supplier_part_numbers: z\n    .record(supplier_name, z.array(z.string()))\n    .optional(),\n  display_value: z.string().optional(),\n  are_pins_interchangeable: z.boolean().optional(),\n  internally_connected_source_port_ids: z.array(z.array(z.string())).optional(),\n  source_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n})\n\ntype InferredSourceComponentBase = z.infer<typeof source_component_base>\n\nexpectTypesMatch<SourceComponentBase, InferredSourceComponentBase>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { resistance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_resistor = source_component_base.extend({\n  ftype: z.literal(\"simple_resistor\"),\n  resistance,\n  display_resistance: z.string().optional(),\n})\n\nexport type SourceSimpleResistorInput = z.input<typeof source_simple_resistor>\ntype InferredSourceSimpleResistor = z.infer<typeof source_simple_resistor>\n\n/**\n * Defines a simple resistor component\n */\nexport interface SourceSimpleResistor extends SourceComponentBase {\n  ftype: \"simple_resistor\"\n  resistance: number\n  display_resistance?: string\n}\n\nexpectTypesMatch<SourceSimpleResistor, InferredSourceSimpleResistor>(true)\n","import {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_diode = source_component_base.extend({\n  ftype: z.literal(\"simple_diode\"),\n})\n\nexport type SourceSimpleDiodeInput = z.input<typeof source_simple_diode>\ntype InferredSourceSimpleDiode = z.infer<typeof source_simple_diode>\n\n/**\n * Defines a simple diode component\n */\nexport interface SourceSimpleDiode extends SourceComponentBase {\n  ftype: \"simple_diode\"\n}\n\nexpectTypesMatch<SourceSimpleDiode, InferredSourceSimpleDiode>(true)\n","import {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport {\n  source_simple_diode,\n  type SourceSimpleDiode,\n} from \"./source_simple_diode\"\n\nexport const source_simple_led = source_simple_diode.extend({\n  ftype: z.literal(\"simple_led\"),\n  color: z.string().optional(),\n  wavelength: z.string().optional(),\n})\n\nexport type SourceSimpleLedInput = z.input<typeof source_simple_led>\ntype InferredSourceSimpleLed = z.infer<typeof source_simple_led>\n\n/**\n * Defines a simple led component\n */\nexport interface SourceSimpleLed extends Omit<SourceSimpleDiode, \"ftype\"> {\n  ftype: \"simple_led\"\n  color?: string\n  wavelength?: string\n}\n\nexpectTypesMatch<SourceSimpleLed, InferredSourceSimpleLed>(true)\n","import {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_ground = source_component_base.extend({\n  ftype: z.literal(\"simple_ground\"),\n})\n\nexport type SourceSimpleGroundInput = z.input<typeof source_simple_ground>\ntype InferredSourceSimpleGround = z.infer<typeof source_simple_ground>\n\n/**\n * Defines a simple ground component\n */\nexport interface SourceSimpleGround extends SourceComponentBase {\n  ftype: \"simple_ground\"\n}\n\nexpectTypesMatch<SourceSimpleGround, InferredSourceSimpleGround>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_chip = source_component_base.extend({\n  ftype: z.literal(\"simple_chip\"),\n})\n\nexport type SourceSimpleChipInput = z.input<typeof source_simple_chip>\ntype InferredSourceSimpleChip = z.infer<typeof source_simple_chip>\n\n/**\n * Defines a simple integrated circuit component\n */\nexport interface SourceSimpleChip extends SourceComponentBase {\n  ftype: \"simple_chip\"\n}\n\nexpectTypesMatch<SourceSimpleChip, InferredSourceSimpleChip>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { voltage } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_power_source = source_component_base.extend({\n  ftype: z.literal(\"simple_power_source\"),\n  voltage,\n})\n\nexport type SourceSimplePowerSourceInput = z.input<\n  typeof source_simple_power_source\n>\ntype InferredSourceSimplePowerSource = z.infer<\n  typeof source_simple_power_source\n>\n\n/**\n * Defines a simple power source component\n */\nexport interface SourceSimplePowerSource extends SourceComponentBase {\n  ftype: \"simple_power_source\"\n  voltage: number\n}\n\nexpectTypesMatch<SourceSimplePowerSource, InferredSourceSimplePowerSource>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport {\n  source_simple_resistor,\n  type SourceSimpleResistor,\n} from \"./source_simple_resistor\"\nimport {\n  source_simple_capacitor,\n  type SourceSimpleCapacitor,\n} from \"./source_simple_capacitor\"\nimport { source_simple_fuse, type SourceSimpleFuse } from \"./source_simple_fuse\"\nimport {\n  source_simple_diode,\n  type SourceSimpleDiode,\n} from \"./source_simple_diode\"\nimport { source_simple_led, type SourceSimpleLed } from \"./source_simple_led\"\nimport {\n  source_simple_ground,\n  type SourceSimpleGround,\n} from \"./source_simple_ground\"\nimport { source_simple_chip, type SourceSimpleChip } from \"./source_simple_chip\"\nimport {\n  source_simple_power_source,\n  type SourceSimplePowerSource,\n} from \"./source_simple_power_source\"\nimport {\n  source_simple_battery,\n  type SourceSimpleBattery,\n} from \"./source_simple_battery\"\nimport {\n  source_simple_inductor,\n  type SourceSimpleInductor,\n} from \"./source_simple_inductor\"\nimport {\n  source_simple_push_button,\n  type SourceSimplePushButton,\n} from \"./source_simple_push_button\"\nimport {\n  source_simple_potentiometer,\n  type SourceSimplePotentiometer,\n} from \"./source_simple_potentiometer\"\nimport {\n  source_simple_crystal,\n  type SourceSimpleCrystal,\n} from \"./source_simple_crystal\"\nimport {\n  source_simple_pin_header,\n  type SourceSimplePinHeader,\n} from \"./source_simple_pin_header\"\nimport {\n  source_simple_pinout,\n  type SourceSimplePinout,\n} from \"./source_simple_pinout\"\nimport {\n  source_simple_resonator,\n  type SourceSimpleResonator,\n} from \"./source_simple_resonator\"\nimport {\n  source_simple_transistor,\n  type SourceSimpleTransistor,\n} from \"./source_simple_transistor\"\nimport {\n  source_simple_test_point,\n  type SourceSimpleTestPoint,\n} from \"./source_simple_test_point\"\nimport {\n  source_simple_mosfet,\n  type SourceSimpleMosfet,\n} from \"./source_simple_mosfet\"\nimport {\n  source_simple_switch,\n  type SourceSimpleSwitch,\n} from \"./source_simple_switch\"\nimport {\n  source_project_metadata,\n  type SourceProjectMetadata,\n} from \"./source_project_metadata\"\nimport {\n  source_missing_property_error,\n  type SourceMissingPropertyError,\n} from \"./source_missing_property_error\"\nimport {\n  source_failed_to_create_component_error,\n  type SourceFailedToCreateComponentError,\n} from \"./source_failed_to_create_component_error\"\nimport {\n  source_trace_not_connected_error,\n  type SourceTraceNotConnectedError,\n} from \"./source_trace_not_connected_error\"\nimport {\n  source_property_ignored_warning,\n  type SourcePropertyIgnoredWarning,\n} from \"./source_property_ignored_warning\"\nimport {\n  source_pin_missing_trace_warning,\n  type SourcePinMissingTraceWarning,\n} from \"./source_pin_missing_trace_warning\"\nimport {\n  source_simple_voltage_probe,\n  type SourceSimpleVoltageProbe,\n} from \"./source_simple_voltage_probe\"\n\nexport const any_source_component = z.union([\n  source_simple_resistor,\n  source_simple_capacitor,\n  source_simple_diode,\n  source_simple_led,\n  source_simple_ground,\n  source_simple_chip,\n  source_simple_power_source,\n  source_simple_battery,\n  source_simple_inductor,\n  source_simple_push_button,\n  source_simple_potentiometer,\n  source_simple_crystal,\n  source_simple_pin_header,\n  source_simple_pinout,\n  source_simple_resonator,\n  source_simple_switch,\n  source_simple_transistor,\n  source_simple_test_point,\n  source_simple_mosfet,\n  source_simple_fuse,\n  source_simple_voltage_probe,\n  source_project_metadata,\n  source_missing_property_error,\n  source_failed_to_create_component_error,\n  source_trace_not_connected_error,\n  source_property_ignored_warning,\n  source_pin_missing_trace_warning,\n])\n\n/**\n * Deprecated: use `AnySourceElement` instead\n */\nexport type AnySourceComponent = z.infer<typeof any_source_component>\n\nexport type AnySourceElement =\n  | SourceSimpleResistor\n  | SourceSimpleCapacitor\n  | SourceSimpleDiode\n  | SourceSimpleLed\n  | SourceSimpleGround\n  | SourceSimpleChip\n  | SourceSimplePowerSource\n  | SourceSimpleBattery\n  | SourceSimpleInductor\n  | SourceSimplePushButton\n  | SourceSimplePotentiometer\n  | SourceSimpleCrystal\n  | SourceSimplePinHeader\n  | SourceSimplePinout\n  | SourceSimpleResonator\n  | SourceSimpleSwitch\n  | SourceSimpleTransistor\n  | SourceSimpleTestPoint\n  | SourceSimpleMosfet\n  | SourceSimpleFuse\n  | SourceSimpleVoltageProbe\n  | SourceProjectMetadata\n  | SourceMissingPropertyError\n  | SourceFailedToCreateComponentError\n  | SourceTraceNotConnectedError\n  | SourcePropertyIgnoredWarning\n  | SourcePinMissingTraceWarning\n\nexpectTypesMatch<AnySourceElement, AnySourceComponent>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"./base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_fuse = source_component_base.extend({\n  ftype: z.literal(\"simple_fuse\"),\n\n  current_rating_amps: z\n    .number()\n    .describe(\"Nominal current in amps the fuse is rated for\"),\n\n  voltage_rating_volts: z\n    .number()\n    .describe(\"Voltage rating in volts, e.g. ±5V would be 5\"),\n})\n\nexport interface SourceSimpleFuse extends SourceComponentBase {\n  ftype: \"simple_fuse\"\n  current_rating_amps: number\n  voltage_rating_volts: number\n}\n\nexport type SourceSimpleFuseInput = z.input<typeof source_simple_fuse>\ntype InferredSourceSimpleFuse = z.infer<typeof source_simple_fuse>\n\nexpectTypesMatch<SourceSimpleFuse, InferredSourceSimpleFuse>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { battery_capacity } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_battery = source_component_base.extend({\n  ftype: z.literal(\"simple_battery\"),\n  capacity: battery_capacity,\n})\n\nexport type SourceSimpleBatteryInput = z.input<typeof source_simple_battery>\ntype InferredSourceSimpleBattery = z.infer<typeof source_simple_battery>\n\n/**\n * Defines a simple battery component\n */\nexport interface SourceSimpleBattery extends SourceComponentBase {\n  ftype: \"simple_battery\"\n  capacity: number\n}\n\nexpectTypesMatch<SourceSimpleBattery, InferredSourceSimpleBattery>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { inductance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_inductor = source_component_base.extend({\n  ftype: z.literal(\"simple_inductor\"),\n  inductance,\n  max_current_rating: z.number().optional(),\n})\n\nexport type SourceSimpleInductorInput = z.input<typeof source_simple_inductor>\ntype InferredSourceSimpleInductor = z.infer<typeof source_simple_inductor>\n\n/**\n * Defines a simple inductor component\n */\nexport interface SourceSimpleInductor extends SourceComponentBase {\n  ftype: \"simple_inductor\"\n  inductance: number\n  max_current_rating?: number\n}\n\nexpectTypesMatch<SourceSimpleInductor, InferredSourceSimpleInductor>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_push_button = source_component_base.extend({\n  ftype: z.literal(\"simple_push_button\"),\n})\n\nexport type SourceSimplePushButtonInput = z.input<\n  typeof source_simple_push_button\n>\ntype InferredSourceSimplePushButton = z.infer<typeof source_simple_push_button>\n\n/**\n * Defines a simple push button component\n */\nexport interface SourceSimplePushButton extends SourceComponentBase {\n  ftype: \"simple_push_button\"\n}\n\nexpectTypesMatch<SourceSimplePushButton, InferredSourceSimplePushButton>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { resistance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_potentiometer = source_component_base.extend({\n  ftype: z.literal(\"simple_potentiometer\"),\n  max_resistance: resistance,\n})\n\nexport type SourceSimplePotentiometerInput = z.input<\n  typeof source_simple_potentiometer\n>\ntype InferredSourceSimplePotentiometer = z.infer<\n  typeof source_simple_potentiometer\n>\n\nexport interface SourceSimplePotentiometer extends SourceComponentBase {\n  ftype: \"simple_potentiometer\"\n  max_resistance: number\n}\n\nexpectTypesMatch<SourceSimplePotentiometer, InferredSourceSimplePotentiometer>(\n  true,\n)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_crystal = source_component_base.extend({\n  ftype: z.literal(\"simple_crystal\"),\n  frequency: z.number().describe(\"Frequency in Hz\"),\n  load_capacitance: z.number().optional().describe(\"Load capacitance in pF\"),\n})\n\nexport type SourceSimpleCrystalInput = z.input<typeof source_simple_crystal>\ntype InferredSourceSimpleCrystal = z.infer<typeof source_simple_crystal>\n\n/**\n * Defines a simple crystal oscillator component\n */\nexport interface SourceSimpleCrystal extends SourceComponentBase {\n  ftype: \"simple_crystal\"\n  frequency: number\n  load_capacitance?: number\n}\n\nexpectTypesMatch<SourceSimpleCrystal, InferredSourceSimpleCrystal>(true)\n","import {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_pin_header = source_component_base.extend({\n  ftype: z.literal(\"simple_pin_header\"),\n  pin_count: z.number(),\n  gender: z.enum([\"male\", \"female\"]).optional().default(\"male\"),\n})\n\nexport type SourceSimplePinHeaderInput = z.input<\n  typeof source_simple_pin_header\n>\ntype InferredSourceSimplePinHeader = z.infer<typeof source_simple_pin_header>\n\nexport interface SourceSimplePinHeader extends SourceComponentBase {\n  ftype: \"simple_pin_header\"\n  pin_count: number\n  gender: \"male\" | \"female\"\n}\n\nexpectTypesMatch<SourceSimplePinHeader, InferredSourceSimplePinHeader>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_pinout = source_component_base.extend({\n  ftype: z.literal(\"simple_pinout\"),\n})\n\nexport type SourceSimplePinoutInput = z.input<typeof source_simple_pinout>\ntype InferredSourceSimplePinout = z.infer<typeof source_simple_pinout>\n\n/**\n * Defines a simple pinout component\n */\nexport interface SourceSimplePinout extends SourceComponentBase {\n  ftype: \"simple_pinout\"\n}\n\nexpectTypesMatch<SourceSimplePinout, InferredSourceSimplePinout>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { capacitance, resistance, frequency } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_resonator = source_component_base.extend({\n  ftype: z.literal(\"simple_resonator\"),\n  load_capacitance: capacitance,\n  equivalent_series_resistance: resistance.optional(),\n  frequency: frequency,\n})\n\nexport type SourceSimpleResonatorInput = z.input<typeof source_simple_resonator>\ntype InferredSourceSimpleResonator = z.infer<typeof source_simple_resonator>\n\n/**\n * Defines a simple resonator component\n */\nexport interface SourceSimpleResonator extends SourceComponentBase {\n  ftype: \"simple_resonator\"\n  load_capacitance: number\n  equivalent_series_resistance?: number\n  frequency: number\n}\n\nexpectTypesMatch<SourceSimpleResonator, InferredSourceSimpleResonator>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_transistor = source_component_base.extend({\n  ftype: z.literal(\"simple_transistor\"),\n  transistor_type: z.enum([\"npn\", \"pnp\"]),\n})\n\nexport type SourceSimpleTransistorInput = z.input<\n  typeof source_simple_transistor\n>\ntype InferredSourceSimpleTransistor = z.infer<typeof source_simple_transistor>\n\n/**\n * Defines a simple transistor component\n * This is a three-pin semiconductor device (emitter, base, collector)\n * Pin configuration is handled by the schematic port system\n */\n\nexport interface SourceSimpleTransistor extends SourceComponentBase {\n  ftype: \"simple_transistor\"\n  transistor_type: \"npn\" | \"pnp\"\n}\n\nexpectTypesMatch<SourceSimpleTransistor, InferredSourceSimpleTransistor>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_test_point = source_component_base.extend({\n  ftype: z.literal(\"simple_test_point\"),\n  footprint_variant: z.enum([\"pad\", \"through_hole\"]).optional(),\n  pad_shape: z.enum([\"rect\", \"circle\"]).optional(),\n  pad_diameter: z.union([z.number(), z.string()]).optional(),\n  hole_diameter: z.union([z.number(), z.string()]).optional(),\n  width: z.union([z.number(), z.string()]).optional(),\n  height: z.union([z.number(), z.string()]).optional(),\n})\n\nexport type SourceSimpleTestPointInput = z.input<\n  typeof source_simple_test_point\n>\ntype InferredSourceSimpleTestPoint = z.infer<typeof source_simple_test_point>\n\n/**\n * Defines a simple test point component\n * Can be surface-mount or through-hole.\n * Pad shape and dimensions configurable for different use cases.\n */\nexport interface SourceSimpleTestPoint extends SourceComponentBase {\n  ftype: \"simple_test_point\"\n  footprint_variant?: \"pad\" | \"through_hole\"\n  pad_shape?: \"rect\" | \"circle\"\n  pad_diameter?: number | string\n  hole_diameter?: number | string\n  width?: number | string\n  height?: number | string\n}\n\nexpectTypesMatch<SourceSimpleTestPoint, InferredSourceSimpleTestPoint>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_mosfet = source_component_base.extend({\n  ftype: z.literal(\"simple_mosfet\"),\n  channel_type: z.enum([\"n\", \"p\"]),\n  mosfet_mode: z.enum([\"enhancement\", \"depletion\"]),\n})\n\nexport type SourceSimpleMosfetInput = z.input<typeof source_simple_mosfet>\ntype InferredSourceSimpleMosfet = z.infer<typeof source_simple_mosfet>\n\n/**\n * Defines a simple mosfet component\n * This is a three-pin semiconductor device (source, gate, drain)\n * Pin configuration is handled by the schematic port system\n */\n\nexport interface SourceSimpleMosfet extends SourceComponentBase {\n  ftype: \"simple_mosfet\"\n  channel_type: \"n\" | \"p\"\n  mosfet_mode: \"enhancement\" | \"depletion\"\n}\n\nexpectTypesMatch<SourceSimpleMosfet, InferredSourceSimpleMosfet>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_switch = source_component_base.extend({\n  ftype: z.literal(\"simple_switch\"),\n})\nexport type SourceSimpleSwitchInput = z.input<typeof source_simple_switch>\ntype InferredSourceSimpleSwitch = z.infer<typeof source_simple_switch>\n\n/**\n * Defines a simple switch component\n */\nexport interface SourceSimpleSwitch extends SourceComponentBase {\n  ftype: \"simple_switch\"\n}\n\nexpectTypesMatch<SourceSimpleSwitch, InferredSourceSimpleSwitch>(true)\n","import { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { z } from \"zod\"\nimport { timestamp } from \"src/units\"\n\nexport interface SourceProjectMetadata {\n  type: \"source_project_metadata\"\n  name?: string\n  software_used_string?: string\n  project_url?: string\n  created_at?: string // ISO8601 timestamp\n}\n\nexport const source_project_metadata = z.object({\n  type: z.literal(\"source_project_metadata\"),\n  name: z.string().optional(),\n  software_used_string: z.string().optional(),\n  project_url: z.string().optional(),\n  created_at: timestamp.optional(),\n})\n\nexport type InferredProjectMetadata = z.infer<typeof source_project_metadata>\nexpectTypesMatch<SourceProjectMetadata, InferredProjectMetadata>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_missing_property_error = z\n  .object({\n    type: z.literal(\"source_missing_property_error\"),\n    source_missing_property_error_id: getZodPrefixedIdWithDefault(\n      \"source_missing_property_error\",\n    ),\n    source_component_id: z.string(),\n    property_name: z.string(),\n    subcircuit_id: z.string().optional(),\n    error_type: z\n      .literal(\"source_missing_property_error\")\n      .default(\"source_missing_property_error\"),\n    message: z.string(),\n  })\n  .describe(\"The source code is missing a property\")\n\nexport type SourceMissingPropertyErrorInput = z.input<\n  typeof source_missing_property_error\n>\ntype InferredSourceMissingPropertyError = z.infer<\n  typeof source_missing_property_error\n>\n\n/**\n * The source code is missing a property\n */\nexport interface SourceMissingPropertyError {\n  type: \"source_missing_property_error\"\n  source_missing_property_error_id: string\n  source_component_id: string\n  property_name: string\n  subcircuit_id?: string\n  error_type: \"source_missing_property_error\"\n  message: string\n}\n\nexpectTypesMatch<\n  SourceMissingPropertyError,\n  InferredSourceMissingPropertyError\n>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_failed_to_create_component_error = z\n  .object({\n    type: z.literal(\"source_failed_to_create_component_error\"),\n    source_failed_to_create_component_error_id: getZodPrefixedIdWithDefault(\n      \"source_failed_to_create_component_error\",\n    ),\n    error_type: z\n      .literal(\"source_failed_to_create_component_error\")\n      .default(\"source_failed_to_create_component_error\"),\n    component_name: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    parent_source_component_id: z.string().optional(),\n    message: z.string(),\n    pcb_center: z\n      .object({\n        x: z.number().optional(),\n        y: z.number().optional(),\n      })\n      .optional(),\n    schematic_center: z\n      .object({\n        x: z.number().optional(),\n        y: z.number().optional(),\n      })\n      .optional(),\n  })\n  .describe(\"Error emitted when a component fails to be constructed\")\n\nexport type SourceFailedToCreateComponentErrorInput = z.input<\n  typeof source_failed_to_create_component_error\n>\ntype InferredSourceFailedToCreateComponentError = z.infer<\n  typeof source_failed_to_create_component_error\n>\n\n/**\n * Error emitted when a component fails to be constructed.\n * Contains details about the failure and prevents the component from being rendered.\n */\nexport interface SourceFailedToCreateComponentError {\n  type: \"source_failed_to_create_component_error\"\n  source_failed_to_create_component_error_id: string\n  error_type: \"source_failed_to_create_component_error\"\n  message: string\n  component_name?: string\n  subcircuit_id?: string\n  parent_source_component_id?: string\n  pcb_center?: {\n    x?: number\n    y?: number\n  }\n  schematic_center?: {\n    x?: number\n    y?: number\n  }\n}\n\nexpectTypesMatch<\n  SourceFailedToCreateComponentError,\n  InferredSourceFailedToCreateComponentError\n>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_trace_not_connected_error = z\n  .object({\n    type: z.literal(\"source_trace_not_connected_error\"),\n    source_trace_not_connected_error_id: getZodPrefixedIdWithDefault(\n      \"source_trace_not_connected_error\",\n    ),\n    error_type: z\n      .literal(\"source_trace_not_connected_error\")\n      .default(\"source_trace_not_connected_error\"),\n    message: z.string(),\n    subcircuit_id: z.string().optional(),\n    source_group_id: z.string().optional(),\n    source_trace_id: z.string().optional(),\n    connected_source_port_ids: z.array(z.string()).optional(),\n    selectors_not_found: z.array(z.string()).optional(),\n  })\n  .describe(\"Occurs when a source trace selector does not match any ports\")\n\nexport type SourceTraceNotConnectedErrorInput = z.input<\n  typeof source_trace_not_connected_error\n>\ntype InferredSourceTraceNotConnectedError = z.infer<\n  typeof source_trace_not_connected_error\n>\n\n/**\n * Occurs when a source trace selector does not match any ports\n */\nexport interface SourceTraceNotConnectedError {\n  type: \"source_trace_not_connected_error\"\n  source_trace_not_connected_error_id: string\n  error_type: \"source_trace_not_connected_error\"\n  message: string\n  subcircuit_id?: string\n  source_group_id?: string\n  source_trace_id?: string\n  connected_source_port_ids?: string[]\n  selectors_not_found?: string[]\n}\n\nexpectTypesMatch<\n  SourceTraceNotConnectedError,\n  InferredSourceTraceNotConnectedError\n>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_property_ignored_warning = z\n  .object({\n    type: z.literal(\"source_property_ignored_warning\"),\n    source_property_ignored_warning_id: getZodPrefixedIdWithDefault(\n      \"source_property_ignored_warning\",\n    ),\n    source_component_id: z.string(),\n    property_name: z.string(),\n    subcircuit_id: z.string().optional(),\n    error_type: z\n      .literal(\"source_property_ignored_warning\")\n      .default(\"source_property_ignored_warning\"),\n    message: z.string(),\n  })\n  .describe(\"The source property was ignored\")\n\nexport type SourcePropertyIgnoredWarningInput = z.input<\n  typeof source_property_ignored_warning\n>\ntype InferredSourcePropertyIgnoredWarning = z.infer<\n  typeof source_property_ignored_warning\n>\n\n/**\n * The source property was ignored\n */\nexport interface SourcePropertyIgnoredWarning {\n  type: \"source_property_ignored_warning\"\n  source_property_ignored_warning_id: string\n  source_component_id: string\n  property_name: string\n  subcircuit_id?: string\n  error_type: \"source_property_ignored_warning\"\n  message: string\n}\n\nexpectTypesMatch<\n  SourcePropertyIgnoredWarning,\n  InferredSourcePropertyIgnoredWarning\n>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_pin_missing_trace_warning = z\n  .object({\n    type: z.literal(\"source_pin_missing_trace_warning\"),\n    source_pin_missing_trace_warning_id: getZodPrefixedIdWithDefault(\n      \"source_pin_missing_trace_warning\",\n    ),\n    warning_type: z\n      .literal(\"source_pin_missing_trace_warning\")\n      .default(\"source_pin_missing_trace_warning\"),\n    message: z.string(),\n    source_component_id: z.string(),\n    source_port_id: z.string(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\n    \"Warning emitted when a source component pin is missing a trace connection\",\n  )\n\nexport type SourcePinMissingTraceWarningInput = z.input<\n  typeof source_pin_missing_trace_warning\n>\ntype InferredSourcePinMissingTraceWarning = z.infer<\n  typeof source_pin_missing_trace_warning\n>\n\n/**\n * Warning emitted when a source component pin is missing a trace connection\n */\nexport interface SourcePinMissingTraceWarning {\n  type: \"source_pin_missing_trace_warning\"\n  source_pin_missing_trace_warning_id: string\n  warning_type: \"source_pin_missing_trace_warning\"\n  message: string\n  source_component_id: string\n  source_port_id: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<\n  SourcePinMissingTraceWarning,\n  InferredSourcePinMissingTraceWarning\n>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_voltage_probe = source_component_base.extend({\n  ftype: z.literal(\"simple_voltage_probe\"),\n})\n\nexport type SourceSimpleVoltageProbeInput = z.input<\n  typeof source_simple_voltage_probe\n>\ntype InferredSourceSimpleVoltageProbe = z.infer<\n  typeof source_simple_voltage_probe\n>\n\n/**\n * Defines a simple voltage probe component for simulation and measurement\n */\nexport interface SourceSimpleVoltageProbe extends SourceComponentBase {\n  ftype: \"simple_voltage_probe\"\n}\n\nexpectTypesMatch<SourceSimpleVoltageProbe, InferredSourceSimpleVoltageProbe>(\n  true,\n)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_port = z.object({\n  type: z.literal(\"source_port\"),\n  pin_number: z.number().optional(),\n  port_hints: z.array(z.string()).optional(),\n  name: z.string(),\n  source_port_id: z.string(),\n  source_component_id: z.string().optional(),\n  source_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  subcircuit_connectivity_map_key: z.string().optional(),\n})\n\nexport type SourcePortInput = z.input<typeof source_port>\ntype InferredSourcePort = z.infer<typeof source_port>\n\n/**\n * Defines a source port that can be connected to other components\n */\nexport interface SourcePort {\n  type: \"source_port\"\n  pin_number?: number\n  port_hints?: string[]\n  name: string\n  source_port_id: string\n  source_component_id?: string\n  source_group_id?: string\n  subcircuit_id?: string\n  subcircuit_connectivity_map_key?: string\n}\n\nexpectTypesMatch<SourcePort, InferredSourcePort>(true)\n","import { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { z } from \"zod\"\n\nexport interface SourceTrace {\n  type: \"source_trace\"\n  source_trace_id: string\n  connected_source_port_ids: string[]\n  connected_source_net_ids: string[]\n  subcircuit_id?: string\n  subcircuit_connectivity_map_key?: string\n  max_length?: number\n  display_name?: string\n  min_trace_thickness?: number\n}\n\nexport const source_trace = z.object({\n  type: z.literal(\"source_trace\"),\n  source_trace_id: z.string(),\n  connected_source_port_ids: z.array(z.string()),\n  connected_source_net_ids: z.array(z.string()),\n  subcircuit_id: z.string().optional(),\n  subcircuit_connectivity_map_key: z.string().optional(),\n  max_length: z.number().optional(),\n  min_trace_thickness: z.number().optional(),\n  display_name: z.string().optional(),\n})\n\ntype InferredSourceTrace = z.infer<typeof source_trace>\n\nexpectTypesMatch<SourceTrace, InferredSourceTrace>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_group = z.object({\n  type: z.literal(\"source_group\"),\n  source_group_id: z.string(),\n  subcircuit_id: z.string().optional(),\n  parent_subcircuit_id: z.string().optional(),\n  parent_source_group_id: z.string().optional(),\n  is_subcircuit: z.boolean().optional(),\n  show_as_schematic_box: z.boolean().optional(),\n  name: z.string().optional(),\n  was_automatically_named: z.boolean().optional(),\n})\n\nexport type SourceGroupInput = z.input<typeof source_group>\ntype InferredSourceGroup = z.infer<typeof source_group>\n\nexport interface SourceGroup {\n  type: \"source_group\"\n  source_group_id: string\n  subcircuit_id?: string\n  parent_subcircuit_id?: string\n  parent_source_group_id?: string\n  is_subcircuit?: boolean\n  show_as_schematic_box?: boolean\n  name?: string\n  was_automatically_named?: boolean\n}\n\nexpectTypesMatch<SourceGroup, InferredSourceGroup>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_net = z.object({\n  type: z.literal(\"source_net\"),\n  source_net_id: z.string(),\n  name: z.string(),\n  member_source_group_ids: z.array(z.string()),\n  is_power: z.boolean().optional(),\n  is_ground: z.boolean().optional(),\n  is_digital_signal: z.boolean().optional(),\n  is_analog_signal: z.boolean().optional(),\n  is_positive_voltage_source: z.boolean().optional(),\n  trace_width: z.number().optional(),\n  subcircuit_id: z.string().optional(),\n  subcircuit_connectivity_map_key: z.string().optional(),\n})\n\nexport type SourceNetInput = z.input<typeof source_net>\ntype InferredSourceNet = z.infer<typeof source_net>\n\nexport interface SourceNet {\n  type: \"source_net\"\n  source_net_id: string\n  name: string\n  member_source_group_ids: string[]\n  is_power?: boolean\n  is_ground?: boolean\n  is_digital_signal?: boolean\n  is_analog_signal?: boolean\n  is_positive_voltage_source?: boolean\n  trace_width?: number\n  subcircuit_id?: string\n  subcircuit_connectivity_map_key?: string\n}\n\nexpectTypesMatch<SourceNet, InferredSourceNet>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_board = z\n  .object({\n    type: z.literal(\"source_board\"),\n    source_board_id: z.string(),\n    source_group_id: z.string(),\n    title: z.string().optional(),\n  })\n  .describe(\"Defines a board in the source domain\")\n\nexport type SourceBoardInput = z.input<typeof source_board>\ntype InferredSourceBoard = z.infer<typeof source_board>\n\n/**\n * Defines a board in the source domain\n */\nexport interface SourceBoard {\n  type: \"source_board\"\n  source_board_id: string\n  source_group_id: string\n  title?: string\n}\n\nexpectTypesMatch<SourceBoard, InferredSourceBoard>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_pcb_ground_plane = z\n  .object({\n    type: z.literal(\"source_pcb_ground_plane\"),\n    source_pcb_ground_plane_id: z.string(),\n    source_group_id: z.string(),\n    source_net_id: z.string(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a ground plane in the source domain\")\n\nexport type SourcePcbGroundPlaneInput = z.input<typeof source_pcb_ground_plane>\ntype InferredSourcePcbGroundPlane = z.infer<typeof source_pcb_ground_plane>\n\n/**\n * Defines a ground plane in the source domain\n */\nexport interface SourcePcbGroundPlane {\n  type: \"source_pcb_ground_plane\"\n  source_pcb_ground_plane_id: string\n  source_group_id: string\n  source_net_id: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<SourcePcbGroundPlane, InferredSourcePcbGroundPlane>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_manually_placed_via = z\n  .object({\n    type: z.literal(\"source_manually_placed_via\"),\n    source_manually_placed_via_id: z.string(),\n    source_group_id: z.string(),\n    source_net_id: z.string(),\n    subcircuit_id: z.string().optional(),\n    source_trace_id: z.string().optional(),\n  })\n  .describe(\"Defines a via that is manually placed in the source domain\")\n\nexport type SourceManuallyPlacedViaInput = z.input<\n  typeof source_manually_placed_via\n>\ntype InferredSourceManuallyPlacedVia = z.infer<\n  typeof source_manually_placed_via\n>\n\n/**\n * Defines a via that is manually placed in the source domain\n */\nexport interface SourceManuallyPlacedVia {\n  type: \"source_manually_placed_via\"\n  source_manually_placed_via_id: string\n  source_group_id: string\n  source_net_id: string\n  subcircuit_id?: string\n  source_trace_id?: string\n}\n\nexpectTypesMatch<SourceManuallyPlacedVia, InferredSourceManuallyPlacedVia>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const all_layers = [\n  \"top\",\n  \"bottom\",\n  \"inner1\",\n  \"inner2\",\n  \"inner3\",\n  \"inner4\",\n  \"inner5\",\n  \"inner6\",\n] as const\n\nexport const layer_string = z.enum(all_layers)\n\nexport const layer_ref = layer_string\n  .or(\n    z.object({\n      name: layer_string,\n    }),\n  )\n  .transform((layer) => {\n    if (typeof layer === \"string\") {\n      return layer\n    }\n    return layer.name\n  })\n\nexport type LayerRefInput = z.input<typeof layer_ref>\ntype InferredLayerRef = z.output<typeof layer_ref>\nexport type LayerRef = (typeof all_layers)[number]\n\nexpectTypesMatch<LayerRef, InferredLayerRef>(true)\n\nexport const visible_layer = z.enum([\"top\", \"bottom\"])\nexport type VisibleLayerRef = z.infer<typeof visible_layer>\nexport type VisibleLayer = z.infer<typeof visible_layer>\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const unknown_error_finding_part = z\n  .object({\n    type: z.literal(\"unknown_error_finding_part\"),\n    unknown_error_finding_part_id: getZodPrefixedIdWithDefault(\n      \"unknown_error_finding_part\",\n    ),\n    error_type: z\n      .literal(\"unknown_error_finding_part\")\n      .default(\"unknown_error_finding_part\"),\n    message: z.string(),\n    source_component_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\n    \"Error emitted when an unexpected error occurs while finding a part\",\n  )\n\nexport type UnknownErrorFindingPartInput = z.input<\n  typeof unknown_error_finding_part\n>\ntype InferredUnknownErrorFindingPart = z.infer<\n  typeof unknown_error_finding_part\n>\n\n/**\n * Error emitted when an unexpected error occurs while finding a part.\n * This includes cases where the API returns HTML instead of JSON,\n * network failures, or other unexpected responses.\n */\nexport interface UnknownErrorFindingPart {\n  type: \"unknown_error_finding_part\"\n  unknown_error_finding_part_id: string\n  error_type: \"unknown_error_finding_part\"\n  message: string\n  source_component_id?: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<UnknownErrorFindingPart, InferredUnknownErrorFindingPart>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport interface SchematicBox {\n  type: \"schematic_box\"\n  schematic_component_id?: string\n  width: number\n  height: number\n  is_dashed: boolean\n  x: number\n  y: number\n  subcircuit_id?: string\n}\n\nexport const schematic_box = z\n  .object({\n    type: z.literal(\"schematic_box\"),\n    schematic_component_id: z.string().optional(),\n    width: distance,\n    height: distance,\n    is_dashed: z.boolean().default(false),\n    x: distance,\n    y: distance,\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Draws a box on the schematic\")\n\nexport type SchematicBoxInput = z.input<typeof schematic_box>\ntype InferredSchematicBox = z.infer<typeof schematic_box>\n\nexpectTypesMatch<SchematicBox, InferredSchematicBox>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport interface SchematicPath {\n  type: \"schematic_path\"\n  schematic_component_id: string\n  fill_color?: \"red\" | \"blue\"\n  is_filled?: boolean\n  points: Point[]\n  subcircuit_id?: string\n}\n\nexport const schematic_path = z.object({\n  type: z.literal(\"schematic_path\"),\n  schematic_component_id: z.string(),\n  fill_color: z.enum([\"red\", \"blue\"]).optional(),\n  is_filled: z.boolean().optional(),\n  points: z.array(point),\n  subcircuit_id: z.string().optional(),\n})\n\nexport type SchematicPathInput = z.input<typeof schematic_path>\ntype InferredSchematicPath = z.infer<typeof schematic_path>\n\nexpectTypesMatch<SchematicPath, InferredSchematicPath>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { size, type Size } from \"../common/size\"\nimport { length } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_pin_styles = z.record(\n  z.object({\n    left_margin: length.optional(),\n    right_margin: length.optional(),\n    top_margin: length.optional(),\n    bottom_margin: length.optional(),\n  }),\n)\n\nexport interface SchematicPortArrangementBySize {\n  left_size: number\n  right_size: number\n  top_size?: number\n  bottom_size?: number\n}\n\nexport interface SchematicPortArrangementBySides {\n  left_side?: { pins: number[]; direction?: \"top-to-bottom\" | \"bottom-to-top\" }\n  right_side?: { pins: number[]; direction?: \"top-to-bottom\" | \"bottom-to-top\" }\n  top_side?: { pins: number[]; direction?: \"left-to-right\" | \"right-to-left\" }\n  bottom_side?: {\n    pins: number[]\n    direction?: \"left-to-right\" | \"right-to-left\"\n  }\n}\n\nexport type SchematicPortArrangement =\n  | SchematicPortArrangementBySize\n  | SchematicPortArrangementBySides\n\nexport interface SchematicComponent {\n  type: \"schematic_component\"\n  size: Size\n  center: Point\n  source_component_id?: string\n  schematic_component_id: string\n  pin_spacing?: number\n  pin_styles?: Record<\n    string,\n    {\n      left_margin?: number\n      right_margin?: number\n      top_margin?: number\n      bottom_margin?: number\n    }\n  >\n  box_width?: number\n  symbol_name?: string\n  port_arrangement?: SchematicPortArrangement\n  port_labels?: Record<string, string>\n  symbol_display_value?: string\n  subcircuit_id?: string\n  schematic_group_id?: string\n  is_schematic_group?: boolean\n  source_group_id?: string\n  is_box_with_pins: boolean\n}\n\nexport const schematic_component_port_arrangement_by_size = z.object({\n  left_size: z.number(),\n  right_size: z.number(),\n  top_size: z.number().optional(),\n  bottom_size: z.number().optional(),\n})\n\nexpectTypesMatch<\n  SchematicPortArrangementBySize,\n  z.infer<typeof schematic_component_port_arrangement_by_size>\n>(true)\n\nexport const schematic_component_port_arrangement_by_sides = z.object({\n  left_side: z\n    .object({\n      pins: z.array(z.number()),\n      // @ts-ignore\n      direction: z.enum([\"top-to-bottom\", \"bottom-to-top\"]).optional(),\n    })\n    .optional(),\n  right_side: z\n    .object({\n      pins: z.array(z.number()),\n      // @ts-ignore\n      direction: z.enum([\"top-to-bottom\", \"bottom-to-top\"]).optional(),\n    })\n    .optional(),\n  top_side: z\n    .object({\n      pins: z.array(z.number()),\n      // @ts-ignore\n      direction: z.enum([\"left-to-right\", \"right-to-left\"]).optional(),\n    })\n    .optional(),\n  bottom_side: z\n    .object({\n      pins: z.array(z.number()),\n      // @ts-ignore\n      direction: z.enum([\"left-to-right\", \"right-to-left\"]).optional(),\n    })\n    .optional(),\n})\n\nexpectTypesMatch<\n  SchematicPortArrangementBySides,\n  z.infer<typeof schematic_component_port_arrangement_by_sides>\n>(true)\n\nexport const port_arrangement = z.union([\n  schematic_component_port_arrangement_by_size,\n  schematic_component_port_arrangement_by_sides,\n])\n\nexport const schematic_component = z.object({\n  type: z.literal(\"schematic_component\"),\n  size,\n  center: point,\n  source_component_id: z.string().optional(),\n  schematic_component_id: z.string(),\n  pin_spacing: length.optional(),\n  pin_styles: schematic_pin_styles.optional(),\n  box_width: length.optional(),\n  symbol_name: z.string().optional(),\n  port_arrangement: port_arrangement.optional(),\n  port_labels: z.record(z.string()).optional(),\n  symbol_display_value: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  schematic_group_id: z.string().optional(),\n  is_schematic_group: z.boolean().optional(),\n  source_group_id: z.string().optional(),\n  is_box_with_pins: z.boolean().optional().default(true),\n})\n\nexport type SchematicComponentInput = z.input<typeof schematic_component>\ntype InferredSchematicComponent = z.infer<typeof schematic_component>\n\nexpectTypesMatch<SchematicComponent, InferredSchematicComponent>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\n/** Draws a styled line on the schematic */\nexport interface SchematicLine {\n  type: \"schematic_line\"\n  schematic_line_id: string\n  schematic_component_id: string\n  x1: number\n  y1: number\n  x2: number\n  y2: number\n  stroke_width?: number | null\n  color: string\n  is_dashed: boolean\n  subcircuit_id?: string\n}\n\nexport const schematic_line = z\n  .object({\n    type: z.literal(\"schematic_line\"),\n    schematic_line_id: getZodPrefixedIdWithDefault(\"schematic_line\"),\n    schematic_component_id: z.string(),\n    x1: distance,\n    y1: distance,\n    x2: distance,\n    y2: distance,\n    stroke_width: distance.nullable().optional(),\n    color: z.string().default(\"#000000\"),\n    is_dashed: z.boolean().default(false),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Draws a styled line on the schematic\")\n\nexport type SchematicLineInput = z.input<typeof schematic_line>\ntype InferredSchematicLine = z.infer<typeof schematic_line>\n\nexpectTypesMatch<SchematicLine, InferredSchematicLine>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { distance, rotation } from \"../units\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\n/** Draws a styled rectangle on the schematic */\nexport interface SchematicRect {\n  type: \"schematic_rect\"\n  schematic_rect_id: string\n  schematic_component_id: string\n  center: Point\n  width: number\n  height: number\n  rotation: number\n  stroke_width?: number | null\n  color: string\n  is_filled: boolean\n  fill_color?: string\n  is_dashed: boolean\n  subcircuit_id?: string\n}\n\nexport const schematic_rect = z\n  .object({\n    type: z.literal(\"schematic_rect\"),\n    schematic_rect_id: getZodPrefixedIdWithDefault(\"schematic_rect\"),\n    schematic_component_id: z.string(),\n    center: point,\n    width: distance,\n    height: distance,\n    rotation: rotation.default(0),\n    stroke_width: distance.nullable().optional(),\n    color: z.string().default(\"#000000\"),\n    is_filled: z.boolean().default(false),\n    fill_color: z.string().optional(),\n    is_dashed: z.boolean().default(false),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Draws a styled rectangle on the schematic\")\n\nexport type SchematicRectInput = z.input<typeof schematic_rect>\ntype InferredSchematicRect = z.infer<typeof schematic_rect>\n\nexpectTypesMatch<SchematicRect, InferredSchematicRect>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { distance } from \"../units\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\n/** Draws a styled circle on the schematic */\nexport interface SchematicCircle {\n  type: \"schematic_circle\"\n  schematic_circle_id: string\n  schematic_component_id: string\n  center: Point\n  radius: number\n  stroke_width?: number | null\n  color: string\n  is_filled: boolean\n  fill_color?: string\n  is_dashed: boolean\n  subcircuit_id?: string\n}\n\nexport const schematic_circle = z\n  .object({\n    type: z.literal(\"schematic_circle\"),\n    schematic_circle_id: getZodPrefixedIdWithDefault(\"schematic_circle\"),\n    schematic_component_id: z.string(),\n    center: point,\n    radius: distance,\n    stroke_width: distance.nullable().optional(),\n    color: z.string().default(\"#000000\"),\n    is_filled: z.boolean().default(false),\n    fill_color: z.string().optional(),\n    is_dashed: z.boolean().default(false),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Draws a styled circle on the schematic\")\n\nexport type SchematicCircleInput = z.input<typeof schematic_circle>\ntype InferredSchematicCircle = z.infer<typeof schematic_circle>\n\nexpectTypesMatch<SchematicCircle, InferredSchematicCircle>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { distance, rotation } from \"../units\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\n/** Draws a styled arc on the schematic */\nexport interface SchematicArc {\n  type: \"schematic_arc\"\n  schematic_arc_id: string\n  schematic_component_id: string\n  center: Point\n  radius: number\n  start_angle_degrees: number\n  end_angle_degrees: number\n  direction: \"clockwise\" | \"counterclockwise\"\n  stroke_width?: number | null\n  color: string\n  is_dashed: boolean\n  subcircuit_id?: string\n}\n\nexport const schematic_arc = z\n  .object({\n    type: z.literal(\"schematic_arc\"),\n    schematic_arc_id: getZodPrefixedIdWithDefault(\"schematic_arc\"),\n    schematic_component_id: z.string(),\n    center: point,\n    radius: distance,\n    start_angle_degrees: rotation,\n    end_angle_degrees: rotation,\n    direction: z\n      .enum([\"clockwise\", \"counterclockwise\"])\n      .default(\"counterclockwise\"),\n    stroke_width: distance.nullable().optional(),\n    color: z.string().default(\"#000000\"),\n    is_dashed: z.boolean().default(false),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Draws a styled arc on the schematic\")\n\nexport type SchematicArcInput = z.input<typeof schematic_arc>\ntype InferredSchematicArc = z.infer<typeof schematic_arc>\n\nexpectTypesMatch<SchematicArc, InferredSchematicArc>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport interface SchematicTraceEdge {\n  from: {\n    x: number\n    y: number\n  }\n  to: {\n    x: number\n    y: number\n  }\n  is_crossing?: boolean\n  from_schematic_port_id?: string\n  to_schematic_port_id?: string\n}\n\nexport interface SchematicTrace {\n  type: \"schematic_trace\"\n  schematic_trace_id: string\n  source_trace_id?: string\n  junctions: {\n    x: number\n    y: number\n  }[]\n  edges: SchematicTraceEdge[]\n  subcircuit_id?: string\n  /** Optional for now, but will be required in a future release */\n  subcircuit_connectivity_map_key?: string\n}\n\nexport const schematic_trace = z.object({\n  type: z.literal(\"schematic_trace\"),\n  schematic_trace_id: z.string(),\n  source_trace_id: z.string().optional(),\n  junctions: z.array(\n    z.object({\n      x: z.number(),\n      y: z.number(),\n    }),\n  ),\n  edges: z.array(\n    z.object({\n      from: z.object({\n        x: z.number(),\n        y: z.number(),\n      }),\n      to: z.object({\n        x: z.number(),\n        y: z.number(),\n      }),\n      is_crossing: z.boolean().optional(),\n      from_schematic_port_id: z.string().optional(),\n      to_schematic_port_id: z.string().optional(),\n    }),\n  ),\n  subcircuit_id: z.string().optional(),\n  // TODO: make required in a future release\n  subcircuit_connectivity_map_key: z.string().optional(),\n})\n\nexport type SchematicTraceInput = z.input<typeof schematic_trace>\ntype InferredSchematicTrace = z.infer<typeof schematic_trace>\n\nexpectTypesMatch<SchematicTraceInput, InferredSchematicTrace>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { ninePointAnchor } from \"src/common/NinePointAnchor\"\nimport type { NinePointAnchor } from \"src/common/NinePointAnchor\"\nimport type { FivePointAnchor } from \"src/common/FivePointAnchor\"\nimport { fivePointAnchor } from \"src/common/FivePointAnchor\"\n\nexport interface SchematicText {\n  type: \"schematic_text\"\n  schematic_component_id?: string\n  schematic_text_id: string\n  text: string\n  font_size: number\n  position: {\n    x: number\n    y: number\n  }\n  rotation: number\n  anchor: NinePointAnchor | FivePointAnchor\n  color: string\n  subcircuit_id?: string\n}\n\nexport const schematic_text = z.object({\n  type: z.literal(\"schematic_text\"),\n  schematic_component_id: z.string().optional(),\n  schematic_text_id: z.string(),\n  text: z.string(),\n  font_size: z.number().default(0.18),\n  position: z.object({\n    x: distance,\n    y: distance,\n  }),\n  rotation: z.number().default(0),\n  anchor: z\n    .union([fivePointAnchor.describe(\"legacy\"), ninePointAnchor])\n    .default(\"center\"),\n  color: z.string().default(\"#000000\"),\n  subcircuit_id: z.string().optional(),\n})\n\nexport type SchematicTextInput = z.input<typeof schematic_text>\ntype InferredSchematicText = z.infer<typeof schematic_text>\n\nexpectTypesMatch<SchematicText, InferredSchematicText>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport type FivePointAnchor = \"center\" | \"left\" | \"right\" | \"top\" | \"bottom\"\n\nexport const fivePointAnchor = z.enum([\n  \"center\",\n  \"left\",\n  \"right\",\n  \"top\",\n  \"bottom\",\n])\n\ntype InferredFivePointAnchor = z.infer<typeof fivePointAnchor>\n\nexpectTypesMatch<FivePointAnchor, InferredFivePointAnchor>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport interface SchematicPort {\n  type: \"schematic_port\"\n  schematic_port_id: string\n  source_port_id: string\n  schematic_component_id?: string\n  center: Point\n  facing_direction?: \"up\" | \"down\" | \"left\" | \"right\"\n  distance_from_component_edge?: number\n  side_of_component?: \"top\" | \"bottom\" | \"left\" | \"right\"\n  true_ccw_index?: number\n  pin_number?: number\n  display_pin_label?: string\n  subcircuit_id?: string\n  is_connected?: boolean\n  has_input_arrow?: boolean\n  has_output_arrow?: boolean\n}\n\nexport const schematic_port = z\n  .object({\n    type: z.literal(\"schematic_port\"),\n    schematic_port_id: z.string(),\n    source_port_id: z.string(),\n    schematic_component_id: z.string().optional(),\n    center: point,\n    facing_direction: z.enum([\"up\", \"down\", \"left\", \"right\"]).optional(),\n    distance_from_component_edge: z.number().optional(),\n    side_of_component: z.enum([\"top\", \"bottom\", \"left\", \"right\"]).optional(),\n    true_ccw_index: z.number().optional(),\n    pin_number: z.number().optional(),\n    display_pin_label: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    is_connected: z.boolean().optional(),\n    has_input_arrow: z.boolean().optional(),\n    has_output_arrow: z.boolean().optional(),\n  })\n  .describe(\"Defines a port on a schematic component\")\n\nexport type SchematicPortInput = z.input<typeof schematic_port>\ntype InferredSchematicPort = z.infer<typeof schematic_port>\n\nexpectTypesMatch<SchematicPort, InferredSchematicPort>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\n\nexport interface SchematicNetLabel {\n  type: \"schematic_net_label\"\n  schematic_net_label_id: string\n  schematic_trace_id?: string\n  source_trace_id?: string\n  source_net_id: string\n  center: Point\n  anchor_position?: Point | undefined\n  anchor_side: \"top\" | \"bottom\" | \"left\" | \"right\"\n  text: string\n  symbol_name?: string | undefined\n  /**\n   * When true the net label can be repositioned. When false the label's\n   * position is fixed by the element it is attached to.\n   */\n  is_movable?: boolean\n  subcircuit_id?: string\n}\n\nexport const schematic_net_label = z.object({\n  type: z.literal(\"schematic_net_label\"),\n  schematic_net_label_id: getZodPrefixedIdWithDefault(\"schematic_net_label\"),\n  schematic_trace_id: z.string().optional(),\n  source_trace_id: z.string().optional(),\n  source_net_id: z.string(),\n  center: point,\n  anchor_position: point.optional(),\n  anchor_side: z.enum([\"top\", \"bottom\", \"left\", \"right\"]),\n  text: z.string(),\n  symbol_name: z.string().optional(),\n  is_movable: z.boolean().optional(),\n  subcircuit_id: z.string().optional(),\n})\n\nexport type SchematicNetLabelInput = z.input<typeof schematic_net_label>\nexport type InferredSchematicNetLabel = z.infer<typeof schematic_net_label>\n\nexpectTypesMatch<SchematicNetLabel, InferredSchematicNetLabel>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport interface SchematicError {\n  type: \"schematic_error\"\n  schematic_error_id: string\n  error_type: \"schematic_port_not_found\"\n  message: string\n  subcircuit_id?: string\n}\n\nexport const schematic_error = z\n  .object({\n    type: z.literal(\"schematic_error\"),\n    schematic_error_id: z.string(),\n    // eventually each error type should be broken out into a dir of files\n    error_type: z\n      .literal(\"schematic_port_not_found\")\n      .default(\"schematic_port_not_found\"),\n    message: z.string(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a schematic error on the schematic\")\n\nexport type SchematicErrorInput = z.input<typeof schematic_error>\ntype InferredSchematicError = z.infer<typeof schematic_error>\n\nexpectTypesMatch<SchematicError, InferredSchematicError>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_layout_error = z\n  .object({\n    type: z.literal(\"schematic_layout_error\"),\n    schematic_layout_error_id: getZodPrefixedIdWithDefault(\n      \"schematic_layout_error\",\n    ),\n    error_type: z\n      .literal(\"schematic_layout_error\")\n      .default(\"schematic_layout_error\"),\n    message: z.string(),\n    source_group_id: z.string(),\n    schematic_group_id: z.string(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Error emitted when schematic layout fails for a group\")\n\nexport type SchematicLayoutErrorInput = z.input<typeof schematic_layout_error>\ntype InferredSchematicLayoutError = z.infer<typeof schematic_layout_error>\n\nexport interface SchematicLayoutError {\n  type: \"schematic_layout_error\"\n  schematic_layout_error_id: string\n  error_type: \"schematic_layout_error\"\n  message: string\n  source_group_id: string\n  schematic_group_id: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<SchematicLayoutError, InferredSchematicLayoutError>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { size, type Size } from \"../common/size\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_debug_object_base = z.object({\n  type: z.literal(\"schematic_debug_object\"),\n  label: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n})\n\nexport const schematic_debug_rect = schematic_debug_object_base.extend({\n  shape: z.literal(\"rect\"),\n  center: point,\n  size: size,\n})\n\nexport const schematic_debug_line = schematic_debug_object_base.extend({\n  shape: z.literal(\"line\"),\n  start: point,\n  end: point,\n})\n\nexport const schematic_debug_point = schematic_debug_object_base.extend({\n  shape: z.literal(\"point\"),\n  center: point,\n})\n\nexport const schematic_debug_object = z.discriminatedUnion(\"shape\", [\n  schematic_debug_rect,\n  schematic_debug_line,\n  schematic_debug_point,\n])\ntype InferredSchematicDebugObject = z.infer<typeof schematic_debug_object>\n\nexport interface SchematicDebugRect {\n  type: \"schematic_debug_object\"\n  label?: string\n  shape: \"rect\"\n  center: Point\n  size: Size\n  subcircuit_id?: string\n}\n\nexport interface SchematicDebugLine {\n  type: \"schematic_debug_object\"\n  label?: string\n  shape: \"line\"\n  start: Point\n  end: Point\n  subcircuit_id?: string\n}\n\nexport interface SchematicDebugPoint {\n  type: \"schematic_debug_object\"\n  label?: string\n  shape: \"point\"\n  center: Point\n  subcircuit_id?: string\n}\n\nexport type SchematicDebugObject =\n  | SchematicDebugRect\n  | SchematicDebugLine\n  | SchematicDebugPoint\n\nexpectTypesMatch<SchematicDebugObject, InferredSchematicDebugObject>(true)\nexport type SchematicDebugObjectInput = z.input<typeof schematic_debug_object>\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { voltage } from \"src/units\"\n\nexport interface SchematicVoltageProbe {\n  type: \"schematic_voltage_probe\"\n  schematic_voltage_probe_id: string\n  source_component_id?: string\n  name?: string\n  position: Point\n  schematic_trace_id: string\n  voltage?: number\n  subcircuit_id?: string\n  color?: string\n}\n\nexport const schematic_voltage_probe = z\n  .object({\n    type: z.literal(\"schematic_voltage_probe\"),\n    schematic_voltage_probe_id: z.string(),\n    source_component_id: z.string().optional(),\n    name: z.string().optional(),\n    position: point,\n    schematic_trace_id: z.string(),\n    voltage: voltage.optional(),\n    subcircuit_id: z.string().optional(),\n    color: z.string().optional(),\n  })\n  .describe(\"Defines a voltage probe measurement point on a schematic trace\")\n\nexport type SchematicVoltageProbeInput = z.input<typeof schematic_voltage_probe>\ntype InferredSchematicVoltageProbe = z.infer<typeof schematic_voltage_probe>\n\nexpectTypesMatch<SchematicVoltageProbe, InferredSchematicVoltageProbe>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"../common\"\nimport { expectTypesMatch } from \"../utils/expect-types-match\"\n\nexport const schematic_manual_edit_conflict_warning = z\n  .object({\n    type: z.literal(\"schematic_manual_edit_conflict_warning\"),\n    schematic_manual_edit_conflict_warning_id: getZodPrefixedIdWithDefault(\n      \"schematic_manual_edit_conflict_warning\",\n    ),\n    warning_type: z\n      .literal(\"schematic_manual_edit_conflict_warning\")\n      .default(\"schematic_manual_edit_conflict_warning\"),\n    message: z.string(),\n    schematic_component_id: z.string(),\n    schematic_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    source_component_id: z.string(),\n  })\n  .describe(\n    \"Warning emitted when a component has both manual placement and explicit schX/schY coordinates\",\n  )\n\nexport type SchematicManualEditConflictWarningInput = z.input<\n  typeof schematic_manual_edit_conflict_warning\n>\ntype InferredSchematicManualEditConflictWarning = z.infer<\n  typeof schematic_manual_edit_conflict_warning\n>\n\n/**\n * Warning emitted when a component has both manual placement (via manualEdits) and explicit schX/schY coordinates\n */\nexport interface SchematicManualEditConflictWarning {\n  type: \"schematic_manual_edit_conflict_warning\"\n  schematic_manual_edit_conflict_warning_id: string\n  warning_type: \"schematic_manual_edit_conflict_warning\"\n  message: string\n  schematic_component_id: string\n  schematic_group_id?: string\n  subcircuit_id?: string\n  source_component_id: string\n}\n\nexpectTypesMatch<\n  SchematicManualEditConflictWarning,\n  InferredSchematicManualEditConflictWarning\n>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_group = z\n  .object({\n    type: z.literal(\"schematic_group\"),\n    schematic_group_id: getZodPrefixedIdWithDefault(\"schematic_group\"),\n    source_group_id: z.string(),\n    is_subcircuit: z.boolean().optional(),\n    subcircuit_id: z.string().optional(),\n    width: length,\n    height: length,\n    center: point,\n    schematic_component_ids: z.array(z.string()),\n    show_as_schematic_box: z.boolean().optional(),\n    name: z.string().optional(),\n    description: z.string().optional(),\n  })\n  .describe(\"Defines a group of components on the schematic\")\n\nexport type SchematicGroupInput = z.input<typeof schematic_group>\ntype InferredSchematicGroup = z.infer<typeof schematic_group>\n\n/**\n * Defines a group of components on the schematic\n */\nexport interface SchematicGroup {\n  type: \"schematic_group\"\n  schematic_group_id: string\n  source_group_id: string\n  is_subcircuit?: boolean\n  subcircuit_id?: string\n  width: Length\n  height: Length\n  center: Point\n  schematic_component_ids: string[]\n  show_as_schematic_box?: boolean\n  name?: string\n  description?: string\n}\n\nexpectTypesMatch<SchematicGroup, InferredSchematicGroup>(true)\n","import { z } from \"zod\"\nimport {\n  getZodPrefixedIdWithDefault,\n  ninePointAnchor,\n  point,\n  type NinePointAnchor,\n  type Point,\n} from \"src/common\"\nimport { distance, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_table = z\n  .object({\n    type: z.literal(\"schematic_table\"),\n    schematic_table_id: getZodPrefixedIdWithDefault(\"schematic_table\"),\n    anchor_position: point,\n    column_widths: z.array(distance),\n    row_heights: z.array(distance),\n    cell_padding: distance.optional(),\n    border_width: distance.optional(),\n    subcircuit_id: z.string().optional(),\n    schematic_component_id: z.string().optional(),\n    anchor: ninePointAnchor.optional(),\n  })\n  .describe(\"Defines a table on the schematic\")\n\nexport type SchematicTableInput = z.input<typeof schematic_table>\ntype InferredSchematicTable = z.infer<typeof schematic_table>\n\n/**\n * Defines a table on the schematic, useful for displaying data in a structured format.\n */\nexport interface SchematicTable {\n  type: \"schematic_table\"\n  schematic_table_id: string\n  anchor_position: Point\n  column_widths: Length[]\n  row_heights: Length[]\n  cell_padding?: Length\n  border_width?: Length\n  subcircuit_id?: string\n  schematic_component_id?: string\n  anchor?: NinePointAnchor\n}\n\nexpectTypesMatch<SchematicTable, InferredSchematicTable>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault, point, type Point } from \"src/common\"\nimport { distance, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_table_cell = z\n  .object({\n    type: z.literal(\"schematic_table_cell\"),\n    schematic_table_cell_id: getZodPrefixedIdWithDefault(\n      \"schematic_table_cell\",\n    ),\n    schematic_table_id: z.string(),\n    start_row_index: z.number(),\n    end_row_index: z.number(),\n    start_column_index: z.number(),\n    end_column_index: z.number(),\n    text: z.string().optional(),\n    center: point,\n    width: distance,\n    height: distance,\n    horizontal_align: z.enum([\"left\", \"center\", \"right\"]).optional(),\n    vertical_align: z.enum([\"top\", \"middle\", \"bottom\"]).optional(),\n    font_size: distance.optional(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a cell within a schematic_table\")\n\nexport type SchematicTableCellInput = z.input<typeof schematic_table_cell>\ntype InferredSchematicTableCell = z.infer<typeof schematic_table_cell>\n\n/**\n * Defines a cell within a schematic_table\n */\nexport interface SchematicTableCell {\n  type: \"schematic_table_cell\"\n  schematic_table_cell_id: string\n  schematic_table_id: string\n  start_row_index: number\n  end_row_index: number\n  start_column_index: number\n  end_column_index: number\n  text?: string\n  center: Point\n  width: Length\n  height: Length\n  horizontal_align?: \"left\" | \"center\" | \"right\"\n  vertical_align?: \"top\" | \"middle\" | \"bottom\"\n  font_size?: Length\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<SchematicTableCell, InferredSchematicTableCell>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_sheet = z\n  .object({\n    type: z.literal(\"schematic_sheet\"),\n    schematic_sheet_id: getZodPrefixedIdWithDefault(\"schematic_sheet\"),\n    name: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\n    \"Defines a schematic sheet or page that components can be placed on\",\n  )\n\nexport type SchematicSheetInput = z.input<typeof schematic_sheet>\ntype InferredSchematicSheet = z.infer<typeof schematic_sheet>\n\n/**\n * Defines a schematic sheet or page that components can be placed on.\n */\nexport interface SchematicSheet {\n  type: \"schematic_sheet\"\n  schematic_sheet_id: string\n  name?: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<SchematicSheet, InferredSchematicSheet>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const point_with_bulge = z.object({\n  x: distance,\n  y: distance,\n  bulge: z.number().optional(),\n})\n\nexport interface PointWithBulge {\n  x: Distance\n  y: Distance\n  bulge?: number\n}\ntype InferredPointWithBulge = z.infer<typeof point_with_bulge>\nexpectTypesMatch<PointWithBulge, InferredPointWithBulge>(true)\n\nexport const ring = z.object({\n  vertices: z.array(point_with_bulge),\n})\n\nexport interface Ring {\n  vertices: PointWithBulge[]\n}\ntype InferredRing = z.infer<typeof ring>\nexpectTypesMatch<Ring, InferredRing>(true)\n\nexport const brep_shape = z.object({\n  outer_ring: ring,\n  inner_rings: z.array(ring).default([]),\n})\n\n/**\n * B-rep shape defined by an outer ring and inner rings (holes).\n */\nexport interface BRepShape {\n  /**\n   * The outer boundary of the shape. Vertices must be in clockwise order.\n   */\n  outer_ring: Ring\n  /**\n   * Inner boundaries (holes). Vertices must be in counter-clockwise order.\n   */\n  inner_rings: Ring[]\n}\ntype InferredBRepShape = z.infer<typeof brep_shape>\nexpectTypesMatch<BRepShape, InferredBRepShape>(true)\n","import { z } from \"zod\"\nimport { distance } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"./layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\n// x: string | number\n// y: string | number\n// via?: boolean\n// via_to_layer?: string\nexport const pcb_route_hint = z.object({\n  x: distance,\n  y: distance,\n  via: z.boolean().optional(),\n  via_to_layer: layer_ref.optional(),\n})\nexport const pcb_route_hints = z.array(pcb_route_hint)\n\nexport type PcbRouteHintInput = z.input<typeof pcb_route_hint>\nexport type PcbRouteHintsInput = z.input<typeof pcb_route_hints>\ntype InferredPcbRouteHint = z.output<typeof pcb_route_hint>\ntype InferredPcbRouteHints = z.output<typeof pcb_route_hints>\n\nexport interface PcbRouteHint {\n  x: number\n  y: number\n  via?: boolean\n  via_to_layer?: LayerRef\n}\n\nexport type PcbRouteHints = PcbRouteHint[]\n\nexpectTypesMatch<PcbRouteHint, InferredPcbRouteHint>(true)\nexpectTypesMatch<PcbRouteHints, InferredPcbRouteHints>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../../units\"\nimport { layer_ref, type LayerRef } from \"./layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const route_hint_point = z.object({\n  x: distance,\n  y: distance,\n  via: z.boolean().optional(),\n  to_layer: layer_ref.optional(),\n  trace_width: distance.optional(),\n})\n\nexport type RouteHintPointInput = z.input<typeof route_hint_point>\ntype InferredRouteHintPoint = z.infer<typeof route_hint_point>\n\nexport interface RouteHintPoint {\n  x: number\n  y: number\n  via?: boolean\n  to_layer?: LayerRef\n  trace_width?: number\n}\n\nexpectTypesMatch<RouteHintPoint, InferredRouteHintPoint>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { rotation, length, type Rotation, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_component = z\n  .object({\n    type: z.literal(\"pcb_component\"),\n    pcb_component_id: getZodPrefixedIdWithDefault(\"pcb_component\"),\n    source_component_id: z.string(),\n    center: point,\n    layer: layer_ref,\n    rotation: rotation,\n    width: length,\n    height: length,\n    do_not_place: z.boolean().optional(),\n    subcircuit_id: z.string().optional(),\n    pcb_group_id: z.string().optional(),\n    position_mode: z\n      .enum([\"packed\", \"relative_to_group_anchor\", \"none\"])\n      .optional(),\n    positioned_relative_to_pcb_group_id: z.string().optional(),\n    obstructs_within_bounds: z\n      .boolean()\n      .default(true)\n      .describe(\n        \"Does this component take up all the space within its bounds on a layer. This is generally true except for when separated pin headers are being represented by a single component (in which case, chips can be placed between the pin headers) or for tall modules where chips fit underneath\",\n      ),\n  })\n  .describe(\"Defines a component on the PCB\")\n\nexport type PcbComponentInput = z.input<typeof pcb_component>\ntype InferredPcbComponent = z.infer<typeof pcb_component>\n\n/**\n * Defines a component on the PCB\n */\nexport interface PcbComponent {\n  type: \"pcb_component\"\n  pcb_component_id: string\n  source_component_id: string\n  subcircuit_id?: string\n  center: Point\n  layer: LayerRef\n  rotation: Rotation\n  width: Length\n  height: Length\n  do_not_place?: boolean\n  pcb_group_id?: string\n  position_mode?: \"packed\" | \"relative_to_group_anchor\" | \"none\"\n  positioned_relative_to_pcb_group_id?: string\n  obstructs_within_bounds: boolean\n}\n\n/**\n * @deprecated use PcbComponent\n */\nexport type PCBComponent = PcbComponent\n\nexpectTypesMatch<PcbComponent, InferredPcbComponent>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { distance, type Distance, rotation, type Rotation } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nconst pcb_hole_circle = z.object({\n  type: z.literal(\"pcb_hole\"),\n  pcb_hole_id: getZodPrefixedIdWithDefault(\"pcb_hole\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.literal(\"circle\"),\n  hole_diameter: z.number(),\n  x: distance,\n  y: distance,\n  soldermask_margin: z.number().optional(),\n})\n\nexport const pcb_hole_circle_shape = pcb_hole_circle.describe(\n  \"Defines a circular hole on the PCB\",\n)\n\nexport type PcbHoleCircleInput = z.input<typeof pcb_hole_circle>\ntype InferredPcbHoleCircle = z.infer<typeof pcb_hole_circle>\n\n/**\n * Defines a circular hole on the PCB\n */\nexport interface PcbHoleCircle {\n  type: \"pcb_hole\"\n  pcb_hole_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"circle\"\n  hole_diameter: number\n  x: Distance\n  y: Distance\n  soldermask_margin?: number\n}\n\nexpectTypesMatch<PcbHoleCircle, InferredPcbHoleCircle>(true)\n\nconst pcb_hole_rect = z.object({\n  type: z.literal(\"pcb_hole\"),\n  pcb_hole_id: getZodPrefixedIdWithDefault(\"pcb_hole\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.literal(\"rect\"),\n  hole_width: z.number(),\n  hole_height: z.number(),\n  x: distance,\n  y: distance,\n  soldermask_margin: z.number().optional(),\n})\n\nexport const pcb_hole_rect_shape = pcb_hole_rect.describe(\n  \"Defines a rectangular (square-capable) hole on the PCB. Use equal width/height for square.\",\n)\n\nexport type PcbHoleRectInput = z.input<typeof pcb_hole_rect>\ntype InferredPcbHoleRect = z.infer<typeof pcb_hole_rect>\n\n/**\n * Defines a rectangular (or square) hole on the PCB\n */\nexport interface PcbHoleRect {\n  type: \"pcb_hole\"\n  pcb_hole_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"rect\"\n  hole_width: number\n  hole_height: number\n  x: Distance\n  y: Distance\n  soldermask_margin?: number\n}\nexpectTypesMatch<PcbHoleRect, InferredPcbHoleRect>(true)\n\nconst pcb_hole_circle_or_square = z.object({\n  type: z.literal(\"pcb_hole\"),\n  pcb_hole_id: getZodPrefixedIdWithDefault(\"pcb_hole\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.enum([\"circle\", \"square\"]),\n  hole_diameter: z.number(),\n  x: distance,\n  y: distance,\n  soldermask_margin: z.number().optional(),\n})\n\nexport const pcb_hole_circle_or_square_shape =\n  pcb_hole_circle_or_square.describe(\n    \"Defines a circular or square hole on the PCB\",\n  )\n\nexport type PcbHoleCircleOrSquareInput = z.input<\n  typeof pcb_hole_circle_or_square\n>\ntype InferredPcbHoleCircleOrSquare = z.infer<typeof pcb_hole_circle_or_square>\n\n/**\n * Defines a circular or square hole on the PCB\n */\n\n/**\n * @deprecated Use `PcbHoleCircle` for circular holes or `PcbHoleRect` for square holes.\n */\nexport interface PcbHoleCircleOrSquare {\n  type: \"pcb_hole\"\n  pcb_hole_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"circle\" | \"square\"\n  hole_diameter: number\n  x: Distance\n  y: Distance\n  soldermask_margin?: number\n}\n\nexpectTypesMatch<PcbHoleCircleOrSquare, InferredPcbHoleCircleOrSquare>(true)\n\nconst pcb_hole_oval = z.object({\n  type: z.literal(\"pcb_hole\"),\n  pcb_hole_id: getZodPrefixedIdWithDefault(\"pcb_hole\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.literal(\"oval\"),\n  hole_width: z.number(),\n  hole_height: z.number(),\n  x: distance,\n  y: distance,\n  soldermask_margin: z.number().optional(),\n})\n\nexport const pcb_hole_oval_shape = pcb_hole_oval.describe(\n  \"Defines an oval hole on the PCB\",\n)\n\nexport type PcbHoleOvalInput = z.input<typeof pcb_hole_oval>\ntype InferredPcbHoleOval = z.infer<typeof pcb_hole_oval>\n\n/**\n * Defines an oval hole on the PCB\n */\nexport interface PcbHoleOval {\n  type: \"pcb_hole\"\n  pcb_hole_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"oval\"\n  hole_width: number\n  hole_height: number\n  x: Distance\n  y: Distance\n  soldermask_margin?: number\n}\n\nexpectTypesMatch<PcbHoleOval, InferredPcbHoleOval>(true)\n\nconst pcb_hole_pill = z.object({\n  type: z.literal(\"pcb_hole\"),\n  pcb_hole_id: getZodPrefixedIdWithDefault(\"pcb_hole\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.literal(\"pill\"),\n  hole_width: z.number(),\n  hole_height: z.number(),\n  x: distance,\n  y: distance,\n  soldermask_margin: z.number().optional(),\n})\n\nexport const pcb_hole_pill_shape = pcb_hole_pill.describe(\n  \"Defines a pill-shaped hole on the PCB\",\n)\n\nexport type PcbHolePillInput = z.input<typeof pcb_hole_pill>\ntype InferredPcbHolePill = z.infer<typeof pcb_hole_pill>\n\n/**\n * Defines a pill-shaped hole on the PCB\n */\nexport interface PcbHolePill {\n  type: \"pcb_hole\"\n  pcb_hole_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"pill\"\n  hole_width: number\n  hole_height: number\n  x: Distance\n  y: Distance\n  soldermask_margin?: number\n}\n\nexpectTypesMatch<PcbHolePill, InferredPcbHolePill>(true)\n\nconst pcb_hole_rotated_pill = z.object({\n  type: z.literal(\"pcb_hole\"),\n  pcb_hole_id: getZodPrefixedIdWithDefault(\"pcb_hole\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.literal(\"rotated_pill\"),\n  hole_width: z.number(),\n  hole_height: z.number(),\n  x: distance,\n  y: distance,\n  ccw_rotation: rotation,\n  soldermask_margin: z.number().optional(),\n})\n\nexport const pcb_hole_rotated_pill_shape = pcb_hole_rotated_pill.describe(\n  \"Defines a rotated pill-shaped hole on the PCB\",\n)\n\nexport type PcbHoleRotatedPillInput = z.input<typeof pcb_hole_rotated_pill>\ntype InferredPcbHoleRotatedPill = z.infer<typeof pcb_hole_rotated_pill>\n\n/**\n * Defines a rotated pill-shaped hole on the PCB\n */\nexport interface PcbHoleRotatedPill {\n  type: \"pcb_hole\"\n  pcb_hole_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"rotated_pill\"\n  hole_width: number\n  hole_height: number\n  x: Distance\n  y: Distance\n  ccw_rotation: Rotation\n  soldermask_margin?: number\n}\n\nexpectTypesMatch<PcbHoleRotatedPill, InferredPcbHoleRotatedPill>(true)\n\nexport const pcb_hole = pcb_hole_circle_or_square\n  .or(pcb_hole_oval)\n  .or(pcb_hole_pill)\n  .or(pcb_hole_rotated_pill)\n  .or(pcb_hole_circle)\n  .or(pcb_hole_rect)\n\n/**\n * @deprecated Use PcbHoleCircleOrSquare, PcbHoleCircle, PcbHoleRect, PcbHoleOval, PcbHolePill, or PcbHoleRotatedPill\n */\nexport type PCBHoleInput = z.input<typeof pcb_hole>\n/**\n * @deprecated Use PcbHoleCircleOrSquare, PcbHoleCircle, PcbHoleRect, PcbHoleOval, PcbHolePill, or PcbHoleRotatedPill\n */\nexport type PCBHole = z.infer<typeof pcb_hole>\n\nexport type PcbHole =\n  | PcbHoleCircleOrSquare\n  | PcbHoleOval\n  | PcbHolePill\n  | PcbHoleRotatedPill\n  | PcbHoleCircle\n  | PcbHoleRect\n","import { z } from \"zod\"\nimport { distance, type Distance, rotation, type Rotation } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nconst pcb_plated_hole_circle = z.object({\n  type: z.literal(\"pcb_plated_hole\"),\n  shape: z.literal(\"circle\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  outer_diameter: z.number(),\n  hole_diameter: z.number(),\n  x: distance,\n  y: distance,\n  layers: z.array(layer_ref),\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  pcb_plated_hole_id: getZodPrefixedIdWithDefault(\"pcb_plated_hole\"),\n  soldermask_margin: z.number().optional(),\n})\n\n/**\n * Defines a circular plated hole on the PCB\n */\nexport interface PcbPlatedHoleCircle {\n  type: \"pcb_plated_hole\"\n  shape: \"circle\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  outer_diameter: number\n  hole_diameter: number\n  x: Distance\n  y: Distance\n  layers: LayerRef[]\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  pcb_plated_hole_id: string\n  soldermask_margin?: number\n}\n\nconst pcb_plated_hole_oval = z.object({\n  type: z.literal(\"pcb_plated_hole\"),\n  shape: z.enum([\"oval\", \"pill\"]),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  outer_width: z.number(),\n  outer_height: z.number(),\n  hole_width: z.number(),\n  hole_height: z.number(),\n  x: distance,\n  y: distance,\n  ccw_rotation: rotation,\n  layers: z.array(layer_ref),\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  pcb_plated_hole_id: getZodPrefixedIdWithDefault(\"pcb_plated_hole\"),\n  soldermask_margin: z.number().optional(),\n})\n\n/**\n * Defines an oval or pill-shaped plated hole on the PCB\n */\nexport interface PcbPlatedHoleOval {\n  type: \"pcb_plated_hole\"\n  shape: \"oval\" | \"pill\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  outer_width: number\n  outer_height: number\n  hole_width: number\n  hole_height: number\n  x: Distance\n  y: Distance\n  ccw_rotation: Rotation\n  layers: LayerRef[]\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  pcb_plated_hole_id: string\n  soldermask_margin?: number\n}\n\nconst pcb_circular_hole_with_rect_pad = z.object({\n  type: z.literal(\"pcb_plated_hole\"),\n  shape: z.literal(\"circular_hole_with_rect_pad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.literal(\"circle\"),\n  pad_shape: z.literal(\"rect\"),\n  hole_diameter: z.number(),\n  rect_pad_width: z.number(),\n  rect_pad_height: z.number(),\n  rect_border_radius: z.number().optional(),\n  hole_offset_x: distance.default(0),\n  hole_offset_y: distance.default(0),\n  x: distance,\n  y: distance,\n  layers: z.array(layer_ref),\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  pcb_plated_hole_id: getZodPrefixedIdWithDefault(\"pcb_plated_hole\"),\n  soldermask_margin: z.number().optional(),\n})\nconst pcb_pill_hole_with_rect_pad = z.object({\n  type: z.literal(\"pcb_plated_hole\"),\n  shape: z.literal(\"pill_hole_with_rect_pad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.literal(\"pill\"),\n  pad_shape: z.literal(\"rect\"),\n  hole_width: z.number(),\n  hole_height: z.number(),\n  rect_pad_width: z.number(),\n  rect_pad_height: z.number(),\n  rect_border_radius: z.number().optional(),\n  hole_offset_x: distance.default(0),\n  hole_offset_y: distance.default(0),\n  x: distance,\n  y: distance,\n  layers: z.array(layer_ref),\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  pcb_plated_hole_id: getZodPrefixedIdWithDefault(\"pcb_plated_hole\"),\n  soldermask_margin: z.number().optional(),\n})\nconst pcb_rotated_pill_hole_with_rect_pad = z.object({\n  type: z.literal(\"pcb_plated_hole\"),\n  shape: z.literal(\"rotated_pill_hole_with_rect_pad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.literal(\"rotated_pill\"),\n  pad_shape: z.literal(\"rect\"),\n  hole_width: z.number(),\n  hole_height: z.number(),\n  hole_ccw_rotation: rotation,\n  rect_pad_width: z.number(),\n  rect_pad_height: z.number(),\n  rect_border_radius: z.number().optional(),\n  rect_ccw_rotation: rotation,\n  hole_offset_x: distance.default(0),\n  hole_offset_y: distance.default(0),\n  x: distance,\n  y: distance,\n  layers: z.array(layer_ref),\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  pcb_plated_hole_id: getZodPrefixedIdWithDefault(\"pcb_plated_hole\"),\n  soldermask_margin: z.number().optional(),\n})\nexport interface PcbHolePillWithRectPad {\n  type: \"pcb_plated_hole\"\n  shape: \"pill_hole_with_rect_pad\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"pill\"\n  pad_shape: \"rect\"\n  hole_width: number\n  hole_height: number\n  rect_pad_width: number\n  rect_pad_height: number\n  rect_border_radius?: number\n  hole_offset_x: Distance\n  hole_offset_y: Distance\n  x: Distance\n  y: Distance\n  layers: LayerRef[]\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  pcb_plated_hole_id: string\n  soldermask_margin?: number\n}\n\nexport interface PcbHoleRotatedPillWithRectPad {\n  type: \"pcb_plated_hole\"\n  shape: \"rotated_pill_hole_with_rect_pad\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"rotated_pill\"\n  pad_shape: \"rect\"\n  hole_width: number\n  hole_height: number\n  hole_ccw_rotation: Rotation\n  rect_pad_width: number\n  rect_pad_height: number\n  rect_border_radius?: number\n  rect_ccw_rotation: Rotation\n  hole_offset_x: Distance\n  hole_offset_y: Distance\n  x: Distance\n  y: Distance\n  layers: LayerRef[]\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  pcb_plated_hole_id: string\n  soldermask_margin?: number\n}\n\nexport interface PcbHoleCircularWithRectPad {\n  type: \"pcb_plated_hole\"\n  shape: \"circular_hole_with_rect_pad\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"circle\"\n  pad_shape: \"rect\"\n  hole_diameter: number\n  rect_pad_width: number\n  rect_pad_height: number\n  rect_border_radius?: number\n  hole_offset_x: Distance\n  hole_offset_y: Distance\n  x: Distance\n  y: Distance\n  layers: LayerRef[]\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  pcb_plated_hole_id: string\n  soldermask_margin?: number\n}\nconst pcb_hole_with_polygon_pad = z.object({\n  type: z.literal(\"pcb_plated_hole\"),\n  shape: z.literal(\"hole_with_polygon_pad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.enum([\"circle\", \"oval\", \"pill\", \"rotated_pill\"]),\n  hole_diameter: z.number().optional(),\n  hole_width: z.number().optional(),\n  hole_height: z.number().optional(),\n\n  pad_outline: z\n    .array(\n      z.object({\n        x: distance,\n        y: distance,\n      }),\n    )\n    .min(3),\n\n  hole_offset_x: distance.default(0),\n  hole_offset_y: distance.default(0),\n  x: distance,\n  y: distance,\n  layers: z.array(layer_ref),\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  pcb_plated_hole_id: getZodPrefixedIdWithDefault(\"pcb_plated_hole\"),\n  soldermask_margin: z.number().optional(),\n})\n\n/**\n * Defines a plated hole with a polygonal pad on the PCB\n */\n\nexport interface PcbHoleWithPolygonPad {\n  type: \"pcb_plated_hole\"\n  shape: \"hole_with_polygon_pad\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"circle\" | \"oval\" | \"pill\" | \"rotated_pill\"\n  hole_diameter?: number\n  hole_width?: number\n  hole_height?: number\n  pad_outline: { x: Distance; y: Distance }[]\n  hole_offset_x: Distance\n  hole_offset_y: Distance\n  x: Distance\n  y: Distance\n  layers: LayerRef[]\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  pcb_plated_hole_id: string\n  soldermask_margin?: number\n}\n\nexport const pcb_plated_hole = z.union([\n  pcb_plated_hole_circle,\n  pcb_plated_hole_oval,\n  pcb_circular_hole_with_rect_pad,\n  pcb_pill_hole_with_rect_pad,\n  pcb_rotated_pill_hole_with_rect_pad,\n  pcb_hole_with_polygon_pad,\n])\nexport type PcbPlatedHole =\n  | PcbPlatedHoleCircle\n  | PcbPlatedHoleOval\n  | PcbHoleCircularWithRectPad\n  | PcbHolePillWithRectPad\n  | PcbHoleRotatedPillWithRectPad\n  | PcbHoleWithPolygonPad\n\nexpectTypesMatch<PcbPlatedHoleCircle, z.infer<typeof pcb_plated_hole_circle>>(\n  true,\n)\nexpectTypesMatch<PcbPlatedHoleOval, z.infer<typeof pcb_plated_hole_oval>>(true)\nexpectTypesMatch<\n  PcbHoleCircularWithRectPad,\n  z.infer<typeof pcb_circular_hole_with_rect_pad>\n>(true)\nexpectTypesMatch<\n  PcbHolePillWithRectPad,\n  z.infer<typeof pcb_pill_hole_with_rect_pad>\n>(true)\nexpectTypesMatch<\n  PcbHoleRotatedPillWithRectPad,\n  z.infer<typeof pcb_rotated_pill_hole_with_rect_pad>\n>(true)\nexpectTypesMatch<\n  PcbHoleWithPolygonPad,\n  z.infer<typeof pcb_hole_with_polygon_pad>\n>(true)\n/**\n * @deprecated use PcbPlatedHole\n */\nexport type PCBPlatedHole = PcbPlatedHole\n\n/**\n * @deprecated use PcbPlatedHoleInput\n */\nexport type PCBPlatedHoleInput = z.input<typeof pcb_plated_hole>\nexport type PcbPlatedHoleInput = z.input<typeof pcb_plated_hole>\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { distance, type Distance } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_port = z\n  .object({\n    type: z.literal(\"pcb_port\"),\n    pcb_port_id: getZodPrefixedIdWithDefault(\"pcb_port\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    source_port_id: z.string(),\n    pcb_component_id: z.string().optional(),\n    x: distance,\n    y: distance,\n    layers: z.array(layer_ref),\n    is_board_pinout: z.boolean().optional(),\n  })\n  .describe(\"Defines a port on the PCB\")\n\nexport type PcbPortInput = z.input<typeof pcb_port>\ntype InferredPcbPort = z.infer<typeof pcb_port>\n\n/**\n * Defines a port on the PCB\n */\nexport interface PcbPort {\n  type: \"pcb_port\"\n  pcb_port_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  source_port_id: string\n  pcb_component_id?: string\n  x: Distance\n  y: Distance\n  layers: LayerRef[]\n  is_board_pinout?: boolean\n}\n\n/**\n * @deprecated use PcbPort\n */\nexport type PCBPort = PcbPort\n\n/**\n * @deprecated use PcbPortInput\n */\nexport type PCBPortInput = PcbPortInput\n\nexpectTypesMatch<PcbPort, InferredPcbPort>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance, rotation, type Rotation } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { getZodPrefixedIdWithDefault, point, type Point } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nconst pcb_smtpad_circle = z.object({\n  type: z.literal(\"pcb_smtpad\"),\n  shape: z.literal(\"circle\"),\n  pcb_smtpad_id: getZodPrefixedIdWithDefault(\"pcb_smtpad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  radius: z.number(),\n  layer: layer_ref,\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  is_covered_with_solder_mask: z.boolean().optional(),\n  soldermask_margin: z.number().optional(),\n})\n\nconst pcb_smtpad_rect = z.object({\n  type: z.literal(\"pcb_smtpad\"),\n  shape: z.literal(\"rect\"),\n  pcb_smtpad_id: getZodPrefixedIdWithDefault(\"pcb_smtpad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  rect_border_radius: z.number().optional(),\n  corner_radius: z.number().optional(),\n  layer: layer_ref,\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  is_covered_with_solder_mask: z.boolean().optional(),\n  soldermask_margin: z.number().optional(),\n})\n\nconst pcb_smtpad_rotated_rect = z.object({\n  type: z.literal(\"pcb_smtpad\"),\n  shape: z.literal(\"rotated_rect\"),\n  pcb_smtpad_id: getZodPrefixedIdWithDefault(\"pcb_smtpad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  rect_border_radius: z.number().optional(),\n  corner_radius: z.number().optional(),\n  ccw_rotation: rotation,\n  layer: layer_ref,\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  is_covered_with_solder_mask: z.boolean().optional(),\n  soldermask_margin: z.number().optional(),\n})\n\nexport const pcb_smtpad_pill = z.object({\n  type: z.literal(\"pcb_smtpad\"),\n  shape: z.literal(\"pill\"),\n  pcb_smtpad_id: getZodPrefixedIdWithDefault(\"pcb_smtpad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  radius: z.number(),\n  layer: layer_ref,\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  is_covered_with_solder_mask: z.boolean().optional(),\n  soldermask_margin: z.number().optional(),\n})\nconst pcb_smtpad_rotated_pill = z.object({\n  type: z.literal(\"pcb_smtpad\"),\n  shape: z.literal(\"rotated_pill\"),\n  pcb_smtpad_id: getZodPrefixedIdWithDefault(\"pcb_smtpad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  radius: z.number(),\n  ccw_rotation: rotation,\n  layer: layer_ref,\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  is_covered_with_solder_mask: z.boolean().optional(),\n  soldermask_margin: z.number().optional(),\n})\n\nconst pcb_smtpad_polygon = z.object({\n  type: z.literal(\"pcb_smtpad\"),\n  shape: z.literal(\"polygon\"),\n  pcb_smtpad_id: getZodPrefixedIdWithDefault(\"pcb_smtpad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  points: z.array(point),\n  layer: layer_ref,\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  is_covered_with_solder_mask: z.boolean().optional(),\n  soldermask_margin: z.number().optional(),\n})\n\nexport const pcb_smtpad = z\n  .discriminatedUnion(\"shape\", [\n    pcb_smtpad_circle,\n    pcb_smtpad_rect,\n    pcb_smtpad_rotated_rect,\n    pcb_smtpad_rotated_pill,\n    pcb_smtpad_pill,\n    pcb_smtpad_polygon,\n  ])\n  .describe(\"Defines an SMT pad on the PCB\")\n\nexport type PCBSMTPadInput = z.input<typeof pcb_smtpad>\ntype PCBSMTPadCircle = z.infer<typeof pcb_smtpad_circle>\ntype PCBSMTPadRect = z.infer<typeof pcb_smtpad_rect>\ntype PCBSMTPadRotatedRect = z.infer<typeof pcb_smtpad_rotated_rect>\ntype PCBSMTPadRotatedPill = z.infer<typeof pcb_smtpad_rotated_pill>\ntype PCBSMTPadPill = z.infer<typeof pcb_smtpad_pill>\ntype PCBSMTPadPolygon = z.infer<typeof pcb_smtpad_polygon>\n\n/**\n * Defines a circular SMT pad on the PCB\n */\nexport interface PcbSmtPadCircle {\n  type: \"pcb_smtpad\"\n  shape: \"circle\"\n  pcb_smtpad_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  radius: number\n  layer: LayerRef\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  is_covered_with_solder_mask?: boolean\n  soldermask_margin?: number\n}\n\n/**\n * Defines a rectangular SMT pad on the PCB\n */\nexport interface PcbSmtPadRect {\n  type: \"pcb_smtpad\"\n  shape: \"rect\"\n  pcb_smtpad_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  rect_border_radius?: number\n  corner_radius?: number\n  layer: LayerRef\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  is_covered_with_solder_mask?: boolean\n  soldermask_margin?: number\n}\n\n/**\n * Defines a rotated rectangular SMT pad on the PCB\n */\nexport interface PcbSmtPadRotatedRect {\n  type: \"pcb_smtpad\"\n  shape: \"rotated_rect\"\n  pcb_smtpad_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  rect_border_radius?: number\n  corner_radius?: number\n  ccw_rotation: Rotation\n  layer: LayerRef\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  is_covered_with_solder_mask?: boolean\n  soldermask_margin?: number\n}\n/**\n * Defines a pill-shaped SMT pad on the PCB (rounded rectangle).\n */\nexport interface PcbSmtPadPill {\n  type: \"pcb_smtpad\"\n  shape: \"pill\"\n  pcb_smtpad_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  radius: number\n  layer: LayerRef\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  is_covered_with_solder_mask?: boolean\n  soldermask_margin?: number\n}\n\n/**\n * Defines a rotated pill-shaped SMT pad on the PCB\n */\nexport interface PcbSmtPadRotatedPill {\n  type: \"pcb_smtpad\"\n  shape: \"rotated_pill\"\n  pcb_smtpad_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  radius: number\n  ccw_rotation: Rotation\n  layer: LayerRef\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  is_covered_with_solder_mask?: boolean\n  soldermask_margin?: number\n}\n\n/**\n * Defines a polygonal SMT pad on the PCB\n */\nexport interface PcbSmtPadPolygon {\n  type: \"pcb_smtpad\"\n  shape: \"polygon\"\n  pcb_smtpad_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  points: Point[]\n  layer: LayerRef\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  is_covered_with_solder_mask?: boolean\n  soldermask_margin?: number\n}\n\nexport type PcbSmtPad =\n  | PcbSmtPadCircle\n  | PcbSmtPadRect\n  | PcbSmtPadRotatedRect\n  | PcbSmtPadRotatedPill\n  | PcbSmtPadPill\n  | PcbSmtPadPolygon\n\n/**\n * @deprecated use PcbSmtPad\n */\nexport type PCBSMTPad = PcbSmtPad\n\nexpectTypesMatch<PcbSmtPadCircle, PCBSMTPadCircle>(true)\nexpectTypesMatch<PcbSmtPadRect, PCBSMTPadRect>(true)\nexpectTypesMatch<PcbSmtPadRotatedRect, PCBSMTPadRotatedRect>(true)\nexpectTypesMatch<PcbSmtPadRotatedPill, PCBSMTPadRotatedPill>(true)\nexpectTypesMatch<PcbSmtPadPill, PCBSMTPadPill>(true)\nexpectTypesMatch<PcbSmtPadPolygon, PCBSMTPadPolygon>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nconst pcb_solder_paste_circle = z.object({\n  type: z.literal(\"pcb_solder_paste\"),\n  shape: z.literal(\"circle\"),\n  pcb_solder_paste_id: getZodPrefixedIdWithDefault(\"pcb_solder_paste\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  radius: z.number(),\n  layer: layer_ref,\n  pcb_component_id: z.string().optional(),\n  pcb_smtpad_id: z.string().optional(),\n})\n\nconst pcb_solder_paste_rect = z.object({\n  type: z.literal(\"pcb_solder_paste\"),\n  shape: z.literal(\"rect\"),\n  pcb_solder_paste_id: getZodPrefixedIdWithDefault(\"pcb_solder_paste\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  layer: layer_ref,\n  pcb_component_id: z.string().optional(),\n  pcb_smtpad_id: z.string().optional(),\n})\nconst pcb_solder_paste_pill = z.object({\n  type: z.literal(\"pcb_solder_paste\"),\n  shape: z.literal(\"pill\"),\n  pcb_solder_paste_id: getZodPrefixedIdWithDefault(\"pcb_solder_paste\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  radius: z.number(),\n  layer: layer_ref,\n  pcb_component_id: z.string().optional(),\n  pcb_smtpad_id: z.string().optional(),\n})\nconst pcb_solder_paste_rotated_rect = z.object({\n  type: z.literal(\"pcb_solder_paste\"),\n  shape: z.literal(\"rotated_rect\"),\n  pcb_solder_paste_id: getZodPrefixedIdWithDefault(\"pcb_solder_paste\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  ccw_rotation: distance,\n  layer: layer_ref,\n  pcb_component_id: z.string().optional(),\n  pcb_smtpad_id: z.string().optional(),\n})\n\nconst pcb_solder_paste_oval = z.object({\n  type: z.literal(\"pcb_solder_paste\"),\n  shape: z.literal(\"oval\"),\n  pcb_solder_paste_id: getZodPrefixedIdWithDefault(\"pcb_solder_paste\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  layer: layer_ref,\n  pcb_component_id: z.string().optional(),\n  pcb_smtpad_id: z.string().optional(),\n})\n\nexport const pcb_solder_paste = z\n  .union([\n    pcb_solder_paste_circle,\n    pcb_solder_paste_rect,\n    pcb_solder_paste_pill,\n    pcb_solder_paste_rotated_rect,\n    pcb_solder_paste_oval,\n  ])\n  .describe(\"Defines solderpaste on the PCB\")\n\nexport type PCBSolderPasteInput = z.input<typeof pcb_solder_paste>\ntype InferredPcbSolderPasteCircle = z.infer<typeof pcb_solder_paste_circle>\ntype InferredPcbSolderPasteRect = z.infer<typeof pcb_solder_paste_rect>\ntype InferredPcbSolderPastePill = z.infer<typeof pcb_solder_paste_pill>\ntype InferredPcbSolderPasteRotatedRect = z.infer<\n  typeof pcb_solder_paste_rotated_rect\n>\ntype InferredPcbSolderPasteOval = z.infer<typeof pcb_solder_paste_oval>\n\n/**\n * Defines solderpaste on the PCB\n */\nexport interface PcbSolderPasteCircle {\n  type: \"pcb_solder_paste\"\n  shape: \"circle\"\n  pcb_solder_paste_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  radius: number\n  layer: LayerRef\n  pcb_component_id?: string\n  pcb_smtpad_id?: string\n}\n\n/**\n * Defines solderpaste on the PCB\n */\nexport interface PcbSolderPasteRect {\n  type: \"pcb_solder_paste\"\n  shape: \"rect\"\n  pcb_solder_paste_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  layer: LayerRef\n  pcb_component_id?: string\n  pcb_smtpad_id?: string\n}\n/**\n * Defines solderpaste on the PCB\n */\nexport interface PcbSolderPastePill {\n  type: \"pcb_solder_paste\"\n  shape: \"pill\"\n  pcb_solder_paste_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  radius: number\n  layer: LayerRef\n  pcb_component_id?: string\n  pcb_smtpad_id?: string\n}\n/**\n * Defines solderpaste on the PCB\n */\nexport interface PcbSolderPasteRotatedRect {\n  type: \"pcb_solder_paste\"\n  shape: \"rotated_rect\"\n  pcb_solder_paste_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  ccw_rotation: Distance\n  layer: LayerRef\n  pcb_component_id?: string\n  pcb_smtpad_id?: string\n}\n/**\n * Defines solderpaste on the PCB\n */\nexport interface PcbSolderPasteOval {\n  type: \"pcb_solder_paste\"\n  shape: \"oval\"\n  pcb_solder_paste_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  layer: LayerRef\n  pcb_component_id?: string\n  pcb_smtpad_id?: string\n}\n\nexport type PcbSolderPaste =\n  | PcbSolderPasteCircle\n  | PcbSolderPasteRect\n  | PcbSolderPastePill\n  | PcbSolderPasteRotatedRect\n  | PcbSolderPasteOval\n\nexpectTypesMatch<PcbSolderPasteCircle, InferredPcbSolderPasteCircle>(true)\nexpectTypesMatch<PcbSolderPasteRect, InferredPcbSolderPasteRect>(true)\nexpectTypesMatch<PcbSolderPastePill, InferredPcbSolderPastePill>(true)\nexpectTypesMatch<PcbSolderPasteRotatedRect, InferredPcbSolderPasteRotatedRect>(\n  true,\n)\nexpectTypesMatch<PcbSolderPasteOval, InferredPcbSolderPasteOval>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_text = z\n  .object({\n    type: z.literal(\"pcb_text\"),\n    pcb_text_id: getZodPrefixedIdWithDefault(\"pcb_text\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    text: z.string(),\n    center: point,\n    layer: layer_ref,\n    width: length,\n    height: length,\n    lines: z.number(),\n    // @ts-ignore\n    align: z.enum([\"bottom-left\"]),\n  })\n  .describe(\"Defines text on the PCB\")\n\nexport type PcbTextInput = z.input<typeof pcb_text>\ntype InferredPcbText = z.infer<typeof pcb_text>\n\n/**\n * Defines text on the PCB\n */\nexport interface PcbText {\n  type: \"pcb_text\"\n  pcb_text_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  text: string\n  center: Point\n  layer: LayerRef\n  width: Length\n  height: Length\n  lines: number\n  // @ts-ignore\n  align: \"bottom-left\"\n}\n\n/**\n * @deprecated use PcbText\n */\nexport type PCBText = PcbText\n\nexpectTypesMatch<PcbText, InferredPcbText>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { distance, type Distance } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_trace_route_point_wire = z.object({\n  route_type: z.literal(\"wire\"),\n  x: distance,\n  y: distance,\n  width: distance,\n  start_pcb_port_id: z.string().optional(),\n  end_pcb_port_id: z.string().optional(),\n  layer: layer_ref,\n})\n\nexport const pcb_trace_route_point_via = z.object({\n  route_type: z.literal(\"via\"),\n  x: distance,\n  y: distance,\n  hole_diameter: distance.optional(),\n  outer_diameter: distance.optional(),\n  from_layer: z.string(),\n  to_layer: z.string(),\n})\n\nexport const pcb_trace_route_point = z.union([\n  pcb_trace_route_point_wire,\n  pcb_trace_route_point_via,\n])\ntype InferredPcbTraceRoutePoint = z.infer<typeof pcb_trace_route_point>\n\nexport const pcb_trace = z\n  .object({\n    type: z.literal(\"pcb_trace\"),\n    source_trace_id: z.string().optional(),\n    pcb_component_id: z.string().optional(),\n    pcb_trace_id: getZodPrefixedIdWithDefault(\"pcb_trace\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    route_thickness_mode: z\n      .enum([\"constant\", \"interpolated\"])\n      .default(\"constant\")\n      .optional(),\n    route_order_index: z.number().optional(),\n    should_round_corners: z.boolean().optional(),\n    trace_length: z.number().optional(),\n    highlight_color: z.string().optional(),\n    route: z.array(pcb_trace_route_point),\n  })\n  .describe(\"Defines a trace on the PCB\")\n\nexport type PcbTraceInput = z.input<typeof pcb_trace>\ntype InferredPcbTrace = z.infer<typeof pcb_trace>\n\nexport interface PcbTraceRoutePointWire {\n  route_type: \"wire\"\n  x: Distance\n  y: Distance\n  width: Distance\n  start_pcb_port_id?: string\n  end_pcb_port_id?: string\n  layer: LayerRef\n}\n\nexport interface PcbTraceRoutePointVia {\n  route_type: \"via\"\n  x: Distance\n  y: Distance\n  hole_diameter?: Distance\n  outer_diameter?: Distance\n  from_layer: string\n  to_layer: string\n}\n\nexport type PcbTraceRoutePoint = PcbTraceRoutePointWire | PcbTraceRoutePointVia\n\n/**\n * Defines a trace on the PCB\n */\nexport interface PcbTrace {\n  type: \"pcb_trace\"\n  source_trace_id?: string\n  pcb_component_id?: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  pcb_trace_id: string\n  /**\n   * The order that this trace was routed in. This can be used to debug the\n   * autorouter and to understand the trace path better\n   *\n   * The route_order_index should be relative to a subcircuit\n   */\n  route_order_index?: number\n  route_thickness_mode?: \"constant\" | \"interpolated\"\n  should_round_corners?: boolean\n  trace_length?: number\n  highlight_color?: string\n  route: Array<PcbTraceRoutePoint>\n}\n\n/**\n * @deprecated use PcbTrace\n */\nexport type PCBTrace = PcbTrace\n\n/**\n * @deprecated use PcbTraceInput\n */\nexport type PCBTraceInput = PcbTraceInput\n\nexpectTypesMatch<PcbTraceRoutePoint, InferredPcbTraceRoutePoint>(true)\nexpectTypesMatch<PcbTrace, InferredPcbTrace>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_trace_error = z\n  .object({\n    type: z.literal(\"pcb_trace_error\"),\n    pcb_trace_error_id: getZodPrefixedIdWithDefault(\"pcb_trace_error\"),\n    error_type: z.literal(\"pcb_trace_error\").default(\"pcb_trace_error\"),\n    message: z.string(),\n    center: point.optional(),\n    pcb_trace_id: z.string(),\n    source_trace_id: z.string(),\n    pcb_component_ids: z.array(z.string()),\n    pcb_port_ids: z.array(z.string()),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a trace error on the PCB\")\n\nexport type PcbTraceErrorInput = z.input<typeof pcb_trace_error>\ntype InferredPcbTraceError = z.infer<typeof pcb_trace_error>\n\n/**\n * Defines a trace error on the PCB\n */\nexport interface PcbTraceError {\n  type: \"pcb_trace_error\"\n  pcb_trace_error_id: string\n  error_type: \"pcb_trace_error\"\n  message: string\n  center?: Point\n  pcb_trace_id: string\n  source_trace_id: string\n  pcb_component_ids: string[]\n  pcb_port_ids: string[]\n  subcircuit_id?: string\n}\n\n/**\n * @deprecated use PcbTraceError\n */\nexport type PCBTraceError = PcbTraceError\n\nexpectTypesMatch<PcbTraceError, InferredPcbTraceError>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_trace_missing_error = z\n  .object({\n    type: z.literal(\"pcb_trace_missing_error\"),\n    pcb_trace_missing_error_id: getZodPrefixedIdWithDefault(\n      \"pcb_trace_missing_error\",\n    ),\n    error_type: z\n      .literal(\"pcb_trace_missing_error\")\n      .default(\"pcb_trace_missing_error\"),\n    message: z.string(),\n    center: point.optional(),\n    source_trace_id: z.string(),\n    pcb_component_ids: z.array(z.string()),\n    pcb_port_ids: z.array(z.string()),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\n    \"Defines an error when a source trace has no corresponding PCB trace\",\n  )\n\nexport type PcbTraceMissingErrorInput = z.input<typeof pcb_trace_missing_error>\ntype InferredPcbTraceMissingError = z.infer<typeof pcb_trace_missing_error>\n\n/**\n * Defines an error when a source trace has no corresponding PCB trace\n */\nexport interface PcbTraceMissingError {\n  type: \"pcb_trace_missing_error\"\n  pcb_trace_missing_error_id: string\n  error_type: \"pcb_trace_missing_error\"\n  message: string\n  center?: Point\n  source_trace_id: string\n  pcb_component_ids: string[]\n  pcb_port_ids: string[]\n  subcircuit_id?: string\n}\n\n/**\n * @deprecated use PcbTraceMissingError\n */\nexport type PCBTraceMissingError = PcbTraceMissingError\n\nexpectTypesMatch<PcbTraceMissingError, InferredPcbTraceMissingError>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_port_not_matched_error = z\n  .object({\n    type: z.literal(\"pcb_port_not_matched_error\"),\n    pcb_error_id: getZodPrefixedIdWithDefault(\"pcb_error\"),\n    error_type: z\n      .literal(\"pcb_port_not_matched_error\")\n      .default(\"pcb_port_not_matched_error\"),\n    message: z.string(),\n    pcb_component_ids: z.array(z.string()),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a trace error on the PCB where a port is not matched\")\n\nexport type PcbPortNotMatchedErrorInput = z.input<\n  typeof pcb_port_not_matched_error\n>\ntype InferredPcbPortNotMatchedError = z.infer<typeof pcb_port_not_matched_error>\n\n/**\n * Defines a trace error on the PCB where a port is not matched\n */\nexport interface PcbPortNotMatchedError {\n  type: \"pcb_port_not_matched_error\"\n  pcb_error_id: string\n  error_type: \"pcb_port_not_matched_error\"\n  message: string\n  pcb_component_ids: string[]\n  subcircuit_id?: string\n}\n\n/**\n * @deprecated use PcbPortNotMatchedError\n */\nexport type PCBPortNotMatchedError = PcbPortNotMatchedError\n\nexpectTypesMatch<PcbPortNotMatchedError, InferredPcbPortNotMatchedError>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_port_not_connected_error = z\n  .object({\n    type: z.literal(\"pcb_port_not_connected_error\"),\n    pcb_port_not_connected_error_id: getZodPrefixedIdWithDefault(\n      \"pcb_port_not_connected_error\",\n    ),\n    error_type: z\n      .literal(\"pcb_port_not_connected_error\")\n      .default(\"pcb_port_not_connected_error\"),\n    message: z.string(),\n    pcb_port_ids: z.array(z.string()),\n    pcb_component_ids: z.array(z.string()),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines an error when a pcb port is not connected to any trace\")\n\nexport type PcbPortNotConnectedErrorInput = z.input<\n  typeof pcb_port_not_connected_error\n>\ntype InferredPcbPortNotConnectedError = z.infer<\n  typeof pcb_port_not_connected_error\n>\n\n/**\n * Defines an error when a pcb port is not connected to any trace\n */\nexport interface PcbPortNotConnectedError {\n  type: \"pcb_port_not_connected_error\"\n  pcb_port_not_connected_error_id: string\n  error_type: \"pcb_port_not_connected_error\"\n  message: string\n  pcb_port_ids: string[]\n  pcb_component_ids: string[]\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<PcbPortNotConnectedError, InferredPcbPortNotConnectedError>(\n  true,\n)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_net = z\n  .object({\n    type: z.literal(\"pcb_net\"),\n    pcb_net_id: getZodPrefixedIdWithDefault(\"pcb_net\"),\n    source_net_id: z.string().optional(),\n    highlight_color: z.string().optional(),\n  })\n  .describe(\"Defines a net on the PCB\")\n\nexport type PcbNetInput = z.input<typeof pcb_net>\ntype InferredPcbNet = z.infer<typeof pcb_net>\n\n/**\n * Defines a net on the PCB\n */\nexport interface PcbNet {\n  type: \"pcb_net\"\n  pcb_net_id: string\n  source_net_id?: string\n  highlight_color?: string\n}\n\nexpectTypesMatch<PcbNet, InferredPcbNet>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance } from \"src/units\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_via = z\n  .object({\n    type: z.literal(\"pcb_via\"),\n    pcb_via_id: getZodPrefixedIdWithDefault(\"pcb_via\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    subcircuit_connectivity_map_key: z.string().optional(),\n    x: distance,\n    y: distance,\n    outer_diameter: distance.default(\"0.6mm\"),\n    hole_diameter: distance.default(\"0.25mm\"),\n    /** @deprecated */\n    from_layer: layer_ref.optional(),\n    /** @deprecated */\n    to_layer: layer_ref.optional(),\n    layers: z.array(layer_ref),\n    pcb_trace_id: z.string().optional(),\n    net_is_assignable: z.boolean().optional(),\n    net_assigned: z.boolean().optional(),\n  })\n  .describe(\"Defines a via on the PCB\")\n\nexport type PcbViaInput = z.input<typeof pcb_via>\ntype InferredPcbVia = z.infer<typeof pcb_via>\n\n/**\n * Defines a via on the PCB\n */\nexport interface PcbVia {\n  type: \"pcb_via\"\n  pcb_via_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  subcircuit_connectivity_map_key?: string\n  x: Distance\n  y: Distance\n  outer_diameter: Distance\n  hole_diameter: Distance\n  /** @deprecated */\n  from_layer?: LayerRef\n  /** @deprecated */\n  to_layer?: LayerRef\n  layers: LayerRef[]\n  pcb_trace_id?: string\n  net_is_assignable?: boolean\n  net_assigned?: boolean\n}\n\n/**\n * @deprecated use PcbVia\n */\nexport type PCBVia = PcbVia\n\nexpectTypesMatch<PcbVia, InferredPcbVia>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_board = z\n  .object({\n    type: z.literal(\"pcb_board\"),\n    pcb_board_id: getZodPrefixedIdWithDefault(\"pcb_board\"),\n    pcb_panel_id: z.string().optional(),\n    is_subcircuit: z.boolean().optional(),\n    subcircuit_id: z.string().optional(),\n    width: length.optional(),\n    height: length.optional(),\n    center: point,\n    thickness: length.optional().default(1.4),\n    num_layers: z.number().optional().default(4),\n    outline: z.array(point).optional(),\n    shape: z.enum([\"rect\", \"polygon\"]).optional(),\n    material: z.enum([\"fr4\", \"fr1\"]).default(\"fr4\"),\n  })\n  .describe(\"Defines the board outline of the PCB\")\n\n/**\n * Defines the board outline of the PCB\n */\nexport interface PcbBoard {\n  type: \"pcb_board\"\n  pcb_board_id: string\n  pcb_panel_id?: string\n  is_subcircuit?: boolean\n  subcircuit_id?: string\n  width?: Length\n  height?: Length\n  thickness: Length\n  num_layers: number\n  center: Point\n  outline?: Point[]\n  shape?: \"rect\" | \"polygon\"\n  material: \"fr4\" | \"fr1\"\n}\n\nexport type PcbBoardInput = z.input<typeof pcb_board>\ntype InferredPcbBoard = z.infer<typeof pcb_board>\n\n/**\n * @deprecated use PcbBoard\n */\nexport type PCBBoard = PcbBoard\n\nexpectTypesMatch<PcbBoard, InferredPcbBoard>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault, point, type Point } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_panel = z\n  .object({\n    type: z.literal(\"pcb_panel\"),\n    pcb_panel_id: getZodPrefixedIdWithDefault(\"pcb_panel\"),\n    width: length,\n    height: length,\n    center: point,\n    covered_with_solder_mask: z.boolean().optional().default(true),\n  })\n  .describe(\"Defines a PCB panel that can contain multiple boards\")\n\n/**\n * Defines a PCB panel that can contain multiple boards\n */\nexport interface PcbPanel {\n  type: \"pcb_panel\"\n  pcb_panel_id: string\n  width: Length\n  height: Length\n  center: Point\n  covered_with_solder_mask: boolean\n}\n\nexport type PcbPanelInput = z.input<typeof pcb_panel>\ntype InferredPcbPanel = z.infer<typeof pcb_panel>\n\n/**\n * @deprecated use PcbPanel\n */\nexport type PCBPanel = PcbPanel\n\nexpectTypesMatch<PcbPanel, InferredPcbPanel>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_placement_error = z\n  .object({\n    type: z.literal(\"pcb_placement_error\"),\n    pcb_placement_error_id: getZodPrefixedIdWithDefault(\"pcb_placement_error\"),\n    error_type: z.literal(\"pcb_placement_error\").default(\"pcb_placement_error\"),\n    message: z.string(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a placement error on the PCB\")\n\nexport type PcbPlacementErrorInput = z.input<typeof pcb_placement_error>\ntype InferredPcbPlacementError = z.infer<typeof pcb_placement_error>\n\n/**\n * Defines a placement error on the PCB\n */\nexport interface PcbPlacementError {\n  type: \"pcb_placement_error\"\n  pcb_placement_error_id: string\n  error_type: \"pcb_placement_error\"\n  message: string\n  subcircuit_id?: string\n}\n\n/**\n * @deprecated use PcbPlacementError\n */\nexport type PCBPlacementError = PcbPlacementError\n\nexpectTypesMatch<PcbPlacementError, InferredPcbPlacementError>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { route_hint_point, type RouteHintPoint } from \"src/pcb\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\n/**\n * A hint that can be used during generation of a PCB trace.\n */\nexport interface PcbTraceHint {\n  type: \"pcb_trace_hint\"\n  pcb_trace_hint_id: string\n  pcb_port_id: string\n  pcb_component_id: string\n  route: RouteHintPoint[]\n  subcircuit_id?: string\n}\n\nexport const pcb_trace_hint = z\n  .object({\n    type: z.literal(\"pcb_trace_hint\"),\n    pcb_trace_hint_id: getZodPrefixedIdWithDefault(\"pcb_trace_hint\"),\n    pcb_port_id: z.string(),\n    pcb_component_id: z.string(),\n    route: z.array(route_hint_point),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"A hint that can be used during generation of a PCB trace\")\n\nexport type PcbTraceHintInput = z.input<typeof pcb_trace_hint>\ntype InferredPcbTraceHint = z.infer<typeof pcb_trace_hint>\n\n/**\n * @deprecated use PcbTraceHint\n */\nexport type PCBTraceHint = PcbTraceHint\n\nexpectTypesMatch<PcbTraceHint, InferredPcbTraceHint>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance } from \"src/units\"\nimport {\n  layer_ref,\n  type LayerRef,\n  type VisibleLayer,\n  visible_layer,\n} from \"src/pcb/properties/layer_ref\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_silkscreen_line = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_line\"),\n    pcb_silkscreen_line_id: getZodPrefixedIdWithDefault(\"pcb_silkscreen_line\"),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    stroke_width: distance.default(\"0.1mm\"),\n    x1: distance,\n    y1: distance,\n    x2: distance,\n    y2: distance,\n    layer: visible_layer,\n  })\n  .describe(\"Defines a silkscreen line on the PCB\")\n\nexport type PcbSilkscreenLineInput = z.input<typeof pcb_silkscreen_line>\ntype InferredPcbSilkscreenLine = z.infer<typeof pcb_silkscreen_line>\n\n/**\n * Defines a silkscreen line on the PCB\n */\nexport interface PcbSilkscreenLine {\n  type: \"pcb_silkscreen_line\"\n  pcb_silkscreen_line_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  stroke_width: Distance\n  x1: Distance\n  y1: Distance\n  x2: Distance\n  y2: Distance\n  layer: VisibleLayer\n}\n\n/**\n * @deprecated use PcbSilkscreenLine\n */\nexport type PCBSilkscreenLine = PcbSilkscreenLine\n\nexpectTypesMatch<PcbSilkscreenLine, InferredPcbSilkscreenLine>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport {\n  visible_layer,\n  type VisibleLayerRef,\n} from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_silkscreen_path = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_path\"),\n    pcb_silkscreen_path_id: getZodPrefixedIdWithDefault(\"pcb_silkscreen_path\"),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    layer: visible_layer,\n    route: z.array(point),\n    stroke_width: length,\n  })\n  .describe(\"Defines a silkscreen path on the PCB\")\n\nexport type PcbSilkscreenPathInput = z.input<typeof pcb_silkscreen_path>\ntype InferredPcbSilkscreenPath = z.infer<typeof pcb_silkscreen_path>\n\n/**\n * Defines a silkscreen path on the PCB\n */\nexport interface PcbSilkscreenPath {\n  type: \"pcb_silkscreen_path\"\n  pcb_silkscreen_path_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  layer: VisibleLayerRef\n  route: Point[]\n  stroke_width: Length\n}\n\n/**\n * @deprecated use PcbSilkscreenPath\n */\nexport type PcbSilkscreenPathDeprecated = PcbSilkscreenPath\n\nexpectTypesMatch<PcbSilkscreenPath, InferredPcbSilkscreenPath>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { distance, length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport {\n  ninePointAnchor,\n  type NinePointAnchor,\n} from \"src/common/NinePointAnchor\"\n\nexport const pcb_silkscreen_text = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_text\"),\n    pcb_silkscreen_text_id: getZodPrefixedIdWithDefault(\"pcb_silkscreen_text\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    font: z.literal(\"tscircuit2024\").default(\"tscircuit2024\"),\n    font_size: distance.default(\"0.2mm\"),\n    pcb_component_id: z.string(),\n    text: z.string(),\n    is_knockout: z.boolean().default(false).optional(),\n    knockout_padding: z\n      .object({\n        left: length,\n        top: length,\n        bottom: length,\n        right: length,\n      })\n      .default({\n        left: \"0.2mm\",\n        top: \"0.2mm\",\n        bottom: \"0.2mm\",\n        right: \"0.2mm\",\n      })\n      .optional(),\n    ccw_rotation: z.number().optional(),\n    layer: layer_ref,\n    is_mirrored: z.boolean().default(false).optional(),\n    anchor_position: point.default({ x: 0, y: 0 }),\n    anchor_alignment: ninePointAnchor.default(\"center\"),\n  })\n  .describe(\"Defines silkscreen text on the PCB\")\n\nexport type PcbSilkscreenTextInput = z.input<typeof pcb_silkscreen_text>\ntype InferredPcbSilkscreenText = z.infer<typeof pcb_silkscreen_text>\n\n/**\n * Defines silkscreen text on the PCB\n */\nexport interface PcbSilkscreenText {\n  type: \"pcb_silkscreen_text\"\n  pcb_silkscreen_text_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  font: \"tscircuit2024\"\n  font_size: Length\n  pcb_component_id: string\n  text: string\n  is_knockout?: boolean\n  knockout_padding?: {\n    left: Length\n    top: Length\n    bottom: Length\n    right: Length\n  }\n  ccw_rotation?: number\n  layer: LayerRef\n  is_mirrored?: boolean\n  anchor_position: Point\n  anchor_alignment: NinePointAnchor\n}\n\n/**\n * @deprecated use PcbSilkscreenText\n */\nexport type PCBSilkscreenText = PcbSilkscreenText\n\nexpectTypesMatch<PcbSilkscreenText, InferredPcbSilkscreenText>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { distance, length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport {\n  ninePointAnchor,\n  type NinePointAnchor,\n} from \"src/common/NinePointAnchor\"\n\nexport const pcb_copper_text = z\n  .object({\n    type: z.literal(\"pcb_copper_text\"),\n    pcb_copper_text_id: getZodPrefixedIdWithDefault(\"pcb_copper_text\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    font: z.literal(\"tscircuit2024\").default(\"tscircuit2024\"),\n    font_size: distance.default(\"0.2mm\"),\n    pcb_component_id: z.string(),\n    text: z.string(),\n    is_knockout: z.boolean().default(false).optional(),\n    knockout_padding: z\n      .object({\n        left: length,\n        top: length,\n        bottom: length,\n        right: length,\n      })\n      .default({\n        left: \"0.2mm\",\n        top: \"0.2mm\",\n        bottom: \"0.2mm\",\n        right: \"0.2mm\",\n      })\n      .optional(),\n    ccw_rotation: z.number().optional(),\n    layer: layer_ref,\n    is_mirrored: z.boolean().default(false).optional(),\n    anchor_position: point.default({ x: 0, y: 0 }),\n    anchor_alignment: ninePointAnchor.default(\"center\"),\n  })\n  .describe(\"Defines copper text on the PCB\")\n\nexport type PcbCopperTextInput = z.input<typeof pcb_copper_text>\ntype InferredPcbCopperText = z.infer<typeof pcb_copper_text>\n\n/**\n * Defines copper text on the PCB\n */\nexport interface PcbCopperText {\n  type: \"pcb_copper_text\"\n  pcb_copper_text_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  font: \"tscircuit2024\"\n  font_size: Length\n  pcb_component_id: string\n  text: string\n  is_knockout?: boolean\n  knockout_padding?: {\n    left: Length\n    top: Length\n    bottom: Length\n    right: Length\n  }\n  ccw_rotation?: number\n  layer: LayerRef\n  is_mirrored?: boolean\n  anchor_position: Point\n  anchor_alignment: NinePointAnchor\n}\n\n/**\n * @deprecated use PcbCopperText\n */\nexport type PCBCopperText = PcbCopperText\n\nexpectTypesMatch<PcbCopperText, InferredPcbCopperText>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_silkscreen_rect = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_rect\"),\n    pcb_silkscreen_rect_id: getZodPrefixedIdWithDefault(\"pcb_silkscreen_rect\"),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    center: point,\n    width: length,\n    height: length,\n    layer: layer_ref,\n    stroke_width: length.default(\"1mm\"),\n    corner_radius: length.optional(),\n    is_filled: z.boolean().default(true).optional(),\n    has_stroke: z.boolean().optional(),\n    is_stroke_dashed: z.boolean().optional(),\n  })\n  .describe(\"Defines a silkscreen rect on the PCB\")\n\nexport type PcbSilkscreenRectInput = z.input<typeof pcb_silkscreen_rect>\ntype InferredPcbSilkscreenRect = z.infer<typeof pcb_silkscreen_rect>\n\n/**\n * Defines a silkscreen rect on the PCB\n */\nexport interface PcbSilkscreenRect {\n  type: \"pcb_silkscreen_rect\"\n  pcb_silkscreen_rect_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  width: Length\n  height: Length\n  layer: LayerRef\n  stroke_width: Length\n  corner_radius?: Length\n  is_filled?: boolean\n  has_stroke?: boolean\n  is_stroke_dashed?: boolean\n}\n\n/**\n * @deprecated use PcbSilkscreenRect\n */\nexport type PcbSilkscreenRectOld = PcbSilkscreenRect\n\nexpectTypesMatch<PcbSilkscreenRect, InferredPcbSilkscreenRect>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport {\n  layer_ref,\n  visible_layer,\n  type LayerRef,\n  type VisibleLayer,\n} from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_silkscreen_circle = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_circle\"),\n    pcb_silkscreen_circle_id: getZodPrefixedIdWithDefault(\n      \"pcb_silkscreen_circle\",\n    ),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    center: point,\n    radius: length,\n    layer: visible_layer,\n    stroke_width: length.default(\"1mm\"),\n  })\n  .describe(\"Defines a silkscreen circle on the PCB\")\n\nexport type PcbSilkscreenCircleInput = z.input<typeof pcb_silkscreen_circle>\ntype InferredPcbSilkscreenCircle = z.infer<typeof pcb_silkscreen_circle>\n\n/**\n * Defines a silkscreen circle on the PCB\n */\nexport interface PcbSilkscreenCircle {\n  type: \"pcb_silkscreen_circle\"\n  pcb_silkscreen_circle_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  radius: Length\n  layer: VisibleLayer\n  stroke_width: Length\n}\n\nexpectTypesMatch<PcbSilkscreenCircle, InferredPcbSilkscreenCircle>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport {\n  layer_ref,\n  type LayerRef,\n  visible_layer,\n  type VisibleLayer,\n} from \"src/pcb/properties/layer_ref\"\nimport { distance, type Distance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_silkscreen_oval = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_oval\"),\n    pcb_silkscreen_oval_id: getZodPrefixedIdWithDefault(\"pcb_silkscreen_oval\"),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    center: point,\n    radius_x: distance,\n    radius_y: distance,\n    layer: visible_layer,\n  })\n  .describe(\"Defines a silkscreen oval on the PCB\")\n\nexport type PcbSilkscreenOvalInput = z.input<typeof pcb_silkscreen_oval>\ntype InferredPcbSilkscreenOval = z.infer<typeof pcb_silkscreen_oval>\n\n/**\n * Defines a silkscreen oval on the PCB\n */\nexport interface PcbSilkscreenOval {\n  type: \"pcb_silkscreen_oval\"\n  pcb_silkscreen_oval_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  radius_x: Distance\n  radius_y: Distance\n  layer: VisibleLayer\n}\n\n/**\n * @deprecated use PcbSilkscreenOval\n */\nexport type PcbSilkscreenOvalDeprecated = PcbSilkscreenOval\n\nexpectTypesMatch<PcbSilkscreenOval, InferredPcbSilkscreenOval>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"src/common\"\nimport { distance, type Length } from \"src/units\"\nimport {\n  visible_layer,\n  type LayerRef,\n  type VisibleLayer,\n} from \"src/pcb/properties/layer_ref\"\nimport { getZodPrefixedIdWithDefault } from \"src/common/getZodPrefixedIdWithDefault\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_fabrication_note_text = z\n  .object({\n    type: z.literal(\"pcb_fabrication_note_text\"),\n    pcb_fabrication_note_text_id: getZodPrefixedIdWithDefault(\n      \"pcb_fabrication_note_text\",\n    ),\n    subcircuit_id: z.string().optional(),\n    pcb_group_id: z.string().optional(),\n    font: z.literal(\"tscircuit2024\").default(\"tscircuit2024\"),\n    font_size: distance.default(\"1mm\"),\n    pcb_component_id: z.string(),\n    text: z.string(),\n    layer: visible_layer,\n    anchor_position: point.default({ x: 0, y: 0 }),\n    anchor_alignment: z\n      .enum([\"center\", \"top_left\", \"top_right\", \"bottom_left\", \"bottom_right\"])\n      .default(\"center\"),\n    color: z.string().optional(),\n  })\n  .describe(\n    \"Defines a fabrication note in text on the PCB, useful for leaving notes for assemblers or fabricators\",\n  )\n\nexport type PcbFabricationNoteTextInput = z.input<\n  typeof pcb_fabrication_note_text\n>\ntype InferredPcbFabricationNoteText = z.infer<typeof pcb_fabrication_note_text>\n\n/**\n * Defines a fabrication note in text on the PCB, useful for leaving notes for assemblers or fabricators\n */\nexport interface PcbFabricationNoteText {\n  type: \"pcb_fabrication_note_text\"\n  pcb_fabrication_note_text_id: string\n  subcircuit_id?: string\n  pcb_group_id?: string\n  font: \"tscircuit2024\"\n  font_size: Length\n  pcb_component_id: string\n  text: string\n  layer: VisibleLayer\n  anchor_position: Point\n  anchor_alignment:\n    | \"center\"\n    | \"top_left\"\n    | \"top_right\"\n    | \"bottom_left\"\n    | \"bottom_right\"\n  color?: string\n}\n\n/**\n * @deprecated use PcbFabricationNoteText\n */\nexport type PCBFabricationNoteText = PcbFabricationNoteText\n\nexpectTypesMatch<PcbFabricationNoteText, InferredPcbFabricationNoteText>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport {\n  layer_ref,\n  visible_layer,\n  type LayerRef,\n} from \"src/pcb/properties/layer_ref\"\nimport { point, type Point } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_fabrication_note_path = z\n  .object({\n    type: z.literal(\"pcb_fabrication_note_path\"),\n    pcb_fabrication_note_path_id: getZodPrefixedIdWithDefault(\n      \"pcb_fabrication_note_path\",\n    ),\n    pcb_component_id: z.string(),\n    subcircuit_id: z.string().optional(),\n    layer: layer_ref,\n    route: z.array(point),\n    stroke_width: length,\n    color: z.string().optional(),\n  })\n  .describe(\n    \"Defines a fabrication path on the PCB for fabricators or assemblers\",\n  )\n\nexport type PcbFabricationNotePathInput = z.input<\n  typeof pcb_fabrication_note_path\n>\ntype InferredPcbFabricationNotePath = z.infer<typeof pcb_fabrication_note_path>\n\n/**\n * Defines a fabrication path on the PCB for fabricators or assemblers\n */\nexport interface PcbFabricationNotePath {\n  type: \"pcb_fabrication_note_path\"\n  pcb_fabrication_note_path_id: string\n  pcb_component_id: string\n  subcircuit_id?: string\n  layer: LayerRef\n  route: Point[]\n  stroke_width: Length\n  color?: string\n}\n\n/**\n * @deprecated use PcbFabricationNotePath\n */\nexport type PCBFabricationNotePath = PcbFabricationNotePath\n\nexpectTypesMatch<PcbFabricationNotePath, InferredPcbFabricationNotePath>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { visible_layer, type VisibleLayer } from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_fabrication_note_rect = z\n  .object({\n    type: z.literal(\"pcb_fabrication_note_rect\"),\n    pcb_fabrication_note_rect_id: getZodPrefixedIdWithDefault(\n      \"pcb_fabrication_note_rect\",\n    ),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    center: point,\n    width: length,\n    height: length,\n    layer: visible_layer,\n    stroke_width: length.default(\"0.1mm\"),\n    corner_radius: length.optional(),\n    is_filled: z.boolean().optional(),\n    has_stroke: z.boolean().optional(),\n    is_stroke_dashed: z.boolean().optional(),\n    color: z.string().optional(),\n  })\n  .describe(\"Defines a fabrication note rectangle on the PCB\")\n\nexport type PcbFabricationNoteRectInput = z.input<\n  typeof pcb_fabrication_note_rect\n>\ntype InferredPcbFabricationNoteRect = z.infer<typeof pcb_fabrication_note_rect>\n\n/**\n * Defines a fabrication note rectangle on the PCB\n */\nexport interface PcbFabricationNoteRect {\n  type: \"pcb_fabrication_note_rect\"\n  pcb_fabrication_note_rect_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  width: Length\n  height: Length\n  layer: VisibleLayer\n  stroke_width: Length\n  corner_radius?: Length\n  is_filled?: boolean\n  has_stroke?: boolean\n  is_stroke_dashed?: boolean\n  color?: string\n}\n\n/**\n * @deprecated use PcbFabricationNoteRect\n */\nexport type PCBFabricationNoteRect = PcbFabricationNoteRect\n\nexpectTypesMatch<PcbFabricationNoteRect, InferredPcbFabricationNoteRect>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { visible_layer, type VisibleLayer } from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_fabrication_note_dimension = z\n  .object({\n    type: z.literal(\"pcb_fabrication_note_dimension\"),\n    pcb_fabrication_note_dimension_id: getZodPrefixedIdWithDefault(\n      \"pcb_fabrication_note_dimension\",\n    ),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    layer: visible_layer,\n    from: point,\n    to: point,\n    text: z.string().optional(),\n    text_ccw_rotation: z.number().optional(),\n    offset: length.optional(),\n    offset_distance: length.optional(),\n    offset_direction: z\n      .object({\n        x: z.number(),\n        y: z.number(),\n      })\n      .optional(),\n    font: z.literal(\"tscircuit2024\").default(\"tscircuit2024\"),\n    font_size: length.default(\"1mm\"),\n    color: z.string().optional(),\n    arrow_size: length.default(\"1mm\"),\n  })\n  .describe(\"Defines a measurement annotation within PCB fabrication notes\")\n\nexport type PcbFabricationNoteDimensionInput = z.input<\n  typeof pcb_fabrication_note_dimension\n>\ntype InferredPcbFabricationNoteDimension = z.infer<\n  typeof pcb_fabrication_note_dimension\n>\n\n/**\n * Defines a measurement annotation within PCB fabrication notes\n */\nexport interface PcbFabricationNoteDimension {\n  type: \"pcb_fabrication_note_dimension\"\n  pcb_fabrication_note_dimension_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  layer: VisibleLayer\n  from: Point\n  to: Point\n  text?: string\n  text_ccw_rotation?: number\n  offset?: Length\n  offset_distance?: Length\n  offset_direction?: {\n    x: number\n    y: number\n  }\n  font: \"tscircuit2024\"\n  font_size: Length\n  color?: string\n  arrow_size: Length\n}\n\n/**\n * @deprecated use PcbFabricationNoteDimension\n */\nexport type PCBFabricationNoteDimension = PcbFabricationNoteDimension\n\nexpectTypesMatch<\n  PcbFabricationNoteDimension,\n  InferredPcbFabricationNoteDimension\n>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { distance, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_note_text = z\n  .object({\n    type: z.literal(\"pcb_note_text\"),\n    pcb_note_text_id: getZodPrefixedIdWithDefault(\"pcb_note_text\"),\n    pcb_component_id: z.string().optional(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    name: z.string().optional(),\n    font: z.literal(\"tscircuit2024\").default(\"tscircuit2024\"),\n    font_size: distance.default(\"1mm\"),\n    text: z.string().optional(),\n    anchor_position: point.default({ x: 0, y: 0 }),\n    anchor_alignment: z\n      .enum([\"center\", \"top_left\", \"top_right\", \"bottom_left\", \"bottom_right\"])\n      .default(\"center\"),\n    color: z.string().optional(),\n  })\n  .describe(\"Defines a documentation note in text on the PCB\")\n\nexport type PcbNoteTextInput = z.input<typeof pcb_note_text>\ntype InferredPcbNoteText = z.infer<typeof pcb_note_text>\n\n/**\n * Defines a documentation note in text on the PCB\n */\nexport interface PcbNoteText {\n  type: \"pcb_note_text\"\n  pcb_note_text_id: string\n  pcb_component_id?: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  name?: string\n  font: \"tscircuit2024\"\n  font_size: Length\n  text?: string\n  anchor_position: Point\n  anchor_alignment:\n    | \"center\"\n    | \"top_left\"\n    | \"top_right\"\n    | \"bottom_left\"\n    | \"bottom_right\"\n  color?: string\n}\n\nexpectTypesMatch<PcbNoteText, InferredPcbNoteText>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_note_rect = z\n  .object({\n    type: z.literal(\"pcb_note_rect\"),\n    pcb_note_rect_id: getZodPrefixedIdWithDefault(\"pcb_note_rect\"),\n    pcb_component_id: z.string().optional(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    name: z.string().optional(),\n    text: z.string().optional(),\n    center: point,\n    width: length,\n    height: length,\n    stroke_width: length.default(\"0.1mm\"),\n    corner_radius: length.optional(),\n    is_filled: z.boolean().optional(),\n    has_stroke: z.boolean().optional(),\n    is_stroke_dashed: z.boolean().optional(),\n    color: z.string().optional(),\n  })\n  .describe(\"Defines a rectangular documentation note on the PCB\")\n\nexport type PcbNoteRectInput = z.input<typeof pcb_note_rect>\ntype InferredPcbNoteRect = z.infer<typeof pcb_note_rect>\n\n/**\n * Defines a rectangular documentation note on the PCB\n */\nexport interface PcbNoteRect {\n  type: \"pcb_note_rect\"\n  pcb_note_rect_id: string\n  pcb_component_id?: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  name?: string\n  text?: string\n  center: Point\n  width: Length\n  height: Length\n  stroke_width: Length\n  corner_radius?: Length\n  is_filled?: boolean\n  has_stroke?: boolean\n  is_stroke_dashed?: boolean\n  color?: string\n}\n\nexpectTypesMatch<PcbNoteRect, InferredPcbNoteRect>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_note_path = z\n  .object({\n    type: z.literal(\"pcb_note_path\"),\n    pcb_note_path_id: getZodPrefixedIdWithDefault(\"pcb_note_path\"),\n    pcb_component_id: z.string().optional(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    name: z.string().optional(),\n    text: z.string().optional(),\n    route: z.array(point),\n    stroke_width: length.default(\"0.1mm\"),\n    color: z.string().optional(),\n  })\n  .describe(\"Defines a polyline documentation note on the PCB\")\n\nexport type PcbNotePathInput = z.input<typeof pcb_note_path>\ntype InferredPcbNotePath = z.infer<typeof pcb_note_path>\n\n/**\n * Defines a polyline documentation note on the PCB\n */\nexport interface PcbNotePath {\n  type: \"pcb_note_path\"\n  pcb_note_path_id: string\n  pcb_component_id?: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  name?: string\n  text?: string\n  route: Point[]\n  stroke_width: Length\n  color?: string\n}\n\nexpectTypesMatch<PcbNotePath, InferredPcbNotePath>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { distance, type Distance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_note_line = z\n  .object({\n    type: z.literal(\"pcb_note_line\"),\n    pcb_note_line_id: getZodPrefixedIdWithDefault(\"pcb_note_line\"),\n    pcb_component_id: z.string().optional(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    name: z.string().optional(),\n    text: z.string().optional(),\n    x1: distance,\n    y1: distance,\n    x2: distance,\n    y2: distance,\n    stroke_width: distance.default(\"0.1mm\"),\n    color: z.string().optional(),\n    is_dashed: z.boolean().optional(),\n  })\n  .describe(\"Defines a straight documentation note line on the PCB\")\n\nexport type PcbNoteLineInput = z.input<typeof pcb_note_line>\ntype InferredPcbNoteLine = z.infer<typeof pcb_note_line>\n\n/**\n * Defines a straight documentation note line on the PCB\n */\nexport interface PcbNoteLine {\n  type: \"pcb_note_line\"\n  pcb_note_line_id: string\n  pcb_component_id?: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  name?: string\n  text?: string\n  x1: Distance\n  y1: Distance\n  x2: Distance\n  y2: Distance\n  stroke_width: Distance\n  color?: string\n  is_dashed?: boolean\n}\n\nexpectTypesMatch<PcbNoteLine, InferredPcbNoteLine>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_note_dimension = z\n  .object({\n    type: z.literal(\"pcb_note_dimension\"),\n    pcb_note_dimension_id: getZodPrefixedIdWithDefault(\"pcb_note_dimension\"),\n    pcb_component_id: z.string().optional(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    name: z.string().optional(),\n    from: point,\n    to: point,\n    text: z.string().optional(),\n    text_ccw_rotation: z.number().optional(),\n    offset_distance: length.optional(),\n    offset_direction: z\n      .object({\n        x: z.number(),\n        y: z.number(),\n      })\n      .optional(),\n    font: z.literal(\"tscircuit2024\").default(\"tscircuit2024\"),\n    font_size: length.default(\"1mm\"),\n    color: z.string().optional(),\n    arrow_size: length.default(\"1mm\"),\n  })\n  .describe(\"Defines a measurement annotation within PCB documentation notes\")\n\nexport type PcbNoteDimensionInput = z.input<typeof pcb_note_dimension>\ntype InferredPcbNoteDimension = z.infer<typeof pcb_note_dimension>\n\n/**\n * Defines a measurement annotation within PCB documentation notes\n */\nexport interface PcbNoteDimension {\n  type: \"pcb_note_dimension\"\n  pcb_note_dimension_id: string\n  pcb_component_id?: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  name?: string\n  from: Point\n  to: Point\n  text?: string\n  text_ccw_rotation?: number\n  offset_distance?: Length\n  offset_direction?: {\n    x: number\n    y: number\n  }\n  font: \"tscircuit2024\"\n  font_size: Length\n  color?: string\n  arrow_size: Length\n}\n\nexpectTypesMatch<PcbNoteDimension, InferredPcbNoteDimension>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_footprint_overlap_error = z\n  .object({\n    type: z.literal(\"pcb_footprint_overlap_error\"),\n    pcb_error_id: getZodPrefixedIdWithDefault(\"pcb_error\"),\n    error_type: z\n      .literal(\"pcb_footprint_overlap_error\")\n      .default(\"pcb_footprint_overlap_error\"),\n    message: z.string(),\n    pcb_smtpad_ids: z.array(z.string()).optional(),\n    pcb_plated_hole_ids: z.array(z.string()).optional(),\n    pcb_hole_ids: z.array(z.string()).optional(),\n    pcb_keepout_ids: z.array(z.string()).optional(),\n  })\n  .describe(\"Error emitted when a pcb footprint overlaps with another element\")\n\nexport type PcbFootprintOverlapErrorInput = z.input<\n  typeof pcb_footprint_overlap_error\n>\ntype InferredPcbFootprintOverlapError = z.infer<\n  typeof pcb_footprint_overlap_error\n>\n\n/** Error emitted when a pcb footprint overlaps with another element */\nexport interface PcbFootprintOverlapError {\n  type: \"pcb_footprint_overlap_error\"\n  pcb_error_id: string\n  error_type: \"pcb_footprint_overlap_error\"\n  message: string\n  pcb_smtpad_ids?: string[]\n  pcb_plated_hole_ids?: string[]\n  pcb_hole_ids?: string[]\n  pcb_keepout_ids?: string[]\n}\n\nexpectTypesMatch<PcbFootprintOverlapError, InferredPcbFootprintOverlapError>(\n  true,\n)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_keepout = z\n  .object({\n    type: z.literal(\"pcb_keepout\"),\n    shape: z.literal(\"rect\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    center: point,\n    width: distance,\n    height: distance,\n    pcb_keepout_id: z.string(),\n    layers: z.array(z.string()), // Specify layers where the keepout applies\n    description: z.string().optional(), // Optional description of the keepout\n  })\n  .or(\n    z.object({\n      type: z.literal(\"pcb_keepout\"),\n      shape: z.literal(\"circle\"),\n      pcb_group_id: z.string().optional(),\n      subcircuit_id: z.string().optional(),\n      center: point,\n      radius: distance,\n      pcb_keepout_id: z.string(),\n      layers: z.array(z.string()), // Specify layers where the keepout applies\n      description: z.string().optional(), // Optional description of the keepout\n    }),\n  )\n\nexport type PCBKeepoutInput = z.input<typeof pcb_keepout>\ntype InferredPCBKeepout = z.infer<typeof pcb_keepout>\n\nexport interface PCBKeepoutRect {\n  type: \"pcb_keepout\"\n  shape: \"rect\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  width: number\n  height: number\n  pcb_keepout_id: string\n  layers: string[]\n  description?: string\n}\n\nexport interface PCBKeepoutCircle {\n  type: \"pcb_keepout\"\n  shape: \"circle\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  radius: number\n  pcb_keepout_id: string\n  layers: string[]\n  description?: string\n}\n\nexport type PCBKeepout = PCBKeepoutRect | PCBKeepoutCircle\n\nexpectTypesMatch<PCBKeepout, InferredPCBKeepout>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length, rotation, type Rotation } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\n// Common properties base for all cutout shapes (internal)\nconst pcb_cutout_base = z.object({\n  type: z.literal(\"pcb_cutout\"),\n  pcb_cutout_id: getZodPrefixedIdWithDefault(\"pcb_cutout\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  pcb_board_id: z.string().optional(),\n  pcb_panel_id: z.string().optional(),\n})\n\n// Rectangular Cutout\nexport const pcb_cutout_rect = pcb_cutout_base.extend({\n  shape: z.literal(\"rect\"),\n  center: point,\n  width: length,\n  height: length,\n  rotation: rotation.optional(),\n  corner_radius: length.optional(),\n})\nexport type PcbCutoutRectInput = z.input<typeof pcb_cutout_rect>\ntype InferredPcbCutoutRect = z.infer<typeof pcb_cutout_rect>\n/**\n * Defines a rectangular cutout on the PCB.\n */\nexport interface PcbCutoutRect {\n  type: \"pcb_cutout\"\n  pcb_cutout_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  pcb_board_id?: string\n  pcb_panel_id?: string\n  shape: \"rect\"\n  center: Point\n  width: Length\n  height: Length\n  rotation?: Rotation\n  corner_radius?: Length\n}\nexpectTypesMatch<PcbCutoutRect, InferredPcbCutoutRect>(true)\n\n// Circular Cutout\nexport const pcb_cutout_circle = pcb_cutout_base.extend({\n  shape: z.literal(\"circle\"),\n  center: point,\n  radius: length,\n})\nexport type PcbCutoutCircleInput = z.input<typeof pcb_cutout_circle>\ntype InferredPcbCutoutCircle = z.infer<typeof pcb_cutout_circle>\n/**\n * Defines a circular cutout on the PCB.\n */\nexport interface PcbCutoutCircle {\n  type: \"pcb_cutout\"\n  pcb_cutout_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  pcb_board_id?: string\n  pcb_panel_id?: string\n  shape: \"circle\"\n  center: Point\n  radius: Length\n}\nexpectTypesMatch<PcbCutoutCircle, InferredPcbCutoutCircle>(true)\n\n// Polygon Cutout\nexport const pcb_cutout_polygon = pcb_cutout_base.extend({\n  shape: z.literal(\"polygon\"),\n  points: z.array(point),\n})\nexport type PcbCutoutPolygonInput = z.input<typeof pcb_cutout_polygon>\ntype InferredPcbCutoutPolygon = z.infer<typeof pcb_cutout_polygon>\n/**\n * Defines a polygonal cutout on the PCB, specified by a list of points.\n * The polygon should be closed (the last point implicitly connects to the first).\n */\nexport interface PcbCutoutPolygon {\n  type: \"pcb_cutout\"\n  pcb_cutout_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  pcb_board_id?: string\n  pcb_panel_id?: string\n  shape: \"polygon\"\n  points: Point[]\n}\nexpectTypesMatch<PcbCutoutPolygon, InferredPcbCutoutPolygon>(true)\n\n// Path Cutout (for slots along a path)\nexport const pcb_cutout_path = pcb_cutout_base.extend({\n  shape: z.literal(\"path\"),\n  route: z.array(point),\n  slot_width: length,\n  slot_length: length.optional(),\n  space_between_slots: length.optional(),\n  slot_corner_radius: length.optional(),\n})\nexport type PcbCutoutPathInput = z.input<typeof pcb_cutout_path>\ntype InferredPcbCutoutPath = z.infer<typeof pcb_cutout_path>\n/**\n * Defines a path-based cutout on the PCB, creating slots along the specified path.\n * When slot_length and space_between_slots are specified, creates a dashed pattern of slots.\n * When they are omitted, creates a continuous slot along the entire path.\n * The slot_corner_radius controls the rounding of slot corners (0 = square, slot_width/2 = circle).\n */\nexport interface PcbCutoutPath {\n  type: \"pcb_cutout\"\n  pcb_cutout_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  pcb_board_id?: string\n  pcb_panel_id?: string\n  shape: \"path\"\n  route: Point[]\n  slot_width: Length\n  slot_length?: Length\n  space_between_slots?: Length\n  slot_corner_radius?: Length\n}\nexpectTypesMatch<PcbCutoutPath, InferredPcbCutoutPath>(true)\n\n// Union of all cutout shapes\nexport const pcb_cutout = z\n  .discriminatedUnion(\"shape\", [\n    pcb_cutout_rect,\n    pcb_cutout_circle,\n    pcb_cutout_polygon,\n    pcb_cutout_path,\n  ])\n  .describe(\"Defines a cutout on the PCB, removing board material.\")\n\nexport type PcbCutoutInput = z.input<typeof pcb_cutout>\nexport type PcbCutout =\n  | PcbCutoutRect\n  | PcbCutoutCircle\n  | PcbCutoutPolygon\n  | PcbCutoutPath\n\ntype InferredPcbCutout = z.infer<typeof pcb_cutout>\nexpectTypesMatch<PcbCutout, InferredPcbCutout>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_missing_footprint_error = z\n  .object({\n    type: z.literal(\"pcb_missing_footprint_error\"),\n    pcb_missing_footprint_error_id: getZodPrefixedIdWithDefault(\n      \"pcb_missing_footprint_error\",\n    ),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    error_type: z\n      .literal(\"pcb_missing_footprint_error\")\n      .default(\"pcb_missing_footprint_error\"),\n    source_component_id: z.string(),\n    message: z.string(),\n  })\n  .describe(\"Defines a missing footprint error on the PCB\")\n\nexport type PcbMissingFootprintErrorInput = z.input<\n  typeof pcb_missing_footprint_error\n>\ntype InferredPcbMissingFootprintError = z.infer<\n  typeof pcb_missing_footprint_error\n>\n\n/**\n * Defines a placement error on the PCB\n */\nexport interface PcbMissingFootprintError {\n  type: \"pcb_missing_footprint_error\"\n  pcb_missing_footprint_error_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  error_type: \"pcb_missing_footprint_error\"\n  source_component_id: string\n  message: string\n}\n\n/**\n * @deprecated use PcbMissingFootprintError\n */\nexport type PCBMissingFootprintError = PcbMissingFootprintError\n\nexpectTypesMatch<PcbMissingFootprintError, InferredPcbMissingFootprintError>(\n  true,\n)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const external_footprint_load_error = z\n  .object({\n    type: z.literal(\"external_footprint_load_error\"),\n    external_footprint_load_error_id: getZodPrefixedIdWithDefault(\n      \"external_footprint_load_error\",\n    ),\n    pcb_component_id: z.string(),\n    source_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    footprinter_string: z.string().optional(),\n    error_type: z\n      .literal(\"external_footprint_load_error\")\n      .default(\"external_footprint_load_error\"),\n    message: z.string(),\n  })\n  .describe(\"Defines an error when an external footprint fails to load\")\n\nexport type ExternalFootprintLoadErrorInput = z.input<\n  typeof external_footprint_load_error\n>\ntype InferredExternalFootprintLoadError = z.infer<\n  typeof external_footprint_load_error\n>\n\nexport interface ExternalFootprintLoadError {\n  type: \"external_footprint_load_error\"\n  external_footprint_load_error_id: string\n  pcb_component_id: string\n  source_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  footprinter_string?: string\n  error_type: \"external_footprint_load_error\"\n  message: string\n}\n\nexpectTypesMatch<\n  ExternalFootprintLoadError,\n  InferredExternalFootprintLoadError\n>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const circuit_json_footprint_load_error = z\n  .object({\n    type: z.literal(\"circuit_json_footprint_load_error\"),\n    circuit_json_footprint_load_error_id: getZodPrefixedIdWithDefault(\n      \"circuit_json_footprint_load_error\",\n    ),\n    pcb_component_id: z.string(),\n    source_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    error_type: z\n      .literal(\"circuit_json_footprint_load_error\")\n      .default(\"circuit_json_footprint_load_error\"),\n    message: z.string(),\n    circuit_json: z.array(z.any()).optional(),\n  })\n  .describe(\"Defines an error when a circuit JSON footprint fails to load\")\n\nexport type CircuitJsonFootprintLoadErrorInput = z.input<\n  typeof circuit_json_footprint_load_error\n>\ntype InferredCircuitJsonFootprintLoadError = z.infer<\n  typeof circuit_json_footprint_load_error\n>\n\nexport interface CircuitJsonFootprintLoadError {\n  type: \"circuit_json_footprint_load_error\"\n  circuit_json_footprint_load_error_id: string\n  pcb_component_id: string\n  source_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  error_type: \"circuit_json_footprint_load_error\"\n  message: string\n  circuit_json?: any[]\n}\n\nexpectTypesMatch<\n  CircuitJsonFootprintLoadError,\n  InferredCircuitJsonFootprintLoadError\n>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_group = z\n  .object({\n    type: z.literal(\"pcb_group\"),\n    pcb_group_id: getZodPrefixedIdWithDefault(\"pcb_group\"),\n    source_group_id: z.string(),\n    is_subcircuit: z.boolean().optional(),\n    subcircuit_id: z.string().optional(),\n    width: length.optional(),\n    height: length.optional(),\n    center: point,\n    outline: z.array(point).optional(),\n    anchor_position: point.optional(),\n    anchor_alignment: z\n      .enum([\"center\", \"top_left\", \"top_right\", \"bottom_left\", \"bottom_right\"])\n      .optional(),\n    pcb_component_ids: z.array(z.string()),\n    child_layout_mode: z.enum([\"packed\", \"none\"]).optional(),\n    name: z.string().optional(),\n    description: z.string().optional(),\n    layout_mode: z.string().optional(),\n    autorouter_configuration: z\n      .object({\n        trace_clearance: length,\n      })\n      .optional(),\n    autorouter_used_string: z.string().optional(),\n  })\n  .describe(\"Defines a group of components on the PCB\")\n\nexport type PcbGroupInput = z.input<typeof pcb_group>\ntype InferredPcbGroup = z.infer<typeof pcb_group>\n\n/**\n * Defines a group of components on the PCB\n */\nexport interface PcbGroup {\n  type: \"pcb_group\"\n  pcb_group_id: string\n  source_group_id: string\n  is_subcircuit?: boolean\n  subcircuit_id?: string\n  width?: Length\n  height?: Length\n  center: Point\n  outline?: Point[]\n  anchor_position?: Point\n  anchor_alignment?:\n    | \"center\"\n    | \"top_left\"\n    | \"top_right\"\n    | \"bottom_left\"\n    | \"bottom_right\"\n  pcb_component_ids: string[]\n  child_layout_mode?: \"packed\" | \"none\"\n  name?: string\n  description?: string\n  layout_mode?: string\n  autorouter_configuration?: {\n    trace_clearance: Length\n  }\n  autorouter_used_string?: string\n}\n\nexpectTypesMatch<PcbGroup, InferredPcbGroup>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_autorouting_error = z\n  .object({\n    type: z.literal(\"pcb_autorouting_error\"),\n    pcb_error_id: getZodPrefixedIdWithDefault(\"pcb_autorouting_error\"),\n    error_type: z\n      .literal(\"pcb_autorouting_error\")\n      .default(\"pcb_autorouting_error\"),\n    message: z.string(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"The autorouting has failed to route a portion of the board\")\n\nexport type PcbAutoroutingErrorInput = z.input<typeof pcb_autorouting_error>\ntype PcbInferredAutoroutingError = z.infer<typeof pcb_autorouting_error>\n\nexport interface PcbAutoroutingErrorInterface {\n  type: \"pcb_autorouting_error\"\n  pcb_error_id: string\n  error_type: \"pcb_autorouting_error\"\n  message: string\n  subcircuit_id?: string\n}\n\nexport type PcbAutoroutingError = PcbAutoroutingErrorInterface\n\nexpectTypesMatch<PcbAutoroutingError, PcbInferredAutoroutingError>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"../common\"\nimport { expectTypesMatch } from \"../utils/expect-types-match\"\n\nexport const pcb_manual_edit_conflict_warning = z\n  .object({\n    type: z.literal(\"pcb_manual_edit_conflict_warning\"),\n    pcb_manual_edit_conflict_warning_id: getZodPrefixedIdWithDefault(\n      \"pcb_manual_edit_conflict_warning\",\n    ),\n    warning_type: z\n      .literal(\"pcb_manual_edit_conflict_warning\")\n      .default(\"pcb_manual_edit_conflict_warning\"),\n    message: z.string(),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    source_component_id: z.string(),\n  })\n  .describe(\n    \"Warning emitted when a component has both manual placement and explicit pcbX/pcbY coordinates\",\n  )\n\nexport type PcbManualEditConflictWarningInput = z.input<\n  typeof pcb_manual_edit_conflict_warning\n>\ntype InferredPcbManualEditConflictWarning = z.infer<\n  typeof pcb_manual_edit_conflict_warning\n>\n\n/**\n * Warning emitted when a component has both manual placement (via manualEdits) and explicit pcbX/pcbY coordinates\n */\nexport interface PcbManualEditConflictWarning {\n  type: \"pcb_manual_edit_conflict_warning\"\n  pcb_manual_edit_conflict_warning_id: string\n  warning_type: \"pcb_manual_edit_conflict_warning\"\n  message: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  source_component_id: string\n}\n\nexpectTypesMatch<\n  PcbManualEditConflictWarning,\n  InferredPcbManualEditConflictWarning\n>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { distance, type Distance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_breakout_point = z\n  .object({\n    type: z.literal(\"pcb_breakout_point\"),\n    pcb_breakout_point_id: getZodPrefixedIdWithDefault(\"pcb_breakout_point\"),\n    pcb_group_id: z.string(),\n    subcircuit_id: z.string().optional(),\n    source_trace_id: z.string().optional(),\n    source_port_id: z.string().optional(),\n    source_net_id: z.string().optional(),\n    x: distance,\n    y: distance,\n  })\n  .describe(\n    \"Defines a routing target within a pcb_group for a source_trace or source_net\",\n  )\n\nexport type PcbBreakoutPointInput = z.input<typeof pcb_breakout_point>\ntype InferredPcbBreakoutPoint = z.infer<typeof pcb_breakout_point>\n\n/**\n * Defines a routing target within a pcb_group for a source_trace or source_net\n */\nexport interface PcbBreakoutPoint {\n  type: \"pcb_breakout_point\"\n  pcb_breakout_point_id: string\n  pcb_group_id: string\n  subcircuit_id?: string\n  source_trace_id?: string\n  source_port_id?: string\n  source_net_id?: string\n  x: Distance\n  y: Distance\n}\n\nexpectTypesMatch<PcbBreakoutPoint, InferredPcbBreakoutPoint>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_ground_plane = z\n  .object({\n    type: z.literal(\"pcb_ground_plane\"),\n    pcb_ground_plane_id: getZodPrefixedIdWithDefault(\"pcb_ground_plane\"),\n    source_pcb_ground_plane_id: z.string(),\n    source_net_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a ground plane on the PCB\")\n\nexport type PcbGroundPlaneInput = z.input<typeof pcb_ground_plane>\ntype InferredPcbGroundPlane = z.infer<typeof pcb_ground_plane>\n\n/**\n * Defines a ground plane on the PCB\n */\nexport interface PcbGroundPlane {\n  type: \"pcb_ground_plane\"\n  pcb_ground_plane_id: string\n  source_pcb_ground_plane_id: string\n  source_net_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<PcbGroundPlane, InferredPcbGroundPlane>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_ground_plane_region = z\n  .object({\n    type: z.literal(\"pcb_ground_plane_region\"),\n    pcb_ground_plane_region_id: getZodPrefixedIdWithDefault(\n      \"pcb_ground_plane_region\",\n    ),\n    pcb_ground_plane_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    layer: layer_ref,\n    points: z.array(point),\n  })\n  .describe(\"Defines a polygon region of a ground plane\")\n\nexport type PcbGroundPlaneRegionInput = z.input<typeof pcb_ground_plane_region>\ntype InferredPcbGroundPlaneRegion = z.infer<typeof pcb_ground_plane_region>\n\n/**\n * Defines a polygon region of a ground plane\n */\nexport interface PcbGroundPlaneRegion {\n  type: \"pcb_ground_plane_region\"\n  pcb_ground_plane_region_id: string\n  pcb_ground_plane_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  layer: LayerRef\n  points: Point[]\n}\n\nexpectTypesMatch<PcbGroundPlaneRegion, InferredPcbGroundPlaneRegion>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance } from \"src/units\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_thermal_spoke = z\n  .object({\n    type: z.literal(\"pcb_thermal_spoke\"),\n    pcb_thermal_spoke_id: getZodPrefixedIdWithDefault(\"pcb_thermal_spoke\"),\n    pcb_ground_plane_id: z.string(),\n    shape: z.string(),\n    spoke_count: z.number(),\n    spoke_thickness: distance,\n    spoke_inner_diameter: distance,\n    spoke_outer_diameter: distance,\n    pcb_plated_hole_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Pattern for connecting a ground plane to a plated hole\")\n\nexport type PcbThermalSpokeInput = z.input<typeof pcb_thermal_spoke>\ntype InferredPcbThermalSpoke = z.infer<typeof pcb_thermal_spoke>\n\n/**\n * Pattern for connecting a ground plane to a plated hole\n */\nexport interface PcbThermalSpoke {\n  type: \"pcb_thermal_spoke\"\n  pcb_thermal_spoke_id: string\n  pcb_ground_plane_id: string\n  shape: string\n  spoke_count: number\n  spoke_thickness: Distance\n  spoke_inner_diameter: Distance\n  spoke_outer_diameter: Distance\n  pcb_plated_hole_id?: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<PcbThermalSpoke, InferredPcbThermalSpoke>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length, rotation, type Rotation } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"./properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { brep_shape, type BRepShape } from \"./properties/brep\"\n\n// Common properties base for all pour shapes (internal)\nconst pcb_copper_pour_base = z.object({\n  type: z.literal(\"pcb_copper_pour\"),\n  pcb_copper_pour_id: getZodPrefixedIdWithDefault(\"pcb_copper_pour\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  layer: layer_ref,\n  source_net_id: z.string().optional(),\n  covered_with_solder_mask: z.boolean().optional().default(true),\n})\n\n// Rectangular Pour\nexport const pcb_copper_pour_rect = pcb_copper_pour_base.extend({\n  shape: z.literal(\"rect\"),\n  center: point,\n  width: length,\n  height: length,\n  rotation: rotation.optional(),\n})\nexport type PcbCopperPourRectInput = z.input<typeof pcb_copper_pour_rect>\ntype InferredPcbCopperPourRect = z.infer<typeof pcb_copper_pour_rect>\n/**\n * Defines a rectangular copper pour on the PCB.\n */\nexport interface PcbCopperPourRect {\n  type: \"pcb_copper_pour\"\n  pcb_copper_pour_id: string\n  covered_with_solder_mask: boolean\n  pcb_group_id?: string\n  subcircuit_id?: string\n  layer: LayerRef\n  source_net_id?: string\n  shape: \"rect\"\n  center: Point\n  width: Length\n  height: Length\n  rotation?: Rotation\n}\nexpectTypesMatch<PcbCopperPourRect, InferredPcbCopperPourRect>(true)\n\n// BRep Pour\nexport const pcb_copper_pour_brep = pcb_copper_pour_base.extend({\n  shape: z.literal(\"brep\"),\n  brep_shape: brep_shape,\n})\nexport type PcbCopperPourBRepInput = z.input<typeof pcb_copper_pour_brep>\ntype InferredPcbCopperPourBRep = z.infer<typeof pcb_copper_pour_brep>\n/**\n * Defines a BRep copper pour on the PCB.\n */\nexport interface PcbCopperPourBRep {\n  type: \"pcb_copper_pour\"\n  pcb_copper_pour_id: string\n  covered_with_solder_mask: boolean\n  pcb_group_id?: string\n  subcircuit_id?: string\n  layer: LayerRef\n  source_net_id?: string\n  shape: \"brep\"\n  brep_shape: BRepShape\n}\nexpectTypesMatch<PcbCopperPourBRep, InferredPcbCopperPourBRep>(true)\n\n// Polygon Pour\nexport const pcb_copper_pour_polygon = pcb_copper_pour_base.extend({\n  shape: z.literal(\"polygon\"),\n  points: z.array(point),\n})\nexport type PcbCopperPourPolygonInput = z.input<typeof pcb_copper_pour_polygon>\ntype InferredPcbCopperPourPolygon = z.infer<typeof pcb_copper_pour_polygon>\n/**\n * Defines a polygonal copper pour on the PCB, specified by a list of points.\n * The polygon should be closed (the last point implicitly connects to the first).\n */\nexport interface PcbCopperPourPolygon {\n  type: \"pcb_copper_pour\"\n  pcb_copper_pour_id: string\n  covered_with_solder_mask: boolean\n  pcb_group_id?: string\n  subcircuit_id?: string\n  layer: LayerRef\n  source_net_id?: string\n  shape: \"polygon\"\n  points: Point[]\n}\nexpectTypesMatch<PcbCopperPourPolygon, InferredPcbCopperPourPolygon>(true)\n\n// Union of all pour shapes\nexport const pcb_copper_pour = z\n  .discriminatedUnion(\"shape\", [\n    pcb_copper_pour_rect,\n    pcb_copper_pour_brep,\n    pcb_copper_pour_polygon,\n  ])\n  .describe(\"Defines a copper pour on the PCB.\")\n\nexport type PcbCopperPourInput = z.input<typeof pcb_copper_pour>\nexport type PcbCopperPour =\n  | PcbCopperPourRect\n  | PcbCopperPourBRep\n  | PcbCopperPourPolygon\n\ntype InferredPcbCopperPour = z.infer<typeof pcb_copper_pour>\nexpectTypesMatch<PcbCopperPour, InferredPcbCopperPour>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { point, type Point } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_component_outside_board_error = z\n  .object({\n    type: z.literal(\"pcb_component_outside_board_error\"),\n    pcb_component_outside_board_error_id: getZodPrefixedIdWithDefault(\n      \"pcb_component_outside_board_error\",\n    ),\n    error_type: z\n      .literal(\"pcb_component_outside_board_error\")\n      .default(\"pcb_component_outside_board_error\"),\n    message: z.string(),\n    pcb_component_id: z.string(),\n    pcb_board_id: z.string(),\n    component_center: point,\n    component_bounds: z.object({\n      min_x: z.number(),\n      max_x: z.number(),\n      min_y: z.number(),\n      max_y: z.number(),\n    }),\n    subcircuit_id: z.string().optional(),\n    source_component_id: z.string().optional(),\n  })\n  .describe(\n    \"Error emitted when a PCB component is placed outside the board boundaries\",\n  )\n\nexport type PcbComponentOutsideBoardErrorInput = z.input<\n  typeof pcb_component_outside_board_error\n>\ntype InferredPcbComponentOutsideBoardError = z.infer<\n  typeof pcb_component_outside_board_error\n>\n\n/** Error emitted when a PCB component is placed outside the board boundaries */\nexport interface PcbComponentOutsideBoardError {\n  type: \"pcb_component_outside_board_error\"\n  pcb_component_outside_board_error_id: string\n  error_type: \"pcb_component_outside_board_error\"\n  message: string\n  pcb_component_id: string\n  pcb_board_id: string\n  component_center: Point\n  component_bounds: {\n    min_x: number\n    max_x: number\n    min_y: number\n    max_y: number\n  }\n  subcircuit_id?: string\n  source_component_id?: string\n}\n\nexpectTypesMatch<\n  PcbComponentOutsideBoardError,\n  InferredPcbComponentOutsideBoardError\n>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_component_invalid_layer_error = z\n  .object({\n    type: z.literal(\"pcb_component_invalid_layer_error\"),\n    pcb_component_invalid_layer_error_id: getZodPrefixedIdWithDefault(\n      \"pcb_component_invalid_layer_error\",\n    ),\n    error_type: z\n      .literal(\"pcb_component_invalid_layer_error\")\n      .default(\"pcb_component_invalid_layer_error\"),\n    message: z.string(),\n    pcb_component_id: z.string().optional(),\n    source_component_id: z.string(),\n    layer: layer_ref,\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\n    \"Error emitted when a component is placed on an invalid layer (components can only be on 'top' or 'bottom' layers)\",\n  )\n\nexport type PcbComponentInvalidLayerErrorInput = z.input<\n  typeof pcb_component_invalid_layer_error\n>\ntype InferredPcbComponentInvalidLayerError = z.infer<\n  typeof pcb_component_invalid_layer_error\n>\n\n/** Error emitted when a component is placed on an invalid layer (components can only be on 'top' or 'bottom' layers) */\nexport interface PcbComponentInvalidLayerError {\n  type: \"pcb_component_invalid_layer_error\"\n  pcb_component_invalid_layer_error_id: string\n  error_type: \"pcb_component_invalid_layer_error\"\n  message: string\n  pcb_component_id?: string\n  source_component_id: string\n  layer: LayerRef\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<\n  PcbComponentInvalidLayerError,\n  InferredPcbComponentInvalidLayerError\n>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { distance, type Distance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_via_clearance_error = z\n  .object({\n    type: z.literal(\"pcb_via_clearance_error\"),\n    pcb_error_id: getZodPrefixedIdWithDefault(\"pcb_error\"),\n    error_type: z\n      .literal(\"pcb_via_clearance_error\")\n      .default(\"pcb_via_clearance_error\"),\n    message: z.string(),\n    pcb_via_ids: z.array(z.string()).min(2),\n    minimum_clearance: distance.optional(),\n    actual_clearance: distance.optional(),\n    pcb_center: z\n      .object({\n        x: z.number().optional(),\n        y: z.number().optional(),\n      })\n      .optional(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Error emitted when vias are closer than the allowed clearance\")\n\nexport type PcbViaClearanceErrorInput = z.input<typeof pcb_via_clearance_error>\ntype InferredPcbViaClearanceError = z.infer<typeof pcb_via_clearance_error>\n\n/** Error emitted when vias are closer than the allowed clearance */\nexport interface PcbViaClearanceError {\n  type: \"pcb_via_clearance_error\"\n  pcb_error_id: string\n  error_type: \"pcb_via_clearance_error\"\n  message: string\n  pcb_via_ids: string[]\n  minimum_clearance?: Distance\n  actual_clearance?: Distance\n  pcb_center?: {\n    x?: number\n    y?: number\n  }\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<PcbViaClearanceError, InferredPcbViaClearanceError>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { visible_layer, type VisibleLayer } from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_courtyard_rect = z\n  .object({\n    type: z.literal(\"pcb_courtyard_rect\"),\n    pcb_courtyard_rect_id: getZodPrefixedIdWithDefault(\"pcb_courtyard_rect\"),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    center: point,\n    width: length,\n    height: length,\n    layer: visible_layer,\n    color: z.string().optional(),\n  })\n  .describe(\"Defines a courtyard rectangle on the PCB\")\n\nexport type PcbCourtyardRectInput = z.input<typeof pcb_courtyard_rect>\ntype InferredPcbCourtyardRect = z.infer<typeof pcb_courtyard_rect>\n\n/**\n * Defines a courtyard rectangle on the PCB\n */\nexport interface PcbCourtyardRect {\n  type: \"pcb_courtyard_rect\"\n  pcb_courtyard_rect_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  width: Length\n  height: Length\n  layer: VisibleLayer\n  color?: string\n}\n\n/**\n * @deprecated use PcbCourtyardRect\n */\nexport type PCBCourtyardRect = PcbCourtyardRect\n\nexpectTypesMatch<PcbCourtyardRect, InferredPcbCourtyardRect>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { visible_layer, type VisibleLayer } from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_courtyard_outline = z\n  .object({\n    type: z.literal(\"pcb_courtyard_outline\"),\n    pcb_courtyard_outline_id: getZodPrefixedIdWithDefault(\n      \"pcb_courtyard_outline\",\n    ),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    layer: visible_layer,\n    outline: z.array(point).min(2),\n    stroke_width: length.default(\"0.1mm\"),\n    is_closed: z.boolean().optional(),\n    is_stroke_dashed: z.boolean().optional(),\n    color: z.string().optional(),\n  })\n  .describe(\"Defines a courtyard outline on the PCB\")\n\nexport type PcbCourtyardOutlineInput = z.input<typeof pcb_courtyard_outline>\ntype InferredPcbCourtyardOutline = z.infer<typeof pcb_courtyard_outline>\n\n/**\n * Defines a courtyard outline on the PCB\n */\nexport interface PcbCourtyardOutline {\n  type: \"pcb_courtyard_outline\"\n  pcb_courtyard_outline_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  layer: VisibleLayer\n  outline: Point[]\n  stroke_width: Length\n  is_closed?: boolean\n  is_stroke_dashed?: boolean\n  color?: string\n}\n\n/**\n * @deprecated use PcbCourtyardOutline\n */\nexport type PCBCourtyardOutline = PcbCourtyardOutline\n\nexpectTypesMatch<PcbCourtyardOutline, InferredPcbCourtyardOutline>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { visible_layer, type VisibleLayer } from \"src/pcb/properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_courtyard_polygon = z\n  .object({\n    type: z.literal(\"pcb_courtyard_polygon\"),\n    pcb_courtyard_polygon_id: getZodPrefixedIdWithDefault(\n      \"pcb_courtyard_polygon\",\n    ),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    layer: visible_layer,\n    points: z.array(point).min(3),\n    color: z.string().optional(),\n  })\n  .describe(\"Defines a courtyard polygon on the PCB\")\n\nexport type PcbCourtyardPolygonInput = z.input<typeof pcb_courtyard_polygon>\ntype InferredPcbCourtyardPolygon = z.infer<typeof pcb_courtyard_polygon>\n\n/**\n * Defines a courtyard polygon on the PCB\n */\nexport interface PcbCourtyardPolygon {\n  type: \"pcb_courtyard_polygon\"\n  pcb_courtyard_polygon_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  layer: VisibleLayer\n  points: Point[]\n  color?: string\n}\n\n/**\n * @deprecated use PcbCourtyardPolygon\n */\nexport type PCBCourtyardPolygon = PcbCourtyardPolygon\n\nexpectTypesMatch<PcbCourtyardPolygon, InferredPcbCourtyardPolygon>(true)\n","import { z } from \"zod\"\nimport { point3, type Point3 } from \"../common\"\nimport { rotation, length, type Rotation, type Length } from \"../units\"\nimport { layer_ref, type LayerRef } from \"src/pcb\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const cad_component = z\n  .object({\n    type: z.literal(\"cad_component\"),\n    cad_component_id: z.string(),\n    pcb_component_id: z.string(),\n    source_component_id: z.string(),\n    position: point3,\n    rotation: point3.optional(),\n    size: point3.optional(),\n    layer: layer_ref.optional(),\n    subcircuit_id: z.string().optional(),\n\n    // These are all ways to generate/load the 3d model\n    footprinter_string: z.string().optional(),\n    model_obj_url: z.string().optional(),\n    model_stl_url: z.string().optional(),\n    model_3mf_url: z.string().optional(),\n    model_gltf_url: z.string().optional(),\n    model_glb_url: z.string().optional(),\n    model_step_url: z.string().optional(),\n    model_wrl_url: z.string().optional(),\n    model_unit_to_mm_scale_factor: z.number().optional(),\n    model_jscad: z.any().optional(),\n  })\n  .describe(\"Defines a component on the PCB\")\n\nexport type CadComponentInput = z.input<typeof cad_component>\ntype InferredCadComponent = z.infer<typeof cad_component>\n\nexport interface CadComponent {\n  type: \"cad_component\"\n  cad_component_id: string\n  pcb_component_id: string\n  source_component_id: string\n  position: Point3\n  rotation?: Point3\n  size?: Point3\n  layer?: LayerRef\n  subcircuit_id?: string\n  footprinter_string?: string\n  model_obj_url?: string\n  model_stl_url?: string\n  model_3mf_url?: string\n  model_gltf_url?: string\n  model_glb_url?: string\n  model_step_url?: string\n  model_wrl_url?: string\n  model_unit_to_mm_scale_factor?: number\n  model_jscad?: any\n}\n\nexpectTypesMatch<CadComponent, InferredCadComponent>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { frequency, rotation, voltage } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const wave_shape = z.enum([\"sinewave\", \"square\", \"triangle\", \"sawtooth\"])\nexport type WaveShape = z.infer<typeof wave_shape>\n\nconst percentage = z\n  .union([z.string(), z.number()])\n  .transform((val) => {\n    if (typeof val === \"string\") {\n      if (val.endsWith(\"%\")) {\n        return parseFloat(val.slice(0, -1)) / 100\n      }\n      return parseFloat(val)\n    }\n    return val\n  })\n  .pipe(\n    z\n      .number()\n      .min(0, \"Duty cycle must be non-negative\")\n      .max(1, \"Duty cycle cannot be greater than 100%\"),\n  )\n\nexport const simulation_dc_voltage_source = z\n  .object({\n    type: z.literal(\"simulation_voltage_source\"),\n    simulation_voltage_source_id: getZodPrefixedIdWithDefault(\n      \"simulation_voltage_source\",\n    ),\n    is_dc_source: z.literal(true).optional().default(true),\n    positive_source_port_id: z.string().optional(),\n    negative_source_port_id: z.string().optional(),\n    positive_source_net_id: z.string().optional(),\n    negative_source_net_id: z.string().optional(),\n    voltage: voltage,\n  })\n  .describe(\"Defines a DC voltage source for simulation\")\n\nexport const simulation_ac_voltage_source = z\n  .object({\n    type: z.literal(\"simulation_voltage_source\"),\n    simulation_voltage_source_id: getZodPrefixedIdWithDefault(\n      \"simulation_voltage_source\",\n    ),\n    is_dc_source: z.literal(false),\n    terminal1_source_port_id: z.string().optional(),\n    terminal2_source_port_id: z.string().optional(),\n    terminal1_source_net_id: z.string().optional(),\n    terminal2_source_net_id: z.string().optional(),\n    voltage: voltage.optional(),\n    frequency: frequency.optional(),\n    peak_to_peak_voltage: voltage.optional(),\n    wave_shape: wave_shape.optional(),\n    phase: rotation.optional(),\n    duty_cycle: percentage.optional(),\n  })\n  .describe(\"Defines an AC voltage source for simulation\")\n\nexport type SimulationAcVoltageSourceInput = z.input<\n  typeof simulation_ac_voltage_source\n>\n\nexport const simulation_voltage_source = z\n  .union([simulation_dc_voltage_source, simulation_ac_voltage_source])\n  .describe(\"Defines a voltage source for simulation\")\n\nexport type SimulationVoltageSourceInput = z.input<\n  typeof simulation_voltage_source\n>\ntype InferredSimulationVoltageSource = z.infer<typeof simulation_voltage_source>\n\n/**\n * Defines a DC voltage source for simulation purposes. It applies a voltage\n * difference between two source ports.\n */\nexport interface SimulationDcVoltageSource {\n  type: \"simulation_voltage_source\"\n  simulation_voltage_source_id: string\n  is_dc_source: true\n  positive_source_port_id?: string\n  positive_source_net_id?: string\n  negative_source_port_id?: string\n  negative_source_net_id?: string\n  voltage: number\n}\n\n/**\n * Defines an AC voltage source for simulation purposes.\n */\nexport interface SimulationAcVoltageSource {\n  type: \"simulation_voltage_source\"\n  simulation_voltage_source_id: string\n  is_dc_source: false\n  terminal1_source_port_id?: string\n  terminal2_source_port_id?: string\n  terminal1_source_net_id?: string\n  terminal2_source_net_id?: string\n  voltage?: number\n  frequency?: number\n  peak_to_peak_voltage?: number\n  wave_shape?: WaveShape\n  phase?: number\n  duty_cycle?: number\n}\n\nexport type SimulationVoltageSource =\n  | SimulationDcVoltageSource\n  | SimulationAcVoltageSource\n\nexpectTypesMatch<\n  SimulationDcVoltageSource,\n  z.infer<typeof simulation_dc_voltage_source>\n>(true)\nexpectTypesMatch<\n  SimulationAcVoltageSource,\n  z.infer<typeof simulation_ac_voltage_source>\n>(true)\nexpectTypesMatch<SimulationVoltageSource, InferredSimulationVoltageSource>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { duration_ms, ms } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const experiment_type = z.union([\n  z.literal(\"spice_dc_sweep\"),\n  z.literal(\"spice_dc_operating_point\"),\n  z.literal(\"spice_transient_analysis\"),\n  z.literal(\"spice_ac_analysis\"),\n])\n\nexport type ExperimentType = z.infer<typeof experiment_type>\n\nexport interface SimulationExperiment {\n  type: \"simulation_experiment\"\n  simulation_experiment_id: string\n  name: string\n  experiment_type: ExperimentType\n  time_per_step?: number // ms\n  start_time_ms?: number // ms\n  end_time_ms?: number // ms\n}\n\nexport const simulation_experiment = z\n  .object({\n    type: z.literal(\"simulation_experiment\"),\n    simulation_experiment_id: getZodPrefixedIdWithDefault(\n      \"simulation_experiment\",\n    ),\n    name: z.string(),\n    experiment_type,\n    time_per_step: duration_ms.optional(),\n    start_time_ms: ms.optional(),\n    end_time_ms: ms.optional(),\n  })\n  .describe(\"Defines a simulation experiment configuration\")\n\nexport type SimulationExperimentInput = z.input<typeof simulation_experiment>\ntype InferredSimulationExperiment = z.infer<typeof simulation_experiment>\n\nexpectTypesMatch<SimulationExperiment, InferredSimulationExperiment>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { duration_ms, ms } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport interface SimulationTransientVoltageGraph {\n  type: \"simulation_transient_voltage_graph\"\n  simulation_transient_voltage_graph_id: string\n  simulation_experiment_id: string\n  timestamps_ms?: number[]\n  voltage_levels: number[]\n  source_component_id?: string\n  subcircuit_connectivity_map_key?: string\n  time_per_step: number\n  start_time_ms: number\n  end_time_ms: number\n  name?: string\n  color?: string\n}\n\nexport const simulation_transient_voltage_graph = z\n  .object({\n    type: z.literal(\"simulation_transient_voltage_graph\"),\n    simulation_transient_voltage_graph_id: getZodPrefixedIdWithDefault(\n      \"simulation_transient_voltage_graph\",\n    ),\n    simulation_experiment_id: z.string(),\n    timestamps_ms: z.array(z.number()).optional(),\n    voltage_levels: z.array(z.number()),\n    source_component_id: z.string().optional(),\n    subcircuit_connectivity_map_key: z.string().optional(),\n    time_per_step: duration_ms,\n    start_time_ms: ms,\n    end_time_ms: ms,\n    name: z.string().optional(),\n    color: z.string().optional(),\n  })\n  .describe(\"Stores voltage measurements over time for a simulation\")\n\nexport type SimulationTransientVoltageGraphInput = z.input<\n  typeof simulation_transient_voltage_graph\n>\ntype InferredSimulationTransientVoltageGraph = z.infer<\n  typeof simulation_transient_voltage_graph\n>\n\nexpectTypesMatch<\n  SimulationTransientVoltageGraph,\n  InferredSimulationTransientVoltageGraph\n>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { frequency, ms } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const simulation_switch = z\n  .object({\n    type: z.literal(\"simulation_switch\"),\n    simulation_switch_id: getZodPrefixedIdWithDefault(\"simulation_switch\"),\n    source_component_id: z.string().optional(),\n    closes_at: ms.optional(),\n    opens_at: ms.optional(),\n    starts_closed: z.boolean().optional(),\n    switching_frequency: frequency.optional(),\n  })\n  .describe(\"Defines a switch for simulation timing control\")\n\nexport type SimulationSwitchInput = z.input<typeof simulation_switch>\n\ntype InferredSimulationSwitch = z.infer<typeof simulation_switch>\n\nexport interface SimulationSwitch {\n  type: \"simulation_switch\"\n  simulation_switch_id: string\n  source_component_id?: string\n  closes_at?: number\n  opens_at?: number\n  starts_closed?: boolean\n  switching_frequency?: number\n}\n\nexpectTypesMatch<SimulationSwitch, InferredSimulationSwitch>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const simulation_voltage_probe = z\n  .object({\n    type: z.literal(\"simulation_voltage_probe\"),\n    simulation_voltage_probe_id: getZodPrefixedIdWithDefault(\n      \"simulation_voltage_probe\",\n    ),\n    source_component_id: z.string().optional(),\n    name: z.string().optional(),\n    source_port_id: z.string().optional(),\n    source_net_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    color: z.string().optional(),\n  })\n  .describe(\n    \"Defines a voltage probe for simulation, connected to a port or a net\",\n  )\n  .refine(\n    (data) => Boolean(data.source_port_id) !== Boolean(data.source_net_id),\n    {\n      message:\n        \"Exactly one of source_port_id or source_net_id must be provided to simulation_voltage_probe\",\n    },\n  )\n\nexport type SimulationVoltageProbeInput = z.input<\n  typeof simulation_voltage_probe\n>\ntype InferredSimulationVoltageProbe = z.infer<typeof simulation_voltage_probe>\n\n/**\n * Defines a voltage probe for simulation, connected to a port or a net.\n */\nexport interface SimulationVoltageProbe {\n  type: \"simulation_voltage_probe\"\n  simulation_voltage_probe_id: string\n  source_component_id?: string\n  name?: string\n  source_port_id?: string\n  source_net_id?: string\n  subcircuit_id?: string\n  color?: string\n}\n\nexpectTypesMatch<SimulationVoltageProbe, InferredSimulationVoltageProbe>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const simulation_unknown_experiment_error = z\n  .object({\n    type: z.literal(\"simulation_unknown_experiment_error\"),\n    simulation_unknown_experiment_error_id: getZodPrefixedIdWithDefault(\n      \"simulation_unknown_experiment_error\",\n    ),\n    error_type: z\n      .literal(\"simulation_unknown_experiment_error\")\n      .default(\"simulation_unknown_experiment_error\"),\n    message: z.string(),\n    simulation_experiment_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"An unknown error occurred during the simulation experiment.\")\n\nexport type SimulationUnknownExperimentErrorInput = z.input<\n  typeof simulation_unknown_experiment_error\n>\ntype InferredSimulationUnknownExperimentError = z.infer<\n  typeof simulation_unknown_experiment_error\n>\n\n/**\n * An unknown error occurred during the simulation experiment.\n */\nexport interface SimulationUnknownExperimentError {\n  type: \"simulation_unknown_experiment_error\"\n  simulation_unknown_experiment_error_id: string\n  error_type: \"simulation_unknown_experiment_error\"\n  message: string\n  simulation_experiment_id?: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<\n  SimulationUnknownExperimentError,\n  InferredSimulationUnknownExperimentError\n>(true)\n","import { z } from \"zod\"\nimport * as pcb from \"./pcb\"\nimport * as sch from \"./schematic\"\nimport * as src from \"./source\"\nimport * as cad from \"./cad\"\nimport * as sim from \"./simulation\"\nimport {\n  expectStringUnionsMatch,\n  expectTypesMatch,\n} from \"./utils/expect-types-match\"\n\nexport const any_circuit_element = z.union([\n  // TODO source_config\n  // TODO pcb_config\n  // TODO schematic_config\n  // TODO schematic_group\n  src.source_trace,\n  src.source_port,\n  src.any_source_component,\n  src.source_net,\n  src.source_group,\n  src.source_simple_chip,\n  src.source_simple_capacitor,\n  src.source_simple_diode,\n  src.source_simple_led,\n  src.source_simple_resistor,\n  src.source_simple_power_source,\n  src.source_simple_battery,\n  src.source_simple_inductor,\n  src.source_simple_pin_header,\n  src.source_simple_pinout,\n  src.source_simple_resonator,\n  src.source_simple_switch,\n  src.source_simple_transistor,\n  src.source_simple_test_point,\n  src.source_simple_mosfet,\n  src.source_simple_potentiometer,\n  src.source_simple_push_button,\n  src.source_pcb_ground_plane,\n  src.source_manually_placed_via,\n  src.source_board,\n  src.source_project_metadata,\n  src.source_trace_not_connected_error,\n  src.source_pin_missing_trace_warning,\n  src.unknown_error_finding_part,\n  pcb.pcb_component,\n  pcb.pcb_hole,\n  pcb.pcb_missing_footprint_error,\n  pcb.external_footprint_load_error,\n  pcb.circuit_json_footprint_load_error,\n  pcb.pcb_manual_edit_conflict_warning,\n  pcb.pcb_plated_hole,\n  pcb.pcb_keepout,\n  pcb.pcb_port,\n  pcb.pcb_net,\n  pcb.pcb_text,\n  pcb.pcb_trace,\n  pcb.pcb_via,\n  pcb.pcb_smtpad,\n  pcb.pcb_solder_paste,\n  pcb.pcb_board,\n  pcb.pcb_panel,\n  pcb.pcb_group,\n  pcb.pcb_trace_hint,\n  pcb.pcb_silkscreen_line,\n  pcb.pcb_silkscreen_path,\n  pcb.pcb_silkscreen_text,\n  pcb.pcb_copper_text,\n  pcb.pcb_silkscreen_rect,\n  pcb.pcb_silkscreen_circle,\n  pcb.pcb_silkscreen_oval,\n  pcb.pcb_trace_error,\n  pcb.pcb_trace_missing_error,\n  pcb.pcb_placement_error,\n  pcb.pcb_port_not_matched_error,\n  pcb.pcb_port_not_connected_error,\n  pcb.pcb_via_clearance_error,\n  pcb.pcb_fabrication_note_path,\n  pcb.pcb_fabrication_note_text,\n  pcb.pcb_fabrication_note_rect,\n  pcb.pcb_fabrication_note_dimension,\n  pcb.pcb_note_text,\n  pcb.pcb_note_rect,\n  pcb.pcb_note_path,\n  pcb.pcb_note_line,\n  pcb.pcb_note_dimension,\n  pcb.pcb_autorouting_error,\n  pcb.pcb_footprint_overlap_error,\n  pcb.pcb_breakout_point,\n  pcb.pcb_cutout,\n  pcb.pcb_ground_plane,\n  pcb.pcb_ground_plane_region,\n  pcb.pcb_thermal_spoke,\n  pcb.pcb_copper_pour,\n  pcb.pcb_component_outside_board_error,\n  pcb.pcb_component_invalid_layer_error,\n  pcb.pcb_courtyard_rect,\n  pcb.pcb_courtyard_outline,\n  pcb.pcb_courtyard_polygon,\n  sch.schematic_box,\n  sch.schematic_text,\n  sch.schematic_line,\n  sch.schematic_rect,\n  sch.schematic_circle,\n  sch.schematic_arc,\n  sch.schematic_component,\n  sch.schematic_port,\n  sch.schematic_trace,\n  sch.schematic_path,\n  sch.schematic_error,\n  sch.schematic_layout_error,\n  sch.schematic_net_label,\n  sch.schematic_debug_object,\n  sch.schematic_voltage_probe,\n  sch.schematic_manual_edit_conflict_warning,\n  sch.schematic_group,\n  sch.schematic_sheet,\n  sch.schematic_table,\n  sch.schematic_table_cell,\n  cad.cad_component,\n  sim.simulation_voltage_source,\n  sim.simulation_experiment,\n  sim.simulation_transient_voltage_graph,\n  sim.simulation_switch,\n  sim.simulation_voltage_probe,\n  sim.simulation_unknown_experiment_error,\n])\n\n/**\n * @deprecated use any_circuit_element instead\n */\nexport const any_soup_element = any_circuit_element\n\nexport type AnyCircuitElement = z.infer<typeof any_circuit_element>\nexport type AnyCircuitElementInput = z.input<typeof any_circuit_element>\n/**\n * @deprecated use AnyCircuitElement instead\n */\nexport type AnySoupElement = AnyCircuitElement\n\n/**\n * @deprecated use AnyCircuitElementInput instead\n */\nexport type AnySoupElementInput = AnyCircuitElementInput\n\n/**\n * Type representing a complete Circuit JSON document, which is an array of circuit elements.\n * This is the primary type used when working with circuit-json files or API responses.\n */\nexport type CircuitJson = AnyCircuitElement[]\n\n// ------------------- SAFETY CHECKS -------------------\n\n// SAFETY CHECK: Every element has a type\nexpectTypesMatch<\n  AnyCircuitElement extends { type: string } ? AnyCircuitElement : never,\n  AnyCircuitElement\n>(true)\n\n// SAFETY CHECK: Every element has an id with the key name `${type}_id`\ntype FindMissingId<T extends AnyCircuitElement> = T extends {\n  type: infer U extends string\n}\n  ? T extends { [K in `${U}_id`]: infer V }\n    ? V extends string\n      ? never\n      : `${U} DOES NOT HAVE AN ${U}_id PROPERTY`\n    : `${U} DOES NOT HAVE AN ${U}_id PROPERTY`\n  : never\n\nexpectStringUnionsMatch<\n  FindMissingId<AnyCircuitElement>,\n  // EXCEPTIONS TO THE RULE\n  // THIS IS FOR LEGACY REASONS, DO NOT ADD MORE EXCEPTIONS\n  | \"source_project_metadata DOES NOT HAVE AN source_project_metadata_id PROPERTY\"\n  | \"pcb_port_not_matched_error DOES NOT HAVE AN pcb_port_not_matched_error_id PROPERTY\"\n  | \"pcb_autorouting_error DOES NOT HAVE AN pcb_autorouting_error_id PROPERTY\"\n  | \"pcb_footprint_overlap_error DOES NOT HAVE AN pcb_footprint_overlap_error_id PROPERTY\"\n  | \"pcb_via_clearance_error DOES NOT HAVE AN pcb_via_clearance_error_id PROPERTY\"\n  | \"schematic_debug_object DOES NOT HAVE AN schematic_debug_object_id PROPERTY\"\n  | \"schematic_box DOES NOT HAVE AN schematic_box_id PROPERTY\"\n  | \"schematic_path DOES NOT HAVE AN schematic_path_id PROPERTY\"\n>(true)\n"],"mappings":"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","names":["z","z","z","z","z","z","z","length","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z"]}