// src/utils/convert-si-unit-to-number.ts
var unitMappings = {
  Hz: {
    baseUnit: "Hz",
    variants: {
      MHz: 1e6,
      kHz: 1e3,
      Hz: 1
    }
  },
  g: {
    baseUnit: "g",
    variants: {
      kg: 1e3,
      g: 1
    }
  },
  \u03A9: {
    baseUnit: "\u03A9",
    variants: {
      m\u03A9: 1e-3,
      \u03A9: 1,
      k\u03A9: 1e3,
      K\u03A9: 1e3,
      kohm: 1e3,
      M\u03A9: 1e6,
      G\u03A9: 1e9,
      T\u03A9: 1e12
    }
  },
  V: {
    baseUnit: "V",
    variants: {
      mV: 1e-3,
      V: 1,
      kV: 1e3,
      KV: 1e3,
      MV: 1e6,
      GV: 1e9,
      TV: 1e12
    }
  },
  A: {
    baseUnit: "A",
    variants: {
      \u00B5A: 1e-6,
      mA: 1e-3,
      ma: 1e-3,
      A: 1,
      kA: 1e3,
      MA: 1e6
    }
  },
  F: {
    baseUnit: "F",
    variants: {
      pF: 1e-12,
      nF: 1e-9,
      \u00B5F: 1e-6,
      uF: 1e-6,
      mF: 1e-3,
      F: 1
    }
  },
  ml: {
    baseUnit: "ml",
    variants: {
      ml: 1,
      mL: 1,
      l: 1e3,
      L: 1e3
    }
  },
  deg: {
    baseUnit: "deg",
    variants: {
      rad: 180 / Math.PI
    }
  },
  ms: {
    baseUnit: "ms",
    variants: {
      s: 1e3
    }
  },
  mm: {
    baseUnit: "mm",
    variants: {
      nm: 1e-6,
      \u00B5m: 1e-3,
      um: 1e-3,
      mm: 1,
      cm: 10,
      dm: 100,
      m: 1e3,
      km: 1e6,
      in: 25.4,
      ft: 304.8,
      IN: 25.4,
      FT: 304.8,
      yd: 914.4,
      mi: 1609344,
      mil: 0.0254
    }
  }
};
var unitMappingAndVariantSuffixes = /* @__PURE__ */ new Set();
for (const [baseUnit, info] of Object.entries(unitMappings)) {
  unitMappingAndVariantSuffixes.add(baseUnit);
  for (const variant of Object.keys(info.variants)) {
    unitMappingAndVariantSuffixes.add(variant);
  }
}
function getBaseTscircuitUnit(unit) {
  for (const [baseUnit, info] of Object.entries(unitMappings)) {
    if (unit in info.variants) {
      return {
        baseUnit: info.baseUnit,
        conversionFactor: info.variants[unit]
      };
    }
  }
  return {
    baseUnit: unit,
    conversionFactor: 1
  };
}
var si_prefix_multiplier = {
  tera: 1e12,
  T: 1e12,
  giga: 1e9,
  G: 1e9,
  mega: 1e6,
  M: 1e6,
  kilo: 1e3,
  k: 1e3,
  deci: 0.1,
  d: 0.1,
  centi: 0.01,
  c: 0.01,
  milli: 1e-3,
  m: 1e-3,
  micro: 1e-6,
  u: 1e-6,
  \u00B5: 1e-6,
  nano: 1e-9,
  n: 1e-9,
  pico: 1e-12,
  p: 1e-12
};
var parseAndConvertSiUnit = (v) => {
  if (typeof v === "undefined")
    return { parsedUnit: null, unitOfValue: null, value: null };
  if (typeof v === "string" && v.match(/^-?[\d\.]+$/))
    return {
      value: Number.parseFloat(v),
      parsedUnit: null,
      unitOfValue: null
    };
  if (typeof v === "number")
    return { value: v, parsedUnit: null, unitOfValue: null };
  if (typeof v === "object" && "x" in v && "y" in v) {
    const { parsedUnit, unitOfValue } = parseAndConvertSiUnit(v.x);
    return {
      parsedUnit,
      unitOfValue,
      value: {
        x: parseAndConvertSiUnit(v.x).value,
        y: parseAndConvertSiUnit(v.y).value
      }
    };
  }
  const reversed_input_string = v.toString().split("").reverse().join("");
  const unit_reversed = reversed_input_string.match(/[^\d\s]+/)?.[0];
  if (!unit_reversed) {
    throw new Error(`Could not determine unit: "${v}"`);
  }
  const unit = unit_reversed.split("").reverse().join("");
  const numberPart = v.slice(0, -unit.length);
  if (unit in si_prefix_multiplier && !unitMappingAndVariantSuffixes.has(unit)) {
    const siMultiplier = si_prefix_multiplier[unit];
    return {
      parsedUnit: null,
      unitOfValue: null,
      value: Number.parseFloat(numberPart) * siMultiplier
    };
  }
  const { baseUnit, conversionFactor } = getBaseTscircuitUnit(unit);
  return {
    parsedUnit: unit,
    unitOfValue: baseUnit,
    value: conversionFactor * Number.parseFloat(numberPart)
  };
};

// src/units/index.ts
import { z } from "zod";
var resistance = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var capacitance = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value).transform((value) => {
  return Number.parseFloat(value.toPrecision(12));
});
var inductance = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var voltage = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var length = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var frequency = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var distance = length;
var current = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var time = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var rotation = z.string().or(z.number()).transform((arg) => {
  if (typeof arg === "number") return arg;
  if (arg.endsWith("deg")) {
    return Number.parseFloat(arg.split("deg")[0]);
  }
  if (arg.endsWith("rad")) {
    return Number.parseFloat(arg.split("rad")[0]) * 180 / Math.PI;
  }
  return Number.parseFloat(arg);
});
var battery_capacity = z.number().or(z.string().endsWith("mAh")).transform((v) => {
  if (typeof v === "string") {
    const valString = v.replace("mAh", "");
    const num = Number.parseFloat(valString);
    if (Number.isNaN(num)) {
      throw new Error("Invalid capacity");
    }
    return num;
  }
  return v;
}).describe("Battery capacity in mAh");

// src/common/point.ts
import { z as z2 } from "zod";

// src/utils/expect-types-match.ts
var expectTypesMatch = (shouldBe) => {
};
expectTypesMatch("extra props b");
expectTypesMatch("missing props b");
expectTypesMatch(true);
expectTypesMatch("mismatched prop types: a");
var expectStringUnionsMatch = (shouldBe) => {
};
expectStringUnionsMatch(true);
expectStringUnionsMatch(
  'T1 has extra: "c", T2 has extra: "d"'
);
expectStringUnionsMatch('T1 has extra: "c"');
expectStringUnionsMatch('T2 has extra: "c"');
expectStringUnionsMatch(
  'T1 has extra: "d", T2 has extra: "c"'
);
expectStringUnionsMatch(true);

// src/common/point.ts
var point = z2.object({
  x: distance,
  y: distance
});
var position = point;
expectTypesMatch(true);
expectTypesMatch(true);

// src/common/point3.ts
import { z as z3 } from "zod";
var point3 = z3.object({
  x: distance,
  y: distance,
  z: distance
});
var position3 = point3;
expectTypesMatch(true);

// src/common/size.ts
import { z as z4 } from "zod";
var size = z4.object({
  width: z4.number(),
  height: z4.number()
});
expectTypesMatch(true);

// src/common/getZodPrefixedIdWithDefault.ts
import { z as z5 } from "zod";
var randomId = (length4) => {
  const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  return Array.from(
    { length: length4 },
    () => chars[Math.floor(Math.random() * chars.length)]
  ).join("");
};
var getZodPrefixedIdWithDefault = (prefix) => {
  return z5.string().optional().default(() => `${prefix}_${randomId(10)}`);
};

// src/common/NinePointAnchor.ts
import { z as z6 } from "zod";
var ninePointAnchor = z6.enum([
  "top_left",
  "top_center",
  "top_right",
  "center_left",
  "center",
  "center_right",
  "bottom_left",
  "bottom_center",
  "bottom_right"
]);
expectTypesMatch(true);

// src/source/source_simple_capacitor.ts
import { z as z9 } from "zod";

// src/pcb/properties/supplier_name.ts
import { z as z7 } from "zod";
var supplier_name = z7.enum([
  "jlcpcb",
  "macrofab",
  "pcbway",
  "digikey",
  "mouser",
  "lcsc"
]);
expectTypesMatch(true);

// src/source/base/source_component_base.ts
import { z as z8 } from "zod";
var source_component_base = z8.object({
  type: z8.literal("source_component"),
  ftype: z8.string().optional(),
  source_component_id: z8.string(),
  name: z8.string(),
  manufacturer_part_number: z8.string().optional(),
  supplier_part_numbers: z8.record(supplier_name, z8.array(z8.string())).optional(),
  display_value: z8.string().optional(),
  are_pins_interchangeable: z8.boolean().optional(),
  internally_connected_source_port_ids: z8.array(z8.array(z8.string())).optional(),
  source_group_id: z8.string().optional(),
  subcircuit_id: z8.string().optional()
});
expectTypesMatch(true);

// src/source/source_simple_capacitor.ts
var source_simple_capacitor = source_component_base.extend({
  ftype: z9.literal("simple_capacitor"),
  capacitance,
  max_voltage_rating: voltage.optional(),
  display_capacitance: z9.string().optional(),
  max_decoupling_trace_length: distance.optional()
});
expectTypesMatch(true);

// src/source/source_simple_resistor.ts
import { z as z10 } from "zod";
var source_simple_resistor = source_component_base.extend({
  ftype: z10.literal("simple_resistor"),
  resistance,
  display_resistance: z10.string().optional()
});
expectTypesMatch(true);

// src/source/source_simple_diode.ts
import { z as z11 } from "zod";
var source_simple_diode = source_component_base.extend({
  ftype: z11.literal("simple_diode")
});
expectTypesMatch(true);

// src/source/source_simple_led.ts
import { z as z12 } from "zod";
var source_simple_led = source_simple_diode.extend({
  ftype: z12.literal("simple_led"),
  color: z12.string().optional(),
  wavelength: z12.string().optional()
});
expectTypesMatch(true);

// src/source/source_simple_ground.ts
import { z as z13 } from "zod";
var source_simple_ground = source_component_base.extend({
  ftype: z13.literal("simple_ground")
});
expectTypesMatch(true);

// src/source/source_simple_chip.ts
import { z as z14 } from "zod";
var source_simple_chip = source_component_base.extend({
  ftype: z14.literal("simple_chip")
});
expectTypesMatch(true);

// src/source/source_simple_power_source.ts
import { z as z15 } from "zod";
var source_simple_power_source = source_component_base.extend({
  ftype: z15.literal("simple_power_source"),
  voltage
});
expectTypesMatch(true);

// src/source/any_source_component.ts
import { z as z32 } from "zod";

// src/source/source_simple_fuse.ts
import { z as z16 } from "zod";
var source_simple_fuse = source_component_base.extend({
  ftype: z16.literal("simple_fuse"),
  current_rating_amps: z16.number().describe("Nominal current in amps the fuse is rated for"),
  voltage_rating_volts: z16.number().describe("Voltage rating in volts, e.g. \xB15V would be 5")
});
expectTypesMatch(true);

// src/source/source_simple_battery.ts
import { z as z17 } from "zod";
var source_simple_battery = source_component_base.extend({
  ftype: z17.literal("simple_battery"),
  capacity: battery_capacity
});
expectTypesMatch(true);

// src/source/source_simple_inductor.ts
import { z as z18 } from "zod";
var source_simple_inductor = source_component_base.extend({
  ftype: z18.literal("simple_inductor"),
  inductance,
  max_current_rating: z18.number().optional()
});
expectTypesMatch(true);

// src/source/source_simple_push_button.ts
import { z as z19 } from "zod";
var source_simple_push_button = source_component_base.extend({
  ftype: z19.literal("simple_push_button")
});
expectTypesMatch(true);

// src/source/source_simple_potentiometer.ts
import { z as z20 } from "zod";
var source_simple_potentiometer = source_component_base.extend({
  ftype: z20.literal("simple_potentiometer"),
  max_resistance: resistance
});
expectTypesMatch(
  true
);

// src/source/source_simple_crystal.ts
import { z as z21 } from "zod";
var source_simple_crystal = source_component_base.extend({
  ftype: z21.literal("simple_crystal"),
  frequency: z21.number().describe("Frequency in Hz"),
  load_capacitance: z21.number().optional().describe("Load capacitance in pF")
});
expectTypesMatch(true);

// src/source/source_simple_pin_header.ts
import { z as z22 } from "zod";
var source_simple_pin_header = source_component_base.extend({
  ftype: z22.literal("simple_pin_header"),
  pin_count: z22.number(),
  gender: z22.enum(["male", "female"]).optional().default("male")
});
expectTypesMatch(true);

// src/source/source_simple_resonator.ts
import { z as z23 } from "zod";
var source_simple_resonator = source_component_base.extend({
  ftype: z23.literal("simple_resonator"),
  load_capacitance: capacitance,
  equivalent_series_resistance: resistance.optional(),
  frequency
});
expectTypesMatch(true);

// src/source/source_simple_transistor.ts
import { z as z24 } from "zod";
var source_simple_transistor = source_component_base.extend({
  ftype: z24.literal("simple_transistor"),
  transistor_type: z24.enum(["npn", "pnp"])
});
expectTypesMatch(true);

// src/source/source_simple_test_point.ts
import { z as z25 } from "zod";
var source_simple_test_point = source_component_base.extend({
  ftype: z25.literal("simple_test_point"),
  footprint_variant: z25.enum(["pad", "through_hole"]).optional(),
  pad_shape: z25.enum(["rect", "circle"]).optional(),
  pad_diameter: z25.union([z25.number(), z25.string()]).optional(),
  hole_diameter: z25.union([z25.number(), z25.string()]).optional(),
  width: z25.union([z25.number(), z25.string()]).optional(),
  height: z25.union([z25.number(), z25.string()]).optional()
});
expectTypesMatch(true);

// src/source/source_simple_mosfet.ts
import { z as z26 } from "zod";
var source_simple_mosfet = source_component_base.extend({
  ftype: z26.literal("simple_mosfet"),
  channel_type: z26.enum(["n", "p"]),
  mosfet_mode: z26.enum(["enhancement", "depletion"])
});
expectTypesMatch(true);

// src/source/source_simple_switch.ts
import { z as z27 } from "zod";
var source_simple_switch = source_component_base.extend({
  ftype: z27.literal("simple_switch")
});
expectTypesMatch(true);

// src/source/source_project_metadata.ts
import { z as z28 } from "zod";
var source_project_metadata = z28.object({
  type: z28.literal("source_project_metadata"),
  name: z28.string().optional(),
  software_used_string: z28.string().optional(),
  project_url: z28.string().optional(),
  created_at: z28.string().datetime().optional()
});
expectTypesMatch(true);

// src/source/source_missing_property_error.ts
import { z as z29 } from "zod";
var source_missing_property_error = z29.object({
  type: z29.literal("source_missing_property_error"),
  source_missing_property_error_id: getZodPrefixedIdWithDefault(
    "source_missing_property_error"
  ),
  source_component_id: z29.string(),
  property_name: z29.string(),
  subcircuit_id: z29.string().optional(),
  error_type: z29.literal("source_missing_property_error").default("source_missing_property_error"),
  message: z29.string()
}).describe("The source code is missing a property");
expectTypesMatch(true);

// src/source/source_failed_to_create_component_error.ts
import { z as z30 } from "zod";
var source_failed_to_create_component_error = z30.object({
  type: z30.literal("source_failed_to_create_component_error"),
  source_failed_to_create_component_error_id: getZodPrefixedIdWithDefault(
    "source_failed_to_create_component_error"
  ),
  error_type: z30.literal("source_failed_to_create_component_error").default("source_failed_to_create_component_error"),
  component_name: z30.string().optional(),
  subcircuit_id: z30.string().optional(),
  parent_source_component_id: z30.string().optional(),
  message: z30.string(),
  pcb_center: z30.object({
    x: z30.number().optional(),
    y: z30.number().optional()
  }).optional(),
  schematic_center: z30.object({
    x: z30.number().optional(),
    y: z30.number().optional()
  }).optional()
}).describe("Error emitted when a component fails to be constructed");
expectTypesMatch(true);

// src/source/source_trace_not_connected_error.ts
import { z as z31 } from "zod";
var source_trace_not_connected_error = z31.object({
  type: z31.literal("source_trace_not_connected_error"),
  source_trace_not_connected_error_id: getZodPrefixedIdWithDefault(
    "source_trace_not_connected_error"
  ),
  error_type: z31.literal("source_trace_not_connected_error").default("source_trace_not_connected_error"),
  message: z31.string(),
  subcircuit_id: z31.string().optional(),
  source_group_id: z31.string().optional(),
  source_trace_id: z31.string().optional(),
  connected_source_port_ids: z31.array(z31.string()).optional(),
  selectors_not_found: z31.array(z31.string()).optional()
}).describe("Occurs when a source trace selector does not match any ports");
expectTypesMatch(true);

// src/source/any_source_component.ts
var any_source_component = z32.union([
  source_simple_resistor,
  source_simple_capacitor,
  source_simple_diode,
  source_simple_led,
  source_simple_ground,
  source_simple_chip,
  source_simple_power_source,
  source_simple_battery,
  source_simple_inductor,
  source_simple_push_button,
  source_simple_potentiometer,
  source_simple_crystal,
  source_simple_pin_header,
  source_simple_resonator,
  source_simple_switch,
  source_simple_transistor,
  source_simple_test_point,
  source_simple_mosfet,
  source_simple_fuse,
  source_project_metadata,
  source_missing_property_error,
  source_failed_to_create_component_error,
  source_trace_not_connected_error
]);
expectTypesMatch(true);

// src/source/source_port.ts
import { z as z33 } from "zod";
var source_port = z33.object({
  type: z33.literal("source_port"),
  pin_number: z33.number().optional(),
  port_hints: z33.array(z33.string()).optional(),
  name: z33.string(),
  source_port_id: z33.string(),
  source_component_id: z33.string(),
  subcircuit_id: z33.string().optional(),
  subcircuit_connectivity_map_key: z33.string().optional()
});
expectTypesMatch(true);

// src/source/source_trace.ts
import { z as z34 } from "zod";
var source_trace = z34.object({
  type: z34.literal("source_trace"),
  source_trace_id: z34.string(),
  connected_source_port_ids: z34.array(z34.string()),
  connected_source_net_ids: z34.array(z34.string()),
  subcircuit_id: z34.string().optional(),
  subcircuit_connectivity_map_key: z34.string().optional(),
  max_length: z34.number().optional(),
  min_trace_thickness: z34.number().optional(),
  display_name: z34.string().optional()
});
expectTypesMatch(true);

// src/source/source_group.ts
import { z as z35 } from "zod";
var source_group = z35.object({
  type: z35.literal("source_group"),
  source_group_id: z35.string(),
  subcircuit_id: z35.string().optional(),
  parent_subcircuit_id: z35.string().optional(),
  parent_source_group_id: z35.string().optional(),
  is_subcircuit: z35.boolean().optional(),
  name: z35.string().optional()
});
expectTypesMatch(true);

// src/source/source_net.ts
import { z as z36 } from "zod";
var source_net = z36.object({
  type: z36.literal("source_net"),
  source_net_id: z36.string(),
  name: z36.string(),
  member_source_group_ids: z36.array(z36.string()),
  is_power: z36.boolean().optional(),
  is_ground: z36.boolean().optional(),
  is_digital_signal: z36.boolean().optional(),
  is_analog_signal: z36.boolean().optional(),
  trace_width: z36.number().optional(),
  subcircuit_id: z36.string().optional(),
  subcircuit_connectivity_map_key: z36.string().optional()
});
expectTypesMatch(true);

// src/source/source_pcb_ground_plane.ts
import { z as z37 } from "zod";
var source_pcb_ground_plane = z37.object({
  type: z37.literal("source_pcb_ground_plane"),
  source_pcb_ground_plane_id: z37.string(),
  source_group_id: z37.string(),
  source_net_id: z37.string(),
  subcircuit_id: z37.string().optional()
}).describe("Defines a ground plane in the source domain");
expectTypesMatch(true);

// src/schematic/schematic_box.ts
import { z as z38 } from "zod";
var schematic_box = z38.object({
  type: z38.literal("schematic_box"),
  schematic_component_id: z38.string().optional(),
  width: distance,
  height: distance,
  is_dashed: z38.boolean().default(false),
  x: distance,
  y: distance,
  subcircuit_id: z38.string().optional()
}).describe("Draws a box on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_path.ts
import { z as z39 } from "zod";
var schematic_path = z39.object({
  type: z39.literal("schematic_path"),
  schematic_component_id: z39.string(),
  fill_color: z39.enum(["red", "blue"]).optional(),
  is_filled: z39.boolean().optional(),
  points: z39.array(point),
  subcircuit_id: z39.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_component.ts
import { z as z40 } from "zod";
var schematic_pin_styles = z40.record(
  z40.object({
    left_margin: length.optional(),
    right_margin: length.optional(),
    top_margin: length.optional(),
    bottom_margin: length.optional()
  })
);
var schematic_component_port_arrangement_by_size = z40.object({
  left_size: z40.number(),
  right_size: z40.number(),
  top_size: z40.number().optional(),
  bottom_size: z40.number().optional()
});
expectTypesMatch(true);
var schematic_component_port_arrangement_by_sides = z40.object({
  left_side: z40.object({
    pins: z40.array(z40.number()),
    // @ts-ignore
    direction: z40.enum(["top-to-bottom", "bottom-to-top"]).optional()
  }).optional(),
  right_side: z40.object({
    pins: z40.array(z40.number()),
    // @ts-ignore
    direction: z40.enum(["top-to-bottom", "bottom-to-top"]).optional()
  }).optional(),
  top_side: z40.object({
    pins: z40.array(z40.number()),
    // @ts-ignore
    direction: z40.enum(["left-to-right", "right-to-left"]).optional()
  }).optional(),
  bottom_side: z40.object({
    pins: z40.array(z40.number()),
    // @ts-ignore
    direction: z40.enum(["left-to-right", "right-to-left"]).optional()
  }).optional()
});
expectTypesMatch(true);
var port_arrangement = z40.union([
  schematic_component_port_arrangement_by_size,
  schematic_component_port_arrangement_by_sides
]);
var schematic_component = z40.object({
  type: z40.literal("schematic_component"),
  size,
  center: point,
  source_component_id: z40.string(),
  schematic_component_id: z40.string(),
  pin_spacing: length.optional(),
  pin_styles: schematic_pin_styles.optional(),
  box_width: length.optional(),
  symbol_name: z40.string().optional(),
  port_arrangement: port_arrangement.optional(),
  port_labels: z40.record(z40.string()).optional(),
  symbol_display_value: z40.string().optional(),
  subcircuit_id: z40.string().optional(),
  schematic_group_id: z40.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_line.ts
import { z as z41 } from "zod";
var schematic_line = z41.object({
  type: z41.literal("schematic_line"),
  schematic_component_id: z41.string(),
  x1: distance,
  x2: distance,
  y1: distance,
  y2: distance,
  subcircuit_id: z41.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_trace.ts
import { z as z42 } from "zod";
var schematic_trace = z42.object({
  type: z42.literal("schematic_trace"),
  schematic_trace_id: z42.string(),
  source_trace_id: z42.string(),
  junctions: z42.array(
    z42.object({
      x: z42.number(),
      y: z42.number()
    })
  ),
  edges: z42.array(
    z42.object({
      from: z42.object({
        x: z42.number(),
        y: z42.number()
      }),
      to: z42.object({
        x: z42.number(),
        y: z42.number()
      }),
      is_crossing: z42.boolean().optional(),
      from_schematic_port_id: z42.string().optional(),
      to_schematic_port_id: z42.string().optional()
    })
  ),
  subcircuit_id: z42.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_text.ts
import { z as z44 } from "zod";

// src/common/FivePointAnchor.ts
import { z as z43 } from "zod";
var fivePointAnchor = z43.enum([
  "center",
  "left",
  "right",
  "top",
  "bottom"
]);
expectTypesMatch(true);

// src/schematic/schematic_text.ts
var schematic_text = z44.object({
  type: z44.literal("schematic_text"),
  schematic_component_id: z44.string().optional(),
  schematic_text_id: z44.string(),
  text: z44.string(),
  font_size: z44.number().default(0.18),
  position: z44.object({
    x: distance,
    y: distance
  }),
  rotation: z44.number().default(0),
  anchor: z44.union([fivePointAnchor.describe("legacy"), ninePointAnchor]).default("center"),
  color: z44.string().default("#000000"),
  subcircuit_id: z44.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_port.ts
import { z as z45 } from "zod";
var schematic_port = z45.object({
  type: z45.literal("schematic_port"),
  schematic_port_id: z45.string(),
  source_port_id: z45.string(),
  schematic_component_id: z45.string().optional(),
  center: point,
  facing_direction: z45.enum(["up", "down", "left", "right"]).optional(),
  distance_from_component_edge: z45.number().optional(),
  side_of_component: z45.enum(["top", "bottom", "left", "right"]).optional(),
  true_ccw_index: z45.number().optional(),
  pin_number: z45.number().optional(),
  display_pin_label: z45.string().optional(),
  subcircuit_id: z45.string().optional(),
  is_connected: z45.boolean().optional()
}).describe("Defines a port on a schematic component");
expectTypesMatch(true);

// src/schematic/schematic_net_label.ts
import { z as z46 } from "zod";
var schematic_net_label = z46.object({
  type: z46.literal("schematic_net_label"),
  schematic_net_label_id: getZodPrefixedIdWithDefault("schematic_net_label"),
  schematic_trace_id: z46.string().optional(),
  source_trace_id: z46.string().optional(),
  source_net_id: z46.string(),
  center: point,
  anchor_position: point.optional(),
  anchor_side: z46.enum(["top", "bottom", "left", "right"]),
  text: z46.string(),
  symbol_name: z46.string().optional(),
  is_movable: z46.boolean().optional(),
  subcircuit_id: z46.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_error.ts
import { z as z47 } from "zod";
var schematic_error = z47.object({
  type: z47.literal("schematic_error"),
  schematic_error_id: z47.string(),
  // eventually each error type should be broken out into a dir of files
  error_type: z47.literal("schematic_port_not_found").default("schematic_port_not_found"),
  message: z47.string(),
  subcircuit_id: z47.string().optional()
}).describe("Defines a schematic error on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_layout_error.ts
import { z as z48 } from "zod";
var schematic_layout_error = z48.object({
  type: z48.literal("schematic_layout_error"),
  schematic_layout_error_id: getZodPrefixedIdWithDefault(
    "schematic_layout_error"
  ),
  error_type: z48.literal("schematic_layout_error").default("schematic_layout_error"),
  message: z48.string(),
  source_group_id: z48.string(),
  schematic_group_id: z48.string(),
  subcircuit_id: z48.string().optional()
}).describe("Error emitted when schematic layout fails for a group");
expectTypesMatch(true);

// src/schematic/schematic_debug_object.ts
import { z as z49 } from "zod";
var schematic_debug_object_base = z49.object({
  type: z49.literal("schematic_debug_object"),
  label: z49.string().optional(),
  subcircuit_id: z49.string().optional()
});
var schematic_debug_rect = schematic_debug_object_base.extend({
  shape: z49.literal("rect"),
  center: point,
  size
});
var schematic_debug_line = schematic_debug_object_base.extend({
  shape: z49.literal("line"),
  start: point,
  end: point
});
var schematic_debug_point = schematic_debug_object_base.extend({
  shape: z49.literal("point"),
  center: point
});
var schematic_debug_object = z49.discriminatedUnion("shape", [
  schematic_debug_rect,
  schematic_debug_line,
  schematic_debug_point
]);
expectTypesMatch(true);

// src/schematic/schematic_voltage_probe.ts
import { z as z50 } from "zod";
var schematic_voltage_probe = z50.object({
  type: z50.literal("schematic_voltage_probe"),
  schematic_voltage_probe_id: z50.string(),
  position: point,
  schematic_trace_id: z50.string(),
  voltage: voltage.optional(),
  subcircuit_id: z50.string().optional()
}).describe("Defines a voltage probe measurement point on a schematic trace");
expectTypesMatch(true);

// src/schematic/schematic_manual_edit_conflict_warning.ts
import { z as z51 } from "zod";
var schematic_manual_edit_conflict_warning = z51.object({
  type: z51.literal("schematic_manual_edit_conflict_warning"),
  schematic_manual_edit_conflict_warning_id: getZodPrefixedIdWithDefault(
    "schematic_manual_edit_conflict_warning"
  ),
  warning_type: z51.literal("schematic_manual_edit_conflict_warning").default("schematic_manual_edit_conflict_warning"),
  message: z51.string(),
  schematic_component_id: z51.string(),
  schematic_group_id: z51.string().optional(),
  subcircuit_id: z51.string().optional(),
  source_component_id: z51.string()
}).describe(
  "Warning emitted when a component has both manual placement and explicit schX/schY coordinates"
);
expectTypesMatch(true);

// src/schematic/schematic_group.ts
import { z as z52 } from "zod";
var schematic_group = z52.object({
  type: z52.literal("schematic_group"),
  schematic_group_id: getZodPrefixedIdWithDefault("schematic_group"),
  source_group_id: z52.string(),
  is_subcircuit: z52.boolean().optional(),
  subcircuit_id: z52.string().optional(),
  width: length,
  height: length,
  center: point,
  schematic_component_ids: z52.array(z52.string()),
  name: z52.string().optional(),
  description: z52.string().optional()
}).describe("Defines a group of components on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_table.ts
import { z as z53 } from "zod";
var schematic_table = z53.object({
  type: z53.literal("schematic_table"),
  schematic_table_id: getZodPrefixedIdWithDefault("schematic_table"),
  anchor_position: point,
  column_widths: z53.array(distance),
  row_heights: z53.array(distance),
  cell_padding: distance.optional(),
  border_width: distance.optional(),
  subcircuit_id: z53.string().optional(),
  schematic_component_id: z53.string().optional(),
  anchor: ninePointAnchor.optional()
}).describe("Defines a table on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_table_cell.ts
import { z as z54 } from "zod";
var schematic_table_cell = z54.object({
  type: z54.literal("schematic_table_cell"),
  schematic_table_cell_id: getZodPrefixedIdWithDefault(
    "schematic_table_cell"
  ),
  schematic_table_id: z54.string(),
  start_row_index: z54.number(),
  end_row_index: z54.number(),
  start_column_index: z54.number(),
  end_column_index: z54.number(),
  text: z54.string().optional(),
  center: point,
  width: distance,
  height: distance,
  horizontal_align: z54.enum(["left", "center", "right"]).optional(),
  vertical_align: z54.enum(["top", "middle", "bottom"]).optional(),
  font_size: distance.optional(),
  subcircuit_id: z54.string().optional()
}).describe("Defines a cell within a schematic_table");
expectTypesMatch(true);

// src/pcb/properties/layer_ref.ts
import { z as z55 } from "zod";
var all_layers = [
  "top",
  "bottom",
  "inner1",
  "inner2",
  "inner3",
  "inner4",
  "inner5",
  "inner6"
];
var layer_string = z55.enum(all_layers);
var layer_ref = layer_string.or(
  z55.object({
    name: layer_string
  })
).transform((layer) => {
  if (typeof layer === "string") {
    return layer;
  }
  return layer.name;
});
expectTypesMatch(true);
var visible_layer = z55.enum(["top", "bottom"]);

// src/pcb/properties/pcb_route_hints.ts
import { z as z56 } from "zod";
var pcb_route_hint = z56.object({
  x: distance,
  y: distance,
  via: z56.boolean().optional(),
  via_to_layer: layer_ref.optional()
});
var pcb_route_hints = z56.array(pcb_route_hint);
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/properties/route_hint_point.ts
import { z as z57 } from "zod";
var route_hint_point = z57.object({
  x: distance,
  y: distance,
  via: z57.boolean().optional(),
  to_layer: layer_ref.optional(),
  trace_width: distance.optional()
});
expectTypesMatch(true);

// src/pcb/pcb_component.ts
import { z as z58 } from "zod";
var pcb_component = z58.object({
  type: z58.literal("pcb_component"),
  pcb_component_id: getZodPrefixedIdWithDefault("pcb_component"),
  source_component_id: z58.string(),
  center: point,
  layer: layer_ref,
  rotation,
  width: length,
  height: length,
  subcircuit_id: z58.string().optional(),
  pcb_group_id: z58.string().optional()
}).describe("Defines a component on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_hole.ts
import { z as z59 } from "zod";
var pcb_hole_circle_or_square = z59.object({
  type: z59.literal("pcb_hole"),
  pcb_hole_id: getZodPrefixedIdWithDefault("pcb_hole"),
  pcb_group_id: z59.string().optional(),
  subcircuit_id: z59.string().optional(),
  hole_shape: z59.enum(["circle", "square"]),
  hole_diameter: z59.number(),
  x: distance,
  y: distance
});
var pcb_hole_circle_or_square_shape = pcb_hole_circle_or_square.describe(
  "Defines a circular or square hole on the PCB"
);
expectTypesMatch(true);
var pcb_hole_oval = z59.object({
  type: z59.literal("pcb_hole"),
  pcb_hole_id: getZodPrefixedIdWithDefault("pcb_hole"),
  pcb_group_id: z59.string().optional(),
  subcircuit_id: z59.string().optional(),
  hole_shape: z59.literal("oval"),
  hole_width: z59.number(),
  hole_height: z59.number(),
  x: distance,
  y: distance
});
var pcb_hole_oval_shape = pcb_hole_oval.describe(
  "Defines an oval hole on the PCB"
);
expectTypesMatch(true);
var pcb_hole = pcb_hole_circle_or_square.or(pcb_hole_oval);

// src/pcb/pcb_plated_hole.ts
import { z as z60 } from "zod";
var pcb_plated_hole_circle = z60.object({
  type: z60.literal("pcb_plated_hole"),
  shape: z60.literal("circle"),
  pcb_group_id: z60.string().optional(),
  subcircuit_id: z60.string().optional(),
  outer_diameter: z60.number(),
  hole_diameter: z60.number(),
  x: distance,
  y: distance,
  layers: z60.array(layer_ref),
  port_hints: z60.array(z60.string()).optional(),
  pcb_component_id: z60.string().optional(),
  pcb_port_id: z60.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole")
});
var pcb_plated_hole_oval = z60.object({
  type: z60.literal("pcb_plated_hole"),
  shape: z60.enum(["oval", "pill"]),
  pcb_group_id: z60.string().optional(),
  subcircuit_id: z60.string().optional(),
  outer_width: z60.number(),
  outer_height: z60.number(),
  hole_width: z60.number(),
  hole_height: z60.number(),
  x: distance,
  y: distance,
  layers: z60.array(layer_ref),
  port_hints: z60.array(z60.string()).optional(),
  pcb_component_id: z60.string().optional(),
  pcb_port_id: z60.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole")
});
var pcb_circular_hole_with_rect_pad = z60.object({
  type: z60.literal("pcb_plated_hole"),
  shape: z60.literal("circular_hole_with_rect_pad"),
  pcb_group_id: z60.string().optional(),
  subcircuit_id: z60.string().optional(),
  hole_shape: z60.literal("circle"),
  pad_shape: z60.literal("rect"),
  hole_diameter: z60.number(),
  rect_pad_width: z60.number(),
  rect_pad_height: z60.number(),
  x: distance,
  y: distance,
  layers: z60.array(layer_ref),
  port_hints: z60.array(z60.string()).optional(),
  pcb_component_id: z60.string().optional(),
  pcb_port_id: z60.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole")
});
var pcb_pill_hole_with_rect_pad = z60.object({
  type: z60.literal("pcb_plated_hole"),
  shape: z60.literal("pill_hole_with_rect_pad"),
  pcb_group_id: z60.string().optional(),
  subcircuit_id: z60.string().optional(),
  hole_shape: z60.literal("pill"),
  pad_shape: z60.literal("rect"),
  hole_width: z60.number(),
  hole_height: z60.number(),
  rect_pad_width: z60.number(),
  rect_pad_height: z60.number(),
  x: distance,
  y: distance,
  layers: z60.array(layer_ref),
  port_hints: z60.array(z60.string()).optional(),
  pcb_component_id: z60.string().optional(),
  pcb_port_id: z60.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole")
});
var pcb_rotated_pill_hole_with_rect_pad = z60.object({
  type: z60.literal("pcb_plated_hole"),
  shape: z60.literal("rotated_pill_hole_with_rect_pad"),
  pcb_group_id: z60.string().optional(),
  subcircuit_id: z60.string().optional(),
  hole_shape: z60.literal("rotated_pill"),
  pad_shape: z60.literal("rect"),
  hole_width: z60.number(),
  hole_height: z60.number(),
  hole_ccw_rotation: rotation,
  rect_pad_width: z60.number(),
  rect_pad_height: z60.number(),
  rect_ccw_rotation: rotation,
  x: distance,
  y: distance,
  layers: z60.array(layer_ref),
  port_hints: z60.array(z60.string()).optional(),
  pcb_component_id: z60.string().optional(),
  pcb_port_id: z60.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole")
});
var pcb_plated_hole = z60.union([
  pcb_plated_hole_circle,
  pcb_plated_hole_oval,
  pcb_circular_hole_with_rect_pad,
  pcb_pill_hole_with_rect_pad,
  pcb_rotated_pill_hole_with_rect_pad
]);
expectTypesMatch(
  true
);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/pcb_port.ts
import { z as z61 } from "zod";
var pcb_port = z61.object({
  type: z61.literal("pcb_port"),
  pcb_port_id: getZodPrefixedIdWithDefault("pcb_port"),
  pcb_group_id: z61.string().optional(),
  subcircuit_id: z61.string().optional(),
  source_port_id: z61.string(),
  pcb_component_id: z61.string(),
  x: distance,
  y: distance,
  layers: z61.array(layer_ref)
}).describe("Defines a port on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_smtpad.ts
import { z as z62 } from "zod";
var pcb_smtpad_circle = z62.object({
  type: z62.literal("pcb_smtpad"),
  shape: z62.literal("circle"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  x: distance,
  y: distance,
  radius: z62.number(),
  layer: layer_ref,
  port_hints: z62.array(z62.string()).optional(),
  pcb_component_id: z62.string().optional(),
  pcb_port_id: z62.string().optional()
});
var pcb_smtpad_rect = z62.object({
  type: z62.literal("pcb_smtpad"),
  shape: z62.literal("rect"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  x: distance,
  y: distance,
  width: z62.number(),
  height: z62.number(),
  layer: layer_ref,
  port_hints: z62.array(z62.string()).optional(),
  pcb_component_id: z62.string().optional(),
  pcb_port_id: z62.string().optional()
});
var pcb_smtpad_rotated_rect = z62.object({
  type: z62.literal("pcb_smtpad"),
  shape: z62.literal("rotated_rect"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  x: distance,
  y: distance,
  width: z62.number(),
  height: z62.number(),
  ccw_rotation: rotation,
  layer: layer_ref,
  port_hints: z62.array(z62.string()).optional(),
  pcb_component_id: z62.string().optional(),
  pcb_port_id: z62.string().optional()
});
var pcb_smtpad_pill = z62.object({
  type: z62.literal("pcb_smtpad"),
  shape: z62.literal("pill"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  x: distance,
  y: distance,
  width: z62.number(),
  height: z62.number(),
  radius: z62.number(),
  layer: layer_ref,
  port_hints: z62.array(z62.string()).optional(),
  pcb_component_id: z62.string().optional(),
  pcb_port_id: z62.string().optional()
});
var pcb_smtpad_rotated_pill = z62.object({
  type: z62.literal("pcb_smtpad"),
  shape: z62.literal("rotated_pill"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  x: distance,
  y: distance,
  width: z62.number(),
  height: z62.number(),
  radius: z62.number(),
  ccw_rotation: rotation,
  layer: layer_ref,
  port_hints: z62.array(z62.string()).optional(),
  pcb_component_id: z62.string().optional(),
  pcb_port_id: z62.string().optional()
});
var pcb_smtpad_polygon = z62.object({
  type: z62.literal("pcb_smtpad"),
  shape: z62.literal("polygon"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  points: z62.array(point),
  layer: layer_ref,
  port_hints: z62.array(z62.string()).optional(),
  pcb_component_id: z62.string().optional(),
  pcb_port_id: z62.string().optional()
});
var pcb_smtpad = z62.discriminatedUnion("shape", [
  pcb_smtpad_circle,
  pcb_smtpad_rect,
  pcb_smtpad_rotated_rect,
  pcb_smtpad_rotated_pill,
  pcb_smtpad_pill,
  pcb_smtpad_polygon
]).describe("Defines an SMT pad on the PCB");
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/pcb_solder_paste.ts
import { z as z63 } from "zod";
var pcb_solder_paste_circle = z63.object({
  type: z63.literal("pcb_solder_paste"),
  shape: z63.literal("circle"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z63.string().optional(),
  subcircuit_id: z63.string().optional(),
  x: distance,
  y: distance,
  radius: z63.number(),
  layer: layer_ref,
  pcb_component_id: z63.string().optional(),
  pcb_smtpad_id: z63.string().optional()
});
var pcb_solder_paste_rect = z63.object({
  type: z63.literal("pcb_solder_paste"),
  shape: z63.literal("rect"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z63.string().optional(),
  subcircuit_id: z63.string().optional(),
  x: distance,
  y: distance,
  width: z63.number(),
  height: z63.number(),
  layer: layer_ref,
  pcb_component_id: z63.string().optional(),
  pcb_smtpad_id: z63.string().optional()
});
var pcb_solder_paste_pill = z63.object({
  type: z63.literal("pcb_solder_paste"),
  shape: z63.literal("pill"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z63.string().optional(),
  subcircuit_id: z63.string().optional(),
  x: distance,
  y: distance,
  width: z63.number(),
  height: z63.number(),
  radius: z63.number(),
  layer: layer_ref,
  pcb_component_id: z63.string().optional(),
  pcb_smtpad_id: z63.string().optional()
});
var pcb_solder_paste_rotated_rect = z63.object({
  type: z63.literal("pcb_solder_paste"),
  shape: z63.literal("rotated_rect"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z63.string().optional(),
  subcircuit_id: z63.string().optional(),
  x: distance,
  y: distance,
  width: z63.number(),
  height: z63.number(),
  ccw_rotation: distance,
  layer: layer_ref,
  pcb_component_id: z63.string().optional(),
  pcb_smtpad_id: z63.string().optional()
});
var pcb_solder_paste_oval = z63.object({
  type: z63.literal("pcb_solder_paste"),
  shape: z63.literal("oval"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z63.string().optional(),
  subcircuit_id: z63.string().optional(),
  x: distance,
  y: distance,
  width: z63.number(),
  height: z63.number(),
  layer: layer_ref,
  pcb_component_id: z63.string().optional(),
  pcb_smtpad_id: z63.string().optional()
});
var pcb_solder_paste = z63.union([
  pcb_solder_paste_circle,
  pcb_solder_paste_rect,
  pcb_solder_paste_pill,
  pcb_solder_paste_rotated_rect,
  pcb_solder_paste_oval
]).describe("Defines solderpaste on the PCB");
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(
  true
);
expectTypesMatch(true);

// src/pcb/pcb_text.ts
import { z as z64 } from "zod";
var pcb_text = z64.object({
  type: z64.literal("pcb_text"),
  pcb_text_id: getZodPrefixedIdWithDefault("pcb_text"),
  pcb_group_id: z64.string().optional(),
  subcircuit_id: z64.string().optional(),
  text: z64.string(),
  center: point,
  layer: layer_ref,
  width: length,
  height: length,
  lines: z64.number(),
  // @ts-ignore
  align: z64.enum(["bottom-left"])
}).describe("Defines text on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_trace.ts
import { z as z65 } from "zod";
var pcb_trace_route_point_wire = z65.object({
  route_type: z65.literal("wire"),
  x: distance,
  y: distance,
  width: distance,
  start_pcb_port_id: z65.string().optional(),
  end_pcb_port_id: z65.string().optional(),
  layer: layer_ref
});
var pcb_trace_route_point_via = z65.object({
  route_type: z65.literal("via"),
  x: distance,
  y: distance,
  hole_diameter: distance.optional(),
  outer_diameter: distance.optional(),
  from_layer: z65.string(),
  to_layer: z65.string()
});
var pcb_trace_route_point = z65.union([
  pcb_trace_route_point_wire,
  pcb_trace_route_point_via
]);
var pcb_trace = z65.object({
  type: z65.literal("pcb_trace"),
  source_trace_id: z65.string().optional(),
  pcb_component_id: z65.string().optional(),
  pcb_trace_id: getZodPrefixedIdWithDefault("pcb_trace"),
  pcb_group_id: z65.string().optional(),
  subcircuit_id: z65.string().optional(),
  route_thickness_mode: z65.enum(["constant", "interpolated"]).default("constant").optional(),
  route_order_index: z65.number().optional(),
  should_round_corners: z65.boolean().optional(),
  trace_length: z65.number().optional(),
  route: z65.array(pcb_trace_route_point)
}).describe("Defines a trace on the PCB");
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/pcb_trace_error.ts
import { z as z66 } from "zod";
var pcb_trace_error = z66.object({
  type: z66.literal("pcb_trace_error"),
  pcb_trace_error_id: getZodPrefixedIdWithDefault("pcb_trace_error"),
  error_type: z66.literal("pcb_trace_error").default("pcb_trace_error"),
  message: z66.string(),
  center: point.optional(),
  pcb_trace_id: z66.string(),
  source_trace_id: z66.string(),
  pcb_component_ids: z66.array(z66.string()),
  pcb_port_ids: z66.array(z66.string()),
  subcircuit_id: z66.string().optional()
}).describe("Defines a trace error on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_trace_missing_error.ts
import { z as z67 } from "zod";
var pcb_trace_missing_error = z67.object({
  type: z67.literal("pcb_trace_missing_error"),
  pcb_trace_missing_error_id: getZodPrefixedIdWithDefault(
    "pcb_trace_missing_error"
  ),
  error_type: z67.literal("pcb_trace_missing_error").default("pcb_trace_missing_error"),
  message: z67.string(),
  center: point.optional(),
  source_trace_id: z67.string(),
  pcb_component_ids: z67.array(z67.string()),
  pcb_port_ids: z67.array(z67.string()),
  subcircuit_id: z67.string().optional()
}).describe(
  "Defines an error when a source trace has no corresponding PCB trace"
);
expectTypesMatch(true);

// src/pcb/pcb_port_not_matched_error.ts
import { z as z68 } from "zod";
var pcb_port_not_matched_error = z68.object({
  type: z68.literal("pcb_port_not_matched_error"),
  pcb_error_id: getZodPrefixedIdWithDefault("pcb_error"),
  error_type: z68.literal("pcb_port_not_matched_error").default("pcb_port_not_matched_error"),
  message: z68.string(),
  pcb_component_ids: z68.array(z68.string()),
  subcircuit_id: z68.string().optional()
}).describe("Defines a trace error on the PCB where a port is not matched");
expectTypesMatch(true);

// src/pcb/pcb_port_not_connected_error.ts
import { z as z69 } from "zod";
var pcb_port_not_connected_error = z69.object({
  type: z69.literal("pcb_port_not_connected_error"),
  pcb_port_not_connected_error_id: getZodPrefixedIdWithDefault(
    "pcb_port_not_connected_error"
  ),
  error_type: z69.literal("pcb_port_not_connected_error").default("pcb_port_not_connected_error"),
  message: z69.string(),
  pcb_port_ids: z69.array(z69.string()),
  pcb_component_ids: z69.array(z69.string()),
  subcircuit_id: z69.string().optional()
}).describe("Defines an error when a pcb port is not connected to any trace");
expectTypesMatch(
  true
);

// src/pcb/pcb_via.ts
import { z as z70 } from "zod";
var pcb_via = z70.object({
  type: z70.literal("pcb_via"),
  pcb_via_id: getZodPrefixedIdWithDefault("pcb_via"),
  pcb_group_id: z70.string().optional(),
  subcircuit_id: z70.string().optional(),
  x: distance,
  y: distance,
  outer_diameter: distance.default("0.6mm"),
  hole_diameter: distance.default("0.25mm"),
  /** @deprecated */
  from_layer: layer_ref.optional(),
  /** @deprecated */
  to_layer: layer_ref.optional(),
  layers: z70.array(layer_ref),
  pcb_trace_id: z70.string().optional()
}).describe("Defines a via on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_board.ts
import { z as z71 } from "zod";
var pcb_board = z71.object({
  type: z71.literal("pcb_board"),
  pcb_board_id: getZodPrefixedIdWithDefault("pcb_board"),
  is_subcircuit: z71.boolean().optional(),
  subcircuit_id: z71.string().optional(),
  width: length,
  height: length,
  center: point,
  thickness: length.optional().default(1.4),
  num_layers: z71.number().optional().default(4),
  outline: z71.array(point).optional(),
  material: z71.enum(["fr4", "fr1"]).default("fr4")
}).describe("Defines the board outline of the PCB");
expectTypesMatch(true);

// src/pcb/pcb_placement_error.ts
import { z as z72 } from "zod";
var pcb_placement_error = z72.object({
  type: z72.literal("pcb_placement_error"),
  pcb_placement_error_id: getZodPrefixedIdWithDefault("pcb_placement_error"),
  error_type: z72.literal("pcb_placement_error").default("pcb_placement_error"),
  message: z72.string(),
  subcircuit_id: z72.string().optional()
}).describe("Defines a placement error on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_trace_hint.ts
import { z as z73 } from "zod";
var pcb_trace_hint = z73.object({
  type: z73.literal("pcb_trace_hint"),
  pcb_trace_hint_id: getZodPrefixedIdWithDefault("pcb_trace_hint"),
  pcb_port_id: z73.string(),
  pcb_component_id: z73.string(),
  route: z73.array(route_hint_point),
  subcircuit_id: z73.string().optional()
}).describe("A hint that can be used during generation of a PCB trace");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_line.ts
import { z as z74 } from "zod";
var pcb_silkscreen_line = z74.object({
  type: z74.literal("pcb_silkscreen_line"),
  pcb_silkscreen_line_id: getZodPrefixedIdWithDefault("pcb_silkscreen_line"),
  pcb_component_id: z74.string(),
  pcb_group_id: z74.string().optional(),
  subcircuit_id: z74.string().optional(),
  stroke_width: distance.default("0.1mm"),
  x1: distance,
  y1: distance,
  x2: distance,
  y2: distance,
  layer: visible_layer
}).describe("Defines a silkscreen line on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_path.ts
import { z as z75 } from "zod";
var pcb_silkscreen_path = z75.object({
  type: z75.literal("pcb_silkscreen_path"),
  pcb_silkscreen_path_id: getZodPrefixedIdWithDefault("pcb_silkscreen_path"),
  pcb_component_id: z75.string(),
  pcb_group_id: z75.string().optional(),
  subcircuit_id: z75.string().optional(),
  layer: visible_layer,
  route: z75.array(point),
  stroke_width: length
}).describe("Defines a silkscreen path on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_text.ts
import { z as z76 } from "zod";
var pcb_silkscreen_text = z76.object({
  type: z76.literal("pcb_silkscreen_text"),
  pcb_silkscreen_text_id: getZodPrefixedIdWithDefault("pcb_silkscreen_text"),
  pcb_group_id: z76.string().optional(),
  subcircuit_id: z76.string().optional(),
  font: z76.literal("tscircuit2024").default("tscircuit2024"),
  font_size: distance.default("0.2mm"),
  pcb_component_id: z76.string(),
  text: z76.string(),
  ccw_rotation: z76.number().optional(),
  layer: layer_ref,
  is_mirrored: z76.boolean().default(false).optional(),
  anchor_position: point.default({ x: 0, y: 0 }),
  anchor_alignment: ninePointAnchor.default("center")
}).describe("Defines silkscreen text on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_rect.ts
import { z as z77 } from "zod";
var pcb_silkscreen_rect = z77.object({
  type: z77.literal("pcb_silkscreen_rect"),
  pcb_silkscreen_rect_id: getZodPrefixedIdWithDefault("pcb_silkscreen_rect"),
  pcb_component_id: z77.string(),
  pcb_group_id: z77.string().optional(),
  subcircuit_id: z77.string().optional(),
  center: point,
  width: length,
  height: length,
  layer: layer_ref,
  stroke_width: length.default("1mm"),
  is_filled: z77.boolean().default(true).optional(),
  has_stroke: z77.boolean().optional(),
  is_stroke_dashed: z77.boolean().optional()
}).describe("Defines a silkscreen rect on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_circle.ts
import { z as z78 } from "zod";
var pcb_silkscreen_circle = z78.object({
  type: z78.literal("pcb_silkscreen_circle"),
  pcb_silkscreen_circle_id: getZodPrefixedIdWithDefault(
    "pcb_silkscreen_circle"
  ),
  pcb_component_id: z78.string(),
  pcb_group_id: z78.string().optional(),
  subcircuit_id: z78.string().optional(),
  center: point,
  radius: length,
  layer: visible_layer,
  stroke_width: length.default("1mm")
}).describe("Defines a silkscreen circle on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_oval.ts
import { z as z79 } from "zod";
var pcb_silkscreen_oval = z79.object({
  type: z79.literal("pcb_silkscreen_oval"),
  pcb_silkscreen_oval_id: getZodPrefixedIdWithDefault("pcb_silkscreen_oval"),
  pcb_component_id: z79.string(),
  pcb_group_id: z79.string().optional(),
  subcircuit_id: z79.string().optional(),
  center: point,
  radius_x: distance,
  radius_y: distance,
  layer: visible_layer
}).describe("Defines a silkscreen oval on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_fabrication_note_text.ts
import { z as z80 } from "zod";
var pcb_fabrication_note_text = z80.object({
  type: z80.literal("pcb_fabrication_note_text"),
  pcb_fabrication_note_text_id: getZodPrefixedIdWithDefault(
    "pcb_fabrication_note_text"
  ),
  subcircuit_id: z80.string().optional(),
  pcb_group_id: z80.string().optional(),
  font: z80.literal("tscircuit2024").default("tscircuit2024"),
  font_size: distance.default("1mm"),
  pcb_component_id: z80.string(),
  text: z80.string(),
  layer: visible_layer,
  anchor_position: point.default({ x: 0, y: 0 }),
  anchor_alignment: z80.enum(["center", "top_left", "top_right", "bottom_left", "bottom_right"]).default("center"),
  color: z80.string().optional()
}).describe(
  "Defines a fabrication note in text on the PCB, useful for leaving notes for assemblers or fabricators"
);
expectTypesMatch(true);

// src/pcb/pcb_fabrication_note_path.ts
import { z as z81 } from "zod";
var pcb_fabrication_note_path = z81.object({
  type: z81.literal("pcb_fabrication_note_path"),
  pcb_fabrication_note_path_id: getZodPrefixedIdWithDefault(
    "pcb_fabrication_note_path"
  ),
  pcb_component_id: z81.string(),
  subcircuit_id: z81.string().optional(),
  layer: layer_ref,
  route: z81.array(point),
  stroke_width: length,
  color: z81.string().optional()
}).describe(
  "Defines a fabrication path on the PCB for fabricators or assemblers"
);
expectTypesMatch(true);

// src/pcb/pcb_footprint_overlap_error.ts
import { z as z82 } from "zod";
var pcb_footprint_overlap_error = z82.object({
  type: z82.literal("pcb_footprint_overlap_error"),
  pcb_error_id: getZodPrefixedIdWithDefault("pcb_error"),
  error_type: z82.literal("pcb_footprint_overlap_error").default("pcb_footprint_overlap_error"),
  message: z82.string(),
  pcb_smtpad_ids: z82.array(z82.string()).optional(),
  pcb_plated_hole_ids: z82.array(z82.string()).optional(),
  pcb_hole_ids: z82.array(z82.string()).optional(),
  pcb_keepout_ids: z82.array(z82.string()).optional()
}).describe("Error emitted when a pcb footprint overlaps with another element");
expectTypesMatch(
  true
);

// src/pcb/pcb_keepout.ts
import { z as z83 } from "zod";
var pcb_keepout = z83.object({
  type: z83.literal("pcb_keepout"),
  shape: z83.literal("rect"),
  pcb_group_id: z83.string().optional(),
  subcircuit_id: z83.string().optional(),
  center: point,
  width: distance,
  height: distance,
  pcb_keepout_id: z83.string(),
  layers: z83.array(z83.string()),
  // Specify layers where the keepout applies
  description: z83.string().optional()
  // Optional description of the keepout
}).or(
  z83.object({
    type: z83.literal("pcb_keepout"),
    shape: z83.literal("circle"),
    pcb_group_id: z83.string().optional(),
    subcircuit_id: z83.string().optional(),
    center: point,
    radius: distance,
    pcb_keepout_id: z83.string(),
    layers: z83.array(z83.string()),
    // Specify layers where the keepout applies
    description: z83.string().optional()
    // Optional description of the keepout
  })
);
expectTypesMatch(true);

// src/pcb/pcb_cutout.ts
import { z as z84 } from "zod";
var pcb_cutout_base = z84.object({
  type: z84.literal("pcb_cutout"),
  pcb_cutout_id: getZodPrefixedIdWithDefault("pcb_cutout"),
  pcb_group_id: z84.string().optional(),
  subcircuit_id: z84.string().optional()
});
var pcb_cutout_rect = pcb_cutout_base.extend({
  shape: z84.literal("rect"),
  center: point,
  width: length,
  height: length,
  rotation: rotation.optional()
});
expectTypesMatch(true);
var pcb_cutout_circle = pcb_cutout_base.extend({
  shape: z84.literal("circle"),
  center: point,
  radius: length
});
expectTypesMatch(true);
var pcb_cutout_polygon = pcb_cutout_base.extend({
  shape: z84.literal("polygon"),
  points: z84.array(point)
});
expectTypesMatch(true);
var pcb_cutout = z84.discriminatedUnion("shape", [
  pcb_cutout_rect,
  pcb_cutout_circle,
  pcb_cutout_polygon
]).describe("Defines a cutout on the PCB, removing board material.");
expectTypesMatch(true);

// src/pcb/pcb_missing_footprint_error.ts
import { z as z85 } from "zod";
var pcb_missing_footprint_error = z85.object({
  type: z85.literal("pcb_missing_footprint_error"),
  pcb_missing_footprint_error_id: getZodPrefixedIdWithDefault(
    "pcb_missing_footprint_error"
  ),
  pcb_group_id: z85.string().optional(),
  subcircuit_id: z85.string().optional(),
  error_type: z85.literal("pcb_missing_footprint_error").default("pcb_missing_footprint_error"),
  source_component_id: z85.string(),
  message: z85.string()
}).describe("Defines a missing footprint error on the PCB");
expectTypesMatch(
  true
);

// src/pcb/pcb_group.ts
import { z as z86 } from "zod";
var pcb_group = z86.object({
  type: z86.literal("pcb_group"),
  pcb_group_id: getZodPrefixedIdWithDefault("pcb_group"),
  source_group_id: z86.string(),
  is_subcircuit: z86.boolean().optional(),
  subcircuit_id: z86.string().optional(),
  width: length,
  height: length,
  center: point,
  pcb_component_ids: z86.array(z86.string()),
  name: z86.string().optional(),
  description: z86.string().optional(),
  layout_mode: z86.string().optional(),
  autorouter_configuration: z86.object({
    trace_clearance: length
  }).optional(),
  autorouter_used_string: z86.string().optional()
}).describe("Defines a group of components on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_autorouting_error.ts
import { z as z87 } from "zod";
var pcb_autorouting_error = z87.object({
  type: z87.literal("pcb_autorouting_error"),
  pcb_error_id: getZodPrefixedIdWithDefault("pcb_autorouting_error"),
  error_type: z87.literal("pcb_autorouting_error").default("pcb_autorouting_error"),
  message: z87.string(),
  subcircuit_id: z87.string().optional()
}).describe("The autorouting has failed to route a portion of the board");
expectTypesMatch(true);

// src/pcb/pcb_manual_edit_conflict_warning.ts
import { z as z88 } from "zod";
var pcb_manual_edit_conflict_warning = z88.object({
  type: z88.literal("pcb_manual_edit_conflict_warning"),
  pcb_manual_edit_conflict_warning_id: getZodPrefixedIdWithDefault(
    "pcb_manual_edit_conflict_warning"
  ),
  warning_type: z88.literal("pcb_manual_edit_conflict_warning").default("pcb_manual_edit_conflict_warning"),
  message: z88.string(),
  pcb_component_id: z88.string(),
  pcb_group_id: z88.string().optional(),
  subcircuit_id: z88.string().optional(),
  source_component_id: z88.string()
}).describe(
  "Warning emitted when a component has both manual placement and explicit pcbX/pcbY coordinates"
);
expectTypesMatch(true);

// src/pcb/pcb_breakout_point.ts
import { z as z89 } from "zod";
var pcb_breakout_point = z89.object({
  type: z89.literal("pcb_breakout_point"),
  pcb_breakout_point_id: getZodPrefixedIdWithDefault("pcb_breakout_point"),
  pcb_group_id: z89.string(),
  subcircuit_id: z89.string().optional(),
  source_trace_id: z89.string().optional(),
  source_port_id: z89.string().optional(),
  source_net_id: z89.string().optional(),
  x: distance,
  y: distance
}).describe(
  "Defines a routing target within a pcb_group for a source_trace or source_net"
);
expectTypesMatch(true);

// src/pcb/pcb_ground_plane.ts
import { z as z90 } from "zod";
var pcb_ground_plane = z90.object({
  type: z90.literal("pcb_ground_plane"),
  pcb_ground_plane_id: getZodPrefixedIdWithDefault("pcb_ground_plane"),
  source_pcb_ground_plane_id: z90.string(),
  source_net_id: z90.string(),
  pcb_group_id: z90.string().optional(),
  subcircuit_id: z90.string().optional()
}).describe("Defines a ground plane on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_ground_plane_region.ts
import { z as z91 } from "zod";
var pcb_ground_plane_region = z91.object({
  type: z91.literal("pcb_ground_plane_region"),
  pcb_ground_plane_region_id: getZodPrefixedIdWithDefault(
    "pcb_ground_plane_region"
  ),
  pcb_ground_plane_id: z91.string(),
  pcb_group_id: z91.string().optional(),
  subcircuit_id: z91.string().optional(),
  layer: layer_ref,
  points: z91.array(point)
}).describe("Defines a polygon region of a ground plane");
expectTypesMatch(true);

// src/pcb/pcb_thermal_spoke.ts
import { z as z92 } from "zod";
var pcb_thermal_spoke = z92.object({
  type: z92.literal("pcb_thermal_spoke"),
  pcb_thermal_spoke_id: getZodPrefixedIdWithDefault("pcb_thermal_spoke"),
  pcb_ground_plane_id: z92.string(),
  shape: z92.string(),
  spoke_count: z92.number(),
  spoke_thickness: distance,
  spoke_inner_diameter: distance,
  spoke_outer_diameter: distance,
  pcb_plated_hole_id: z92.string().optional(),
  subcircuit_id: z92.string().optional()
}).describe("Pattern for connecting a ground plane to a plated hole");
expectTypesMatch(true);

// src/cad/cad_component.ts
import { z as z93 } from "zod";
var cad_component = z93.object({
  type: z93.literal("cad_component"),
  cad_component_id: z93.string(),
  pcb_component_id: z93.string(),
  source_component_id: z93.string(),
  position: point3,
  rotation: point3.optional(),
  size: point3.optional(),
  layer: layer_ref.optional(),
  subcircuit_id: z93.string().optional(),
  // These are all ways to generate/load the 3d model
  footprinter_string: z93.string().optional(),
  model_obj_url: z93.string().optional(),
  model_stl_url: z93.string().optional(),
  model_3mf_url: z93.string().optional(),
  model_jscad: z93.any().optional()
}).describe("Defines a component on the PCB");
expectTypesMatch(true);

// src/simulation/simulation_voltage_source.ts
import { z as z94 } from "zod";
var wave_shape = z94.enum(["sinewave", "square", "triangle", "sawtooth"]);
var simulation_dc_voltage_source = z94.object({
  type: z94.literal("simulation_voltage_source"),
  simulation_voltage_source_id: getZodPrefixedIdWithDefault(
    "simulation_voltage_source"
  ),
  is_dc_source: z94.literal(true).optional().default(true),
  positive_source_port_id: z94.string().optional(),
  negative_source_port_id: z94.string().optional(),
  positive_source_net_id: z94.string().optional(),
  negative_source_net_id: z94.string().optional(),
  voltage
}).describe("Defines a DC voltage source for simulation");
var simulation_ac_voltage_source = z94.object({
  type: z94.literal("simulation_voltage_source"),
  simulation_voltage_source_id: getZodPrefixedIdWithDefault(
    "simulation_voltage_source"
  ),
  is_dc_source: z94.literal(false),
  terminal1_source_port_id: z94.string().optional(),
  terminal2_source_port_id: z94.string().optional(),
  terminal1_source_net_id: z94.string().optional(),
  terminal2_source_net_id: z94.string().optional(),
  voltage: voltage.optional(),
  frequency: frequency.optional(),
  peak_to_peak_voltage: voltage.optional(),
  wave_shape: wave_shape.optional(),
  phase: rotation.optional()
}).describe("Defines an AC voltage source for simulation");
var simulation_voltage_source = z94.union([simulation_dc_voltage_source, simulation_ac_voltage_source]).describe("Defines a voltage source for simulation");
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);

// src/any_circuit_element.ts
import { z as z95 } from "zod";
var any_circuit_element = z95.union([
  source_trace,
  source_port,
  any_source_component,
  source_net,
  source_group,
  source_simple_chip,
  source_simple_capacitor,
  source_simple_diode,
  source_simple_led,
  source_simple_resistor,
  source_simple_power_source,
  source_simple_battery,
  source_simple_inductor,
  source_simple_pin_header,
  source_simple_resonator,
  source_simple_switch,
  source_simple_transistor,
  source_simple_test_point,
  source_simple_mosfet,
  source_simple_potentiometer,
  source_simple_push_button,
  source_pcb_ground_plane,
  source_project_metadata,
  source_trace_not_connected_error,
  pcb_component,
  pcb_hole,
  pcb_missing_footprint_error,
  pcb_manual_edit_conflict_warning,
  pcb_plated_hole,
  pcb_keepout,
  pcb_port,
  pcb_text,
  pcb_trace,
  pcb_via,
  pcb_smtpad,
  pcb_solder_paste,
  pcb_board,
  pcb_group,
  pcb_trace_hint,
  pcb_silkscreen_line,
  pcb_silkscreen_path,
  pcb_silkscreen_text,
  pcb_silkscreen_rect,
  pcb_silkscreen_circle,
  pcb_silkscreen_oval,
  pcb_trace_error,
  pcb_trace_missing_error,
  pcb_placement_error,
  pcb_port_not_matched_error,
  pcb_port_not_connected_error,
  pcb_fabrication_note_path,
  pcb_fabrication_note_text,
  pcb_autorouting_error,
  pcb_footprint_overlap_error,
  pcb_breakout_point,
  pcb_cutout,
  pcb_ground_plane,
  pcb_ground_plane_region,
  pcb_thermal_spoke,
  schematic_box,
  schematic_text,
  schematic_line,
  schematic_component,
  schematic_port,
  schematic_trace,
  schematic_path,
  schematic_error,
  schematic_layout_error,
  schematic_net_label,
  schematic_debug_object,
  schematic_voltage_probe,
  schematic_manual_edit_conflict_warning,
  schematic_group,
  schematic_table,
  schematic_table_cell,
  cad_component,
  simulation_voltage_source
]);
var any_soup_element = any_circuit_element;
expectTypesMatch(true);
expectStringUnionsMatch(true);
export {
  all_layers,
  any_circuit_element,
  any_soup_element,
  any_source_component,
  battery_capacity,
  cad_component,
  capacitance,
  current,
  distance,
  frequency,
  getZodPrefixedIdWithDefault,
  inductance,
  layer_ref,
  layer_string,
  length,
  ninePointAnchor,
  pcb_autorouting_error,
  pcb_board,
  pcb_breakout_point,
  pcb_component,
  pcb_cutout,
  pcb_cutout_circle,
  pcb_cutout_polygon,
  pcb_cutout_rect,
  pcb_fabrication_note_path,
  pcb_fabrication_note_text,
  pcb_footprint_overlap_error,
  pcb_ground_plane,
  pcb_ground_plane_region,
  pcb_group,
  pcb_hole,
  pcb_hole_circle_or_square_shape,
  pcb_hole_oval_shape,
  pcb_keepout,
  pcb_manual_edit_conflict_warning,
  pcb_missing_footprint_error,
  pcb_placement_error,
  pcb_plated_hole,
  pcb_port,
  pcb_port_not_connected_error,
  pcb_port_not_matched_error,
  pcb_route_hint,
  pcb_route_hints,
  pcb_silkscreen_circle,
  pcb_silkscreen_line,
  pcb_silkscreen_oval,
  pcb_silkscreen_path,
  pcb_silkscreen_rect,
  pcb_silkscreen_text,
  pcb_smtpad,
  pcb_smtpad_pill,
  pcb_solder_paste,
  pcb_text,
  pcb_thermal_spoke,
  pcb_trace,
  pcb_trace_error,
  pcb_trace_hint,
  pcb_trace_missing_error,
  pcb_trace_route_point,
  pcb_trace_route_point_via,
  pcb_trace_route_point_wire,
  pcb_via,
  point,
  point3,
  port_arrangement,
  position,
  position3,
  resistance,
  rotation,
  route_hint_point,
  schematic_box,
  schematic_component,
  schematic_component_port_arrangement_by_sides,
  schematic_component_port_arrangement_by_size,
  schematic_debug_line,
  schematic_debug_object,
  schematic_debug_object_base,
  schematic_debug_point,
  schematic_debug_rect,
  schematic_error,
  schematic_group,
  schematic_layout_error,
  schematic_line,
  schematic_manual_edit_conflict_warning,
  schematic_net_label,
  schematic_path,
  schematic_pin_styles,
  schematic_port,
  schematic_table,
  schematic_table_cell,
  schematic_text,
  schematic_trace,
  schematic_voltage_probe,
  simulation_ac_voltage_source,
  simulation_dc_voltage_source,
  simulation_voltage_source,
  size,
  source_component_base,
  source_failed_to_create_component_error,
  source_group,
  source_missing_property_error,
  source_net,
  source_pcb_ground_plane,
  source_port,
  source_project_metadata,
  source_simple_battery,
  source_simple_capacitor,
  source_simple_chip,
  source_simple_crystal,
  source_simple_diode,
  source_simple_ground,
  source_simple_inductor,
  source_simple_led,
  source_simple_mosfet,
  source_simple_pin_header,
  source_simple_potentiometer,
  source_simple_power_source,
  source_simple_push_button,
  source_simple_resistor,
  source_simple_resonator,
  source_simple_switch,
  source_simple_test_point,
  source_simple_transistor,
  source_trace,
  source_trace_not_connected_error,
  supplier_name,
  time,
  visible_layer,
  voltage,
  wave_shape
};
//# sourceMappingURL=index.mjs.map