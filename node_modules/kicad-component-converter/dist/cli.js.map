{"version":3,"sources":["../src/cli/cli.ts","../src/parse-kicad-mod-to-kicad-json.ts","../src/kicad-zod.ts","../src/get-attr.ts","../src/convert-kicad-json-to-tscircuit-soup.ts","../src/math/arc-utils.ts","../src/math/make-point.ts","../src/math/points-equal.ts","../src/math/find-closed-polygons.ts","../src/math/polygon-to-points.ts","../src/get-Silkscreen-Font-Size-From-Fp-Texts.ts","../src/parse-kicad-mod-to-circuit-json.ts","../src/cli/cmds/convert-kicad-directory-to-ts.ts","../src/cli/param-handlers/interact-for-local-directory.ts","../src/cli/param-handlers/index.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { perfectCli } from \"perfect-cli\"\nimport { program } from \"commander\"\nimport { convertKicadDirectoryToTs } from \"./cmds\"\nimport { PARAM_HANDLERS_BY_PARAM_NAME } from \"./param-handlers\"\nimport type { ParamHandler } from \"./param-handlers/param-handler-type\"\n\nprogram.name(\"kicad-mod-converter\")\n\nprogram\n  .command(\"convert-kicad-directory\")\n  .requiredOption(\"--input-dir <input>\", \"Input directory\")\n  .requiredOption(\"--output-dir <output>\", \"Output directory\")\n  .action((opts) => convertKicadDirectoryToTs(opts))\n\nperfectCli(program, process.argv, {\n  async customParamHandler({ commandPath, optionName }, { prompts }) {\n    const optionNameHandler: ParamHandler | undefined =\n      PARAM_HANDLERS_BY_PARAM_NAME[optionName.replace(/-/g, \"_\")]\n\n    if (optionNameHandler) {\n      return optionNameHandler({\n        commandPath,\n        optionName,\n        prompts,\n        ctx: undefined,\n      })\n    }\n  },\n})\n","import parseSExpression from \"s-expression\"\nimport {\n  attributes_def,\n  hole_def,\n  kicad_mod_json_def,\n  pad_def,\n  type FpArc,\n  type FpLine,\n  type FpText,\n  type FpCircle,\n  type FpPoly,\n  type Hole,\n  type KicadModJson,\n  type Pad,\n  type Property,\n} from \"./kicad-zod\"\nimport { formatAttr, getAttr } from \"./get-attr\"\nimport Debug from \"debug\"\n\nconst debug = Debug(\"kicad-mod-converter\")\n\nexport const parseKicadModToKicadJson = (fileContent: string): KicadModJson => {\n  const kicadSExpr = parseSExpression(fileContent)\n\n  const footprintName = kicadSExpr[1].valueOf()\n\n  const topLevelAttributes: any = {}\n\n  const simpleTopLevelAttributes = Object.entries(kicad_mod_json_def.shape)\n    .filter(\n      ([attributeKey, def]) =>\n        def._def.typeName === \"ZodString\" || attributeKey === \"tags\",\n    )\n    .map(([attributeKey]) => attributeKey)\n  for (const kicadSExprRow of kicadSExpr.slice(2)) {\n    if (!simpleTopLevelAttributes.includes(kicadSExprRow[0])) continue\n\n    const key = kicadSExprRow[0].valueOf()\n    const val = formatAttr(kicadSExprRow.slice(1), key)\n    topLevelAttributes[key] = val\n  }\n\n  const properties = kicadSExpr\n    .slice(2)\n    .filter((row: any[]) => row[0] === \"property\")\n    .map((row: any) => {\n      const key = row[1].valueOf()\n      const val = row[2].valueOf()\n      const attributes = attributes_def.parse(\n        row.slice(3).reduce((acc: any, attrAr: any[]) => {\n          const attrKey = attrAr[0].valueOf()\n          acc[attrKey] = formatAttr(attrAr.slice(1), attrKey)\n          return acc\n        }, {} as any),\n      )\n\n      return {\n        key,\n        val,\n        attributes,\n      } as Property\n    })\n\n  const padRows = kicadSExpr.slice(2).filter((row: any[]) => row[0] === \"pad\")\n\n  const pads: Array<Pad> = []\n\n  for (const row of padRows) {\n    const at = getAttr(row, \"at\")\n    const size = getAttr(row, \"size\")\n    const drill = getAttr(row, \"drill\")\n    let layers = getAttr(row, \"layers\")\n    if (Array.isArray(layers)) {\n      layers = layers.map((layer) => layer.valueOf())\n    } else if (typeof layers === \"string\") {\n      layers = [layers]\n    } else if (!layers) {\n      layers = []\n    }\n\n    // Skip pads that do NOT include 'F.Cu' layer\n    if (!layers.includes(\"F.Cu\")) {\n      debug(`Skipping pad without F.Cu layer: layers=${layers.join(\", \")}`)\n      continue\n    }\n\n    const roundrect_rratio = getAttr(row, \"roundrect_rratio\")\n    const uuid = getAttr(row, \"uuid\")\n    const padRaw = {\n      name: row[1].valueOf(),\n      pad_type: row[2].valueOf(),\n      pad_shape: row[3].valueOf(),\n      at,\n      drill,\n      size,\n      layers,\n      roundrect_rratio,\n      uuid,\n    }\n\n    debug(`attempting to parse pad: ${JSON.stringify(padRaw, null, \"  \")}`)\n    pads.push(pad_def.parse(padRaw))\n  }\n\n  const fp_texts_rows = kicadSExpr\n    .slice(2)\n    .filter((row: any[]) => row[0] === \"fp_text\")\n\n  const fp_texts: FpText[] = []\n\n  for (const fp_text_row of fp_texts_rows) {\n    const text = fp_text_row[2].valueOf()\n    const at = getAttr(fp_text_row, \"at\")\n    const layer = getAttr(fp_text_row, \"layer\")\n    const uuid = getAttr(fp_text_row, \"uuid\")\n    const effects = getAttr(fp_text_row, \"effects\")\n\n    fp_texts.push({\n      fp_text_type: \"user\",\n      text,\n      at,\n      layer,\n      uuid,\n      effects,\n    })\n  }\n\n  const fp_lines: FpLine[] = []\n\n  const fp_lines_rows = kicadSExpr\n    .slice(2)\n    .filter((row: any[]) => row[0] === \"fp_line\")\n\n  for (const fp_line_row of fp_lines_rows) {\n    const start = getAttr(fp_line_row, \"start\")\n    const end = getAttr(fp_line_row, \"end\")\n    const stroke = getAttr(fp_line_row, \"stroke\")\n    const layer = getAttr(fp_line_row, \"layer\")\n    const uuid = getAttr(fp_line_row, \"uuid\")\n\n    fp_lines.push({\n      start,\n      end,\n      stroke,\n      layer,\n      uuid,\n    })\n  }\n\n  const fp_arcs: FpArc[] = []\n  const fp_arcs_rows = kicadSExpr\n    .slice(2)\n    .filter((row: any[]) => row[0] === \"fp_arc\")\n\n  for (const fp_arc_row of fp_arcs_rows) {\n    const start = getAttr(fp_arc_row, \"start\")\n    const mid = getAttr(fp_arc_row, \"mid\")\n    const end = getAttr(fp_arc_row, \"end\")\n    const stroke = getAttr(fp_arc_row, \"stroke\")\n    const layer = getAttr(fp_arc_row, \"layer\")\n    const uuid = getAttr(fp_arc_row, \"uuid\")\n\n    if (!start || !end || !mid || !stroke || !layer) {\n      continue\n    }\n\n    fp_arcs.push({\n      start,\n      mid,\n      end,\n      stroke,\n      layer,\n      uuid,\n    })\n  }\n\n  const fp_circles: FpCircle[] = []\n  const fp_circles_rows = kicadSExpr\n    .slice(2)\n    .filter((row: any[]) => row[0] === \"fp_circle\")\n\n  for (const fp_circle_row of fp_circles_rows) {\n    const center = getAttr(fp_circle_row, \"center\")\n    const end = getAttr(fp_circle_row, \"end\")\n    const stroke = getAttr(fp_circle_row, \"stroke\")\n    const fill = getAttr(fp_circle_row, \"fill\")\n    const layer = getAttr(fp_circle_row, \"layer\")\n    const uuid = getAttr(fp_circle_row, \"uuid\")\n\n    if (!center || !end || !stroke || !layer) {\n      continue\n    }\n\n    fp_circles.push({\n      center,\n      end,\n      stroke,\n      fill,\n      layer,\n      uuid,\n    })\n  }\n\n  const fp_polys: FpPoly[] = []\n  const fp_polys_rows = kicadSExpr\n    .slice(2)\n    .filter((row: any[]) => row[0] === \"fp_poly\")\n\n  for (const fp_poly_row of fp_polys_rows) {\n    const pts = getAttr(fp_poly_row, \"pts\")\n    const stroke = getAttr(fp_poly_row, \"stroke\")\n    const width = getAttr(fp_poly_row, \"width\")\n    const layer = getAttr(fp_poly_row, \"layer\")\n    const uuid = getAttr(fp_poly_row, \"uuid\")\n    const fill = getAttr(fp_poly_row, \"fill\")\n    let normalizedStroke = stroke\n    if (!normalizedStroke && typeof width === \"number\") {\n      normalizedStroke = { width, type: \"solid\" }\n    } else if (\n      normalizedStroke &&\n      typeof normalizedStroke === \"object\" &&\n      typeof width === \"number\" &&\n      normalizedStroke.width === undefined\n    ) {\n      normalizedStroke = { ...normalizedStroke, width }\n    }\n    fp_polys.push({\n      pts,\n      stroke: normalizedStroke,\n      layer,\n      uuid,\n      fill,\n    })\n  }\n\n  const holes: Hole[] = []\n\n  for (const row of kicadSExpr.slice(2)) {\n    if (row[0] !== \"pad\") continue\n    if (row[2]?.valueOf?.() !== \"thru_hole\") continue\n\n    const name = row[1]?.valueOf?.()\n    const pad_type = row[2]?.valueOf?.()\n    const pad_shape = row[3]?.valueOf?.()\n\n    const at = getAttr(row, \"at\")\n    const drill = getAttr(row, \"drill\")\n\n    // ---- FIX: normalize size ----\n    let size = getAttr(row, \"size\")\n    if (Array.isArray(size)) {\n      // remove \"size\" token if present\n      if (size[0] === \"size\") size = size.slice(1)\n      size = {\n        width: Number(size[0]),\n        height: Number(size[1]),\n      }\n    }\n\n    const uuid = getAttr(row, \"uuid\")\n    const roundrect_rratio = getAttr(row, \"roundrect_rratio\")\n\n    let layers = getAttr(row, \"layers\")\n    if (Array.isArray(layers)) {\n      layers = layers.map((layer) => layer.valueOf())\n    } else if (typeof layers === \"string\") {\n      layers = [layers]\n    } else if (!layers) {\n      layers = []\n    }\n\n    const holeRaw = {\n      name,\n      pad_type,\n      pad_shape,\n      at,\n      drill,\n      size,\n      layers,\n      roundrect_rratio,\n      uuid,\n    }\n\n    debug(`attempting to parse holes: ${JSON.stringify(holeRaw, null, 2)}`)\n    holes.push(hole_def.parse(holeRaw))\n  }\n\n  return kicad_mod_json_def.parse({\n    footprint_name: footprintName,\n    ...topLevelAttributes,\n    properties,\n    fp_lines,\n    fp_texts,\n    fp_arcs,\n    fp_circles,\n    pads,\n    holes,\n    fp_polys,\n  })\n}\n","import { z } from \"zod\"\n\nexport const point2 = z.tuple([z.coerce.number(), z.coerce.number()])\nexport const point3 = z.tuple([z.number(), z.number(), z.number()])\nexport const point = z.union([point2, point3])\n\ntype MakeRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>\n\nexport const fp_poly_arc_segment_def = z.object({\n  kind: z.literal(\"arc\"),\n  start: point2,\n  mid: point2,\n  end: point2,\n})\n\nexport const fp_poly_point_def = z.union([point2, fp_poly_arc_segment_def])\n\nexport const attributes_def = z\n  .object({\n    at: point,\n    size: point2,\n    layer: z.string(),\n    layers: z.array(z.string()),\n    roundrect_rratio: z.number(),\n    uuid: z.string(),\n  })\n  .partial()\n\nexport const property_def = z.object({\n  key: z.string(),\n  val: z.string(),\n  attributes: attributes_def,\n})\n\nconst drill_def = z.object({\n  oval: z.boolean().default(false),\n  width: z.number().optional(),\n  height: z.number().optional(),\n  offset: point2.optional(),\n})\n\nexport const hole_def = z.object({\n  name: z.string(),\n  pad_type: z.enum([\"thru_hole\", \"smd\", \"np_thru_hole\", \"connect\"]),\n  pad_shape: z.enum([\n    \"roundrect\",\n    \"circle\",\n    \"rect\",\n    \"oval\",\n    \"trapezoid\",\n    \"custom\",\n  ]),\n  at: point,\n  drill: z\n    .union([z.number(), z.array(z.any()), drill_def])\n    .transform((a) => {\n      if (typeof a === \"number\") {\n        return { oval: false, width: a, height: a }\n      }\n      if (\"oval\" in a) return a\n      if (a.length === 2) {\n        return {\n          oval: false,\n          width: Number.parseFloat(a[0]),\n          height: Number.parseFloat(a[0]),\n          offset: point2.parse(a[1].slice(1)),\n        }\n      }\n      if (a.length === 3 || a.length === 4) {\n        return {\n          oval: a[0] === \"oval\",\n          width: Number.parseFloat(a[1] as string),\n          height: Number.parseFloat(a[2] as string),\n          offset: a[3] ? point2.parse(a[3].slice(1)) : undefined,\n        }\n      }\n      return a\n    })\n    .pipe(drill_def),\n  size: z.union([\n    z\n      .array(z.number())\n      .length(2)\n      .transform(([w, h]) => ({ width: w, height: h })),\n    z.object({\n      width: z.number(),\n      height: z.number(),\n    }),\n  ]),\n  layers: z.array(z.string()).optional(),\n  roundrect_rratio: z.number().optional(),\n  uuid: z.string().optional(),\n})\n\nexport const pad_def = z.object({\n  name: z.string(),\n  pad_type: z.enum([\"thru_hole\", \"smd\", \"np_thru_hole\", \"connect\"]),\n  pad_shape: z.enum([\n    \"roundrect\",\n    \"circle\",\n    \"rect\",\n    \"oval\",\n    \"trapezoid\",\n    \"custom\",\n  ]),\n  at: point,\n  size: point2,\n  drill: z\n    .union([z.number(), z.array(z.any()), drill_def])\n    .transform((a) => {\n      if (typeof a === \"number\") {\n        return { oval: false, width: a, height: a }\n      }\n      if (\"oval\" in a) return a\n      if (a.length === 2) {\n        return {\n          oval: false,\n          width: Number.parseFloat(a[0]),\n          height: Number.parseFloat(a[0]),\n          offset: point2.parse(a[1].slice(1)),\n        }\n      }\n      if (a.length === 3 || a.length === 4) {\n        return {\n          oval: a[0] === \"oval\",\n          width: Number.parseFloat(a[1] as string),\n          height: Number.parseFloat(a[2] as string),\n          offset: a[3] ? point2.parse(a[3].slice(1)) : undefined,\n        }\n      }\n      return a\n    })\n    .pipe(drill_def)\n    .optional(),\n  layers: z.array(z.string()).optional(),\n  roundrect_rratio: z.number().optional(),\n  chamfer_ratio: z.number().optional(),\n  solder_paste_margin: z.number().optional(),\n  solder_paste_margin_ratio: z.number().optional(),\n  clearance: z.number().optional(),\n  zone_connection: z\n    .union([\n      z.literal(0).describe(\"Pad is not connect to zone\"),\n      z.literal(1).describe(\"Pad is connected to zone using thermal relief\"),\n      z.literal(2).describe(\"Pad is connected to zone using solid fill\"),\n    ])\n    .optional(),\n  thermal_width: z.number().optional(),\n  thermal_gap: z.number().optional(),\n  uuid: z.string().optional(),\n})\n\nexport const effects_def = z\n  .object({\n    font: z.object({\n      size: point2,\n      thickness: z.number().optional(),\n    }),\n  })\n  .partial()\n\nexport const fp_text_def = z.object({\n  fp_text_type: z.literal(\"user\"),\n  text: z.string(),\n  at: point,\n  layer: z.string(),\n  uuid: z.string().optional(),\n  effects: effects_def.partial(),\n})\n\nexport const fp_arc_def = z.object({\n  start: point2,\n  mid: point2,\n  end: point2,\n  stroke: z.object({\n    width: z.number(),\n    type: z.string(),\n  }),\n  layer: z.string(),\n  uuid: z.string().optional(),\n})\n\nexport const fp_circle_def = z.object({\n  center: point2,\n  end: point2,\n  stroke: z.object({\n    width: z.number(),\n    type: z.string(),\n  }),\n  fill: z.string().optional(),\n  layer: z.string(),\n  uuid: z.string().optional(),\n})\n\nexport const fp_poly_def = z\n  .object({\n    pts: z.array(fp_poly_point_def),\n    stroke: z\n      .object({\n        width: z.number(),\n        type: z.string(),\n      })\n      .optional(),\n    width: z.number().optional(),\n    layer: z.string(),\n    uuid: z.string().optional(),\n    fill: z.string().optional(),\n  })\n  // Old kicad versions don't have \"stroke\"\n  .transform((data) => {\n    return {\n      ...data,\n      width: undefined,\n      stroke: data.stroke ?? { width: data.width },\n    } as MakeRequired<Omit<typeof data, \"width\">, \"stroke\">\n  })\n\nexport const fp_line = z\n  .object({\n    start: point2,\n    end: point2,\n    stroke: z\n      .object({\n        width: z.number(),\n        type: z.string(),\n      })\n      .optional(),\n    width: z.number().optional(),\n    layer: z.string(),\n    uuid: z.string().optional(),\n  })\n  // Old kicad versions don't have \"stroke\"\n  .transform((data) => {\n    return {\n      ...data,\n      width: undefined,\n      stroke: data.stroke ?? { width: data.width },\n    } as MakeRequired<Omit<typeof data, \"width\">, \"stroke\">\n  })\n\nexport const kicad_mod_json_def = z.object({\n  footprint_name: z.string(),\n  version: z.string().optional(),\n  generator: z.string().optional(),\n  generator_version: z.string().optional(),\n  layer: z.string(),\n  descr: z.string().default(\"\"),\n  tags: z.array(z.string()).optional(),\n  properties: z.array(property_def),\n  fp_lines: z.array(fp_line),\n  fp_texts: z.array(fp_text_def),\n  fp_arcs: z.array(fp_arc_def),\n  fp_circles: z.array(fp_circle_def).optional(),\n  fp_polys: z.array(fp_poly_def).optional(),\n  pads: z.array(pad_def),\n  holes: z.array(hole_def).optional(),\n})\n\nexport type Point2 = z.infer<typeof point2>\nexport type Point3 = z.infer<typeof point3>\nexport type Point = z.infer<typeof point>\nexport type Attributes = z.infer<typeof attributes_def>\nexport type Property = z.infer<typeof property_def>\nexport type Pad = z.infer<typeof pad_def>\nexport type Hole = z.infer<typeof hole_def>\nexport type EffectsObj = z.infer<typeof effects_def>\nexport type FpText = z.infer<typeof fp_text_def>\nexport type FpLine = z.infer<typeof fp_line>\nexport type FpArc = z.infer<typeof fp_arc_def>\nexport type FpCircle = z.infer<typeof fp_circle_def>\nexport type FpPoly = z.infer<typeof fp_poly_def>\nexport type KicadModJson = z.infer<typeof kicad_mod_json_def>\n","import { type EffectsObj, effects_def } from \"./kicad-zod\"\n\nexport const formatAttr = (val: any, attrKey: string) => {\n  if (attrKey === \"effects\" && Array.isArray(val)) {\n    // val = [ [ 'font', [ 'size', '1', '1' ], [ 'thickness', '0.2' ] ] ]\n    const effectsObj: EffectsObj = {}\n    for (const elm of val) {\n      if (elm[0] === \"font\") {\n        const fontObj: any = {}\n        for (const fontElm of elm.slice(1)) {\n          if (fontElm.length === 2) {\n            fontObj[fontElm[0].valueOf()] = Number.parseFloat(\n              fontElm[1].valueOf(),\n            )\n          } else {\n            fontObj[fontElm[0].valueOf()] = fontElm\n              .slice(1)\n              .map((n: any) => Number.parseFloat(n.valueOf()))\n          }\n        }\n        effectsObj.font = fontObj\n      }\n    }\n    return effects_def.parse(effectsObj)\n  }\n  if (attrKey === \"pts\") {\n    // val can include coordinate tuples as well as arc definitions.\n    return val.map((segment: any[]) => {\n      const segmentType = segment[0]?.valueOf?.() ?? segment[0]\n      if (segmentType === \"xy\") {\n        return segment.slice(1).map((n: any) => Number.parseFloat(n.valueOf()))\n      }\n      if (segmentType === \"arc\") {\n        const arcObj: Record<string, any> = { kind: \"arc\" }\n        for (const arcAttr of segment.slice(1)) {\n          const key = arcAttr[0].valueOf()\n          arcObj[key] = arcAttr\n            .slice(1)\n            .map((n: any) => Number.parseFloat(n.valueOf()))\n        }\n        return arcObj\n      }\n      return segment\n    })\n  }\n  if (attrKey === \"stroke\") {\n    const strokeObj: any = {}\n    for (const strokeElm of val) {\n      const strokePropKey = strokeElm[0].valueOf()\n      strokeObj[strokePropKey] = formatAttr(strokeElm.slice(1), strokePropKey)\n    }\n    return strokeObj\n  }\n  if (\n    attrKey === \"at\" ||\n    attrKey === \"size\" ||\n    attrKey === \"start\" ||\n    attrKey === \"mid\" ||\n    attrKey === \"end\"\n  ) {\n    // Some KiCad versions may include non-numeric flags like \"unlocked\" in\n    // the (at ...) attribute. Filter out any non-numeric tokens before parsing.\n    const nums = (Array.isArray(val) ? val : [val])\n      .map((n: any) => n?.valueOf?.() ?? n)\n      .filter(\n        (v: any) =>\n          typeof v === \"number\" ||\n          (typeof v === \"string\" && /^[-+]?\\d*\\.?\\d+(e[-+]?\\d+)?$/i.test(v)),\n      )\n      .map((v: any) => (typeof v === \"number\" ? v : Number.parseFloat(v)))\n\n    return nums\n  }\n  if (attrKey === \"tags\") {\n    return val.map((n: any) => n.valueOf())\n  }\n  if (attrKey === \"generator_version\" || attrKey === \"version\") {\n    return val[0].valueOf()\n  }\n  if (val.length === 2) {\n    return val.valueOf()\n  }\n  if (attrKey === \"uuid\") {\n    if (Array.isArray(val)) {\n      return val[0].valueOf()\n    }\n    return val.valueOf()\n  }\n  if (/^[\\d\\.]+$/.test(val) && !Number.isNaN(Number.parseFloat(val))) {\n    return Number.parseFloat(val)\n  }\n  if (Array.isArray(val) && val.length === 1) {\n    return val[0].valueOf()\n  }\n  if (Array.isArray(val)) {\n    return val.map((s) => s.valueOf())\n  }\n  return val\n}\n\nexport const getAttr = (s: Array<any>, key: string) => {\n  for (const elm of s) {\n    if (Array.isArray(elm) && elm[0] === key) {\n      return formatAttr(elm.slice(1), key)\n    }\n  }\n}\n","import type { KicadModJson } from \"./kicad-zod\"\nimport type { AnyCircuitElement } from \"circuit-json\"\nimport Debug from \"debug\"\nimport { generateArcPath, getArcLength } from \"./math/arc-utils\"\nimport { makePoint } from \"./math/make-point\"\nimport type { EdgeSegment } from \"./math/edge-segment\"\nimport { findClosedPolygons } from \"./math/find-closed-polygons\"\nimport { polygonToPoints } from \"./math/polygon-to-points\"\nimport { getSilkscreenFontSizeFromFpTexts } from \"./get-Silkscreen-Font-Size-From-Fp-Texts\"\n\nconst degToRad = (deg: number) => (deg * Math.PI) / 180\nconst rotatePoint = (x: number, y: number, deg: number) => {\n  const r = degToRad(deg)\n  const cos = Math.cos(r)\n  const sin = Math.sin(r)\n  return { x: x * cos - y * sin, y: x * sin + y * cos }\n}\nconst getAxisAlignedRectFromPoints = (\n  points: Array<{ x: number; y: number }>,\n) => {\n  const uniquePoints = [\n    ...new Map(points.map((p) => [`${p.x},${p.y}`, p])).values(),\n  ]\n\n  if (uniquePoints.length !== 4) return null\n\n  const xs = uniquePoints.map((p) => p.x)\n  const ys = uniquePoints.map((p) => p.y)\n  const uniqueXs = [...new Set(xs)]\n  const uniqueYs = [...new Set(ys)]\n\n  if (uniqueXs.length !== 2 || uniqueYs.length !== 2) return null\n\n  const [minX, maxX] = uniqueXs.sort((a, b) => a - b)\n  const [minY, maxY] = uniqueYs.sort((a, b) => a - b)\n\n  if (\n    minX === undefined ||\n    maxX === undefined ||\n    minY === undefined ||\n    maxY === undefined\n  ) {\n    return null\n  }\n\n  return {\n    x: (minX + maxX) / 2,\n    y: (minY + maxY) / 2,\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}\n\nconst fpPolyHasFill = (fill?: string) => {\n  if (!fill) return false\n  const normalized = fill.toLowerCase()\n  return (\n    normalized !== \"no\" && normalized !== \"none\" && normalized !== \"outline\"\n  )\n}\n\nconst getRotationDeg = (at: number[] | undefined) => {\n  if (!at) return 0\n  if (Array.isArray(at) && at.length >= 3 && typeof at[2] === \"number\") {\n    return at[2] as number\n  }\n  return 0\n}\nconst isNinetyLike = (deg: number) => {\n  const n = ((deg % 360) + 360) % 360\n  return n === 90 || n === 270\n}\n\nconst debug = Debug(\"kicad-mod-converter\")\n\nexport const convertKicadLayerToTscircuitLayer = (kicadLayer: string) => {\n  const lowerLayer = kicadLayer.toLowerCase()\n  switch (lowerLayer) {\n    case \"f.cu\":\n    case \"f.fab\":\n    case \"f.silks\":\n    case \"edge.cuts\":\n      return \"top\"\n    case \"b.cu\":\n    case \"b.fab\":\n    case \"b.silks\":\n      return \"bottom\"\n  }\n}\n\nexport const convertKicadJsonToTsCircuitSoup = async (\n  kicadJson: KicadModJson,\n): Promise<AnyCircuitElement[]> => {\n  const {\n    fp_lines,\n    fp_texts,\n    fp_arcs,\n    fp_circles,\n    pads,\n    properties,\n    holes,\n    fp_polys,\n  } = kicadJson\n\n  const circuitJson: AnyCircuitElement[] = []\n\n  circuitJson.push({\n    type: \"source_component\",\n    source_component_id: \"source_component_0\",\n    supplier_part_numbers: {},\n  } as any)\n\n  circuitJson.push({\n    type: \"schematic_component\",\n    schematic_component_id: \"schematic_component_0\",\n    source_component_id: \"source_component_0\",\n    center: { x: 0, y: 0 },\n    rotation: 0,\n    size: { width: 0, height: 0 },\n  } as any)\n\n  // Collect all unique port names from pads and holes\n  const portNames = new Set<string>()\n  for (const pad of pads) {\n    if (pad.name) portNames.add(pad.name)\n  }\n  if (holes) {\n    for (const hole of holes) {\n      if (hole.name) portNames.add(hole.name)\n    }\n  }\n\n  // Create source_port elements\n  let sourcePortId = 0\n  const portNameToSourcePortId = new Map<string, string>()\n  for (const portName of portNames) {\n    const source_port_id = `source_port_${sourcePortId++}`\n    portNameToSourcePortId.set(portName, source_port_id)\n    circuitJson.push({\n      type: \"source_port\",\n      source_port_id,\n      source_component_id: \"source_component_0\",\n      name: portName,\n      port_hints: [portName],\n    })\n    circuitJson.push({\n      type: \"schematic_port\",\n      schematic_port_id: `schematic_port_${sourcePortId++}`,\n      source_port_id,\n      schematic_component_id: \"schematic_component_0\",\n      center: { x: 0, y: 0 },\n    })\n  }\n\n  let minX = Number.POSITIVE_INFINITY\n  let maxX = Number.NEGATIVE_INFINITY\n  let minY = Number.POSITIVE_INFINITY\n  let maxY = Number.NEGATIVE_INFINITY\n  for (const pad of pads) {\n    const x = pad.at[0]\n    const y = -pad.at[1]\n    const w = pad.size[0]\n    const h = pad.size[1]\n    minX = Math.min(minX, x - w / 2)\n    maxX = Math.max(maxX, x + w / 2)\n    minY = Math.min(minY, y - h / 2)\n    maxY = Math.max(maxY, y + h / 2)\n  }\n  const pcb_component_id = \"pcb_component_0\"\n\n  circuitJson.push({\n    type: \"pcb_component\",\n    source_component_id: \"source_component_0\",\n    pcb_component_id,\n    layer: \"top\",\n    center: { x: 0, y: 0 },\n    rotation: 0,\n    width: Number.isFinite(minX) ? maxX - minX : 0,\n    height: Number.isFinite(minY) ? maxY - minY : 0,\n  } as any)\n\n  // Create pcb_port elements\n  let pcbPortId = 0\n  const portNameToPcbPortId = new Map<string, string>()\n  for (const portName of portNames) {\n    const pcb_port_id = `pcb_port_${pcbPortId++}`\n    const source_port_id = portNameToSourcePortId.get(portName)!\n    portNameToPcbPortId.set(portName, pcb_port_id)\n\n    // Find the position from the first pad/hole with this name\n    let x = 0\n    let y = 0\n    let layers: string[] = [\"top\", \"bottom\"]\n\n    const pad = pads.find((p) => p.name === portName)\n    if (pad) {\n      x = pad.at[0]\n      y = -pad.at[1]\n      layers = pad.layers\n        ? (pad.layers\n            .map((l) => convertKicadLayerToTscircuitLayer(l))\n            .filter(Boolean) as string[])\n        : [\"top\", \"bottom\"]\n    } else if (holes) {\n      const hole = holes.find((h) => h.name === portName)\n      if (hole) {\n        x = hole.at[0]\n        y = -hole.at[1]\n        layers = hole.layers\n          ? (hole.layers\n              .map((l) => convertKicadLayerToTscircuitLayer(l))\n              .filter(Boolean) as string[])\n          : [\"top\", \"bottom\"]\n      }\n    }\n\n    circuitJson.push({\n      type: \"pcb_port\",\n      pcb_port_id,\n      source_port_id,\n      pcb_component_id,\n      x,\n      y,\n      layers,\n    } as any)\n  }\n\n  let smtpadId = 0\n  let platedHoleId = 0\n  let holeId = 0\n  for (const pad of pads) {\n    if (pad.pad_type === \"smd\") {\n      const rotation = getRotationDeg(pad.at)\n      const width = isNinetyLike(rotation) ? pad.size[1] : pad.size[0]\n      const height = isNinetyLike(rotation) ? pad.size[0] : pad.size[1]\n      const pcb_port_id = pad.name\n        ? portNameToPcbPortId.get(pad.name)\n        : undefined\n      circuitJson.push({\n        type: \"pcb_smtpad\",\n        pcb_smtpad_id: `pcb_smtpad_${smtpadId++}`,\n        shape: \"rect\",\n        x: pad.at[0],\n        y: -pad.at[1],\n        width,\n        height,\n        layer: convertKicadLayerToTscircuitLayer(pad.layers?.[0] ?? \"F.Cu\")!,\n        pcb_component_id,\n        port_hints: [pad.name],\n        pcb_port_id,\n      } as any)\n    } else if (pad.pad_type === \"thru_hole\") {\n      if (pad.pad_shape === \"rect\") {\n        const rotation = getRotationDeg(pad.at as any)\n        const width = isNinetyLike(rotation) ? pad.size[1] : pad.size[0]\n        const height = isNinetyLike(rotation) ? pad.size[0] : pad.size[1]\n        const offX = pad.drill?.offset?.[0] ?? 0\n        const offY = pad.drill?.offset?.[1] ?? 0\n        const rotOff = rotatePoint(offX, offY, rotation)\n        const pcb_port_id = pad.name\n          ? portNameToPcbPortId.get(pad.name)\n          : undefined\n        circuitJson.push({\n          type: \"pcb_plated_hole\",\n          pcb_plated_hole_id: `pcb_plated_hole_${platedHoleId++}`,\n          shape: \"circular_hole_with_rect_pad\",\n          hole_shape: \"circle\",\n          pad_shape: \"rect\",\n          // x/y are the pad center; hole_offset_* positions the hole\n          x: pad.at[0],\n          y: -pad.at[1],\n          hole_offset_x: -rotOff.x,\n          hole_offset_y: -rotOff.y,\n          hole_diameter: pad.drill?.width!,\n          rect_pad_width: width,\n          rect_pad_height: height,\n          layers: [\"top\", \"bottom\"],\n          pcb_component_id,\n          port_hints: [pad.name],\n          pcb_port_id,\n        } as any)\n      } else if (pad.pad_shape === \"circle\") {\n        const pcb_port_id = pad.name\n          ? portNameToPcbPortId.get(pad.name)\n          : undefined\n        circuitJson.push({\n          type: \"pcb_plated_hole\",\n          pcb_plated_hole_id: `pcb_plated_hole_${platedHoleId++}`,\n          shape: \"circle\",\n          x: pad.at[0],\n          y: -pad.at[1],\n          outer_diameter: pad.size[0],\n          hole_diameter: pad.drill?.width!,\n          layers: [\"top\", \"bottom\"],\n          pcb_component_id,\n          port_hints: [pad.name],\n          pcb_port_id,\n        } as any)\n      } else if (pad.pad_shape === \"oval\") {\n        const pcb_port_id = pad.name\n          ? portNameToPcbPortId.get(pad.name)\n          : undefined\n        circuitJson.push({\n          type: \"pcb_plated_hole\",\n          pcb_plated_hole_id: `pcb_plated_hole_${platedHoleId++}`,\n          shape: \"pill\",\n          x: pad.at[0],\n          y: -pad.at[1],\n          outer_width: pad.size[0],\n          outer_height: pad.size[1],\n          hole_width: pad.drill?.width!,\n          hole_height: pad.drill?.height!,\n          layers: [\"top\", \"bottom\"],\n          pcb_component_id,\n          port_hints: [pad.name],\n          pcb_port_id,\n        } as any)\n      }\n    } else if (pad.pad_type === \"np_thru_hole\") {\n      circuitJson.push({\n        type: \"pcb_hole\",\n        pcb_hole_id: `pcb_hole_${holeId++}`,\n        x: pad.at[0],\n        y: -pad.at[1],\n        hole_diameter: pad.drill?.width!,\n        pcb_component_id,\n      } as any)\n    }\n  }\n\n  if (holes) {\n    for (const hole of holes) {\n      const hasCuLayer = hole.layers?.some(\n        (l) => l.endsWith(\".Cu\") || l === \"*.Cu\",\n      )\n\n      const rotation = getRotationDeg(hole.at as any)\n      const offX = hole.drill?.offset?.[0] ?? 0\n      const offY = hole.drill?.offset?.[1] ?? 0\n      const rotOff = rotatePoint(offX, offY, rotation)\n      const x = hole.at[0] + rotOff.x\n      const y = -(hole.at[1] + rotOff.y)\n      const holeDiameter = hole.drill?.width ?? 0\n      const outerDiameter = hole.size?.width ?? holeDiameter\n      const rr = hole.roundrect_rratio ?? 0\n      const rectBorderRadius =\n        rr > 0\n          ? (Math.min(\n              isNinetyLike(rotation)\n                ? (hole.size?.height ?? outerDiameter)\n                : (hole.size?.width ?? outerDiameter),\n              isNinetyLike(rotation)\n                ? (hole.size?.width ?? outerDiameter)\n                : (hole.size?.height ?? outerDiameter),\n            ) /\n              2) *\n            rr\n          : 0\n      if (hasCuLayer) {\n        if (hole.pad_shape === \"rect\") {\n          const pcb_port_id = hole.name\n            ? portNameToPcbPortId.get(hole.name)\n            : undefined\n          circuitJson.push({\n            type: \"pcb_plated_hole\",\n            pcb_plated_hole_id: `pcb_plated_hole_${platedHoleId++}`,\n            shape: \"circular_hole_with_rect_pad\",\n            hole_shape: \"circle\",\n            pad_shape: \"rect\",\n            // x/y are the pad center; hole_offset_* positions the hole\n            x: hole.at[0],\n            y: -hole.at[1],\n            hole_offset_x: -rotOff.x,\n            hole_offset_y: -rotOff.y,\n            hole_diameter: holeDiameter,\n            rect_pad_width: isNinetyLike(rotation)\n              ? (hole.size?.height ?? outerDiameter)\n              : (hole.size?.width ?? outerDiameter),\n            rect_pad_height: isNinetyLike(rotation)\n              ? (hole.size?.width ?? outerDiameter)\n              : (hole.size?.height ?? outerDiameter),\n            rect_border_radius: rectBorderRadius,\n            port_hints: [hole.name],\n            layers: [\"top\", \"bottom\"],\n            pcb_component_id,\n            pcb_port_id,\n          } as any)\n        } else if (hole.pad_shape === \"oval\") {\n          const pcb_port_id = hole.name\n            ? portNameToPcbPortId.get(hole.name)\n            : undefined\n          circuitJson.push({\n            type: \"pcb_plated_hole\",\n            pcb_plated_hole_id: `pcb_plated_hole_${platedHoleId++}`,\n            shape: \"pill\",\n            x,\n            y,\n            outer_width: isNinetyLike(rotation)\n              ? (hole.size?.height ?? outerDiameter)\n              : (hole.size?.width ?? outerDiameter),\n            outer_height: isNinetyLike(rotation)\n              ? (hole.size?.width ?? outerDiameter)\n              : (hole.size?.height ?? outerDiameter),\n            hole_width: isNinetyLike(rotation)\n              ? (hole.drill?.height ?? holeDiameter)\n              : (hole.drill?.width ?? holeDiameter),\n            hole_height: isNinetyLike(rotation)\n              ? (hole.drill?.width ?? holeDiameter)\n              : (hole.drill?.height ?? holeDiameter),\n            port_hints: [hole.name],\n            layers: [\"top\", \"bottom\"],\n            pcb_component_id,\n            pcb_port_id,\n          } as any)\n        } else if (hole.pad_shape === \"roundrect\") {\n          const pcb_port_id = hole.name\n            ? portNameToPcbPortId.get(hole.name)\n            : undefined\n          const offX = hole.drill?.offset?.[0] ?? 0\n          const offY = hole.drill?.offset?.[1] ?? 0\n          const rotOff = rotatePoint(offX, offY, rotation)\n          const width = isNinetyLike(rotation)\n            ? (hole.size?.height ?? outerDiameter)\n            : (hole.size?.width ?? outerDiameter)\n          const height = isNinetyLike(rotation)\n            ? (hole.size?.width ?? outerDiameter)\n            : (hole.size?.height ?? outerDiameter)\n          circuitJson.push({\n            type: \"pcb_plated_hole\",\n            pcb_plated_hole_id: `pcb_plated_hole_${platedHoleId++}`,\n            shape: \"circular_hole_with_rect_pad\",\n            hole_shape: \"circle\",\n            pad_shape: \"rect\",\n            x,\n            y,\n            hole_offset_x: -rotOff.x,\n            hole_offset_y: rotOff.y,\n            hole_diameter: holeDiameter,\n            rect_pad_width: width,\n            rect_pad_height: height,\n            rect_border_radius: rectBorderRadius,\n            port_hints: [hole.name],\n            layers: [\"top\", \"bottom\"],\n            pcb_component_id,\n            pcb_port_id,\n          } as any)\n        } else {\n          const pcb_port_id = hole.name\n            ? portNameToPcbPortId.get(hole.name)\n            : undefined\n          circuitJson.push({\n            type: \"pcb_plated_hole\",\n            pcb_plated_hole_id: `pcb_plated_hole_${platedHoleId++}`,\n            shape: \"circle\",\n            x,\n            y,\n            outer_diameter: outerDiameter,\n            hole_diameter: holeDiameter,\n            port_hints: [hole.name],\n            layers: [\"top\", \"bottom\"],\n            pcb_component_id,\n            pcb_port_id,\n          })\n        }\n      } else {\n        circuitJson.push({\n          type: \"pcb_hole\",\n          pcb_hole_id: `pcb_hole_${holeId++}`,\n          x,\n          y,\n          hole_diameter: outerDiameter,\n          hole_shape: \"circle\",\n          pcb_component_id,\n        } as any)\n      }\n    }\n  }\n\n  // Collect Edge.Cuts segments for closed polygon detection\n  const edgeCutSegments: EdgeSegment[] = []\n\n  for (const fp_line of fp_lines) {\n    const lowerLayer = fp_line.layer.toLowerCase()\n    if (lowerLayer === \"edge.cuts\") {\n      edgeCutSegments.push({\n        type: \"line\",\n        start: { x: fp_line.start[0], y: fp_line.start[1] },\n        end: { x: fp_line.end[0], y: fp_line.end[1] },\n        strokeWidth: fp_line.stroke.width,\n      })\n    }\n  }\n\n  for (const fp_arc of fp_arcs) {\n    const lowerLayer = fp_arc.layer.toLowerCase()\n    if (lowerLayer === \"edge.cuts\") {\n      edgeCutSegments.push({\n        type: \"arc\",\n        start: { x: fp_arc.start[0], y: fp_arc.start[1] },\n        mid: { x: fp_arc.mid[0], y: fp_arc.mid[1] },\n        end: { x: fp_arc.end[0], y: fp_arc.end[1] },\n        strokeWidth: fp_arc.stroke.width,\n      })\n    }\n  }\n\n  // Detect closed polygons from Edge.Cuts segments\n  const closedPolygons = findClosedPolygons(edgeCutSegments)\n\n  // Create pcb_cutout elements for closed polygons\n  let cutoutId = 0\n  for (const polygon of closedPolygons) {\n    const points = polygonToPoints(polygon)\n    if (points.length >= 3) {\n      circuitJson.push({\n        type: \"pcb_cutout\",\n        pcb_cutout_id: `pcb_cutout_${cutoutId++}`,\n        shape: \"polygon\",\n        points: points.map((p) => ({ x: p.x, y: -p.y })),\n        pcb_component_id,\n      } as any)\n    }\n  }\n\n  let traceId = 0\n  let silkPathId = 0\n  let fabPathId = 0\n  let noteLineId = 0\n  for (const fp_line of fp_lines) {\n    const route = [\n      { x: fp_line.start[0], y: -fp_line.start[1] },\n      { x: fp_line.end[0], y: -fp_line.end[1] },\n    ]\n    const lowerLayer = fp_line.layer.toLowerCase()\n    if (lowerLayer === \"f.cu\") {\n      circuitJson.push({\n        type: \"pcb_trace\",\n        pcb_trace_id: `pcb_trace_${traceId++}`,\n        pcb_component_id,\n        layer: convertKicadLayerToTscircuitLayer(fp_line.layer)!,\n        route,\n        thickness: fp_line.stroke.width,\n      } as any)\n    } else if (lowerLayer === \"f.silks\") {\n      circuitJson.push({\n        type: \"pcb_silkscreen_path\",\n        pcb_silkscreen_path_id: `pcb_silkscreen_path_${silkPathId++}`,\n        pcb_component_id,\n        layer: \"top\",\n        route,\n        stroke_width: fp_line.stroke.width,\n      } as any)\n    } else if (lowerLayer === \"edge.cuts\") {\n      // Skip Edge.Cuts - they are handled as pcb_cutout elements above\n      debug(\n        \"Skipping Edge.Cuts fp_line (converted to pcb_cutout)\",\n        fp_line.layer,\n      )\n    } else if (lowerLayer === \"f.fab\") {\n      circuitJson.push({\n        type: \"pcb_fabrication_note_path\",\n        fabrication_note_path_id: `fabrication_note_path_${fabPathId++}`,\n        pcb_component_id,\n        layer: \"top\",\n        route,\n        stroke_width: fp_line.stroke.width,\n        port_hints: [],\n      } as any)\n    } else if (lowerLayer.startsWith(\"user.\")) {\n      // Convert user-defined layers to pcb_note_line\n      circuitJson.push({\n        type: \"pcb_note_line\",\n        pcb_note_line_id: `pcb_note_line_${noteLineId++}`,\n        pcb_component_id,\n        x1: fp_line.start[0],\n        y1: -fp_line.start[1],\n        x2: fp_line.end[0],\n        y2: -fp_line.end[1],\n        stroke_width: fp_line.stroke.width,\n      } as any)\n    } else {\n      debug(\"Unhandled layer for fp_line\", fp_line.layer)\n    }\n  }\n\n  if (fp_polys) {\n    for (const fp_poly of fp_polys) {\n      const route: Array<{ x: number; y: number }> = []\n      const pushRoutePoint = (point: { x: number; y: number }) => {\n        if (!Number.isFinite(point.x) || !Number.isFinite(point.y)) {\n          return\n        }\n        route.push(point)\n      }\n      for (const segment of fp_poly.pts) {\n        if (Array.isArray(segment)) {\n          pushRoutePoint({ x: segment[0], y: -segment[1] })\n          continue\n        }\n        if (segment && typeof segment === \"object\" && \"kind\" in segment) {\n          if (segment.kind === \"arc\") {\n            const start = makePoint(segment.start)\n            const mid = makePoint(segment.mid)\n            const end = makePoint(segment.end)\n            const arcLength = getArcLength(start, mid, end)\n            const numPoints = Math.max(8, Math.ceil(arcLength))\n            const adjustedNumPoints = Math.max(2, Math.ceil(arcLength / 0.1))\n            const arcPoints = generateArcPath(\n              start,\n              mid,\n              end,\n              adjustedNumPoints,\n            ).map((p) => ({\n              x: p.x,\n              y: -p.y,\n            }))\n            for (const point of arcPoints) {\n              pushRoutePoint(point)\n            }\n          }\n          continue\n        }\n      }\n      const routePoints = route\n      const isClosed =\n        routePoints.length > 2 &&\n        routePoints[0]!.x === routePoints[routePoints.length - 1]!.x &&\n        routePoints[0]!.y === routePoints[routePoints.length - 1]!.y\n      const polygonPoints = isClosed ? routePoints.slice(0, -1) : routePoints\n      if (routePoints.length === 0) continue\n      const strokeWidth = fp_poly.stroke?.width ?? 0\n      if (fp_poly.layer.endsWith(\".Cu\")) {\n        const rect = getAxisAlignedRectFromPoints(polygonPoints)\n        if (rect) {\n          circuitJson.push({\n            type: \"pcb_smtpad\",\n            pcb_smtpad_id: `pcb_smtpad_${smtpadId++}`,\n            shape: \"rect\",\n            x: rect.x,\n            y: rect.y,\n            width: rect.width,\n            height: rect.height,\n            layer: convertKicadLayerToTscircuitLayer(fp_poly.layer)!,\n            pcb_component_id,\n          } as any)\n        } else if (fpPolyHasFill(fp_poly.fill)) {\n          if (polygonPoints.length >= 3) {\n            circuitJson.push({\n              type: \"pcb_smtpad\",\n              pcb_smtpad_id: `pcb_smtpad_${smtpadId++}`,\n              shape: \"polygon\",\n              points: polygonPoints,\n              layer: convertKicadLayerToTscircuitLayer(fp_poly.layer)!,\n              pcb_component_id,\n            } as any)\n          } else if (polygonPoints.length >= 2) {\n            circuitJson.push({\n              type: \"pcb_trace\",\n              pcb_trace_id: `pcb_trace_${traceId++}`,\n              pcb_component_id,\n              layer: convertKicadLayerToTscircuitLayer(fp_poly.layer)!,\n              route: polygonPoints,\n              thickness: strokeWidth,\n            } as any)\n          }\n        } else if (polygonPoints.length >= 2) {\n          circuitJson.push({\n            type: \"pcb_trace\",\n            pcb_trace_id: `pcb_trace_${traceId++}`,\n            pcb_component_id,\n            layer: convertKicadLayerToTscircuitLayer(fp_poly.layer)!,\n            route: polygonPoints,\n            thickness: strokeWidth,\n          } as any)\n        }\n      } else if (fp_poly.layer.endsWith(\".SilkS\")) {\n        circuitJson.push({\n          type: \"pcb_silkscreen_path\",\n          pcb_silkscreen_path_id: `pcb_silkscreen_path_${silkPathId++}`,\n          pcb_component_id,\n          layer: convertKicadLayerToTscircuitLayer(fp_poly.layer)!,\n          route: routePoints,\n          stroke_width: strokeWidth,\n        } as any)\n      } else if (fp_poly.layer.endsWith(\".Fab\")) {\n        circuitJson.push({\n          type: \"pcb_fabrication_note_path\",\n          fabrication_note_path_id: `fabrication_note_path_${fabPathId++}`,\n          pcb_component_id,\n          layer: convertKicadLayerToTscircuitLayer(fp_poly.layer)!,\n          route: polygonPoints,\n          stroke_width: strokeWidth,\n          port_hints: [],\n        } as any)\n      } else {\n        debug(\"Unhandled layer for fp_poly\", fp_poly.layer)\n      }\n    }\n  }\n\n  let notePathId = 0\n  for (const fp_arc of fp_arcs) {\n    const lowerLayer = fp_arc.layer.toLowerCase()\n\n    // Skip Edge.Cuts - they are handled as pcb_cutout elements above\n    if (lowerLayer === \"edge.cuts\") {\n      debug(\"Skipping Edge.Cuts fp_arc (converted to pcb_cutout)\", fp_arc.layer)\n      continue\n    }\n\n    const start = makePoint(fp_arc.start)\n    const mid = makePoint(fp_arc.mid)\n    const end = makePoint(fp_arc.end)\n    const arcLength = getArcLength(start, mid, end)\n\n    const arcPoints = generateArcPath(start, mid, end, Math.ceil(arcLength))\n\n    if (lowerLayer.startsWith(\"user.\")) {\n      circuitJson.push({\n        type: \"pcb_note_path\",\n        pcb_note_path_id: `pcb_note_path_${notePathId++}`,\n        pcb_component_id,\n        route: arcPoints.map((p) => ({ x: p.x, y: -p.y })),\n        stroke_width: fp_arc.stroke.width,\n      } as any)\n      continue\n    }\n\n    const tscircuitLayer = convertKicadLayerToTscircuitLayer(fp_arc.layer)\n    if (!tscircuitLayer) {\n      debug(\"Unable to convert layer for fp_arc\", fp_arc.layer)\n      continue\n    }\n\n    circuitJson.push({\n      type: \"pcb_silkscreen_path\",\n      pcb_silkscreen_path_id: `pcb_silkscreen_path_${silkPathId++}`,\n      layer: tscircuitLayer,\n      pcb_component_id,\n      route: arcPoints.map((p) => ({ x: p.x, y: -p.y })),\n      stroke_width: fp_arc.stroke.width,\n    } as any)\n  }\n\n  if (fp_circles) {\n    for (const fp_circle of fp_circles) {\n      const lowerLayer = fp_circle.layer.toLowerCase()\n\n      const center = makePoint(fp_circle.center)\n      const endPoint = makePoint(fp_circle.end)\n      const radius = Math.sqrt(\n        (endPoint.x - center.x) ** 2 + (endPoint.y - center.y) ** 2,\n      )\n\n      // Generate circle as a series of points\n      const numPoints = Math.max(16, Math.ceil(2 * Math.PI * radius))\n      const circlePoints: Array<{ x: number; y: number }> = []\n      for (let i = 0; i <= numPoints; i++) {\n        const angle = (i / numPoints) * 2 * Math.PI\n        circlePoints.push({\n          x: center.x + radius * Math.cos(angle),\n          y: center.y + radius * Math.sin(angle),\n        })\n      }\n\n      // Convert user-defined layers to pcb_note_path\n      if (lowerLayer.startsWith(\"user.\")) {\n        circuitJson.push({\n          type: \"pcb_note_path\",\n          pcb_note_path_id: `pcb_note_path_${notePathId++}`,\n          pcb_component_id,\n          route: circlePoints.map((p) => ({ x: p.x, y: -p.y })),\n          stroke_width: fp_circle.stroke.width,\n        } as any)\n      }\n    }\n  }\n\n  for (const fp_text of fp_texts) {\n    const layerRef = convertKicadLayerToTscircuitLayer(fp_text.layer)!\n\n    if (fp_text.layer.endsWith(\".SilkS\")) {\n      circuitJson.push({\n        type: \"pcb_silkscreen_text\",\n        layer: layerRef,\n        font: \"tscircuit2024\",\n        font_size: fp_text.effects?.font?.size[0] ?? 1,\n        pcb_component_id,\n        anchor_position: { x: fp_text.at[0], y: -fp_text.at[1] },\n        anchor_alignment: \"center\",\n        text: fp_text.text,\n      } as any)\n    } else if (fp_text.layer.endsWith(\".Fab\")) {\n      circuitJson.push({\n        type: \"pcb_fabrication_note_text\",\n        layer: layerRef,\n        font: \"tscircuit2024\",\n        font_size: fp_text.effects?.font?.size[0] ?? 1,\n        pcb_component_id,\n        anchor_position: { x: fp_text.at[0], y: -fp_text.at[1] },\n        anchor_alignment: \"center\",\n        text: fp_text.text,\n      } as any)\n    } else {\n      debug(\"Unhandled layer for fp_text\", fp_text.layer)\n    }\n  }\n\n  const refProp = properties.find((prop) => prop.key === \"Reference\")\n  const valProp = properties.find((prop) => prop.key === \"Value\")\n  const propFabTexts = [refProp, valProp].filter((p) => p && Boolean(p.val))\n  for (const propFab of propFabTexts) {\n    const at = propFab!.attributes.at\n    if (!at) continue\n\n    // Determine type based on layer attribute\n    const propLayer = propFab!.attributes.layer?.toLowerCase()\n    const isFabLayer = propLayer?.endsWith(\".fab\")\n\n    const font_size = getSilkscreenFontSizeFromFpTexts(fp_texts)\n\n    circuitJson.push({\n      type: isFabLayer ? \"pcb_fabrication_note_text\" : \"pcb_silkscreen_text\",\n      layer: \"top\",\n      font: \"tscircuit2024\",\n      font_size,\n      pcb_component_id,\n      anchor_position: { x: at[0], y: -at[1] },\n      anchor_alignment: \"center\",\n      text: propFab!.val,\n    } as any)\n  }\n\n  return circuitJson as any\n}\n","export interface Point {\n  x: number\n  y: number\n}\n\nconst TWO_PI = Math.PI * 2\n\nconst normalizeAngle = (angle: number) => {\n  let result = angle % TWO_PI\n  if (result < 0) result += TWO_PI\n  return result\n}\n\nconst directedAngleCCW = (start: number, target: number) => {\n  const startNorm = normalizeAngle(start)\n  let targetNorm = normalizeAngle(target)\n  let delta = targetNorm - startNorm\n  if (delta < 0) delta += TWO_PI\n  return delta\n}\n\nexport function calculateCenter(start: Point, mid: Point, end: Point): Point {\n  const mid1 = { x: (start.x + mid.x) / 2, y: (start.y + mid.y) / 2 }\n  const mid2 = { x: (mid.x + end.x) / 2, y: (mid.y + end.y) / 2 }\n\n  const slope1 = -(start.x - mid.x) / (start.y - mid.y)\n  const slope2 = -(mid.x - end.x) / (mid.y - end.y)\n\n  const centerX =\n    (mid1.y - mid2.y + slope2 * mid2.x - slope1 * mid1.x) / (slope2 - slope1)\n  const centerY = mid1.y + slope1 * (centerX - mid1.x)\n\n  return { x: centerX, y: centerY }\n}\n\nfunction calculateRadius(center: Point, point: Point): number {\n  return Math.sqrt((center.x - point.x) ** 2 + (center.y - point.y) ** 2)\n}\n\nfunction calculateAngle(center: Point, point: Point): number {\n  return Math.atan2(point.y - center.y, point.x - center.x)\n}\n\nexport const getArcLength = (start: Point, mid: Point, end: Point) => {\n  const center = calculateCenter(start, mid, end)\n  const radius = calculateRadius(center, start)\n\n  const angleStart = calculateAngle(center, start)\n  const angleMid = calculateAngle(center, mid)\n  const angleEnd = calculateAngle(center, end)\n\n  const ccwToMid = directedAngleCCW(angleStart, angleMid)\n  const ccwToEnd = directedAngleCCW(angleStart, angleEnd)\n\n  let angleDelta = ccwToEnd\n  if (ccwToMid > ccwToEnd) {\n    angleDelta = ccwToEnd - TWO_PI\n  }\n\n  return Math.abs(radius * angleDelta)\n}\n\nexport function generateArcPath(\n  start: Point,\n  mid: Point,\n  end: Point,\n  numPoints: number,\n): Point[] {\n  const center = calculateCenter(start, mid, end)\n  const radius = calculateRadius(center, start)\n\n  const angleStart = calculateAngle(center, start)\n  const angleMid = calculateAngle(center, mid)\n  const angleEnd = calculateAngle(center, end)\n\n  const ccwToMid = directedAngleCCW(angleStart, angleMid)\n  const ccwToEnd = directedAngleCCW(angleStart, angleEnd)\n\n  let angleDelta = ccwToEnd\n  if (ccwToMid > ccwToEnd) {\n    angleDelta = ccwToEnd - TWO_PI\n  }\n\n  const path: Point[] = []\n\n  for (let i = 0; i <= numPoints; i++) {\n    const angle = angleStart + (i / numPoints) * angleDelta\n    const x = center.x + radius * Math.cos(angle)\n    const y = center.y + radius * Math.sin(angle)\n    path.push({ x, y })\n  }\n\n  return path\n}\n","export const makePoint = (\n  p: { x: number; y: number } | [number, number],\n): { x: number; y: number } => {\n  if (Array.isArray(p)) {\n    return { x: p[0], y: p[1] }\n  }\n  return p\n}\n","export const pointsEqual = (\n  p1: { x: number; y: number },\n  p2: { x: number; y: number },\n  tolerance = 0.0001,\n) => {\n  return Math.abs(p1.x - p2.x) < tolerance && Math.abs(p1.y - p2.y) < tolerance\n}\n","import type { EdgeSegment } from \"./edge-segment\"\nimport { pointsEqual } from \"./points-equal\"\n\nexport const findClosedPolygons = (\n  segments: EdgeSegment[],\n): Array<EdgeSegment[]> => {\n  const polygons: Array<EdgeSegment[]> = []\n  const used = new Set<number>()\n\n  for (let i = 0; i < segments.length; i++) {\n    if (used.has(i)) continue\n\n    const polygon: EdgeSegment[] = [segments[i]]\n    used.add(i)\n    let currentEnd = segments[i].end\n\n    // Try to find a closed loop\n    let foundNext = true\n    while (foundNext) {\n      foundNext = false\n\n      // Check if we've closed the loop\n      if (polygon.length > 1 && pointsEqual(currentEnd, polygon[0].start)) {\n        polygons.push(polygon)\n        break\n      }\n\n      // Find the next segment\n      for (let j = 0; j < segments.length; j++) {\n        if (used.has(j)) continue\n\n        if (pointsEqual(currentEnd, segments[j].start)) {\n          polygon.push(segments[j])\n          used.add(j)\n          currentEnd = segments[j].end\n          foundNext = true\n          break\n        } else if (pointsEqual(currentEnd, segments[j].end)) {\n          // Reverse the segment\n          if (segments[j].type === \"arc\") {\n            // For arcs, mark as reversed but keep original start/mid/end\n            polygon.push({\n              ...segments[j],\n              reversed: true,\n            })\n          } else {\n            // For lines, just swap start and end\n            polygon.push({\n              ...segments[j],\n              start: segments[j].end,\n              end: segments[j].start,\n            })\n          }\n          used.add(j)\n          currentEnd = segments[j].start\n          foundNext = true\n          break\n        }\n      }\n\n      if (!foundNext) {\n        // Couldn't complete the polygon, clear used flags for this polygon\n        for (let k = polygon.length - 1; k >= 0; k--) {\n          const idx = segments.indexOf(polygon[k])\n          if (idx !== -1) used.delete(idx)\n        }\n        break\n      }\n    }\n  }\n\n  return polygons\n}\n","import type { EdgeSegment } from \"./edge-segment\"\nimport { generateArcPath, getArcLength } from \"./arc-utils\"\n\nexport const polygonToPoints = (\n  polygon: EdgeSegment[],\n): Array<{ x: number; y: number }> => {\n  const points: Array<{ x: number; y: number }> = []\n\n  for (const segment of polygon) {\n    if (segment.type === \"line\") {\n      // For lines, just add the start point (end point will be added by next segment)\n      points.push(segment.start)\n    } else if (segment.type === \"arc\" && segment.mid) {\n      // For arcs, approximate with multiple points\n      const arcLength = getArcLength(segment.start, segment.mid, segment.end)\n      const numPoints = Math.max(3, Math.ceil(arcLength))\n      let arcPoints = generateArcPath(\n        segment.start,\n        segment.mid,\n        segment.end,\n        numPoints,\n      )\n\n      // If arc is reversed, reverse the points to traverse it backwards\n      if (segment.reversed) {\n        arcPoints = arcPoints.reverse()\n      }\n\n      // Add all arc points except the last one (will be added by next segment)\n      points.push(...arcPoints.slice(0, -1))\n    }\n  }\n\n  return points\n}\n","export function getSilkscreenFontSizeFromFpTexts(\n  fp_texts: any[],\n): number | null {\n  if (!Array.isArray(fp_texts)) return null\n\n  // Find the text used for the reference on F.SilkS (front silkscreen)\n  const refText = fp_texts.find(\n    (t) =>\n      t.layer?.toLowerCase() === \"f.silks\" &&\n      (t.text?.includes(\"${REFERENCE}\") ||\n        t.fp_text_type?.toLowerCase() === \"reference\" ||\n        t.text?.match(/^R\\d+|C\\d+|U\\d+/)),\n  )\n\n  // Fall back to F.Fab reference if no silkscreen reference found\n  const fallbackText =\n    refText ||\n    fp_texts.find(\n      (t) =>\n        t.layer?.toLowerCase() === \"f.fab\" &&\n        (t.text?.includes(\"${REFERENCE}\") ||\n          t.fp_text_type?.toLowerCase() === \"reference\"),\n    )\n\n  const target = refText || fallbackText\n  if (!target?.effects?.font?.size) return null\n\n  const [width, height] = target.effects.font.size\n  return height ?? width ?? 1.0 // KiCad uses height for text height\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport { parseKicadModToKicadJson } from \"./parse-kicad-mod-to-kicad-json\"\nimport { convertKicadJsonToTsCircuitSoup as convertKicadJsonToCircuitJson } from \"./convert-kicad-json-to-tscircuit-soup\"\n\nexport const parseKicadModToCircuitJson = async (\n  kicadMod: string,\n): Promise<AnyCircuitElement[]> => {\n  const kicadJson = parseKicadModToKicadJson(kicadMod)\n\n  const circuitJson = await convertKicadJsonToCircuitJson(kicadJson)\n  return circuitJson as any\n}\n","import { parseKicadModToCircuitJson } from \"../../parse-kicad-mod-to-circuit-json\"\nimport {\n  readFileSync,\n  readdirSync,\n  writeFileSync,\n  mkdirSync,\n  existsSync,\n} from \"node:fs\"\nimport path, { join, relative, dirname } from \"node:path\"\nimport { format } from \"prettier\"\nimport prompts from \"prompts\"\n\nfunction normalizeFileNameToVarName(str: string) {\n  return str\n    .replace(/[^a-zA-Z0-9]/g, \"_\")\n    .replace(/-([a-z])/g, (g: any) => g[1].toUpperCase())\n}\n\nasync function getTsFileContentFromKicadModFile(kicadModFilePath: string) {\n  const kicadModFileContent = readFileSync(kicadModFilePath, \"utf-8\")\n  const fileNameWoExt = kicadModFilePath.split(\"/\").pop()?.split(\".\")[0]\n\n  const tsCircuitSoup = await parseKicadModToCircuitJson(kicadModFileContent)\n\n  const varName = normalizeFileNameToVarName(fileNameWoExt!)\n\n  const tsContent = format(\n    `\nexport const ${varName} = ${JSON.stringify(tsCircuitSoup, null, \"  \")};\n\nexport default ${varName};\n  `.trim(),\n    {\n      parser: \"typescript\",\n      semi: false,\n    },\n  )\n\n  return tsContent\n}\n\nexport const convertKicadDirectoryToTs = async (args: {\n  inputDir: string\n  outputDir: string\n}) => {\n  const { inputDir, outputDir } = args\n\n  // Ensure output directory exists\n  if (!existsSync(outputDir)) {\n    mkdirSync(outputDir, { recursive: true })\n  }\n\n  // 0.1 If there's no package.json, we should offer to initialize and offer\n  //    some options for the name of the package\n  if (!existsSync(join(outputDir, \"package.json\"))) {\n    const { packageName } = await prompts({\n      name: \"packageName\",\n      type: \"text\",\n      message: \"Enter the name of the package (e.g. mygithubname/my-package)\",\n    })\n\n    // Get latest version of tscircuit\n    const tscircuitPackageInfo: any = await fetch(\n      \"https://registry.npmjs.org/tscircuit\",\n    ).then((r) => r.json())\n    // Get latest typescript version\n    const typescriptPackageInfo: any = await fetch(\n      \"https://registry.npmjs.org/typescript\",\n    ).then((r) => r.json())\n\n    if (!packageName.includes(\"/\")) {\n      throw new Error(\n        \"Package name must be in the format of 'mygithubname/my-package'\",\n      )\n    }\n\n    // TODO this is basically doing a simplified version of \"tsci init\", we\n    // should just do \"tsci init\" in the future\n    writeFileSync(\n      join(outputDir, \"package.json\"),\n      JSON.stringify(\n        {\n          name: `@tsci/${packageName.replace(\"@\", \"\")}`,\n          version: \"0.0.1\",\n          description: \"\",\n          main: \"dist/index.cjs\",\n          scripts: {\n            start: \"npm run dev\",\n            dev: \"tsci dev\",\n            build: \"tsup ./index.tsx --sourcemap --dts\",\n            ship: \"tsci publish --increment\",\n          },\n          files: [\"dist\"],\n          devDependencies: {\n            typescript: `^${typescriptPackageInfo[\"dist-tags\"].latest}`,\n            tscircuit: `^${tscircuitPackageInfo[\"dist-tags\"].latest}`,\n          },\n        },\n        null,\n        2,\n      ),\n    )\n\n    if (!existsSync(join(outputDir, \".gitignore\"))) {\n      writeFileSync(\n        join(outputDir, \".gitignore\"),\n        [\"node_modules\", \"dist\"].join(\"\\n\"),\n      )\n    }\n\n    if (!existsSync(join(outputDir, \".github/workflows/tsci-publish.yml\"))) {\n      const { shouldCreateGithubWorkflow } = await prompts({\n        name: \"shouldCreateGithubWorkflow\",\n        type: \"confirm\",\n        message:\n          \"BETA FEATURE: Create a GitHub workflow for CI/CD to autopublish to the tscircuit registry?\",\n      })\n\n      mkdirSync(join(outputDir, \".github/workflows\"), { recursive: true })\n\n      if (shouldCreateGithubWorkflow) {\n        writeFileSync(\n          join(outputDir, \".github/workflows/tsci-publish.yml\"),\n          `\nname: Publish to tscircuit registry\non:\n  push:\n    branches:\n      - main\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    working-directory: ${outputDir}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 20\n          registry-url: https://registry.npmjs.org/\n      - run: npm install\n      - run: npm run build\n      - run: npm run ship\n        env:\n          NODE_AUTH_TOKEN: \\${{ secrets.TSCI_TOKEN }}\n`.trim(),\n        )\n        console.log(\n          \"NOTE: You need to add a TSCI_TOKEN secret to your org or repo. You can generate a token from https://registry.tscircuit.com/profile\",\n        )\n      }\n\n      if (!existsSync(join(outputDir, \"tsconfig.json\"))) {\n        writeFileSync(\n          join(outputDir, \"tsconfig.json\"),\n          JSON.stringify(\n            {\n              compilerOptions: {\n                lib: [\"ESNext\"],\n                target: \"ESNext\",\n                module: \"ESNext\",\n                moduleDetection: \"force\",\n                jsx: \"react-jsx\",\n                allowJs: true,\n                types: [\"@tscircuit/react-fiber\"],\n                baseUrl: \".\",\n                moduleResolution: \"bundler\",\n                allowImportingTsExtensions: true,\n                verbatimModuleSyntax: true,\n                noEmit: true,\n                strict: true,\n                skipLibCheck: true,\n                noFallthroughCasesInSwitch: true,\n                noUnusedLocals: false,\n                noUnusedParameters: false,\n                noPropertyAccessFromIndexSignature: false,\n              },\n            },\n            null,\n            \"  \",\n          ),\n        )\n      }\n    }\n  }\n\n  // 1. Deep scan directory for .kicad_mod files (usually inputDir is a .pretty dir)\n  const scanDirectory = (dir: string): string[] => {\n    let files: string[] = []\n    const entries = readdirSync(dir, { withFileTypes: true })\n    for (const entry of entries) {\n      const fullPath = join(dir, entry.name)\n      if (entry.isDirectory()) {\n        files = files.concat(scanDirectory(fullPath))\n      } else if (entry.isFile() && entry.name.endsWith(\".kicad_mod\")) {\n        files.push(fullPath)\n      }\n    }\n    return files\n  }\n\n  const kicadModFiles = scanDirectory(inputDir).map((fpath) =>\n    relative(inputDir, fpath),\n  )\n  console.log(`Converting ${kicadModFiles.length} kicad_mod files...`)\n\n  // 2. Convert each kicad_mod file to ts and write to output directory with same path\n  const exports = await Promise.all(\n    kicadModFiles.map(async (file) => {\n      const inputFilePath = join(inputDir, file)\n      const outputFilePath = join(\n        outputDir,\n        \"lib\",\n        `${normalizeFileNameToVarName(file).replace(\"_kicad_mod\", \".tsx\")}`,\n      )\n      const exampleFilePath = join(\n        outputDir,\n        \"examples\",\n        `${normalizeFileNameToVarName(file).replace(\"_kicad_mod\", \".tsx\")}`,\n      )\n\n      const tsContent = await getTsFileContentFromKicadModFile(inputFilePath)\n\n      // Ensure the directory for the output file exists\n      const outputFileDir = dirname(outputFilePath)\n      if (!existsSync(outputFileDir)) {\n        mkdirSync(outputFileDir, { recursive: true })\n      }\n      const exampleFileDir = dirname(exampleFilePath)\n      if (!existsSync(exampleFileDir)) {\n        mkdirSync(exampleFileDir, { recursive: true })\n      }\n\n      writeFileSync(outputFilePath, tsContent)\n\n      const varName = normalizeFileNameToVarName(file).replace(\"_kicad_mod\", \"\")\n\n      const exampleContent = `\nimport { ${varName} } from \"../lib/${varName}\"\n\nexport const ${varName}Example = () => {\n  return (\n    <group>\n      <component footprint={${varName}} />\n    </group>\n  )\n}\n`\n\n      writeFileSync(exampleFilePath, exampleContent)\n\n      return {\n        varName,\n        relativePath: `./${relative(outputDir, outputFilePath)\n          .replace(/\\\\/g, \"/\")\n          .replace(/\\.tsx$/, \"\")}`,\n      }\n    }),\n  )\n\n  // 3. Write an \"index.tsx\" file in the output directory that exports all the files\n  const indexContent = exports\n    .map(\n      (exp) =>\n        `export { default as ${exp.varName} } from '${exp.relativePath}';`,\n    )\n    .join(\"\\n\")\n\n  writeFileSync(join(outputDir, \"index.tsx\"), indexContent)\n\n  console.log(\n    `\\n\"${outputDir}\" is now a tscircuit project that can be published or imported.\n\nRun \"npm install\" to install dependencies then...\n1. Run \"npm run start\" inside of it to inspect all the footprints\n2. Run \"npm run ship\" to publish it to the tscircuit registry`,\n  )\n}\n","import type { ParamHandler } from \"./param-handler-type\"\nimport * as fs from \"node:fs/promises\"\n\nexport const interactForLocalDirectory: ParamHandler = async ({ prompts }) => {\n  const { selectionMode } = await prompts({\n    type: \"select\",\n    name: \"selectionMode\",\n    message: \"Select a directory\",\n    choices: [\n      { title: \"Manually Enter Path\", value: \"manual\" },\n      { title: \"Browse for Directory\", value: \"browse\" },\n    ],\n  })\n\n  if (selectionMode === \"manual\") {\n    const { manualPath } = await prompts({\n      type: \"text\",\n      name: \"manualPath\",\n      message: \"Enter the path to the directory\",\n    })\n    return manualPath\n  }\n\n  let currentDirectory = \".\"\n  while (true) {\n    const files = await fs.readdir(currentDirectory)\n    const dirChoices = files\n      .filter((d) => !d.includes(\".\"))\n      .map((file) => ({ title: file, value: file }))\n    const { selectedDir } = await prompts({\n      type: \"autocomplete\",\n      name: \"selectedDir\",\n      message: \"Select a directory\",\n      initial: \"__select__\",\n      choices: [\n        { title: \".. (Go Up)\", value: \"..\" },\n        { title: `[\"${currentDirectory}\"]`, value: \"__select__\" },\n        ...dirChoices,\n      ],\n    })\n    if (selectedDir === \"..\") {\n      // Go up one directory\n      const lastIndex = currentDirectory.lastIndexOf(\"/\")\n      currentDirectory = currentDirectory.substring(0, lastIndex)\n    } else if (selectedDir === \"__select__\") {\n      return currentDirectory\n    } else {\n      // Check if selectedFile is a file or directory\n      const stats = await fs.stat(`${currentDirectory}/${selectedDir}`)\n      if (stats.isFile()) {\n        throw new Error(\"Selected file is a file, not a directory\")\n      }\n\n      // Go into the selected directory\n      currentDirectory = `${currentDirectory}/${selectedDir}`\n    }\n  }\n}\n","import { interactForLocalDirectory } from \"./interact-for-local-directory\"\nimport type { ParamHandler } from \"./param-handler-type\"\n\nexport const PARAM_HANDLERS_BY_PARAM_NAME: Record<string, ParamHandler> = {\n  input_dir: interactForLocalDirectory,\n  output_dir: interactForLocalDirectory,\n}\n"],"mappings":"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","names":["Debug","point","path","debug","Debug","offX","offY","rotOff","fp_line","point","prompts","prompts"]}