// lib/solvers/CopperPourPipelineSolver.ts
import { BasePipelineSolver } from "@tscircuit/solver-utils";

// lib/solvers/copper-pour/get-board-polygon.ts
import Flatten from "@flatten-js/core";
var getBoardPolygon = (region) => {
  const board_edge_margin = region.board_edge_margin ?? 0;
  if (region.outline && region.outline.length > 0) {
    const polygon = new Flatten.Polygon(
      region.outline.map((p) => Flatten.point(p.x, p.y))
    );
    if (polygon.orientation() === Flatten.ORIENTATION.CW) {
      polygon.reverse();
    }
    return polygon;
  }
  const { bounds } = region;
  const newBounds = {
    minX: bounds.minX + board_edge_margin,
    minY: bounds.minY + board_edge_margin,
    maxX: bounds.maxX - board_edge_margin,
    maxY: bounds.maxY - board_edge_margin
  };
  if (newBounds.minX >= newBounds.maxX || newBounds.minY >= newBounds.maxY) {
    return new Flatten.Polygon();
  }
  return new Flatten.Polygon(
    new Flatten.Box(
      newBounds.minX,
      newBounds.minY,
      newBounds.maxX,
      newBounds.maxY
    ).toPoints()
  );
};

// lib/solvers/CopperPourPipelineSolver.ts
import Flatten5 from "@flatten-js/core";

// lib/solvers/copper-pour/process-obstacles.ts
import Flatten3 from "@flatten-js/core";

// lib/solvers/copper-pour/circle-to-polygon.ts
import Flatten2 from "@flatten-js/core";
var circleToPolygon = (circle, numSegments = 32) => {
  const points = [];
  for (let i = 0; i < numSegments; i++) {
    const angle = i / numSegments * 2 * Math.PI;
    points.push(
      new Flatten2.Point(
        circle.center.x + circle.r * Math.cos(angle),
        circle.center.y + circle.r * Math.sin(angle)
      )
    );
  }
  return new Flatten2.Polygon(points);
};

// lib/solvers/copper-pour/process-obstacles.ts
var isRectPad = (pad) => pad.shape === "rect";
var isTracePad = (pad) => pad.shape === "trace";
var isCircularPad = (pad) => pad.shape === "circle";
var isPolygonPad = (pad) => pad.shape === "polygon";
var processObstaclesForPour = (pads, pourConnectivityKey, margins, boardOutline) => {
  const polygonsToSubtract = [];
  const { padMargin, traceMargin, board_edge_margin, cutoutMargin } = margins;
  if (boardOutline && boardOutline.length > 0 && board_edge_margin && board_edge_margin > 0) {
    const boardPoly = new Flatten3.Polygon(
      boardOutline.map((p) => Flatten3.point(p.x, p.y))
    );
    if (boardPoly.area() < 0) {
      boardPoly.reverse();
    }
    const vertices = boardPoly.vertices;
    for (let i = 0; i < vertices.length; i++) {
      const p1 = vertices[i === 0 ? vertices.length - 1 : i - 1];
      const p2 = vertices[i];
      const p3 = vertices[(i + 1) % vertices.length];
      if (!p1 || !p2 || !p3) continue;
      const v1 = new Flatten3.Vector(p1, p2);
      const v2 = new Flatten3.Vector(p2, p3);
      const crossProduct = v1.cross(v2);
      const circle = new Flatten3.Circle(p2, board_edge_margin);
      polygonsToSubtract.push(circleToPolygon(circle));
      if (crossProduct < 0) {
        const box = new Flatten3.Box(
          p2.x - board_edge_margin,
          p2.y - board_edge_margin,
          p2.x + board_edge_margin,
          p2.y + board_edge_margin
        );
        polygonsToSubtract.push(new Flatten3.Polygon(box.toPoints()));
      }
    }
    for (let i = 0; i < vertices.length; i++) {
      const p1 = vertices[i];
      const p2 = vertices[(i + 1) % vertices.length];
      if (!p1 || !p2) continue;
      const segmentLength = Math.hypot(p1.x - p2.x, p1.y - p2.y);
      if (segmentLength === 0) continue;
      const enlargedWidth = board_edge_margin * 2;
      const centerX = (p1.x + p2.x) / 2;
      const centerY = (p1.y + p2.y) / 2;
      const rotationDeg = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
      const w2 = segmentLength / 2;
      const h2 = enlargedWidth / 2;
      const angleRad = rotationDeg * Math.PI / 180;
      const cosAngle = Math.cos(angleRad);
      const sinAngle = Math.sin(angleRad);
      const corners = [
        { x: -w2, y: -h2 },
        { x: w2, y: -h2 },
        { x: w2, y: h2 },
        { x: -w2, y: h2 }
      ];
      const rotatedCorners = corners.map((p) => ({
        x: centerX + p.x * cosAngle - p.y * sinAngle,
        y: centerY + p.x * sinAngle + p.y * cosAngle
      }));
      polygonsToSubtract.push(
        new Flatten3.Polygon(rotatedCorners.map((p) => Flatten3.point(p.x, p.y)))
      );
    }
  }
  for (const pad of pads) {
    const isOnNet = pad.connectivityKey === pourConnectivityKey;
    if (isOnNet) {
      continue;
    }
    const isHoleOrCutout = pad.connectivityKey.startsWith("hole:") || pad.connectivityKey.startsWith("cutout:");
    if (isCircularPad(pad)) {
      const margin = isHoleOrCutout ? cutoutMargin ?? 0 : padMargin;
      const circle = new Flatten3.Circle(
        new Flatten3.Point(pad.x, pad.y),
        pad.radius + margin
      );
      polygonsToSubtract.push(circleToPolygon(circle));
      continue;
    }
    if (isRectPad(pad)) {
      const margin = isHoleOrCutout ? cutoutMargin ?? 0 : padMargin;
      const { bounds } = pad;
      const b = new Flatten3.Box(
        bounds.minX - margin,
        bounds.minY - margin,
        bounds.maxX + margin,
        bounds.maxY + margin
      );
      polygonsToSubtract.push(new Flatten3.Polygon(b.toPoints()));
      continue;
    }
    if (isPolygonPad(pad)) {
      const margin = isHoleOrCutout ? cutoutMargin ?? 0 : 0;
      const seen = /* @__PURE__ */ new Set();
      const uniquePoints = pad.points.filter((p) => {
        const key = `${p.x},${p.y}`;
        if (seen.has(key)) {
          return false;
        }
        seen.add(key);
        return true;
      });
      if (uniquePoints.length < 3) continue;
      const polygon = new Flatten3.Polygon(
        uniquePoints.map((p) => Flatten3.point(p.x, p.y))
      );
      if (Math.abs(polygon.area()) < 1e-9) continue;
      if (margin <= 0) {
        polygonsToSubtract.push(polygon);
        continue;
      }
      if (polygon.area() > 0) {
        polygon.reverse();
      }
      const offsetLines = [];
      const polygonVertices = polygon.vertices;
      for (let i = 0; i < polygonVertices.length; i++) {
        const p1 = polygonVertices[i];
        const p2 = polygonVertices[(i + 1) % polygonVertices.length];
        const segment = Flatten3.segment(p1, p2);
        if (segment.length === 0) continue;
        const line = Flatten3.line(segment.start, segment.end);
        const norm = line.norm;
        const offsetLine = line.translate(norm.multiply(-margin));
        offsetLines.push(offsetLine);
      }
      const newPolygonPoints = [];
      for (let i = 0; i < offsetLines.length; i++) {
        const line1 = offsetLines[i];
        const line2 = offsetLines[(i + 1) % offsetLines.length];
        const ip = line1.intersect(line2);
        if (ip.length > 0) {
          newPolygonPoints.push(ip[0]);
        }
      }
      if (newPolygonPoints.length >= 3) {
        polygonsToSubtract.push(new Flatten3.Polygon(newPolygonPoints));
      }
      continue;
    }
    if (isTracePad(pad)) {
      for (const segment of pad.segments) {
        const circle = new Flatten3.Circle(
          new Flatten3.Point(segment.x, segment.y),
          pad.width / 2 + traceMargin
        );
        polygonsToSubtract.push(circleToPolygon(circle));
      }
      for (let i = 0; i < pad.segments.length - 1; i++) {
        const p1 = pad.segments[i];
        const p2 = pad.segments[i + 1];
        if (!p1 || !p2) continue;
        const segmentLength = Math.hypot(p1.x - p2.x, p1.y - p2.y);
        if (segmentLength === 0) continue;
        const enlargedWidth = pad.width + traceMargin * 2;
        const centerX = (p1.x + p2.x) / 2;
        const centerY = (p1.y + p2.y) / 2;
        const rotationDeg = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
        const w2 = segmentLength / 2;
        const h2 = enlargedWidth / 2;
        const angleRad = rotationDeg * Math.PI / 180;
        const cosAngle = Math.cos(angleRad);
        const sinAngle = Math.sin(angleRad);
        const corners = [
          { x: -w2, y: -h2 },
          { x: w2, y: -h2 },
          { x: w2, y: h2 },
          { x: -w2, y: h2 }
        ];
        const rotatedCorners = corners.map((p) => ({
          x: centerX + p.x * cosAngle - p.y * sinAngle,
          y: centerY + p.x * sinAngle + p.y * cosAngle
        }));
        polygonsToSubtract.push(
          new Flatten3.Polygon(
            rotatedCorners.map((p) => Flatten3.point(p.x, p.y))
          )
        );
      }
      continue;
    }
  }
  return { polygonsToSubtract };
};

// lib/solvers/copper-pour/generate-brep.ts
import Flatten4 from "@flatten-js/core";
var faceToVertices = (face) => face.edges.map((e) => {
  const pt = {
    x: e.start.x,
    y: e.start.y
  };
  if (e.isArc) {
    const bulge = Math.tan(e.shape.sweep / 4);
    if (Math.abs(bulge) > 1e-9) {
      pt.bulge = bulge;
    }
  }
  return pt;
});
var generateBRep = (pourPolygons) => {
  const brep_shapes = [];
  const polygons = Array.isArray(pourPolygons) ? pourPolygons : [pourPolygons];
  for (const p of polygons) {
    const islands = p.splitToIslands();
    for (const island of islands) {
      if (island.isEmpty()) continue;
      const faces = [...island.faces];
      const outer_face_ccw = faces.find(
        (f) => f.orientation() === Flatten4.ORIENTATION.CCW
      );
      const inner_faces_cw = faces.filter(
        (f) => f.orientation() === Flatten4.ORIENTATION.CW
      );
      if (!outer_face_ccw) continue;
      outer_face_ccw.reverse();
      const outer_ring_vertices = faceToVertices(outer_face_ccw);
      const inner_rings = inner_faces_cw.map((f) => {
        f.reverse();
        return { vertices: faceToVertices(f) };
      });
      brep_shapes.push({
        outer_ring: { vertices: outer_ring_vertices },
        inner_rings
      });
    }
  }
  return brep_shapes;
};

// lib/solvers/CopperPourPipelineSolver.ts
var CopperPourPipelineSolver = class extends BasePipelineSolver {
  constructor(input) {
    super(input);
    this.input = input;
  }
  pipelineDef = [];
  getOutput() {
    const brep_shapes = [];
    for (const region of this.input.regionsForPour) {
      const boardPolygon = getBoardPolygon(region);
      const padsForLayer = this.input.pads.filter(
        (p) => p.layer === region.layer
      );
      const { polygonsToSubtract } = processObstaclesForPour(
        padsForLayer,
        region.connectivityKey,
        {
          padMargin: region.padMargin,
          traceMargin: region.traceMargin,
          board_edge_margin: region.board_edge_margin,
          cutoutMargin: region.cutout_margin
        },
        region.outline
      );
      let pourPolygons = boardPolygon;
      for (const poly of polygonsToSubtract) {
        const currentPolys = Array.isArray(pourPolygons) ? pourPolygons : [pourPolygons];
        const nextPolys = [];
        for (const p of currentPolys) {
          const result = Flatten5.BooleanOperations.subtract(p, poly);
          if (result) {
            if (Array.isArray(result)) {
              nextPolys.push(...result.filter((r) => !r.isEmpty()));
            } else {
              if (!result.isEmpty()) nextPolys.push(result);
            }
          }
        }
        pourPolygons = nextPolys;
      }
      const new_breps = generateBRep(pourPolygons);
      brep_shapes.push(...new_breps);
    }
    return {
      brep_shapes
    };
  }
};

// lib/circuit-json/convert-circuit-json-to-input-problem.ts
var convertCircuitJsonToInputProblem = (circuitJson, options) => {
  const source_ports = circuitJson.filter(
    (e) => e.type === "source_port"
  );
  const pcb_ports = circuitJson.filter(
    (e) => e.type === "pcb_port"
  );
  const source_traces = circuitJson.filter(
    (e) => e.type === "source_trace"
  );
  const pcb_traces = circuitJson.filter(
    (e) => e.type === "pcb_trace"
  );
  const source_nets = circuitJson.filter(
    (e) => e.type === "source_net"
  );
  const pcb_board = circuitJson.find((e) => e.type === "pcb_board");
  if (!pcb_board) throw new Error("No pcb_board found in circuit json");
  const sourcePortIdToConnectivityKey = Object.fromEntries(
    source_ports.map((sp) => [
      sp.source_port_id,
      sp.subcircuit_connectivity_map_key
    ])
  );
  const pcbPortIdToConnectivityKey = Object.fromEntries(
    pcb_ports.map((pp) => [
      pp.pcb_port_id,
      sourcePortIdToConnectivityKey[pp.source_port_id]
    ])
  );
  const pcbPlatedHoleIdToConnectivityKey = {};
  for (const pcb_port of pcb_ports) {
    if (pcb_port.pcb_port_id) {
      pcbPlatedHoleIdToConnectivityKey[pcb_port.pcb_port_id] = pcbPortIdToConnectivityKey[pcb_port.pcb_port_id];
    }
  }
  const sourceTraceIdToConnectivityKey = Object.fromEntries(
    source_traces.map((st) => [
      st.source_trace_id,
      st.subcircuit_connectivity_map_key
    ])
  );
  const sourceNetIdToConnectivityKey = Object.fromEntries(
    source_nets.map((sn) => [
      sn.source_net_id,
      sn.subcircuit_connectivity_map_key
    ])
  );
  const idToConnectivityKey = {
    ...sourceTraceIdToConnectivityKey,
    ...sourceNetIdToConnectivityKey
  };
  const pcbTraceIdToConnectivityKey = Object.fromEntries(
    pcb_traces.map(
      (trace) => [
        trace.pcb_trace_id,
        trace.source_trace_id ? idToConnectivityKey[trace.source_trace_id] : void 0
      ]
    ).filter((entry) => Boolean(entry[1]))
  );
  const pads = [];
  for (const elm of circuitJson) {
    if (elm.type === "pcb_smtpad") {
      const smtpad = elm;
      if (smtpad.layer !== options.layer) continue;
      let connectivityKey;
      if (smtpad.pcb_port_id) {
        connectivityKey = pcbPortIdToConnectivityKey[smtpad.pcb_port_id];
      }
      if (!connectivityKey) {
        connectivityKey = `unconnected:${smtpad.pcb_smtpad_id}`;
      }
      if (smtpad.shape === "rect") {
        pads.push({
          shape: "rect",
          padId: smtpad.pcb_smtpad_id,
          layer: smtpad.layer,
          connectivityKey,
          bounds: {
            minX: smtpad.x - smtpad.width / 2,
            minY: smtpad.y - smtpad.height / 2,
            maxX: smtpad.x + smtpad.width / 2,
            maxY: smtpad.y + smtpad.height / 2
          }
        });
      } else if (smtpad.shape === "circle") {
        pads.push({
          shape: "circle",
          padId: smtpad.pcb_smtpad_id,
          layer: smtpad.layer,
          connectivityKey,
          x: smtpad.x,
          y: smtpad.y,
          radius: smtpad.radius
        });
      }
    } else if (elm.type === "pcb_plated_hole") {
      const platedHole = elm;
      if (platedHole.shape !== "circle") continue;
      if (!platedHole.layers.includes(options.layer)) continue;
      let connectivityKey = pcbPlatedHoleIdToConnectivityKey[platedHole.pcb_plated_hole_id];
      if (!connectivityKey) {
        connectivityKey = `unconnected-plated-hole:${platedHole.pcb_plated_hole_id}`;
      }
      pads.push({
        shape: "circle",
        padId: platedHole.pcb_plated_hole_id,
        layer: options.layer,
        connectivityKey,
        x: platedHole.x,
        y: platedHole.y,
        radius: platedHole.outer_diameter / 2
      });
    } else if (elm.type === "pcb_hole") {
      const hole = elm;
      if (hole.hole_shape !== "circle") continue;
      pads.push({
        shape: "circle",
        padId: hole.pcb_hole_id,
        layer: options.layer,
        // holes are through-all
        connectivityKey: `hole:${hole.pcb_hole_id}`,
        x: hole.x,
        y: hole.y,
        radius: hole.hole_diameter / 2
      });
    } else if (elm.type === "pcb_cutout") {
      const cutout = elm;
      if (cutout.shape === "rect") {
        pads.push({
          shape: "rect",
          padId: cutout.pcb_cutout_id,
          layer: options.layer,
          // through-all
          connectivityKey: `cutout:${cutout.pcb_cutout_id}`,
          bounds: {
            minX: cutout.center.x - cutout.width / 2,
            minY: cutout.center.y - cutout.height / 2,
            maxX: cutout.center.x + cutout.width / 2,
            maxY: cutout.center.y + cutout.height / 2
          }
        });
      } else if (cutout.shape === "circle") {
        pads.push({
          shape: "circle",
          padId: cutout.pcb_cutout_id,
          layer: options.layer,
          // through-all
          connectivityKey: `cutout:${cutout.pcb_cutout_id}`,
          x: cutout.center.x,
          y: cutout.center.y,
          radius: cutout.radius
        });
      } else if (cutout.shape === "polygon") {
        pads.push({
          shape: "polygon",
          padId: cutout.pcb_cutout_id,
          layer: options.layer,
          // through-all
          connectivityKey: `cutout:${cutout.pcb_cutout_id}`,
          points: cutout.points
        });
      }
    } else if (elm.type === "pcb_via") {
      const via = elm;
      if (!via.layers.includes(options.layer)) continue;
      const connectivityKey = via.subcircuit_connectivity_map_key ?? pcbTraceIdToConnectivityKey[via.pcb_trace_id ?? ""] ?? `unconnected-via:${via.pcb_via_id}`;
      pads.push({
        shape: "circle",
        padId: via.pcb_via_id,
        layer: options.layer,
        connectivityKey,
        x: via.x,
        y: via.y,
        radius: via.outer_diameter / 2
      });
    } else if (elm.type === "pcb_trace") {
      const trace = elm;
      if (!trace.source_trace_id) continue;
      const connectivityKey = idToConnectivityKey[trace.source_trace_id];
      if (!connectivityKey) continue;
      let currentSegmentGroup = [];
      let currentWidth = null;
      const commitGroup = () => {
        if (currentSegmentGroup.length > 1) {
          pads.push({
            shape: "trace",
            padId: `${trace.pcb_trace_id}-${pads.length}`,
            layer: options.layer,
            connectivityKey,
            segments: currentSegmentGroup,
            width: currentWidth
          });
        }
        currentSegmentGroup = [];
        currentWidth = null;
      };
      for (const r of trace.route) {
        const ri = r;
        const isWireOnLayer = ri.route_type === "wire" && ri.layer === options.layer;
        if (isWireOnLayer) {
          if (currentWidth === null) currentWidth = ri.width;
          currentSegmentGroup.push({ x: ri.x, y: ri.y });
        } else {
          commitGroup();
        }
      }
      commitGroup();
    }
  }
  const { width, height } = pcb_board;
  const regionsForPour = [
    {
      shape: "rect",
      layer: options.layer,
      bounds: {
        minX: -width / 2,
        minY: -height / 2,
        maxX: width / 2,
        maxY: height / 2
      },
      outline: pcb_board.outline,
      connectivityKey: options.pour_connectivity_key,
      padMargin: options.pad_margin,
      traceMargin: options.trace_margin,
      board_edge_margin: options.board_edge_margin ?? 0,
      cutout_margin: options.cutout_margin
    }
  ];
  return {
    pads,
    regionsForPour
  };
};
export {
  CopperPourPipelineSolver,
  convertCircuitJsonToInputProblem
};
