import { BasePipelineSolver } from '@tscircuit/solver-utils';
import { Bounds, Point } from '@tscircuit/math-utils';
import { BRepShape, AnyCircuitElement, LayerRef } from 'circuit-json';

interface InputPourRegion {
    shape: "rect";
    layer: string;
    bounds: Bounds;
    outline?: Point[];
    connectivityKey: string;
    padMargin: number;
    traceMargin: number;
    board_edge_margin?: number;
    cutout_margin?: number;
}
interface BaseInputPad {
    padId: string;
    connectivityKey: string;
    layer: string;
}
interface InputRectPad extends BaseInputPad {
    shape: "rect";
    bounds: Bounds;
}
interface InputCircularPad extends BaseInputPad {
    shape: "circle";
    x: number;
    y: number;
    radius: number;
}
interface InputTracePad extends BaseInputPad {
    shape: "trace";
    width: number;
    segments: Point[];
}
interface InputPolygonPad extends BaseInputPad {
    shape: "polygon";
    points: Point[];
}
type InputPad = InputRectPad | InputCircularPad | InputTracePad | InputPolygonPad;
interface InputProblem {
    regionsForPour: InputPourRegion[];
    pads: InputPad[];
}
interface PipelineOutput {
    brep_shapes: BRepShape[];
}

declare class CopperPourPipelineSolver extends BasePipelineSolver<InputProblem> {
    input: InputProblem;
    pipelineDef: never[];
    constructor(input: InputProblem);
    getOutput(): PipelineOutput;
}

declare const convertCircuitJsonToInputProblem: (circuitJson: AnyCircuitElement[], options: {
    layer: LayerRef;
    pour_connectivity_key: string;
    pad_margin: number;
    trace_margin: number;
    board_edge_margin?: number;
    cutout_margin?: number;
}) => InputProblem;

export { type BaseInputPad, CopperPourPipelineSolver, type InputCircularPad, type InputPad, type InputPolygonPad, type InputPourRegion, type InputProblem, type InputRectPad, type InputTracePad, type PipelineOutput, convertCircuitJsonToInputProblem };
