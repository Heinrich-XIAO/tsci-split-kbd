var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// lib/layoutCircuitJsonWithFlex.ts
import {RootFlexBox} from "@tscircuit/miniflex";
import Debug from "debug";
import {
  getCircuitJsonTree,
  repositionPcbComponentTo
} from "@tscircuit/circuit-json-util";

// lib/getMinimumFlexContainer.ts
function getMinimumFlexContainer(children, options = {}) {
  var _a, _b, _c;
  if (children.length === 0)
    return {width: 0, height: 0};
  const direction = (_a = options.direction) != null ? _a : "row";
  const columnGap = (_b = options.columnGap) != null ? _b : 0;
  const rowGap = (_c = options.rowGap) != null ? _c : 0;
  const isRowDirection = direction === "row" || direction === "row-reverse";
  if (isRowDirection) {
    const totalChildWidth = children.reduce((sum, c) => sum + c.width, 0);
    const width = totalChildWidth + columnGap * Math.max(0, children.length - 1);
    const height = children.reduce((max, c) => Math.max(max, c.height), 0);
    return {width, height};
  } else {
    const totalChildHeight = children.reduce((sum, c) => sum + c.height, 0);
    const height = totalChildHeight + rowGap * Math.max(0, children.length - 1);
    const width = children.reduce((max, c) => Math.max(max, c.width), 0);
    return {width, height};
  }
}

// lib/layoutCircuitJsonWithFlex.ts
var debug = Debug("tscircuit:circuit-json-flex:layoutCircuitJsonWithFlex");
var toNumber = (v) => typeof v === "number" ? v : typeof v === "string" ? parseFloat(v) : 0;
function layoutCircuitJsonWithFlex(circuitJson, options = {}) {
  var _a, _b, _c, _d, _e, _f, _g;
  const circuitJsonCopy = circuitJson.map((e) => __spreadValues({}, e));
  const tree = getCircuitJsonTree(circuitJsonCopy);
  let rootContainer;
  const rootSubcircuitId = (_a = tree.sourceGroup) == null ? void 0 : _a.subcircuit_id;
  if (rootSubcircuitId) {
    rootContainer = circuitJsonCopy.find((e) => e.type === "pcb_board");
    if (!rootContainer) {
      rootContainer = circuitJsonCopy.find((e) => e.type === "pcb_group" && e.is_subcircuit === true && e.subcircuit_id === rootSubcircuitId);
    }
  }
  if (!rootContainer)
    return circuitJsonCopy;
  let effectiveTree = tree;
  let effectiveRootContainer = rootContainer;
  while (effectiveTree.childNodes.length === 1 && (() => {
    var _a2;
    const firstChild = effectiveTree.childNodes[0];
    return firstChild !== void 0 && firstChild.nodeType === "group" && Boolean((_a2 = firstChild.sourceGroup) == null ? void 0 : _a2.subcircuit_id);
  })()) {
    const firstChild = effectiveTree.childNodes[0];
    const childSubId = firstChild.sourceGroup.subcircuit_id;
    const childPcbGroup = circuitJsonCopy.find((e) => e.type === "pcb_group" && e.is_subcircuit === true && e.subcircuit_id === childSubId);
    if (!childPcbGroup || childPcbGroup.width == null || childPcbGroup.height == null) {
      break;
    }
    effectiveTree = firstChild;
    effectiveRootContainer = childPcbGroup;
  }
  const rootSubcircuitWidth = toNumber(effectiveRootContainer.width);
  const rootSubcircuitHeight = toNumber(effectiveRootContainer.height);
  const nodeInfos = [];
  for (const child of effectiveTree.childNodes) {
    let refCenter;
    let width;
    let height;
    let childFlexItemId;
    let pcbComponentIds;
    if (child.nodeType === "component") {
      const comp = circuitJsonCopy.find((e) => e.type === "pcb_component" && e.source_component_id === child.sourceComponent.source_component_id);
      if (!comp) {
        continue;
      }
      width = toNumber(comp.width);
      height = toNumber(comp.height);
      refCenter = comp.center;
      childFlexItemId = comp.pcb_component_id;
      pcbComponentIds = [comp.pcb_component_id];
    } else {
      const scId = (_b = child.sourceGroup) == null ? void 0 : _b.subcircuit_id;
      const pcbGroup = circuitJsonCopy.find((e) => e.type === "pcb_group" && e.is_subcircuit === true && e.subcircuit_id === scId);
      if (!pcbGroup) {
        continue;
      }
      width = toNumber(pcbGroup.width);
      height = toNumber(pcbGroup.height);
      refCenter = pcbGroup.center;
      childFlexItemId = pcbGroup.subcircuit_id;
      pcbComponentIds = circuitJsonCopy.filter((e) => e.type === "pcb_component" && e.subcircuit_id === pcbGroup.subcircuit_id).map((c) => c.pcb_component_id);
    }
    nodeInfos.push({
      id: childFlexItemId,
      pcbComponentIds,
      refCenter,
      width,
      height
    });
  }
  let containerWidth = rootSubcircuitWidth;
  let containerHeight = rootSubcircuitHeight;
  if (options.inferContainerSize === true || !(containerWidth > 0) || !(containerHeight > 0)) {
    const {width: minW, height: minH} = getMinimumFlexContainer(nodeInfos.map((n) => ({width: n.width, height: n.height})), options);
    if (options.inferContainerSize === true || !(containerWidth > 0)) {
      containerWidth = minW;
    }
    if (options.inferContainerSize === true || !(containerHeight > 0)) {
      containerHeight = minH;
    }
    ;
    effectiveRootContainer.width = containerWidth;
    effectiveRootContainer.height = containerHeight;
  }
  const rootFlex = new RootFlexBox(containerWidth, containerHeight, {
    id: effectiveRootContainer.subcircuit_id,
    justifyContent: (_c = options.justifyContent) != null ? _c : "center",
    alignItems: (_d = options.alignItems) != null ? _d : "center",
    direction: (_e = options.direction) != null ? _e : "row",
    columnGap: (_f = options.columnGap) != null ? _f : 0,
    rowGap: (_g = options.rowGap) != null ? _g : 0
  });
  for (const info of nodeInfos) {
    rootFlex.addChild({
      id: info.id,
      flexBasis: info.width,
      height: info.height
    });
  }
  rootFlex.build();
  const layout = rootFlex.getLayout();
  for (const info of nodeInfos) {
    const l = layout[info.id];
    if (!l)
      continue;
    const {width, height, refCenter: originalCenter} = info;
    const newCenter = {
      x: l.position.x + width / 2 - containerWidth / 2,
      y: -(l.position.y + height / 2) + containerHeight / 2
    };
    const dx = newCenter.x - originalCenter.x;
    const dy = newCenter.y - originalCenter.y;
    for (const pcbComponentId of info.pcbComponentIds) {
      const pcbComponent = circuitJsonCopy.find((e) => e.type === "pcb_component" && e.pcb_component_id === pcbComponentId);
      repositionPcbComponentTo(circuitJsonCopy, pcbComponentId, {
        x: pcbComponent.center.x + dx,
        y: pcbComponent.center.y + dy
      });
    }
  }
  return circuitJsonCopy;
}
export {
  getMinimumFlexContainer,
  layoutCircuitJsonWithFlex
};
