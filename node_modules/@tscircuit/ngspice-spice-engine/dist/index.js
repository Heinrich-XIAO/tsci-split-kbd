// lib/parse-tran-params.ts
var SUFFIX_MULTIPLIERS = {
  t: 1e12,
  g: 1e9,
  meg: 1e6,
  k: 1e3,
  m: 1e-3,
  ms: 1e-3,
  u: 1e-6,
  us: 1e-6,
  n: 1e-9,
  ns: 1e-9,
  p: 1e-12,
  ps: 1e-12,
  f: 1e-15,
  fs: 1e-15,
  s: 1
};
var sanitizeToken = (token) => token.replace(/[,]/g, "");
var parseNumericToken = (token) => {
  const sanitized = sanitizeToken(token);
  const normalized = sanitized.toLowerCase();
  const match = normalized.match(/^([+-]?\d*\.?\d+(?:e[+-]?\d+)?)([a-z]+)?$/i);
  if (!match) {
    return void 0;
  }
  const [, basePart = "", suffix = ""] = match;
  const base = Number.parseFloat(basePart);
  if (Number.isNaN(base)) {
    return void 0;
  }
  if (!suffix) {
    return base;
  }
  const multiplier = SUFFIX_MULTIPLIERS[suffix] ?? SUFFIX_MULTIPLIERS[suffix.replace(/s$/, "")] ?? 1;
  return base * multiplier;
};
var parseTranParams = (spiceString) => {
  const lines = spiceString.split(/\r?\n/);
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line || line.startsWith("*")) {
      continue;
    }
    if (!line.toLowerCase().startsWith(".tran")) {
      continue;
    }
    const [withoutComments = ""] = line.split(";");
    const tokens = withoutComments.split(/\s+/).filter(Boolean);
    if (tokens.length <= 1) {
      return {};
    }
    const values = [];
    let uic = false;
    for (const token of tokens.slice(1)) {
      if (token.toLowerCase() === "uic") {
        uic = true;
        continue;
      }
      const value = parseNumericToken(token);
      if (value !== void 0) {
        values.push(value);
      }
    }
    const params = {};
    if (values[0] !== void 0) {
      params.tstep = values[0];
    }
    if (values[1] !== void 0) {
      params.tstop = values[1];
    }
    if (values[2] !== void 0) {
      params.tstart = values[2];
    }
    if (values[3] !== void 0) {
      params.tmax = values[3];
    }
    if (uic) {
      params.uic = true;
    }
    return params;
  }
  return null;
};

// lib/index.ts
var ensureSimulation = async () => {
  const { Simulation: SimulationCtor } = await import("eecircuit-engine");
  const instance = new SimulationCtor();
  await instance.start();
  return instance;
};
var simulationPromise = null;
var getSimulation = async () => {
  if (!simulationPromise) {
    simulationPromise = ensureSimulation().catch((error) => {
      simulationPromise = null;
      throw error;
    });
  }
  return simulationPromise;
};
var extractRequestedPlots = (spiceString) => {
  const match = spiceString.match(/\.print\s+tran\s+(.*)/i);
  if (!match || !match[1]) {
    return null;
  }
  const tokens = match[1].split(/\s+/).filter(Boolean);
  if (tokens.length === 0) {
    return null;
  }
  const plotMap = /* @__PURE__ */ new Map();
  for (const token of tokens) {
    const lowerCaseToken = token.toLowerCase();
    if (!plotMap.has(lowerCaseToken)) {
      plotMap.set(lowerCaseToken, token);
    }
  }
  return plotMap;
};
var getNetName = (rawName) => {
  const match = rawName.match(/^v\((.*)\)$/i);
  if (!match) {
    return rawName;
  }
  return match[1] ?? rawName;
};
var eecircuitResultToVGraphs = (result, spiceString) => {
  if (!result || !result.data || result.dataType !== "real") {
    return [];
  }
  const requestedPlots = extractRequestedPlots(spiceString);
  const timeData = result.data.find((item) => item.type === "time");
  if (!timeData || !Array.isArray(timeData.values)) {
    return [];
  }
  const timeValues = timeData.values;
  const graphs = [];
  for (const item of result.data) {
    if (item.type !== "voltage" || !Array.isArray(item.values)) {
      continue;
    }
    const lowerCaseItemName = item.name.toLowerCase();
    if (requestedPlots && !requestedPlots.has(lowerCaseItemName)) {
      continue;
    }
    const netName = getNetName(
      requestedPlots ? requestedPlots.get(lowerCaseItemName) : item.name
    );
    graphs.push({
      netName,
      time: timeValues,
      voltage: item.values
    });
  }
  return graphs;
};
var voltageGraphsToCircuitJson = (graphs, spiceString) => {
  const tranParams = parseTranParams(spiceString);
  return graphs.map((graph) => ({
    type: "simulation_transient_voltage_graph",
    simulation_experiment_id: "placeholder_simulation_experiment_id",
    simulation_transient_voltage_graph_id: `simulation_graph_${graph.netName}`,
    name: graph.netName,
    voltage_levels: graph.voltage,
    timestamps_ms: graph.time.map((timePoint) => timePoint * 1e3),
    start_time_ms: (tranParams?.tstart ?? 0) * 1e3,
    time_per_step: (tranParams?.tstep ?? 0) * 1e3,
    end_time_ms: (tranParams?.tstop ?? 0) * 1e3
  }));
};
var simulate = async (spiceString) => {
  const simulation = await getSimulation();
  simulation.setNetList(spiceString);
  let result;
  try {
    result = await simulation.runSim();
  } catch (error) {
    console.error(error);
    throw error;
  }
  if (!result) {
    return { simulationResultCircuitJson: [] };
  }
  const graphs = eecircuitResultToVGraphs(result, spiceString);
  return {
    simulationResultCircuitJson: voltageGraphsToCircuitJson(
      graphs,
      spiceString
    )
  };
};
var createNgspiceSpiceEngine = async () => ({
  simulate
});
var index_default = createNgspiceSpiceEngine;
export {
  createNgspiceSpiceEngine,
  index_default as default,
  eecircuitResultToVGraphs,
  parseTranParams
};
