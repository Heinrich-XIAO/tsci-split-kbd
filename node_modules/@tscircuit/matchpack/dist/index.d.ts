import { GraphicsObject } from 'graphics-debug';
import { Point, Bounds } from '@tscircuit/math-utils';
import { PackSolver2 } from 'calculate-packing';

declare class BaseSolver {
    MAX_ITERATIONS: number;
    solved: boolean;
    failed: boolean;
    iterations: number;
    progress: number;
    error: string | null;
    activeSubSolver?: BaseSolver | null;
    failedSubSolvers?: BaseSolver[];
    timeToSolve?: number;
    stats: Record<string, any>;
    /** DO NOT OVERRIDE! Override _step() instead */
    step(): void;
    _step(): void;
    getConstructorParams(): void;
    solve(): void;
    visualize(): GraphicsObject;
    /**
     * Called when the solver is about to fail, but we want to see if we have an
     * "acceptable" or "passable" solution. Mostly used for optimizers that
     * have an aggressive early stopping criterion.
     */
    tryFinalAcceptance(): void;
    /**
     * A lightweight version of the visualize method that can be used to stream
     * progress
     */
    preview(): GraphicsObject;
}

type Side = "x-" | "x+" | "y-" | "y+";

type PinId = string;
type ChipId = string;
type GroupId = string;
type NetId = string;
type ChipPin = {
    pinId: PinId;
    offset: Point;
    side: Side;
};
type Chip = {
    chipId: ChipId;
    pins: PinId[];
    size: Point;
    isDecouplingCap?: boolean;
    availableRotations?: Array<0 | 90 | 180 | 270>;
};
type Group = {
    groupId: GroupId;
    pins: PinId[];
    /** The shape of the group is defined by a set of bounding boxes */
    shape: Bounds[];
};
type GroupPin = {
    pinId: PinId;
    offset: Point;
};
type Net = {
    netId: NetId;
    isGround?: boolean;
    isPositiveVoltageSource?: boolean;
};
type InputProblem = {
    chipMap: Record<ChipId, Chip>;
    chipPinMap: Record<PinId, ChipPin>;
    netMap: Record<NetId, Net>;
    /** This is a two-way map */
    pinStrongConnMap: Record<`${PinId}-${PinId}`, boolean>;
    netConnMap: Record<`${PinId}-${NetId}`, boolean>;
    /** The minimum gap between chips within a partition */
    chipGap: number;
    /** The minimum gap between two partitions */
    partitionGap: number;
    decouplingCapsGap?: number;
    inferDecouplingCaps?: boolean;
};
interface PartitionInputProblem extends InputProblem {
    isPartition?: true;
    partitionType?: "default" | "decoupling_caps";
}

/**
 * Identifies decoupling capacitor groups based on specific criteria:
 * 1. Component has exactly 2 pins and restricted rotation (0/180 only or no rotation)
 * 2. One pin indirectly connected to net with "y+" restriction, one to "y-" restriction
 * 3. At least one pin directly connected to another chip
 */

interface DecouplingCapGroup {
    decouplingCapGroupId: string;
    mainChipId: ChipId;
    netPair: [NetId, NetId];
    decouplingCapChipIds: ChipId[];
}
/**
 * Identify decoupling capacitor groups based on specific criteria:
 * 1. Component has exactly 2 pins and restricted rotation (0/180 only or no rotation)
 * 2. One pin indirectly connected to net with isGround and one to isPositiveVoltageSource
 * 3. At least one pin directly connected to a chip (the main chip, typically a microcontroller)
 */
declare class IdentifyDecouplingCapsSolver extends BaseSolver {
    inputProblem: InputProblem;
    queuedChips: Chip[];
    outputDecouplingCapGroups: DecouplingCapGroup[];
    /** Quick lookup of groups by main chip and net pair for accumulation */
    private groupsByMainChipId;
    constructor(inputProblem: InputProblem);
    /** Determine if chip is a 2-pin component with restricted rotation */
    private isTwoPinRestrictedRotation;
    /** Check that the two pins are on opposite Y sides (y+ and y-) */
    private pinsOnOppositeYSides;
    /** Get chips strongly connected (direct pin-to-pin) to this pin */
    private getStronglyConnectedNeighborChips;
    /** Find the main chip id for a decoupling capacitor candidate */
    private findMainChipIdForCap;
    /** Get all net IDs connected to a pin */
    private getNetIdsForPin;
    /** Get a normalized, sorted pair of net IDs connected across the two pins of a capacitor chip */
    private getNormalizedNetPair;
    /** Adds a decoupling capacitor to the group for the given main chip and net pair */
    private addToGroup;
    lastChip: Chip | null;
    _step(): void;
    visualize(): GraphicsObject;
    getConstructorParams(): [InputProblem];
    computeProgress(): number;
}

/**
 * Creates partitions (small subset groups) surrounding complex chips.
 * Divides the layout problem into manageable sections for more efficient processing.
 */

declare class ChipPartitionsSolver extends BaseSolver {
    inputProblem: InputProblem;
    partitions: PartitionInputProblem[];
    decouplingCapGroups?: DecouplingCapGroup[];
    constructor({ inputProblem, decouplingCapGroups, }: {
        inputProblem: InputProblem;
        decouplingCapGroups?: DecouplingCapGroup[];
    });
    _step(): void;
    /**
     * Creates partitions by:
     * - Separating each decoupling capacitor group into its own partition (caps only, excluding the main chip)
     * - Partitioning remaining chips by connected components through strong pin connections
     */
    private createPartitions;
    /**
     * Finds the owner chip of a given pin
     */
    private findPinOwner;
    /**
     * Depth-first search to find connected components
     */
    private dfs;
    /**
     * Creates a new InputProblem containing only the components in the given partition
     */
    private createInputProblemFromPartition;
    visualize(): GraphicsObject;
}

type Placement = Point & {
    ccwRotationDegrees: number;
};
type OutputLayout = {
    chipPlacements: Record<ChipId, Placement>;
    groupPlacements: Record<GroupId, Placement>;
};

/**
 * Packs components within a single partition to create an optimal internal layout.
 * Uses a packing algorithm to arrange chips and their connections within the partition.
 */

declare class SingleInnerPartitionPackingSolver extends BaseSolver {
    partitionInputProblem: PartitionInputProblem;
    layout: OutputLayout | null;
    activeSubSolver: PackSolver2 | null;
    pinIdToStronglyConnectedPins: Record<PinId, ChipPin[]>;
    constructor(params: {
        partitionInputProblem: PartitionInputProblem;
        pinIdToStronglyConnectedPins: Record<PinId, ChipPin[]>;
    });
    _step(): void;
    private createPackInput;
    private createLayoutFromPackingResult;
    visualize(): GraphicsObject;
    getConstructorParams(): [InputProblem];
}

/**
 * Packs the internal layout of each partition using SingleInnerPartitionPackingSolver.
 * This stage takes the partitions from ChipPartitionsSolver and creates optimized
 * internal layouts for each partition before they are packed together.
 */

type PackedPartition = {
    inputProblem: InputProblem;
    layout: OutputLayout;
};
declare class PackInnerPartitionsSolver extends BaseSolver {
    partitions: InputProblem[];
    packedPartitions: PackedPartition[];
    completedSolvers: SingleInnerPartitionPackingSolver[];
    activeSolver: SingleInnerPartitionPackingSolver | null;
    currentPartitionIndex: number;
    activeSubSolver: SingleInnerPartitionPackingSolver | null;
    pinIdToStronglyConnectedPins: Record<PinId, ChipPin[]>;
    constructor(params: {
        partitions: InputProblem[];
        pinIdToStronglyConnectedPins: Record<PinId, ChipPin[]>;
    });
    _step(): void;
    visualize(): GraphicsObject;
    getConstructorParams(): [InputProblem[]];
}

/**
 * Packs the laid out chip partitions into a single layout.
 * Combines all the individually processed partitions into the final schematic layout.
 */

interface PartitionPackingSolverInput {
    packedPartitions: PackedPartition[];
    inputProblem: InputProblem;
}
declare class PartitionPackingSolver extends BaseSolver {
    packedPartitions: PackedPartition[];
    inputProblem: InputProblem;
    finalLayout: OutputLayout | null;
    packSolver2: PackSolver2 | null;
    constructor(input: PartitionPackingSolverInput);
    _step(): void;
    private organizePackedPartitions;
    private createPackInput;
    private applyPackingResult;
    visualize(): GraphicsObject;
    getConstructorParams(): PartitionPackingSolverInput;
}

/**
 * Pipeline solver that runs a series of solvers to find the best schematic layout.
 * Coordinates the entire layout process from chip partitioning through final packing.
 */

type PipelineStep<T extends new (...args: any[]) => BaseSolver> = {
    solverName: string;
    solverClass: T;
    getConstructorParams: (instance: LayoutPipelineSolver) => ConstructorParameters<T>;
    onSolved?: (instance: LayoutPipelineSolver) => void;
};
declare class LayoutPipelineSolver extends BaseSolver {
    identifyDecouplingCapsSolver?: IdentifyDecouplingCapsSolver;
    chipPartitionsSolver?: ChipPartitionsSolver;
    packInnerPartitionsSolver?: PackInnerPartitionsSolver;
    partitionPackingSolver?: PartitionPackingSolver;
    startTimeOfPhase: Record<string, number>;
    endTimeOfPhase: Record<string, number>;
    timeSpentOnPhase: Record<string, number>;
    firstIterationOfPhase: Record<string, number>;
    pinIdToStronglyConnectedPins: Record<PinId, ChipPin[]>;
    inputProblem: InputProblem;
    chipPartitions?: ChipPartitionsSolver["partitions"];
    packedPartitions?: PackedPartition[];
    pipelineDef: (PipelineStep<typeof IdentifyDecouplingCapsSolver> | PipelineStep<typeof ChipPartitionsSolver> | PipelineStep<typeof PackInnerPartitionsSolver> | PipelineStep<typeof PartitionPackingSolver>)[];
    constructor(inputProblem: InputProblem);
    currentPipelineStepIndex: number;
    _step(): void;
    solveUntilPhase(phase: string): void;
    getCurrentPhase(): string;
    visualize(): GraphicsObject;
    /**
     * A lightweight version of the visualize method that can be used to stream
     * progress
     */
    preview(): GraphicsObject;
    /**
     * Checks if any chips are overlapping in the given layout, considering rotation.
     * Returns an array of overlapping chip pairs.
     */
    checkForOverlaps(layout: OutputLayout): Array<{
        chip1: string;
        chip2: string;
        overlapArea: number;
    }>;
    /**
     * Calculate the axis-aligned bounding box for a rotated chip
     */
    private getRotatedBounds;
    /**
     * Calculate the overlap area between two axis-aligned bounding boxes
     */
    private calculateOverlapArea;
    getOutputLayout(): OutputLayout;
}

export { type Chip, type ChipId, type ChipPin, type Group, type GroupId, type GroupPin, type InputProblem, LayoutPipelineSolver, type Net, type NetId, type OutputLayout, type PartitionInputProblem, type PinId, type Placement };
