// lib/solvers/BaseSolver.ts
var BaseSolver = class {
  MAX_ITERATIONS = 1e5;
  solved = false;
  failed = false;
  iterations = 0;
  progress = 0;
  error = null;
  activeSubSolver;
  failedSubSolvers;
  timeToSolve;
  stats = {};
  /** DO NOT OVERRIDE! Override _step() instead */
  step() {
    if (this.solved) return;
    if (this.failed) return;
    this.iterations++;
    try {
      this._step();
    } catch (e) {
      this.error = `${this.constructor.name} error: ${e}`;
      this.failed = true;
      throw e;
    }
    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {
      this.tryFinalAcceptance();
    }
    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {
      this.error = `${this.constructor.name} ran out of iterations`;
      this.failed = true;
    }
    if ("computeProgress" in this) {
      this.progress = this.computeProgress();
    }
  }
  _step() {
  }
  getConstructorParams() {
    throw new Error("getConstructorParams not implemented");
  }
  solve() {
    const startTime = Date.now();
    while (!this.solved && !this.failed) {
      this.step();
    }
    const endTime = Date.now();
    this.timeToSolve = endTime - startTime;
  }
  visualize() {
    return {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
  }
  /**
   * Called when the solver is about to fail, but we want to see if we have an
   * "acceptable" or "passable" solution. Mostly used for optimizers that
   * have an aggressive early stopping criterion.
   */
  tryFinalAcceptance() {
  }
  /**
   * A lightweight version of the visualize method that can be used to stream
   * progress
   */
  preview() {
    return {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
  }
};

// lib/solvers/ChipPartitionsSolver/ChipPartitionsSolver.ts
import { stackGraphicsHorizontally } from "graphics-debug";

// lib/solvers/LayoutPipelineSolver/visualizeInputProblem.ts
function rotatePoint(point, angleDegrees) {
  const angleRad = angleDegrees * Math.PI / 180;
  const cos = Math.cos(angleRad);
  const sin = Math.sin(angleRad);
  return {
    x: point.x * cos - point.y * sin,
    y: point.x * sin + point.y * cos
  };
}
function getRotatedDimensions(width, height, rotation) {
  const normalizedRotation = (rotation % 360 + 360) % 360;
  if (Math.round((normalizedRotation + 90) % 180) === 0) {
    return { width: height, height: width };
  }
  return { width, height };
}
function visualizeInputProblem(inputProblem, basicLayout) {
  const inputViz = {
    points: [],
    rects: [],
    lines: [],
    circles: [],
    texts: []
  };
  const pinToNetMap = {};
  for (const conn of Object.keys(inputProblem.netConnMap)) {
    const [pinId, netId] = conn.split("-");
    pinToNetMap[pinId] = netId;
  }
  for (const [chipId, chip] of Object.entries(inputProblem.chipMap)) {
    const chipPins = chip.pins.map((p) => inputProblem.chipPinMap[p]);
    const placement = basicLayout.chipPlacements[chipId];
    if (!placement) continue;
    let width;
    let height;
    if (chip.size && Number.isFinite(chip.size.x) && Number.isFinite(chip.size.y)) {
      width = chip.size.x;
      height = chip.size.y;
    } else {
      const xs = chipPins.map((p) => p.offset.x);
      const ys = chipPins.map((p) => p.offset.y);
      const minX = xs.length ? Math.min(...xs) : -5;
      const maxX = xs.length ? Math.max(...xs) : 5;
      const minY = ys.length ? Math.min(...ys) : -5;
      const maxY = ys.length ? Math.max(...ys) : 5;
      width = Math.max(10, maxX - minX + 6);
      height = Math.max(10, maxY - minY + 6);
    }
    const chipCenterX = placement.x;
    const chipCenterY = placement.y;
    const rotatedDims = getRotatedDimensions(
      width,
      height,
      placement.ccwRotationDegrees
    );
    inputViz.rects.push({
      center: { x: chipCenterX, y: chipCenterY },
      width: rotatedDims.width,
      height: rotatedDims.height,
      label: chipId
    });
    inputViz.texts.push({ x: chipCenterX, y: chipCenterY, text: chipId });
    for (const pin of chipPins) {
      const rotatedOffset = rotatePoint(
        pin.offset,
        placement.ccwRotationDegrees
      );
      const pinAbsX = placement.x + rotatedOffset.x;
      const pinAbsY = placement.y + rotatedOffset.y;
      const netId = pinToNetMap[pin.pinId];
      const label = netId ? `${pin.pinId} (${netId})` : pin.pinId;
      inputViz.points.push({
        x: pinAbsX,
        y: pinAbsY,
        label
      });
    }
  }
  const netToPins = {};
  for (const [pinId, netId] of Object.entries(pinToNetMap)) {
    if (!netToPins[netId]) netToPins[netId] = [];
    netToPins[netId].push(pinId);
  }
  for (const [, pinIds] of Object.entries(netToPins)) {
    const pinPositions = pinIds.map((pinId) => {
      const chipPin = inputProblem.chipPinMap[pinId];
      if (chipPin) {
        for (const [chipId, chip] of Object.entries(inputProblem.chipMap)) {
          if (chip.pins.includes(pinId)) {
            const placement = basicLayout.chipPlacements[chipId];
            if (placement) {
              const rotatedOffset = rotatePoint(
                chipPin.offset,
                placement.ccwRotationDegrees
              );
              return {
                x: placement.x + rotatedOffset.x,
                y: placement.y + rotatedOffset.y
              };
            }
          }
        }
        return chipPin.offset;
      }
      return null;
    }).filter(Boolean);
    for (let i = 0; i < pinPositions.length; i++) {
      for (let j = i + 1; j < pinPositions.length; j++) {
        inputViz.lines.push({
          points: [pinPositions[i], pinPositions[j]],
          strokeColor: "rgba(0,0,0,0.1)"
        });
      }
    }
  }
  const getAbsolutePositionForPin = (pinId) => {
    const chipPin = inputProblem.chipPinMap[pinId];
    if (chipPin) {
      for (const [chipId, chip] of Object.entries(inputProblem.chipMap)) {
        if (chip.pins.includes(pinId)) {
          const placement = basicLayout.chipPlacements[chipId];
          if (placement) {
            const rotatedOffset = rotatePoint(
              chipPin.offset,
              placement.ccwRotationDegrees
            );
            return {
              x: placement.x + rotatedOffset.x,
              y: placement.y + rotatedOffset.y
            };
          }
        }
      }
      return chipPin.offset;
    }
    return null;
  };
  const seenStrongConn = /* @__PURE__ */ new Set();
  for (const [connKey, connected] of Object.entries(
    inputProblem.pinStrongConnMap
  )) {
    if (!connected) continue;
    const [pinA, pinB] = connKey.split("-");
    const uniqueKey = pinA < pinB ? `${pinA}-${pinB}` : `${pinB}-${pinA}`;
    if (seenStrongConn.has(uniqueKey)) continue;
    seenStrongConn.add(uniqueKey);
    const p1 = getAbsolutePositionForPin(pinA);
    const p2 = getAbsolutePositionForPin(pinB);
    if (!p1 || !p2) continue;
    inputViz.lines.push({
      points: [p1, p2]
      // Slightly darker to distinguish from net-group lines
      // strokeColor: "rgba(0,0,0,0.6)",
    });
  }
  return inputViz;
}

// lib/solvers/LayoutPipelineSolver/doBasicInputProblemLayout.ts
import { pack } from "calculate-packing";

// lib/solvers/LayoutPipelineSolver/hashInputProblem.ts
var hashInputProblem = (inputProblem) => {
  return JSON.stringify(inputProblem);
};

// lib/solvers/LayoutPipelineSolver/doBasicInputProblemLayout.ts
var cachedProblems = /* @__PURE__ */ new Map();
function doBasicInputProblemLayout(inputProblem) {
  const problemHash = hashInputProblem(inputProblem);
  if (cachedProblems.has(problemHash)) {
    return structuredClone(cachedProblems.get(problemHash));
  }
  const components = Object.entries(inputProblem.chipMap).map(
    ([chipId, chip]) => {
      const chipPins = chip.pins.map((pinId) => inputProblem.chipPinMap[pinId]);
      const pads = chipPins.map((pin) => {
        let networkId = pin.pinId;
        for (const [connKey, connected] of Object.entries(
          inputProblem.pinStrongConnMap
        )) {
          if (connected && connKey.includes(pin.pinId)) {
            const [pin1Id, pin2Id] = connKey.split("-");
            if (pin1Id === pin.pinId || pin2Id === pin.pinId) {
              networkId = [pin1Id, pin2Id].sort().join("_");
              break;
            }
          }
        }
        return {
          padId: pin.pinId,
          networkId,
          type: "rect",
          offset: pin.offset,
          size: { x: 1e-3, y: 1e-3 }
          // Small pad size
        };
      });
      pads.push({
        padId: `${chipId}-body`,
        networkId: chipId,
        type: "rect",
        offset: { x: 0, y: 0 },
        size: { x: chip.size.x, y: chip.size.y }
      });
      return {
        componentId: chipId,
        pads
      };
    }
  );
  const packResult = pack({
    components,
    minGap: 0.4,
    packOrderStrategy: "largest_to_smallest",
    packPlacementStrategy: "shortest_connection_along_outline"
  });
  const chipPlacements = {};
  for (const component of packResult.components) {
    chipPlacements[component.componentId] = {
      x: component.center.x,
      y: component.center.y,
      ccwRotationDegrees: component.ccwRotationOffset
    };
  }
  const outputLayout = {
    chipPlacements,
    groupPlacements: {}
    // No groups for now
  };
  cachedProblems.set(problemHash, outputLayout);
  return structuredClone(outputLayout);
}

// lib/solvers/ChipPartitionsSolver/ChipPartitionsSolver.ts
var ChipPartitionsSolver = class extends BaseSolver {
  inputProblem;
  partitions = [];
  decouplingCapGroups;
  constructor({
    inputProblem,
    decouplingCapGroups
  }) {
    super();
    this.inputProblem = inputProblem;
    this.decouplingCapGroups = decouplingCapGroups;
  }
  _step() {
    this.partitions = this.createPartitions(this.inputProblem);
    this.solved = true;
  }
  /**
   * Creates partitions by:
   * - Separating each decoupling capacitor group into its own partition (caps only, excluding the main chip)
   * - Partitioning remaining chips by connected components through strong pin connections
   */
  createPartitions(inputProblem) {
    const chipIds = Object.keys(inputProblem.chipMap);
    const decapChipIdSet = /* @__PURE__ */ new Set();
    const decapGroupPartitions = [];
    if (this.decouplingCapGroups && this.decouplingCapGroups.length > 0) {
      for (const group of this.decouplingCapGroups) {
        const capsOnly = [];
        for (const capId of group.decouplingCapChipIds) {
          if (inputProblem.chipMap[capId]) {
            capsOnly.push(capId);
          }
        }
        if (capsOnly.length >= 2) {
          decapGroupPartitions.push(capsOnly);
          for (const capId of capsOnly) {
            decapChipIdSet.add(capId);
          }
        }
      }
    }
    const nonDecapChipIds = chipIds.filter((id) => !decapChipIdSet.has(id));
    const adjacencyMap = /* @__PURE__ */ new Map();
    for (const chipId of nonDecapChipIds) {
      adjacencyMap.set(chipId, /* @__PURE__ */ new Set());
    }
    for (const [connKey, isConnected] of Object.entries(
      inputProblem.pinStrongConnMap
    )) {
      if (!isConnected) continue;
      const [pin1Id, pin2Id] = connKey.split("-");
      const owner1 = this.findPinOwner(pin1Id, inputProblem);
      const owner2 = this.findPinOwner(pin2Id, inputProblem);
      if (owner1 && owner2 && owner1 !== owner2 && !decapChipIdSet.has(owner1) && !decapChipIdSet.has(owner2)) {
        adjacencyMap.get(owner1).add(owner2);
        adjacencyMap.get(owner2).add(owner1);
      }
    }
    const visited = /* @__PURE__ */ new Set();
    const nonDecapPartitions = [];
    for (const componentId of nonDecapChipIds) {
      if (!visited.has(componentId)) {
        const partition = this.dfs(componentId, adjacencyMap, visited);
        if (partition.length > 0) {
          nonDecapPartitions.push(partition);
        }
      }
    }
    return [
      ...decapGroupPartitions.map(
        (partition) => this.createInputProblemFromPartition(partition, inputProblem, {
          partitionType: "decoupling_caps"
        })
      ),
      ...nonDecapPartitions.map(
        (partition) => this.createInputProblemFromPartition(partition, inputProblem)
      )
    ];
  }
  /**
   * Finds the owner chip of a given pin
   */
  findPinOwner(pinId, inputProblem) {
    const chipPin = inputProblem.chipPinMap[pinId];
    if (chipPin) {
      for (const [chipId, chip] of Object.entries(inputProblem.chipMap)) {
        if (chip.pins.includes(pinId)) {
          return chipId;
        }
      }
    }
    return null;
  }
  /**
   * Depth-first search to find connected components
   */
  dfs(startId, adjacencyMap, visited) {
    const partition = [];
    const stack = [startId];
    while (stack.length > 0) {
      const currentId = stack.pop();
      if (visited.has(currentId)) continue;
      visited.add(currentId);
      partition.push(currentId);
      const neighbors = adjacencyMap.get(currentId) || /* @__PURE__ */ new Set();
      for (const neighborId of neighbors) {
        if (!visited.has(neighborId)) {
          stack.push(neighborId);
        }
      }
    }
    return partition;
  }
  /**
   * Creates a new InputProblem containing only the components in the given partition
   */
  createInputProblemFromPartition(partition, originalProblem, opts) {
    const chipIds = partition;
    const relevantPinIds = /* @__PURE__ */ new Set();
    for (const chipId of chipIds) {
      const chip = originalProblem.chipMap[chipId];
      for (const pinId of chip.pins) {
        relevantPinIds.add(pinId);
      }
    }
    const chipMap = {};
    const chipPinMap = {};
    const netMap = {};
    const pinStrongConnMap = {};
    const netConnMap = {};
    for (const chipId of chipIds) {
      chipMap[chipId] = originalProblem.chipMap[chipId];
    }
    for (const pinId of relevantPinIds) {
      if (originalProblem.chipPinMap[pinId]) {
        chipPinMap[pinId] = originalProblem.chipPinMap[pinId];
      }
    }
    for (const [connKey, isConnected] of Object.entries(
      originalProblem.pinStrongConnMap
    )) {
      const [pin1Id, pin2Id] = connKey.split("-");
      if (relevantPinIds.has(pin1Id) && relevantPinIds.has(pin2Id)) {
        pinStrongConnMap[connKey] = isConnected;
      }
    }
    const relevantNetIds = /* @__PURE__ */ new Set();
    for (const [connKey, isConnected] of Object.entries(
      originalProblem.netConnMap
    )) {
      if (!isConnected) continue;
      const [pinId, netId] = connKey.split("-");
      if (relevantPinIds.has(pinId)) {
        relevantNetIds.add(netId);
        netConnMap[connKey] = isConnected;
      }
    }
    for (const netId of relevantNetIds) {
      if (originalProblem.netMap[netId]) {
        netMap[netId] = originalProblem.netMap[netId];
      }
    }
    return {
      ...originalProblem,
      chipMap,
      chipPinMap,
      netMap,
      pinStrongConnMap,
      netConnMap,
      isPartition: true,
      partitionType: opts?.partitionType
    };
  }
  visualize() {
    if (this.partitions.length === 0) {
      return super.visualize();
    }
    const partitionVisualizations = this.partitions.map((partition) => {
      const layout = doBasicInputProblemLayout(partition);
      return visualizeInputProblem(partition, layout);
    });
    const titles = this.partitions.map((_, index) => `partition${index}`);
    return stackGraphicsHorizontally(partitionVisualizations, { titles });
  }
};

// lib/utils/getColorFromString.ts
var getColorFromString = (string, alpha = 1) => {
  let hash = 0;
  for (let i = 0; i < string.length; i++) {
    const char = string.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return `hsl(${Math.abs(hash) % 360}, 70%, 50%, ${alpha})`;
};

// lib/solvers/IdentifyDecouplingCapsSolver/IdentifyDecouplingCapsSolver.ts
var IdentifyDecouplingCapsSolver = class extends BaseSolver {
  inputProblem;
  queuedChips;
  outputDecouplingCapGroups = [];
  /** Quick lookup of groups by main chip and net pair for accumulation */
  groupsByMainChipId = /* @__PURE__ */ new Map();
  constructor(inputProblem) {
    super();
    this.inputProblem = inputProblem;
    this.queuedChips = Object.values(inputProblem.chipMap);
  }
  /** Determine if chip is a 2-pin component with restricted rotation */
  isTwoPinRestrictedRotation(chip) {
    if (chip.pins.length !== 2) return false;
    if (!chip.availableRotations) return false;
    const allowed = /* @__PURE__ */ new Set([0, 180]);
    return chip.availableRotations.length > 0 && chip.availableRotations.every((r) => allowed.has(r));
  }
  /** Check that the two pins are on opposite Y sides (y+ and y-) */
  pinsOnOppositeYSides(chip) {
    if (chip.pins.length !== 2) return false;
    const [p1, p2] = chip.pins;
    const cp1 = this.inputProblem.chipPinMap[p1];
    const cp2 = this.inputProblem.chipPinMap[p2];
    if (!cp1 || !cp2) return false;
    const sides = /* @__PURE__ */ new Set([cp1.side, cp2.side]);
    return sides.has("y+") && sides.has("y-");
  }
  /** Get chips strongly connected (direct pin-to-pin) to this pin */
  getStronglyConnectedNeighborChips(pinId) {
    const neighbors = /* @__PURE__ */ new Set();
    for (const [connKey, connected] of Object.entries(
      this.inputProblem.pinStrongConnMap
    )) {
      if (!connected) continue;
      const [a, b] = connKey.split("-");
      if (a === pinId) {
        const otherChipId = b.split(".")[0];
        neighbors.add(otherChipId);
      } else if (b === pinId) {
        const otherChipId = a.split(".")[0];
        neighbors.add(otherChipId);
      }
    }
    return neighbors;
  }
  /** Find the main chip id for a decoupling capacitor candidate */
  findMainChipIdForCap(capChip) {
    const strongNeighbors = /* @__PURE__ */ new Map();
    for (const pinId of capChip.pins) {
      const neighbors = this.getStronglyConnectedNeighborChips(pinId);
      for (const n of neighbors) {
        if (n === capChip.chipId) continue;
        strongNeighbors.set(n, (strongNeighbors.get(n) || 0) + 1);
      }
    }
    if (strongNeighbors.size === 0) return null;
    let best = null;
    for (const [id, score] of strongNeighbors.entries()) {
      if (!best || score > best.score || score === best.score && id < best.id)
        best = { id, score };
    }
    return best ? best.id : null;
  }
  /** Get all net IDs connected to a pin */
  getNetIdsForPin(pinId) {
    const nets = /* @__PURE__ */ new Set();
    for (const [connKey, connected] of Object.entries(
      this.inputProblem.netConnMap
    )) {
      if (!connected) continue;
      const [p, n] = connKey.split("-");
      if (p === pinId) nets.add(n);
    }
    return nets;
  }
  /** Get a normalized, sorted pair of net IDs connected across the two pins of a capacitor chip */
  getNormalizedNetPair(capChip) {
    if (capChip.pins.length !== 2) return null;
    const nets = /* @__PURE__ */ new Set();
    for (const pinId of capChip.pins) {
      const pinNets = this.getNetIdsForPin(pinId);
      for (const n of pinNets) nets.add(n);
    }
    if (nets.size !== 2) return null;
    const [a, b] = Array.from(nets).sort();
    return [a, b];
  }
  /** Adds a decoupling capacitor to the group for the given main chip and net pair */
  addToGroup(mainChipId, netPair, capChipId) {
    const [n1, n2] = netPair;
    const groupKey = `${mainChipId}__${n1}__${n2}`;
    let group = this.groupsByMainChipId.get(groupKey);
    if (!group) {
      group = {
        decouplingCapGroupId: `decap_group_${mainChipId}__${n1}__${n2}`,
        mainChipId,
        netPair: [n1, n2],
        decouplingCapChipIds: []
      };
      this.groupsByMainChipId.set(groupKey, group);
      this.outputDecouplingCapGroups.push(group);
    }
    if (!group.decouplingCapChipIds.includes(capChipId)) {
      group.decouplingCapChipIds.push(capChipId);
    }
  }
  lastChip = null;
  _step() {
    const currentChip = this.queuedChips.shift();
    this.lastChip = currentChip ?? null;
    if (!currentChip) {
      this.solved = true;
      return;
    }
    const isDecouplingCap = this.isTwoPinRestrictedRotation(currentChip) && this.pinsOnOppositeYSides(currentChip);
    if (!isDecouplingCap) return;
    const mainChipId = this.findMainChipIdForCap(currentChip);
    if (!mainChipId) return;
    const netPair = this.getNormalizedNetPair(currentChip);
    if (!netPair) return;
    const [n1, n2] = netPair;
    const net1 = this.inputProblem.netMap[n1];
    const net2 = this.inputProblem.netMap[n2];
    const isDecouplingNetPair = net1?.isGround && net2?.isPositiveVoltageSource || net2?.isGround && net1?.isPositiveVoltageSource;
    if (!isDecouplingNetPair) return;
    this.addToGroup(mainChipId, netPair, currentChip.chipId);
  }
  visualize() {
    const basicLayout = doBasicInputProblemLayout(this.inputProblem);
    const graphics = visualizeInputProblem(
      this.inputProblem,
      basicLayout
    );
    const chipDecapGroupMap = /* @__PURE__ */ new Map();
    for (const group of this.outputDecouplingCapGroups) {
      chipDecapGroupMap.set(group.mainChipId, group);
      for (const capChipId of group.decouplingCapChipIds) {
        chipDecapGroupMap.set(capChipId, group);
      }
    }
    for (const rect of graphics.rects || []) {
      if (rect.label !== this.lastChip?.chipId) {
        rect.fill = "rgba(0,0,0,0.5)";
      }
    }
    for (const rect of graphics.rects || []) {
      const chipId = rect.label;
      const group = chipDecapGroupMap.get(chipId);
      if (!group) continue;
      rect.label = `${rect.label}
${group.decouplingCapGroupId}`;
      rect.fill = getColorFromString(group.decouplingCapGroupId, 0.8);
    }
    return graphics;
  }
  getConstructorParams() {
    return [this.inputProblem];
  }
  computeProgress() {
    const total = Object.keys(this.inputProblem.chipMap).length || 1;
    const processed = total - this.queuedChips.length;
    return Math.min(1, Math.max(0, processed / total));
  }
};

// lib/solvers/PackInnerPartitionsSolver/SingleInnerPartitionPackingSolver.ts
import { PackSolver2 } from "calculate-packing";

// lib/utils/networkFiltering.ts
function createFilteredNetworkMapping(params) {
  const { inputProblem, pinIdToStronglyConnectedPins } = params;
  const pinToNetworkMap = /* @__PURE__ */ new Map();
  const filteredPins = /* @__PURE__ */ new Set();
  let hasStrongConnections = false;
  const strongConnectedChipSides = /* @__PURE__ */ new Map();
  for (const [connKey, connected] of Object.entries(
    inputProblem.pinStrongConnMap
  )) {
    if (!connected) continue;
    hasStrongConnections = true;
    const pins = connKey.split("-");
    if (pins.length === 2 && pins[0] && pins[1]) {
      const pin1 = inputProblem.chipPinMap[pins[0]];
      const pin2 = inputProblem.chipPinMap[pins[1]];
      if (pin1 && pin2) {
        const chip1Id = pins[0].split(".")[0];
        const chip2Id = pins[1].split(".")[0];
        if (chip1Id && chip2Id && chip1Id !== chip2Id) {
          const key1 = `${chip1Id}-${chip2Id}`;
          const key2 = `${chip2Id}-${chip1Id}`;
          if (!strongConnectedChipSides.has(key1)) {
            strongConnectedChipSides.set(key1, /* @__PURE__ */ new Set());
          }
          if (!strongConnectedChipSides.has(key2)) {
            strongConnectedChipSides.set(key2, /* @__PURE__ */ new Set());
          }
          strongConnectedChipSides.get(key1).add(pin1.side);
          strongConnectedChipSides.get(key2).add(pin2.side);
        }
      }
    }
  }
  if (hasStrongConnections) {
    for (const [connKey, connected] of Object.entries(
      inputProblem.netConnMap
    )) {
      if (!connected) continue;
      const [pinId, netId] = connKey.split("-");
      if (pinId && netId) {
        filteredPins.add(pinId);
      }
    }
  } else {
    for (const [connKey, connected] of Object.entries(
      inputProblem.netConnMap
    )) {
      if (!connected) continue;
      const [pinId, netId] = connKey.split("-");
      if (pinId && netId) {
        const pin = inputProblem.chipPinMap[pinId];
        if (!pin) continue;
        const chipId = pinId.split(".")[0];
        let shouldIncludeInNetwork = true;
        for (const [
          strongKey,
          strongSides
        ] of strongConnectedChipSides.entries()) {
          const [fromChip, toChip] = strongKey.split("-");
          if (fromChip === chipId) {
            for (const [otherConnKey, otherConnected] of Object.entries(
              inputProblem.netConnMap
            )) {
              if (!otherConnected) continue;
              const [otherPinId, otherNetId] = otherConnKey.split("-");
              if (otherNetId === netId && otherPinId && otherPinId !== pinId) {
                const otherPin = inputProblem.chipPinMap[otherPinId];
                if (!otherPin) continue;
                const otherChipId = otherPinId.split(".")[0];
                if (otherChipId === toChip) {
                  if (!strongSides.has(otherPin.side)) {
                    shouldIncludeInNetwork = false;
                    break;
                  }
                }
              }
            }
          }
        }
        if (shouldIncludeInNetwork) {
          pinToNetworkMap.set(pinId, netId);
        } else {
          const disconnectedNetworkId = `${pinId}_opposite-strong-side-disconnected`;
          pinToNetworkMap.set(pinId, disconnectedNetworkId);
          filteredPins.add(pinId);
        }
      }
    }
  }
  for (const [connKey, connected] of Object.entries(
    inputProblem.pinStrongConnMap
  )) {
    if (!connected) continue;
    const pins = connKey.split("-");
    if (pins.length === 2 && pins[0] && pins[1]) {
      const existingNet = pinToNetworkMap.get(pins[0]) || pinToNetworkMap.get(pins[1]);
      if (existingNet) {
        pinToNetworkMap.set(pins[0], existingNet);
        pinToNetworkMap.set(pins[1], existingNet);
      } else {
        pinToNetworkMap.set(pins[0], connKey);
        pinToNetworkMap.set(pins[1], connKey);
      }
    }
  }
  return {
    pinToNetworkMap,
    filteredPins
  };
}

// lib/solvers/PackInnerPartitionsSolver/getPadsBoundingBox.ts
var getPadsBoundingBox = (pads) => {
  const xs = pads.flatMap((p) => [
    p.offset.x - p.size.x / 2,
    p.offset.x + p.size.x / 2
  ]);
  const ys = pads.flatMap((p) => [
    p.offset.y - p.size.y / 2,
    p.offset.y + p.size.y / 2
  ]);
  const minX = xs.length ? Math.min(...xs) : 0;
  const maxX = xs.length ? Math.max(...xs) : 0;
  const minY = ys.length ? Math.min(...ys) : 0;
  const maxY = ys.length ? Math.max(...ys) : 0;
  return { minX, maxX, minY, maxY };
};

// lib/solvers/PackInnerPartitionsSolver/SingleInnerPartitionPackingSolver.ts
var PIN_SIZE = 0.1;
var SingleInnerPartitionPackingSolver = class extends BaseSolver {
  partitionInputProblem;
  layout = null;
  pinIdToStronglyConnectedPins;
  constructor(params) {
    super();
    this.partitionInputProblem = params.partitionInputProblem;
    this.pinIdToStronglyConnectedPins = params.pinIdToStronglyConnectedPins;
  }
  _step() {
    if (!this.activeSubSolver) {
      const packInput = this.createPackInput();
      this.activeSubSolver = new PackSolver2(packInput);
      this.activeSubSolver = this.activeSubSolver;
    }
    this.activeSubSolver.step();
    if (this.activeSubSolver.failed) {
      this.failed = true;
      this.error = `PackSolver2 failed: ${this.activeSubSolver.error}`;
      return;
    }
    if (this.activeSubSolver.solved) {
      this.layout = this.createLayoutFromPackingResult(
        this.activeSubSolver.packedComponents
      );
      this.solved = true;
      this.activeSubSolver = null;
    }
  }
  createPackInput() {
    const pinToNetworkMap = createFilteredNetworkMapping({
      inputProblem: this.partitionInputProblem,
      pinIdToStronglyConnectedPins: this.pinIdToStronglyConnectedPins
    }).pinToNetworkMap;
    const packComponents = Object.entries(
      this.partitionInputProblem.chipMap
    ).map(([chipId, chip]) => {
      const pads = [];
      for (const pinId of chip.pins) {
        const pin = this.partitionInputProblem.chipPinMap[pinId];
        if (!pin) continue;
        const networkId = pinToNetworkMap.get(pinId) || `${pinId}_isolated`;
        pads.push({
          padId: pinId,
          networkId,
          type: "rect",
          offset: { x: pin.offset.x, y: pin.offset.y },
          size: { x: PIN_SIZE, y: PIN_SIZE }
          // Small size for pins
        });
      }
      const padsBoundingBox = getPadsBoundingBox(pads);
      const padsBoundingBoxSize = {
        x: padsBoundingBox.maxX - padsBoundingBox.minX,
        y: padsBoundingBox.maxY - padsBoundingBox.minY
      };
      pads.push({
        padId: `${chipId}_body`,
        networkId: `${chipId}_body_disconnected`,
        type: "rect",
        offset: { x: 0, y: 0 },
        size: {
          x: Math.max(padsBoundingBoxSize.x, chip.size.x),
          y: Math.max(padsBoundingBoxSize.y, chip.size.y)
        }
      });
      return {
        componentId: chipId,
        pads,
        availableRotationDegrees: chip.availableRotations || [0, 90, 180, 270]
      };
    });
    let minGap = this.partitionInputProblem.chipGap;
    if (this.partitionInputProblem.partitionType === "decoupling_caps") {
      minGap = this.partitionInputProblem.decouplingCapsGap ?? minGap;
    }
    return {
      components: packComponents,
      minGap,
      packOrderStrategy: "largest_to_smallest",
      packPlacementStrategy: "minimum_closest_sum_squared_distance"
    };
  }
  createLayoutFromPackingResult(packedComponents) {
    const chipPlacements = {};
    for (const packedComponent of packedComponents) {
      const chipId = packedComponent.componentId;
      chipPlacements[chipId] = {
        x: packedComponent.center.x,
        y: packedComponent.center.y,
        ccwRotationDegrees: packedComponent.ccwRotationOffset || packedComponent.ccwRotationDegrees || 0
      };
    }
    return {
      chipPlacements,
      groupPlacements: {}
    };
  }
  visualize() {
    if (this.activeSubSolver && !this.solved) {
      return this.activeSubSolver.visualize();
    }
    if (!this.layout) {
      const basicLayout = doBasicInputProblemLayout(this.partitionInputProblem);
      return visualizeInputProblem(this.partitionInputProblem, basicLayout);
    }
    return visualizeInputProblem(this.partitionInputProblem, this.layout);
  }
  getConstructorParams() {
    return [this.partitionInputProblem];
  }
};

// lib/solvers/PackInnerPartitionsSolver/PackInnerPartitionsSolver.ts
import { stackGraphicsHorizontally as stackGraphicsHorizontally2 } from "graphics-debug";
var PackInnerPartitionsSolver = class extends BaseSolver {
  partitions;
  packedPartitions = [];
  completedSolvers = [];
  activeSolver = null;
  currentPartitionIndex = 0;
  pinIdToStronglyConnectedPins;
  constructor(params) {
    super();
    this.partitions = params.partitions;
    this.pinIdToStronglyConnectedPins = params.pinIdToStronglyConnectedPins;
  }
  _step() {
    if (this.currentPartitionIndex >= this.partitions.length) {
      this.solved = true;
      return;
    }
    if (!this.activeSolver) {
      const currentPartition = this.partitions[this.currentPartitionIndex];
      this.activeSolver = new SingleInnerPartitionPackingSolver({
        partitionInputProblem: currentPartition,
        pinIdToStronglyConnectedPins: this.pinIdToStronglyConnectedPins
      });
      this.activeSubSolver = this.activeSolver;
    }
    this.activeSolver.step();
    if (this.activeSolver.failed) {
      this.failed = true;
      this.error = `Partition ${this.currentPartitionIndex} failed: ${this.activeSolver.error}`;
      return;
    }
    if (this.activeSolver.solved) {
      this.completedSolvers.push(this.activeSolver);
      if (this.activeSolver.layout) {
        this.packedPartitions.push({
          inputProblem: this.partitions[this.currentPartitionIndex],
          layout: this.activeSolver.layout
        });
      } else {
        this.failed = true;
        this.error = `Partition ${this.currentPartitionIndex} completed but has no layout`;
        return;
      }
      this.activeSolver = null;
      this.activeSubSolver = null;
      this.currentPartitionIndex++;
    }
  }
  visualize() {
    if (this.activeSolver) {
      return this.activeSolver.visualize();
    }
    if (this.completedSolvers.length === 0) {
      return super.visualize();
    }
    const partitionVisualizations = this.completedSolvers.map(
      (solver) => solver.visualize()
    );
    const titles = this.completedSolvers.map(
      (_, index) => `packed_partition_${index}`
    );
    return stackGraphicsHorizontally2(partitionVisualizations, { titles });
  }
  getConstructorParams() {
    return [this.partitions];
  }
};

// lib/solvers/PartitionPackingSolver/PartitionPackingSolver.ts
import { PackSolver2 as PackSolver22 } from "calculate-packing";
var PartitionPackingSolver = class extends BaseSolver {
  packedPartitions;
  inputProblem;
  finalLayout = null;
  packSolver2 = null;
  constructor(input) {
    super();
    this.packedPartitions = input.packedPartitions;
    this.inputProblem = input.inputProblem;
  }
  _step() {
    try {
      if (this.packedPartitions.length === 0) {
        this.finalLayout = {
          chipPlacements: {},
          groupPlacements: {}
        };
        this.solved = true;
        return;
      }
      if (this.packedPartitions.length === 1) {
        this.finalLayout = this.packedPartitions[0].layout;
        this.solved = true;
        return;
      }
      const partitionGroups = this.organizePackedPartitions();
      if (!this.packSolver2) {
        const packInput = this.createPackInput(partitionGroups);
        this.packSolver2 = new PackSolver22(packInput);
        this.activeSubSolver = this.packSolver2;
      }
      this.packSolver2.step();
      if (this.packSolver2.failed) {
        this.failed = true;
        this.error = `PackSolver2 failed: ${this.packSolver2.error}`;
        return;
      }
      if (this.packSolver2.solved) {
        const packedLayout = this.applyPackingResult(
          this.packSolver2.packedComponents,
          partitionGroups
        );
        this.finalLayout = packedLayout;
        this.solved = true;
        this.activeSubSolver = null;
      }
    } catch (error) {
      this.failed = true;
      this.error = `Failed to pack partitions: ${error}`;
    }
  }
  organizePackedPartitions() {
    const partitionGroups = [];
    for (let i = 0; i < this.packedPartitions.length; i++) {
      const packedPartition = this.packedPartitions[i];
      const partitionChipIds = Object.keys(
        packedPartition.layout.chipPlacements
      );
      if (partitionChipIds.length > 0) {
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (const chipId of partitionChipIds) {
          const placement = packedPartition.layout.chipPlacements[chipId];
          const chip = packedPartition.inputProblem.chipMap[chipId];
          let chipWidth = chip.size.x;
          let chipHeight = chip.size.y;
          if (placement.ccwRotationDegrees === 90 || placement.ccwRotationDegrees === 270) {
            ;
            [chipWidth, chipHeight] = [chipHeight, chipWidth];
          }
          const chipMinX = placement.x - chipWidth / 2;
          const chipMaxX = placement.x + chipWidth / 2;
          const chipMinY = placement.y - chipHeight / 2;
          const chipMaxY = placement.y + chipHeight / 2;
          minX = Math.min(minX, chipMinX);
          maxX = Math.max(maxX, chipMaxX);
          minY = Math.min(minY, chipMinY);
          maxY = Math.max(maxY, chipMaxY);
        }
        const bounds = { minX, maxX, minY, maxY };
        partitionGroups.push({
          partitionIndex: i,
          chipIds: partitionChipIds,
          bounds
        });
      }
    }
    return partitionGroups;
  }
  createPackInput(partitionGroups) {
    const pinToNetworkMap = /* @__PURE__ */ new Map();
    for (const packedPartition of this.packedPartitions) {
      for (const [connKey, connected] of Object.entries(
        packedPartition.inputProblem.netConnMap
      )) {
        if (!connected) continue;
        const [pinId, netId] = connKey.split("-");
        if (pinId && netId) {
          pinToNetworkMap.set(pinId, netId);
        }
      }
      for (const [connKey, connected] of Object.entries(
        packedPartition.inputProblem.pinStrongConnMap
      )) {
        if (!connected) continue;
        const pins = connKey.split("-");
        if (pins.length === 2 && pins[0] && pins[1]) {
          const existingNet = pinToNetworkMap.get(pins[0]) || pinToNetworkMap.get(pins[1]);
          if (existingNet) {
            pinToNetworkMap.set(pins[0], existingNet);
            pinToNetworkMap.set(pins[1], existingNet);
          } else {
            pinToNetworkMap.set(pins[0], connKey);
            pinToNetworkMap.set(pins[1], connKey);
          }
        }
      }
    }
    const packComponents = partitionGroups.map((group) => {
      const packedPartition = this.packedPartitions[group.partitionIndex];
      const partitionWidth = group.bounds.maxX - group.bounds.minX;
      const partitionHeight = group.bounds.maxY - group.bounds.minY;
      const centerX = (group.bounds.minX + group.bounds.maxX) / 2;
      const centerY = (group.bounds.minY + group.bounds.maxY) / 2;
      const pads = [
        {
          padId: `partition_${group.partitionIndex}_body`,
          networkId: `partition_${group.partitionIndex}_disconnected`,
          type: "rect",
          offset: { x: 0, y: 0 },
          size: {
            x: Math.max(partitionWidth, 0.1),
            y: Math.max(partitionHeight, 0.1)
          }
        }
      ];
      const addedNetworks = /* @__PURE__ */ new Set();
      const pinPositions = /* @__PURE__ */ new Map();
      for (const chipId of group.chipIds) {
        const chipPlacement = packedPartition.layout.chipPlacements[chipId];
        const chip = packedPartition.inputProblem.chipMap[chipId];
        for (const pinId of chip.pins) {
          const chipPin = packedPartition.inputProblem.chipPinMap[pinId];
          if (!chipPin) continue;
          let transformedOffset = { x: chipPin.offset.x, y: chipPin.offset.y };
          const rotation = chipPlacement.ccwRotationDegrees || 0;
          if (rotation === 90) {
            transformedOffset = { x: -chipPin.offset.y, y: chipPin.offset.x };
          } else if (rotation === 180) {
            transformedOffset = { x: -chipPin.offset.x, y: -chipPin.offset.y };
          } else if (rotation === 270) {
            transformedOffset = { x: chipPin.offset.y, y: -chipPin.offset.x };
          }
          const absolutePinX = chipPlacement.x + transformedOffset.x;
          const absolutePinY = chipPlacement.y + transformedOffset.y;
          pinPositions.set(pinId, { x: absolutePinX, y: absolutePinY });
          const networkId = pinToNetworkMap.get(pinId) || `${pinId}_disconnected`;
          if (!addedNetworks.has(networkId)) {
            addedNetworks.add(networkId);
            const padOffsetX = absolutePinX - centerX;
            const padOffsetY = absolutePinY - centerY;
            pads.push({
              padId: `${group.partitionIndex}_pin_${pinId}`,
              networkId,
              type: "rect",
              offset: { x: padOffsetX, y: padOffsetY },
              size: { x: 0.01, y: 0.01 }
              // Small pin pad
            });
          }
        }
      }
      return {
        componentId: `partition_${group.partitionIndex}`,
        pads,
        availableRotationDegrees: [0]
        // Keep partitions unrotated
      };
    });
    return {
      components: packComponents,
      minGap: this.inputProblem.partitionGap,
      // Use partitionGap from input problem
      packOrderStrategy: "largest_to_smallest",
      packPlacementStrategy: "minimum_sum_squared_distance_to_network"
    };
  }
  applyPackingResult(packedComponents, partitionGroups) {
    const newChipPlacements = {};
    for (const packedComponent of packedComponents) {
      const partitionIndex = parseInt(
        packedComponent.componentId.replace("partition_", "")
      );
      const group = partitionGroups.find(
        (g) => g.partitionIndex === partitionIndex
      );
      const packedPartition = this.packedPartitions[partitionIndex];
      if (group && packedPartition) {
        const currentCenterX = (group.bounds.minX + group.bounds.maxX) / 2;
        const currentCenterY = (group.bounds.minY + group.bounds.maxY) / 2;
        const newCenterX = packedComponent.center.x;
        const newCenterY = packedComponent.center.y;
        const offsetX = newCenterX - currentCenterX;
        const offsetY = newCenterY - currentCenterY;
        for (const chipId of group.chipIds) {
          const originalPlacement = packedPartition.layout.chipPlacements[chipId];
          newChipPlacements[chipId] = {
            x: originalPlacement.x + offsetX,
            y: originalPlacement.y + offsetY,
            ccwRotationDegrees: originalPlacement.ccwRotationDegrees
          };
        }
      }
    }
    return {
      chipPlacements: newChipPlacements,
      groupPlacements: {}
    };
  }
  visualize() {
    if (this.packSolver2 && !this.solved) {
      return this.packSolver2.visualize();
    }
    if (!this.finalLayout) {
      return super.visualize();
    }
    const combinedProblem = {
      chipMap: {},
      chipPinMap: {},
      pinStrongConnMap: {},
      netMap: {},
      netConnMap: {},
      chipGap: this.inputProblem.chipGap,
      partitionGap: this.inputProblem.partitionGap
    };
    for (const packedPartition of this.packedPartitions) {
      Object.assign(
        combinedProblem.chipMap,
        packedPartition.inputProblem.chipMap
      );
      Object.assign(
        combinedProblem.chipPinMap,
        packedPartition.inputProblem.chipPinMap
      );
      Object.assign(
        combinedProblem.pinStrongConnMap,
        packedPartition.inputProblem.pinStrongConnMap
      );
      Object.assign(combinedProblem.netMap, packedPartition.inputProblem.netMap);
      Object.assign(
        combinedProblem.netConnMap,
        packedPartition.inputProblem.netConnMap
      );
    }
    return visualizeInputProblem(combinedProblem, this.finalLayout);
  }
  getConstructorParams() {
    return {
      packedPartitions: this.packedPartitions,
      inputProblem: this.inputProblem
    };
  }
};

// lib/solvers/LayoutPipelineSolver/getPinIdToStronglyConnectedPinsObj.ts
var getPinIdToStronglyConnectedPinsObj = (inputProblem) => {
  const pinIdToStronglyConnectedPins = {};
  const pinIds = Object.keys(inputProblem.chipPinMap);
  for (let i = 0; i < pinIds.length; i++) {
    for (let j = i + 1; j < pinIds.length; j++) {
      const pinId1 = pinIds[i];
      const pinId2 = pinIds[j];
      if (inputProblem.pinStrongConnMap[`${pinId1}-${pinId2}`] || inputProblem.pinStrongConnMap[`${pinId2}-${pinId1}`]) {
        pinIdToStronglyConnectedPins[pinId1] ??= [];
        pinIdToStronglyConnectedPins[pinId2] ??= [];
        pinIdToStronglyConnectedPins[pinId1].push(
          inputProblem.chipPinMap[pinId2]
        );
        pinIdToStronglyConnectedPins[pinId2].push(
          inputProblem.chipPinMap[pinId1]
        );
      }
    }
  }
  return pinIdToStronglyConnectedPins;
};

// lib/solvers/LayoutPipelineSolver/LayoutPipelineSolver.ts
function definePipelineStep(solverName, solverClass, getConstructorParams, opts = {}) {
  return {
    solverName,
    solverClass,
    getConstructorParams,
    onSolved: opts.onSolved
  };
}
var LayoutPipelineSolver = class extends BaseSolver {
  identifyDecouplingCapsSolver;
  chipPartitionsSolver;
  packInnerPartitionsSolver;
  partitionPackingSolver;
  startTimeOfPhase;
  endTimeOfPhase;
  timeSpentOnPhase;
  firstIterationOfPhase;
  // Computed utility objects
  pinIdToStronglyConnectedPins;
  inputProblem;
  chipPartitions;
  packedPartitions;
  pipelineDef = [
    definePipelineStep(
      "identifyDecouplingCapsSolver",
      IdentifyDecouplingCapsSolver,
      () => [this.inputProblem],
      {
        onSolved: (_layoutSolver) => {
        }
      }
    ),
    definePipelineStep(
      "chipPartitionsSolver",
      ChipPartitionsSolver,
      () => [
        {
          inputProblem: this.inputProblem,
          decouplingCapGroups: this.identifyDecouplingCapsSolver?.outputDecouplingCapGroups
        }
      ],
      {
        onSolved: (_layoutSolver) => {
          this.chipPartitions = this.chipPartitionsSolver.partitions;
        }
      }
    ),
    definePipelineStep(
      "packInnerPartitionsSolver",
      PackInnerPartitionsSolver,
      () => [
        {
          partitions: this.chipPartitions,
          pinIdToStronglyConnectedPins: this.pinIdToStronglyConnectedPins
        }
      ],
      {
        onSolved: (_solver) => {
          this.packedPartitions = this.packInnerPartitionsSolver.packedPartitions;
        }
      }
    ),
    definePipelineStep(
      "partitionPackingSolver",
      PartitionPackingSolver,
      () => [
        {
          packedPartitions: this.packedPartitions || [],
          inputProblem: this.inputProblem
        }
      ],
      {
        onSolved: (_solver) => {
        }
      }
    )
  ];
  constructor(inputProblem) {
    super();
    this.inputProblem = inputProblem;
    this.MAX_ITERATIONS = 1e6;
    this.startTimeOfPhase = {};
    this.endTimeOfPhase = {};
    this.timeSpentOnPhase = {};
    this.firstIterationOfPhase = {};
    this.pinIdToStronglyConnectedPins = getPinIdToStronglyConnectedPinsObj(inputProblem);
  }
  currentPipelineStepIndex = 0;
  _step() {
    const pipelineStepDef = this.pipelineDef[this.currentPipelineStepIndex];
    if (!pipelineStepDef) {
      this.solved = true;
      return;
    }
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      if (this.activeSubSolver.solved) {
        this.endTimeOfPhase[pipelineStepDef.solverName] = performance.now();
        this.timeSpentOnPhase[pipelineStepDef.solverName] = this.endTimeOfPhase[pipelineStepDef.solverName] - this.startTimeOfPhase[pipelineStepDef.solverName];
        pipelineStepDef.onSolved?.(this);
        this.activeSubSolver = null;
        this.currentPipelineStepIndex++;
      } else if (this.activeSubSolver.failed) {
        this.error = this.activeSubSolver?.error;
        this.failed = true;
        this.activeSubSolver = null;
      }
      return;
    }
    const constructorParams = pipelineStepDef.getConstructorParams(this);
    this.activeSubSolver = new pipelineStepDef.solverClass(...constructorParams);
    this[pipelineStepDef.solverName] = this.activeSubSolver;
    this.timeSpentOnPhase[pipelineStepDef.solverName] = 0;
    this.startTimeOfPhase[pipelineStepDef.solverName] = performance.now();
    this.firstIterationOfPhase[pipelineStepDef.solverName] = this.iterations;
  }
  solveUntilPhase(phase) {
    while (this.getCurrentPhase() !== phase) {
      this.step();
    }
  }
  getCurrentPhase() {
    return this.pipelineDef[this.currentPipelineStepIndex]?.solverName ?? "none";
  }
  visualize() {
    if (!this.solved && this.activeSubSolver)
      return this.activeSubSolver.visualize();
    if (this.solved && this.partitionPackingSolver?.solved) {
      return this.partitionPackingSolver.visualize();
    }
    const identifyDecouplingCapsViz = this.identifyDecouplingCapsSolver?.visualize();
    const chipPartitionsViz = this.chipPartitionsSolver?.visualize();
    const packInnerPartitionsViz = this.packInnerPartitionsSolver?.visualize();
    const partitionPackingViz = this.partitionPackingSolver?.visualize();
    const basicLayout = doBasicInputProblemLayout(this.inputProblem);
    const inputViz = visualizeInputProblem(this.inputProblem, basicLayout);
    const visualizations = [
      inputViz,
      identifyDecouplingCapsViz,
      chipPartitionsViz,
      packInnerPartitionsViz,
      partitionPackingViz
    ].filter(Boolean).map((viz, stepIndex) => {
      for (const rect of viz.rects ?? []) {
        rect.step = stepIndex;
      }
      for (const point of viz.points ?? []) {
        point.step = stepIndex;
      }
      for (const circle of viz.circles ?? []) {
        circle.step = stepIndex;
      }
      for (const text of viz.texts ?? []) {
        text.step = stepIndex;
      }
      for (const line of viz.lines ?? []) {
        line.step = stepIndex;
      }
      return viz;
    });
    if (visualizations.length === 1) return visualizations[0];
    return {
      points: visualizations.flatMap((v) => v.points || []),
      rects: visualizations.flatMap((v) => v.rects || []),
      lines: visualizations.flatMap((v) => v.lines || []),
      circles: visualizations.flatMap((v) => v.circles || []),
      texts: visualizations.flatMap((v) => v.texts || [])
    };
  }
  /**
   * A lightweight version of the visualize method that can be used to stream
   * progress
   */
  preview() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.preview();
    }
    if (this.partitionPackingSolver?.solved) {
      return this.partitionPackingSolver.visualize();
    }
    if (this.packInnerPartitionsSolver?.solved) {
      return this.packInnerPartitionsSolver.visualize();
    }
    if (this.chipPartitionsSolver?.solved) {
      return this.chipPartitionsSolver.visualize();
    }
    if (this.identifyDecouplingCapsSolver?.solved) {
      return this.identifyDecouplingCapsSolver.visualize();
    }
    return super.preview();
  }
  /**
   * Checks if any chips are overlapping in the given layout, considering rotation.
   * Returns an array of overlapping chip pairs.
   */
  checkForOverlaps(layout) {
    const overlaps = [];
    const chipIds = Object.keys(layout.chipPlacements);
    for (let i = 0; i < chipIds.length; i++) {
      for (let j = i + 1; j < chipIds.length; j++) {
        const chip1Id = chipIds[i];
        const chip2Id = chipIds[j];
        const placement1 = layout.chipPlacements[chip1Id];
        const placement2 = layout.chipPlacements[chip2Id];
        const chip1 = this.inputProblem.chipMap[chip1Id];
        const chip2 = this.inputProblem.chipMap[chip2Id];
        if (!chip1 || !chip2) continue;
        const bounds1 = this.getRotatedBounds(placement1, chip1.size);
        const bounds2 = this.getRotatedBounds(placement2, chip2.size);
        const overlapArea = this.calculateOverlapArea(bounds1, bounds2);
        if (overlapArea > 0) {
          overlaps.push({
            chip1: chip1Id,
            chip2: chip2Id,
            overlapArea
          });
        }
      }
    }
    return overlaps;
  }
  /**
   * Calculate the axis-aligned bounding box for a rotated chip
   */
  getRotatedBounds(placement, size) {
    const halfWidth = size.x / 2;
    const halfHeight = size.y / 2;
    const angleRad = placement.ccwRotationDegrees * Math.PI / 180;
    const cos = Math.abs(Math.cos(angleRad));
    const sin = Math.abs(Math.sin(angleRad));
    const rotatedWidth = halfWidth * cos + halfHeight * sin;
    const rotatedHeight = halfWidth * sin + halfHeight * cos;
    return {
      minX: placement.x - rotatedWidth,
      maxX: placement.x + rotatedWidth,
      minY: placement.y - rotatedHeight,
      maxY: placement.y + rotatedHeight
    };
  }
  /**
   * Calculate the overlap area between two axis-aligned bounding boxes
   */
  calculateOverlapArea(bounds1, bounds2) {
    if (bounds1.maxX <= bounds2.minX || bounds1.minX >= bounds2.maxX || bounds1.maxY <= bounds2.minY || bounds1.minY >= bounds2.maxY) {
      return 0;
    }
    const overlapWidth = Math.min(bounds1.maxX, bounds2.maxX) - Math.max(bounds1.minX, bounds2.minX);
    const overlapHeight = Math.min(bounds1.maxY, bounds2.maxY) - Math.max(bounds1.minY, bounds2.minY);
    return overlapWidth * overlapHeight;
  }
  getOutputLayout() {
    if (!this.solved) {
      throw new Error(
        "Pipeline not solved yet. Call solve() or step() until solved."
      );
    }
    let finalLayout;
    if (this.partitionPackingSolver?.solved && this.partitionPackingSolver.finalLayout) {
      finalLayout = this.partitionPackingSolver.finalLayout;
    } else {
      throw new Error(
        "No layout available. Pipeline may have failed or not progressed far enough."
      );
    }
    const overlaps = this.checkForOverlaps(finalLayout);
    if (overlaps.length > 0) {
      const overlapDetails = overlaps.map(
        (overlap) => `${overlap.chip1} overlaps ${overlap.chip2} (area: ${overlap.overlapArea.toFixed(4)})`
      ).join(", ");
      console.warn(
        `Warning: ${overlaps.length} chip overlaps detected in final layout: ${overlapDetails}`
      );
    }
    return finalLayout;
  }
};
export {
  LayoutPipelineSolver
};
