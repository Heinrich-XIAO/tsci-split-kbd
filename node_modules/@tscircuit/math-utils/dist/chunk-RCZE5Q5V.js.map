{"version":3,"sources":["../src/polygon.ts"],"sourcesContent":["import type { Bounds, Point, UniversalRect } from \"./common\"\nimport { doSegmentsIntersect } from \"./line-intersections\"\n\nexport type Polygon = readonly Point[]\n\nconst universalRectToBounds = (rect: UniversalRect): Bounds => {\n  if (\"minX\" in rect) {\n    return rect\n  }\n\n  const halfWidth = rect.width / 2\n  const halfHeight = rect.height / 2\n\n  return {\n    minX: rect.center.x - halfWidth,\n    minY: rect.center.y - halfHeight,\n    maxX: rect.center.x + halfWidth,\n    maxY: rect.center.y + halfHeight,\n  }\n}\n\nconst getBoundsCorners = (bounds: Bounds): Point[] => [\n  { x: bounds.minX, y: bounds.minY },\n  { x: bounds.maxX, y: bounds.minY },\n  { x: bounds.maxX, y: bounds.maxY },\n  { x: bounds.minX, y: bounds.maxY },\n]\n\nconst getPolygonEdges = (polygon: Polygon): Array<[Point, Point]> => {\n  const edges: Array<[Point, Point]> = []\n  for (let i = 0; i < polygon.length; i++) {\n    const start = polygon[i]\n    const end = polygon[(i + 1) % polygon.length]\n    edges.push([start, end])\n  }\n  return edges\n}\n\nconst isPointOnSegment = (point: Point, start: Point, end: Point): boolean => {\n  const cross =\n    (point.y - start.y) * (end.x - start.x) -\n    (point.x - start.x) * (end.y - start.y)\n  if (Math.abs(cross) > 1e-9) {\n    return false\n  }\n\n  const dot =\n    (point.x - start.x) * (end.x - start.x) +\n    (point.y - start.y) * (end.y - start.y)\n  if (dot < 0) {\n    return false\n  }\n\n  const squaredLength = (end.x - start.x) ** 2 + (end.y - start.y) ** 2\n  if (dot > squaredLength) {\n    return false\n  }\n\n  return true\n}\n\nconst isPointInsideBounds = (point: Point, bounds: Bounds): boolean =>\n  point.x >= bounds.minX &&\n  point.x <= bounds.maxX &&\n  point.y >= bounds.minY &&\n  point.y <= bounds.maxY\n\nexport const isPointInsidePolygon = (\n  point: Point,\n  polygon: Polygon,\n): boolean => {\n  if (polygon.length < 3) return false\n\n  const edges = getPolygonEdges(polygon)\n  for (const [start, end] of edges) {\n    if (isPointOnSegment(point, start, end)) {\n      return true\n    }\n  }\n\n  let inside = false\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x\n    const yi = polygon[i].y\n    const xj = polygon[j].x\n    const yj = polygon[j].y\n\n    const intersects =\n      yi > point.y !== yj > point.y &&\n      point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi\n\n    if (intersects) {\n      inside = !inside\n    }\n  }\n\n  return inside\n}\n\nconst doesPolygonIntersectBounds = (\n  bounds: Bounds,\n  polygon: Polygon,\n): boolean => {\n  const boundsCorners = getBoundsCorners(bounds)\n  const boundsEdges: Array<[Point, Point]> = [\n    [boundsCorners[0], boundsCorners[1]],\n    [boundsCorners[1], boundsCorners[2]],\n    [boundsCorners[2], boundsCorners[3]],\n    [boundsCorners[3], boundsCorners[0]],\n  ]\n\n  const polygonEdges = getPolygonEdges(polygon)\n\n  for (const [start, end] of polygonEdges) {\n    for (const [rectStart, rectEnd] of boundsEdges) {\n      if (doSegmentsIntersect(start, end, rectStart, rectEnd)) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nexport const areBoundsOverlappingPolygon = (\n  bounds: Bounds,\n  polygon: Polygon,\n): boolean => {\n  if (polygon.length < 3) return false\n\n  if (polygon.some((point) => isPointInsideBounds(point, bounds))) {\n    return true\n  }\n\n  const corners = getBoundsCorners(bounds)\n  if (corners.some((corner) => isPointInsidePolygon(corner, polygon))) {\n    return true\n  }\n\n  return doesPolygonIntersectBounds(bounds, polygon)\n}\n\nexport const areBoundsCompletelyInsidePolygon = (\n  bounds: Bounds,\n  polygon: Polygon,\n): boolean => {\n  if (polygon.length < 3) return false\n\n  const corners = getBoundsCorners(bounds)\n  if (!corners.every((corner) => isPointInsidePolygon(corner, polygon))) {\n    return false\n  }\n\n  return !doesPolygonIntersectBounds(bounds, polygon)\n}\n\nexport const isRectOverlappingPolygon = (\n  rect: UniversalRect,\n  polygon: Polygon,\n): boolean => areBoundsOverlappingPolygon(universalRectToBounds(rect), polygon)\n\nexport const isRectCompletelyInsidePolygon = (\n  rect: UniversalRect,\n  polygon: Polygon,\n): boolean =>\n  areBoundsCompletelyInsidePolygon(universalRectToBounds(rect), polygon)\n"],"mappings":"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","names":[]}