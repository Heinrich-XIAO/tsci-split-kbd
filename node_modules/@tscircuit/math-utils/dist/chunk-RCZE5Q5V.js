import {
  doSegmentsIntersect
} from "./chunk-EFLPMB4J.js";

// src/polygon.ts
var universalRectToBounds = (rect) => {
  if ("minX" in rect) {
    return rect;
  }
  const halfWidth = rect.width / 2;
  const halfHeight = rect.height / 2;
  return {
    minX: rect.center.x - halfWidth,
    minY: rect.center.y - halfHeight,
    maxX: rect.center.x + halfWidth,
    maxY: rect.center.y + halfHeight
  };
};
var getBoundsCorners = (bounds) => [
  { x: bounds.minX, y: bounds.minY },
  { x: bounds.maxX, y: bounds.minY },
  { x: bounds.maxX, y: bounds.maxY },
  { x: bounds.minX, y: bounds.maxY }
];
var getPolygonEdges = (polygon) => {
  const edges = [];
  for (let i = 0; i < polygon.length; i++) {
    const start = polygon[i];
    const end = polygon[(i + 1) % polygon.length];
    edges.push([start, end]);
  }
  return edges;
};
var isPointOnSegment = (point, start, end) => {
  const cross = (point.y - start.y) * (end.x - start.x) - (point.x - start.x) * (end.y - start.y);
  if (Math.abs(cross) > 1e-9) {
    return false;
  }
  const dot = (point.x - start.x) * (end.x - start.x) + (point.y - start.y) * (end.y - start.y);
  if (dot < 0) {
    return false;
  }
  const squaredLength = (end.x - start.x) ** 2 + (end.y - start.y) ** 2;
  if (dot > squaredLength) {
    return false;
  }
  return true;
};
var isPointInsideBounds = (point, bounds) => point.x >= bounds.minX && point.x <= bounds.maxX && point.y >= bounds.minY && point.y <= bounds.maxY;
var isPointInsidePolygon = (point, polygon) => {
  if (polygon.length < 3) return false;
  const edges = getPolygonEdges(polygon);
  for (const [start, end] of edges) {
    if (isPointOnSegment(point, start, end)) {
      return true;
    }
  }
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersects = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
    if (intersects) {
      inside = !inside;
    }
  }
  return inside;
};
var doesPolygonIntersectBounds = (bounds, polygon) => {
  const boundsCorners = getBoundsCorners(bounds);
  const boundsEdges = [
    [boundsCorners[0], boundsCorners[1]],
    [boundsCorners[1], boundsCorners[2]],
    [boundsCorners[2], boundsCorners[3]],
    [boundsCorners[3], boundsCorners[0]]
  ];
  const polygonEdges = getPolygonEdges(polygon);
  for (const [start, end] of polygonEdges) {
    for (const [rectStart, rectEnd] of boundsEdges) {
      if (doSegmentsIntersect(start, end, rectStart, rectEnd)) {
        return true;
      }
    }
  }
  return false;
};
var areBoundsOverlappingPolygon = (bounds, polygon) => {
  if (polygon.length < 3) return false;
  if (polygon.some((point) => isPointInsideBounds(point, bounds))) {
    return true;
  }
  const corners = getBoundsCorners(bounds);
  if (corners.some((corner) => isPointInsidePolygon(corner, polygon))) {
    return true;
  }
  return doesPolygonIntersectBounds(bounds, polygon);
};
var areBoundsCompletelyInsidePolygon = (bounds, polygon) => {
  if (polygon.length < 3) return false;
  const corners = getBoundsCorners(bounds);
  if (!corners.every((corner) => isPointInsidePolygon(corner, polygon))) {
    return false;
  }
  return !doesPolygonIntersectBounds(bounds, polygon);
};
var isRectOverlappingPolygon = (rect, polygon) => areBoundsOverlappingPolygon(universalRectToBounds(rect), polygon);
var isRectCompletelyInsidePolygon = (rect, polygon) => areBoundsCompletelyInsidePolygon(universalRectToBounds(rect), polygon);

export {
  isPointInsidePolygon,
  areBoundsOverlappingPolygon,
  areBoundsCompletelyInsidePolygon,
  isRectOverlappingPolygon,
  isRectCompletelyInsidePolygon
};
//# sourceMappingURL=chunk-RCZE5Q5V.js.map