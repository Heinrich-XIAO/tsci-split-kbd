// webworker/execution-context.ts
import { RootCircuit } from "@tscircuit/core";
import * as tscircuitCore from "@tscircuit/core";
import * as React from "react";
import * as tscircuitMathUtils from "@tscircuit/math-utils";

// node_modules/@tscircuit/parts-engine/lib/footprint-translators/get-footprinter-string-from-kicad.ts
var getFootprinterStringFromKicad = (kicadFootprint) => {
  let match = kicadFootprint.match(/:[RC]_(\d{4})_/);
  if (match) return match[1];
  match = kicadFootprint.match(
    /:(SOIC-\d+|SOT-\d+|SOD-\d+|SSOP-\d+|TSSOP-\d+|QFP-\d+|QFN-\d+)/
  );
  if (match) return match[1];
  return void 0;
};

// node_modules/@tscircuit/parts-engine/lib/footprint-translators/get-jlc-package-from-footprinter-string.ts
var getJlcPackageFromFootprinterString = (footprinterString) => {
  if (footprinterString.includes("cap")) {
    return footprinterString.replace(/cap/g, "");
  }
  return footprinterString;
};

// node_modules/@tscircuit/parts-engine/lib/footprint-translators/index.ts
var getJlcpcbPackageName = (footprint) => {
  if (!footprint) return void 0;
  if (footprint.startsWith("kicad:")) {
    const footprinterString = getFootprinterStringFromKicad(footprint);
    if (footprinterString) {
      return getJlcPackageFromFootprinterString(footprinterString);
    }
    return footprint;
  }
  return getJlcPackageFromFootprinterString(footprint);
};

// node_modules/@tscircuit/parts-engine/lib/jlc-parts-engine.ts
var cache = /* @__PURE__ */ new Map();
var getJlcPartsCached = async (name, params) => {
  const paramString = new URLSearchParams({
    ...params,
    json: "true"
  }).toString();
  if (cache.has(paramString)) {
    return cache.get(paramString);
  }
  const response = await fetch(
    `https://jlcsearch.tscircuit.com/${name}/list?${paramString}`
  );
  const responseJson = await response.json();
  cache.set(paramString, responseJson);
  return responseJson;
};
var withBasicPartPreference = (parts) => {
  if (!parts) return [];
  return [...parts].sort(
    (a, b) => Number(b.is_basic ?? false) - Number(a.is_basic ?? false)
  );
};
var jlcPartsEngine = {
  findPart: async ({
    sourceComponent,
    footprinterString
  }) => {
    const jlcpcbPackage = getJlcpcbPackageName(footprinterString);
    if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resistor") {
      const { resistors } = await getJlcPartsCached("resistors", {
        resistance: sourceComponent.resistance,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(resistors).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_capacitor") {
      const { capacitors } = await getJlcPartsCached("capacitors", {
        capacitance: sourceComponent.capacitance,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(capacitors).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_pin_header") {
      let pitch;
      if (footprinterString?.includes("_p")) {
        pitch = Number(footprinterString.split("_p")[1]);
      }
      const { headers } = await getJlcPartsCached(
        "headers",
        pitch ? {
          pitch,
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        } : {
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        }
      );
      return {
        jlcpcb: withBasicPartPreference(headers).map((h) => `C${h.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_potentiometer") {
      const { potentiometers } = await getJlcPartsCached("potentiometers", {
        resistance: sourceComponent.max_resistance,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(potentiometers).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_diode") {
      const { diodes } = await getJlcPartsCached("diodes", {
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(diodes).map((d) => `C${d.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_chip") {
      const { chips } = await getJlcPartsCached("chips", {
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(chips).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_transistor") {
      const { transistors } = await getJlcPartsCached("transistors", {
        package: jlcpcbPackage,
        transistor_type: sourceComponent.transistor_type
      });
      return {
        jlcpcb: withBasicPartPreference(transistors).map((t) => `C${t.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_power_source") {
      const { power_sources } = await getJlcPartsCached("power_sources", {
        voltage: sourceComponent.voltage,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(power_sources).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_inductor") {
      const { inductors } = await getJlcPartsCached("inductors", {
        inductance: sourceComponent.inductance,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(inductors).map((i) => `C${i.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_crystal") {
      const { crystals } = await getJlcPartsCached("crystals", {
        frequency: sourceComponent.frequency,
        load_capacitance: sourceComponent.load_capacitance,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(crystals).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_mosfet") {
      const { mosfets } = await getJlcPartsCached("mosfets", {
        package: jlcpcbPackage,
        mosfet_mode: sourceComponent.mosfet_mode,
        channel_type: sourceComponent.channel_type
      });
      return {
        jlcpcb: withBasicPartPreference(mosfets).map((m) => `C${m.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resonator") {
      const { resonators } = await getJlcPartsCached("resonators", {
        frequency: sourceComponent.frequency,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(resonators).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_switch") {
      const { switches } = await getJlcPartsCached("switches", {
        switch_type: sourceComponent.type,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(switches).map((s) => `C${s.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_led") {
      const { leds } = await getJlcPartsCached("leds", {
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(leds).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_fuse") {
      const { fuses } = await getJlcPartsCached("fuses", {
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(fuses).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    }
    return {};
  }
};

// lib/getPlatformConfig.ts
import { parseKicadModToCircuitJson } from "kicad-component-converter";

// lib/utils/dynamically-load-dependency-with-cdn-backup.ts
var dynamicallyLoadDependencyWithCdnBackup = async (packageName) => {
  try {
    const module = await import(packageName);
    return module.default;
  } catch (e) {
    console.log(`Failed to load ${packageName} locally, trying CDN fallback...`);
    try {
      const res = await fetch(
        `https://cdn.jsdelivr.net/npm/${packageName}/+esm`
      );
      if (!res.ok) {
        throw new Error(
          `Failed to fetch ${packageName} from CDN: ${res.statusText}`
        );
      }
      const code = await res.text();
      const blob = new Blob([code], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      try {
        const { default: loadedModule } = await import(url);
        return loadedModule;
      } finally {
        URL.revokeObjectURL(url);
      }
    } catch (cdnError) {
      console.error(`CDN fallback for ${packageName} also failed:`, cdnError);
      throw cdnError;
    }
  }
};

// lib/getPlatformConfig.ts
var KICAD_FOOTPRINT_CACHE_URL = "https://kicad-mod-cache.tscircuit.com";
var ngspiceEngineCache = null;
var getPlatformConfig = () => ({
  partsEngine: jlcPartsEngine,
  spiceEngineMap: {
    ngspice: {
      simulate: async (spice) => {
        if (!ngspiceEngineCache) {
          const createNgspiceSpiceEngine = await dynamicallyLoadDependencyWithCdnBackup(
            "@tscircuit/ngspice-spice-engine"
          ).catch((error) => {
            throw new Error(
              "Could not load ngspice engine from local node_modules or CDN fallback.",
              { cause: error }
            );
          });
          if (createNgspiceSpiceEngine) {
            ngspiceEngineCache = await createNgspiceSpiceEngine();
          }
        }
        if (!ngspiceEngineCache) {
          throw new Error(
            "Could not load ngspice engine from local node_modules or CDN fallback."
          );
        }
        return ngspiceEngineCache.simulate(spice);
      }
    }
  },
  footprintLibraryMap: {
    kicad: async (footprintName) => {
      const baseUrl = `${KICAD_FOOTPRINT_CACHE_URL}/${footprintName}`;
      const circuitJsonUrl = `${baseUrl}.circuit.json`;
      const res = await fetch(circuitJsonUrl);
      const raw = await res.json();
      const filtered = Array.isArray(raw) ? raw.filter(
        (el) => el?.type === "pcb_silkscreen_text" ? el?.text === "REF**" : true
      ) : raw;
      const wrlUrl = `${baseUrl}.wrl`;
      return {
        footprintCircuitJson: filtered,
        cadModel: { wrlUrl, modelUnitToMmScale: 2.54 }
      };
    }
  },
  footprintFileParserMap: {
    kicad_mod: {
      loadFromUrl: async (url) => {
        const kicadContent = await fetch(url).then((res) => res.text());
        const kicadJson = await parseKicadModToCircuitJson(kicadContent);
        return {
          footprintCircuitJson: Array.isArray(kicadJson) ? kicadJson : [kicadJson]
        };
      }
    }
  }
});

// webworker/execution-context.ts
import Debug from "debug";
var debug = Debug("tsci:eval:execution-context");
function createExecutionContext(webWorkerConfiguration, opts = {}) {
  globalThis.React = React;
  const basePlatform = opts.platform || getPlatformConfig();
  const platform = opts.projectConfig ? { ...basePlatform, ...opts.projectConfig } : basePlatform;
  if (platform.partsEngineDisabled) {
    platform.partsEngine = void 0;
  }
  const circuit = new RootCircuit({
    platform
  });
  if (opts.name) {
    circuit.name = opts.name;
  }
  if (opts.debugNamespace) {
    circuit.enableDebug(opts.debugNamespace);
  }
  const logs = [];
  return {
    fsMap: {},
    entrypoint: "",
    logger: {
      info: (message) => {
        logs.push({ msg: message });
      },
      getLogs: () => logs,
      stringifyLogs: () => logs.map((log) => log.msg).join("\n")
    },
    preSuppliedImports: {
      "@tscircuit/core": tscircuitCore,
      tscircuit: tscircuitCore,
      "@tscircuit/math-utils": tscircuitMathUtils,
      react: React,
      debug: Debug,
      // This is usually used as a type import, we can remove the shim when we
      // ignore type imports in getImportsFromCode
      "@tscircuit/props": {}
    },
    circuit,
    tsConfig: null,
    importStack: [],
    currentlyImporting: /* @__PURE__ */ new Set(),
    ...webWorkerConfiguration
  };
}

// lib/runner/normalizeFsMap.ts
function normalizeFilePath(filePath) {
  let normFilePath = filePath;
  normFilePath = normFilePath.replace(/\\/g, "/");
  normFilePath = normFilePath.trim();
  if (normFilePath.startsWith("./")) {
    normFilePath = normFilePath.slice(2);
  }
  if (normFilePath.startsWith("/")) {
    normFilePath = normFilePath.slice(1);
  }
  return normFilePath;
}
function normalizeFsMap(fsMap) {
  const normalizedFsMap = {};
  for (const [fsPath, fileContent] of Object.entries(fsMap)) {
    normalizedFsMap[normalizeFilePath(fsPath)] = fileContent;
  }
  return normalizedFsMap;
}

// lib/runner/tsconfigPaths.ts
function getTsConfig(fsMapOrAllFilePaths) {
  if (Array.isArray(fsMapOrAllFilePaths)) return null;
  const tsconfigContent = fsMapOrAllFilePaths["tsconfig.json"];
  if (!tsconfigContent) return null;
  try {
    const sanitizedContent = tsconfigContent.replace(
      /\/\*[\s\S]*?\*\/|\/\/.*/g,
      ""
    );
    const parsed = JSON.parse(sanitizedContent);
    return parsed;
  } catch (e) {
    throw new Error(`Failed to parse tsconfig.json: ${e.message}`);
  }
}
function resolveWithTsconfigPaths(opts) {
  const { importPath, normalizedFilePathMap, extensions, tsConfig } = opts;
  const paths = tsConfig?.compilerOptions?.paths;
  if (!paths) return null;
  const baseUrl = tsConfig?.compilerOptions?.baseUrl || ".";
  const tryResolveCandidate = (candidate) => {
    const normalizedCandidate = normalizeFilePath(candidate);
    if (normalizedFilePathMap.has(normalizedCandidate)) {
      return normalizedFilePathMap.get(normalizedCandidate);
    }
    for (const ext of extensions) {
      const withExt = `${normalizedCandidate}.${ext}`;
      if (normalizedFilePathMap.has(withExt)) {
        return normalizedFilePathMap.get(withExt);
      }
    }
    return null;
  };
  for (const [alias, targets] of Object.entries(paths)) {
    const hasWildcard = alias.includes("*");
    if (hasWildcard) {
      const [prefix, suffix] = alias.split("*");
      if (!importPath.startsWith(prefix) || !importPath.endsWith(suffix || "")) {
        continue;
      }
      const starMatch = importPath.slice(
        prefix.length,
        importPath.length - (suffix ? suffix.length : 0)
      );
      for (const target of targets) {
        const replaced = target.replace("*", starMatch);
        const candidate = baseUrl && !replaced.startsWith("./") && !replaced.startsWith("/") ? `${baseUrl}/${replaced}` : replaced;
        const resolved = tryResolveCandidate(candidate);
        if (resolved) return resolved;
      }
    } else {
      if (importPath !== alias) continue;
      for (const target of targets) {
        const candidate = baseUrl && !target.startsWith("./") && !target.startsWith("/") ? `${baseUrl}/${target}` : target;
        const resolved = tryResolveCandidate(candidate);
        if (resolved) return resolved;
      }
    }
  }
  const resolvedPathFromBaseUrl = resolveWithBaseUrl({
    importPath,
    normalizedFilePathMap,
    extensions,
    tsConfig
  });
  if (resolvedPathFromBaseUrl) return resolvedPathFromBaseUrl;
  return null;
}
function resolveWithBaseUrl(opts) {
  const { importPath, normalizedFilePathMap, extensions, tsConfig } = opts;
  const baseUrl = tsConfig?.compilerOptions?.baseUrl;
  if (!baseUrl) return null;
  const filePathToResolve = `${baseUrl}/${importPath}`;
  const normalizedFilePath = normalizeFilePath(filePathToResolve);
  if (normalizedFilePathMap.has(normalizedFilePath)) {
    return normalizedFilePathMap.get(normalizedFilePath);
  }
  for (const ext of extensions) {
    const withExt = `${normalizedFilePath}.${ext}`;
    if (normalizedFilePathMap.has(withExt)) {
      return normalizedFilePathMap.get(withExt);
    }
  }
  return null;
}
function matchesTsconfigPathPattern(importPath, tsConfig) {
  const paths = tsConfig?.compilerOptions?.paths;
  if (!paths) return false;
  for (const [alias] of Object.entries(paths)) {
    const hasWildcard = alias.includes("*");
    if (hasWildcard) {
      const [prefix, suffix] = alias.split("*");
      if (importPath.startsWith(prefix) && importPath.endsWith(suffix || "")) {
        return true;
      }
    } else {
      if (importPath === alias) return true;
    }
  }
  return false;
}

// lib/runner/CircuitRunner.ts
import "react";

// lib/utils/dirname.ts
function dirname(path) {
  if (!path) return ".";
  const normalizedPath = path.replace(/\\/g, "/");
  const cleanPath = normalizedPath.replace(/\/+$/, "");
  if (cleanPath.indexOf("/") === -1) return ".";
  return cleanPath.substring(0, cleanPath.lastIndexOf("/")) || "/";
}

// lib/utils/resolveRelativePath.ts
function resolveRelativePath(importPath, cwd) {
  if (importPath.startsWith("../")) {
    const parentDir = dirname(cwd);
    return resolveRelativePath(importPath.slice(3), parentDir);
  }
  if (importPath.startsWith("./")) {
    return resolveRelativePath(importPath.slice(2), cwd);
  }
  if (importPath.startsWith("/")) {
    return importPath.slice(1);
  }
  return `${cwd}/${importPath}`;
}

// lib/runner/resolveFilePath.ts
var resolveFilePath = (unknownFilePath, fsMapOrAllFilePaths, cwd, opts = {}) => {
  const resolvedPath = cwd ? resolveRelativePath(unknownFilePath, cwd) : unknownFilePath;
  const filePaths = new Set(
    Array.isArray(fsMapOrAllFilePaths) ? fsMapOrAllFilePaths : Object.keys(fsMapOrAllFilePaths)
  );
  if (filePaths.has(resolvedPath)) {
    return resolvedPath;
  }
  const normalizedFilePathMap = /* @__PURE__ */ new Map();
  for (const filePath of filePaths) {
    normalizedFilePathMap.set(normalizeFilePath(filePath), filePath);
  }
  const normalizedResolvedPath = normalizeFilePath(resolvedPath);
  if (normalizedFilePathMap.has(normalizedResolvedPath)) {
    return normalizedFilePathMap.get(normalizedResolvedPath);
  }
  const extension = ["tsx", "ts", "json", "js", "jsx", "obj", "gltf", "glb"];
  for (const ext of extension) {
    const possibleFilePath = `${normalizedResolvedPath}.${ext}`;
    if (normalizedFilePathMap.has(possibleFilePath)) {
      return normalizedFilePathMap.get(possibleFilePath);
    }
  }
  const tsConfig = opts.tsConfig ?? null;
  if (!unknownFilePath.startsWith("./") && !unknownFilePath.startsWith("../")) {
    const resolvedPathFromPaths = resolveWithTsconfigPaths({
      importPath: unknownFilePath,
      normalizedFilePathMap,
      extensions: extension,
      tsConfig
    });
    if (resolvedPathFromPaths) return resolvedPathFromPaths;
    const resolvedPathFromBaseUrl = resolveWithBaseUrl({
      importPath: unknownFilePath,
      normalizedFilePathMap,
      extensions: extension,
      tsConfig
    });
    if (resolvedPathFromBaseUrl) return resolvedPathFromBaseUrl;
  }
  if (!unknownFilePath.startsWith("./") && !unknownFilePath.startsWith("../")) {
    const normalizedUnknownFilePath = normalizeFilePath(unknownFilePath);
    if (normalizedFilePathMap.has(normalizedUnknownFilePath)) {
      return normalizedFilePathMap.get(normalizedUnknownFilePath);
    }
    for (const ext of extension) {
      const possibleFilePath = `${normalizedUnknownFilePath}.${ext}`;
      if (normalizedFilePathMap.has(possibleFilePath)) {
        return normalizedFilePathMap.get(possibleFilePath);
      }
    }
  }
  return null;
};
var resolveFilePathOrThrow = (unknownFilePath, fsMapOrAllFilePaths, cwd, opts = {}) => {
  const resolvedFilePath = resolveFilePath(
    unknownFilePath,
    fsMapOrAllFilePaths,
    cwd,
    opts
  );
  if (!resolvedFilePath) {
    throw new Error(
      `File not found "${unknownFilePath}", available paths:

${Object.keys(fsMapOrAllFilePaths).join(", ")}`
    );
  }
  return resolvedFilePath;
};

// lib/utils/get-imports-from-code.ts
var getImportsFromCode = (code) => {
  const importRegex = /^\s*import\s+(?:(?:[\w\s]+,\s*)?(?:\*\s+as\s+[\w\s]+|\{[\s\w,]+\}|\w+)\s+from\s*)?['"](.+?)['"]/gm;
  const imports = [];
  let match;
  while ((match = importRegex.exec(code)) !== null) {
    const fullMatch = match[0];
    if (/^\s*import\s+type\b/.test(fullMatch)) {
      continue;
    }
    imports.push(match[1]);
  }
  const reExportRegex = /^\s*export\s+(?:type\s+)?(?:\*\s+as\s+[\w$]+|\*|\{[^}]+\})\s+from\s*['"](.+?)['"]/gm;
  let reExportMatch;
  while ((reExportMatch = reExportRegex.exec(code)) !== null) {
    const fullMatch = reExportMatch[0];
    if (/^\s*export\s+type\b/.test(fullMatch)) {
      continue;
    }
    imports.push(reExportMatch[1]);
  }
  return imports;
};

// webworker/eval-compiled-js.ts
function evalCompiledJs(compiledCode, preSuppliedImports, cwd) {
  ;
  globalThis.__tscircuit_require = (name) => {
    const resolvedFilePath = resolveFilePath(name, preSuppliedImports, cwd);
    const hasResolvedFilePath = resolvedFilePath && preSuppliedImports[resolvedFilePath];
    if (!preSuppliedImports[name] && !hasResolvedFilePath) {
      throw new Error(`Import "${name}" not found ${cwd ? `in "${cwd}"` : ""}`);
    }
    const mod = preSuppliedImports[name] || preSuppliedImports[resolvedFilePath];
    return new Proxy(mod, {
      get(target, prop) {
        if (!(prop in target)) {
          if (prop === "default") {
            if (target.default !== void 0) {
              return target.default;
            }
            if (target.__esModule) {
              return void 0;
            }
            if (typeof target === "function" || typeof target === "object") {
              return target;
            }
            return void 0;
          }
          if (prop === "__esModule") {
            return true;
          }
          throw new Error(
            `Component "${String(prop)}" is not exported by "${name}"`
          );
        }
        return target[prop];
      }
    });
  };
  const functionBody = `
  var exports = {};
  var require = globalThis.__tscircuit_require;
  var module = { exports };
  var circuit = globalThis.__tscircuit_circuit;
  ${compiledCode};
  return module;`.trim();
  return Function(functionBody).call(globalThis);
}

// webworker/import-local-file.ts
import Debug2 from "debug";

// lib/shared/static-asset-extensions.ts
var STATIC_ASSET_EXTENSIONS = [
  ".glb",
  ".kicad_mod",
  ".gltf",
  ".obj",
  ".stl"
];
var isStaticAssetPath = (path) => STATIC_ASSET_EXTENSIONS.some((ext) => path.endsWith(ext));

// webworker/transform-with-sucrase.ts
import { transform } from "sucrase";
var TS_EXTENSIONS = /* @__PURE__ */ new Set([".ts", ".tsx", ".mts", ".cts"]);
var JSX_EXTENSIONS = /* @__PURE__ */ new Set([".tsx", ".jsx", ".ts"]);
var TYPE_STAR_EXPORT_REGEX = /^\s*export\s+type\s+\*\s+(?:as\s+[\w$]+\s+)?from\s+['"][^'"]+['"]\s*;?\s*$/gim;
var stripTypeStarExports = (code) => code.replace(TYPE_STAR_EXPORT_REGEX, "");
var stripQueryAndHash = (filePath) => {
  const queryIndex = filePath.indexOf("?");
  const hashIndex = filePath.indexOf("#");
  let endIndex = filePath.length;
  if (queryIndex !== -1 && hashIndex !== -1) {
    endIndex = Math.min(queryIndex, hashIndex);
  } else if (queryIndex !== -1) {
    endIndex = queryIndex;
  } else if (hashIndex !== -1) {
    endIndex = hashIndex;
  }
  return filePath.slice(0, endIndex);
};
var getExtension = (filePath) => {
  const normalizedPath = stripQueryAndHash(filePath);
  const lastDotIndex = normalizedPath.lastIndexOf(".");
  if (lastDotIndex === -1) {
    return "";
  }
  const lastSlashIndex = Math.max(
    normalizedPath.lastIndexOf("/"),
    normalizedPath.lastIndexOf("\\")
  );
  if (lastSlashIndex > lastDotIndex) {
    return "";
  }
  return normalizedPath.slice(lastDotIndex).toLowerCase();
};
var getTransformsForFilePath = (filePath) => {
  const extension = getExtension(filePath);
  const transforms = ["imports"];
  if (TS_EXTENSIONS.has(extension)) {
    transforms.unshift("typescript");
  }
  if (JSX_EXTENSIONS.has(extension)) {
    transforms.push("jsx");
  }
  return transforms;
};
var transformWithSucrase = (code, filePath) => {
  const transforms = getTransformsForFilePath(filePath);
  const sanitizedCode = stripTypeStarExports(code);
  const { code: transformedCode } = transform(sanitizedCode, {
    filePath,
    production: true,
    transforms
  });
  return transformedCode;
};

// webworker/import-local-file.ts
import { KicadToCircuitJsonConverter } from "kicad-to-circuit-json";
var debug2 = Debug2("tsci:eval:import-local-file");
var importLocalFile = async (importName, ctx, depth = 0) => {
  debug2("importLocalFile called with:", {
    importName
  });
  const { fsMap, preSuppliedImports, importStack, currentlyImporting } = ctx;
  const fsPath = resolveFilePathOrThrow(importName, fsMap, void 0, {
    tsConfig: ctx.tsConfig
  });
  debug2("fsPath:", fsPath);
  if (currentlyImporting.has(fsPath)) {
    const cycleStartIndex = importStack.indexOf(fsPath);
    const cyclePath = cycleStartIndex >= 0 ? importStack.slice(cycleStartIndex).concat(fsPath) : [...importStack, fsPath];
    throw new Error(
      `Circular dependency detected while importing "${fsPath}". The following import chain forms a cycle:

${cyclePath.join(
        " -> "
      )}`
    );
  }
  if (!ctx.fsMap[fsPath]) {
    debug2("fsPath not found in fsMap:", fsPath);
    throw new Error(`File "${fsPath}" not found`);
  }
  const fileContent = fsMap[fsPath];
  debug2("fileContent:", fileContent?.slice(0, 100));
  currentlyImporting.add(fsPath);
  importStack.push(fsPath);
  try {
    if (fsPath.endsWith(".json")) {
      const jsonData = JSON.parse(fileContent);
      preSuppliedImports[fsPath] = {
        __esModule: true,
        default: jsonData
      };
    } else if (fsPath.endsWith(".kicad_pcb")) {
      const converter = new KicadToCircuitJsonConverter();
      converter.addFile(fsPath, fileContent);
      converter.runUntilFinished();
      const circuitJson = converter.getOutput();
      preSuppliedImports[fsPath] = {
        __esModule: true,
        circuitJson
      };
    } else if (isStaticAssetPath(fsPath)) {
      let staticUrl;
      if (fileContent === "__STATIC_ASSET__") {
        const platformConfig = ctx.circuit.platform;
        staticUrl = `${platformConfig?.projectBaseUrl ?? ""}/${fsPath.startsWith("./") ? fsPath.slice(2) : fsPath}`;
      } else {
        const blob = new Blob([fileContent], {
          type: fsPath.endsWith(".kicad_mod") ? "text/plain" : "application/octet-stream"
        });
        staticUrl = URL.createObjectURL(blob);
      }
      preSuppliedImports[fsPath] = {
        __esModule: true,
        default: staticUrl
      };
    } else if (fsPath.endsWith(".tsx") || fsPath.endsWith(".ts")) {
      const importNames = getImportsFromCode(fileContent);
      for (const importName2 of importNames) {
        if (!preSuppliedImports[importName2]) {
          await importEvalPath(importName2, ctx, depth + 1, {
            cwd: dirname(fsPath)
          });
        }
      }
      try {
        const transformedCode = transformWithSucrase(fileContent, fsPath);
        debug2("evalCompiledJs called with:", {
          code: transformedCode.slice(0, 100),
          dirname: dirname(fsPath)
        });
        const importRunResult = evalCompiledJs(
          transformedCode,
          preSuppliedImports,
          dirname(fsPath)
        );
        debug2("importRunResult:", {
          fsPath,
          importRunResult
        });
        preSuppliedImports[fsPath] = importRunResult.exports;
      } catch (error) {
        throw new Error(
          `Eval compiled js error for "${importName}": ${error.message}`
        );
      }
    } else if (fsPath.endsWith(".js")) {
      preSuppliedImports[fsPath] = evalCompiledJs(
        transformWithSucrase(fileContent, fsPath),
        preSuppliedImports,
        dirname(fsPath)
      ).exports;
    } else {
      throw new Error(
        `Unsupported file extension "${fsPath.split(".").pop()}" for "${fsPath}"`
      );
    }
  } finally {
    importStack.pop();
    currentlyImporting.delete(fsPath);
  }
};

// webworker/import-snippet.ts
async function importSnippet(importName, ctx, depth = 0) {
  const { preSuppliedImports } = ctx;
  const fullSnippetName = importName.replace("@tsci/", "").replace(".", "/");
  const { cjs, error } = await globalThis.fetch(`${ctx.cjsRegistryUrl}/${fullSnippetName}`).then(async (res) => ({ cjs: await res.text(), error: null })).catch((e) => ({ error: e, cjs: null }));
  if (error) {
    console.error("Error fetching import", importName, error);
    return;
  }
  try {
    preSuppliedImports[importName] = evalCompiledJs(
      cjs,
      preSuppliedImports
    ).exports;
  } catch (e) {
    console.error("Error importing snippet", e);
  }
}

// lib/utils/resolve-node-module.ts
function createContext(modulePath, fsMap, basePath) {
  return {
    fsMap,
    extensions: [".js", ".jsx", ".ts", ".tsx", ".json"],
    basePath,
    modulePath
  };
}
function findPackageJson(nodeModulesPath, ctx) {
  const packageJsonPath = `${nodeModulesPath}/package.json`;
  if (!ctx.fsMap[packageJsonPath]) return null;
  try {
    return JSON.parse(ctx.fsMap[packageJsonPath]);
  } catch {
    return null;
  }
}
function tryResolveWithExtensions(path, ctx) {
  if (ctx.fsMap[path]) return path;
  for (const ext of ctx.extensions) {
    const pathWithExt = path.replace(/\.js$|\.jsx$/, "") + ext;
    if (ctx.fsMap[pathWithExt]) return pathWithExt;
  }
  return null;
}
function resolveExportPath(nodeModulesPath, exportPath, ctx) {
  const fullExportPath = `${nodeModulesPath}/${exportPath.replace(/^\.\//, "")}`;
  return tryResolveWithExtensions(fullExportPath, ctx);
}
function resolvePackageExports(nodeModulesPath, packageJson, remainingPath, ctx) {
  if (!packageJson.exports) return null;
  const defaultExport = packageJson.exports["."];
  if (remainingPath === "" && defaultExport) {
    if (typeof defaultExport === "string") {
      const resolved = resolveExportPath(nodeModulesPath, defaultExport, ctx);
      if (resolved) return resolved;
    }
  }
  const subpathExport = remainingPath ? packageJson.exports[`./${remainingPath}`] : null;
  if (subpathExport && typeof subpathExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, subpathExport, ctx);
    if (resolved) return resolved;
  }
  const importExport = packageJson.exports["import"];
  if (remainingPath === "" && importExport && typeof importExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, importExport, ctx);
    if (resolved) return resolved;
  }
  return null;
}
function resolvePackageEntryPoint(nodeModulesPath, packageJson, ctx) {
  const entryPoint = packageJson.module || packageJson.main || "index.js";
  const fullPath = `${nodeModulesPath}/${entryPoint}`;
  return tryResolveWithExtensions(fullPath, ctx);
}
function resolveRemainingPath(nodeModulesPath, remainingPath, ctx) {
  if (!remainingPath) {
    for (const ext of ctx.extensions) {
      const indexPath = `${nodeModulesPath}/index${ext}`;
      if (ctx.fsMap[indexPath]) return indexPath;
    }
    return null;
  }
  const fullPath = `${nodeModulesPath}/${remainingPath}`;
  const directMatch = tryResolveWithExtensions(fullPath, ctx);
  if (directMatch) return directMatch;
  for (const ext of ctx.extensions) {
    const indexPath = `${fullPath}/index${ext}`;
    if (ctx.fsMap[indexPath]) return indexPath;
  }
  return null;
}
function resolveNodeModuleInPath(searchPath, ctx) {
  const moduleParts = ctx.modulePath.split("/");
  const scope = moduleParts[0].startsWith("@") ? moduleParts.slice(0, 2).join("/") : moduleParts[0];
  const remainingPath = moduleParts.slice(scope.includes("/") ? 2 : 1).join("/");
  const nodeModulesPath = `${searchPath == "." ? "" : `${searchPath}/`}node_modules/${scope}`;
  const packageJson = findPackageJson(nodeModulesPath, ctx);
  if (packageJson) {
    const exportsResolution = resolvePackageExports(
      nodeModulesPath,
      packageJson,
      remainingPath,
      ctx
    );
    if (exportsResolution) return exportsResolution;
    const entryPointResolution = resolvePackageEntryPoint(
      nodeModulesPath,
      packageJson,
      ctx
    );
    if (entryPointResolution) return entryPointResolution;
  }
  const remainingPathResolution = resolveRemainingPath(
    nodeModulesPath,
    remainingPath,
    ctx
  );
  if (remainingPathResolution) return remainingPathResolution;
  const parentPath = dirname(searchPath);
  if (parentPath && parentPath !== searchPath) {
    return resolveNodeModuleInPath(parentPath, ctx);
  }
  return null;
}
function resolveNodeModule(modulePath, fsMap, basePath) {
  const ctx = createContext(modulePath, fsMap, basePath);
  return resolveNodeModuleInPath(ctx.basePath, ctx);
}

// webworker/import-node-module.ts
import Debug3 from "debug";
var debug3 = Debug3("tsci:eval:import-node-module");
var importNodeModule = async (importName, ctx, depth = 0) => {
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) {
    return;
  }
  const resolvedNodeModulePath = resolveNodeModule(importName, ctx.fsMap, "");
  if (!resolvedNodeModulePath) {
    const platform = ctx.circuit?.platform;
    if (platform?.nodeModulesResolver) {
      debug3(`Attempting to resolve "${importName}" using nodeModulesResolver`);
      try {
        const fileContent = await platform.nodeModulesResolver(importName);
        if (fileContent) {
          debug3(`Successfully resolved "${importName}" via nodeModulesResolver`);
          const syntheticPath = `node_modules/${importName}.ts`;
          ctx.fsMap[syntheticPath] = fileContent;
          await importLocalFile(syntheticPath, ctx, depth);
          preSuppliedImports[importName] = preSuppliedImports[syntheticPath];
          const unprefixedPath2 = syntheticPath.replace(/^node_modules\//, "");
          preSuppliedImports[unprefixedPath2] = preSuppliedImports[syntheticPath];
          return;
        }
        debug3(`nodeModulesResolver returned null for "${importName}"`);
      } catch (error) {
        debug3(`nodeModulesResolver failed for "${importName}":`, error);
      }
    }
    throw new Error(`Node module "${importName}" not found`);
  }
  await importLocalFile(resolvedNodeModulePath, ctx, depth);
  preSuppliedImports[importName] = preSuppliedImports[resolvedNodeModulePath];
  const unprefixedPath = resolvedNodeModulePath.replace(/^node_modules\//, "");
  preSuppliedImports[unprefixedPath] = preSuppliedImports[resolvedNodeModulePath];
  if (resolvedNodeModulePath.endsWith("/index.tsx") || resolvedNodeModulePath.endsWith("/index.ts") || resolvedNodeModulePath.endsWith("/index.js")) {
    const dirPath = resolvedNodeModulePath.replace(/\/index\.(tsx?|js)$/, "");
    const unprefixedDirPath = dirPath.replace(/^node_modules\//, "");
    preSuppliedImports[unprefixedDirPath] = preSuppliedImports[resolvedNodeModulePath];
    if (unprefixedDirPath.startsWith("@")) {
      const scopeParts = unprefixedDirPath.split("/");
      if (scopeParts.length >= 2) {
        const scopedName = `${scopeParts[0]}/${scopeParts[1]}`;
        preSuppliedImports[scopedName] = preSuppliedImports[resolvedNodeModulePath];
      }
    }
  }
};

// webworker/import-npm-package.ts
import Debug4 from "debug";
var debug4 = Debug4("tsci:eval:import-npm-package");
function extractPackagePathFromJSDelivr(url) {
  const prefix = "https://cdn.jsdelivr.net/npm/";
  if (url.startsWith(prefix)) {
    return url.substring(prefix.length).replace(/\/\+esm$/, "");
  }
  return url;
}
async function importNpmPackage(importName, ctx, depth = 0) {
  debug4(`importing npm package: ${importName}`);
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) return;
  const npmCdnUrl = `https://cdn.jsdelivr.net/npm/${importName}/+esm`;
  let finalUrl;
  const { content, error } = await globalThis.fetch(npmCdnUrl).then(async (res) => {
    finalUrl = res.url;
    if (!res.ok)
      throw new Error(
        `Could not fetch "${importName}" from jsdelivr: ${res.statusText}

${ctx.logger.stringifyLogs()}`
      );
    return { content: await res.text(), error: null };
  }).catch((e) => ({ error: e, content: null }));
  if (error) {
    console.error("Error fetching npm import", importName, error);
    throw error;
  }
  const finalImportName = extractPackagePathFromJSDelivr(finalUrl);
  const cwd = dirname(finalImportName);
  const importNames = getImportsFromCode(content);
  for (const subImportName of importNames) {
    if (!preSuppliedImports[subImportName]) {
      await importEvalPath(subImportName, ctx, depth + 1, {
        cwd
      });
    }
  }
  const transformedCode = transformWithSucrase(
    content,
    finalImportName || importName
  );
  try {
    const exports = evalCompiledJs(
      transformedCode,
      preSuppliedImports,
      cwd
    ).exports;
    preSuppliedImports[importName] = exports;
    preSuppliedImports[finalImportName] = exports;
    preSuppliedImports[finalUrl] = exports;
  } catch (e) {
    throw new Error(
      `Eval npm package error for "${importName}": ${e.message}

${ctx.logger.stringifyLogs()}`
    );
  }
}

// webworker/import-eval-path.ts
import Debug5 from "debug";
var debug5 = Debug5("tsci:eval:import-eval-path");
async function importEvalPath(importName, ctx, depth = 0, opts = {}) {
  debug5("importEvalPath called with:", {
    importName,
    depth,
    opts
  });
  ctx.logger.info(
    `importEvalPath("${importName}", {cwd: "${opts.cwd}", depth: ${depth}})`
  );
  debug5(`${"  ".repeat(depth)}\u27A1\uFE0F`, importName);
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) {
    ctx.logger.info(`Import "${importName}" in preSuppliedImports[1]`);
    return;
  }
  if (importName.startsWith("./") && preSuppliedImports[importName.slice(2)]) {
    ctx.logger.info(`Import "${importName}" in preSuppliedImports[2]`);
    return;
  }
  if (depth > 30) {
    throw new Error(
      `Max depth for imports reached (30) Import Path: ${ctx.importStack.join(" -> ")}`
    );
  }
  if (importName.startsWith("/npm/")) {
    const pkgName = importName.replace(/^\/npm\//, "").replace(/\/\+esm$/, "");
    ctx.logger.info(`importNpmPackage("${pkgName}")`);
    await importNpmPackage(pkgName, ctx, depth);
    const pkg = preSuppliedImports[pkgName];
    if (pkg) {
      preSuppliedImports[importName] = pkg;
    }
    return;
  }
  const resolvedLocalImportPath = resolveFilePath(
    importName,
    ctx.fsMap,
    opts.cwd,
    { tsConfig: ctx.tsConfig }
  );
  if (resolvedLocalImportPath) {
    ctx.logger.info(`importLocalFile("${resolvedLocalImportPath}")`);
    await importLocalFile(resolvedLocalImportPath, ctx, depth);
    if (importName !== resolvedLocalImportPath) {
      preSuppliedImports[importName] = preSuppliedImports[resolvedLocalImportPath];
    }
    return;
  }
  const tsConfig = ctx.tsConfig ?? getTsConfig(ctx.fsMap);
  if (!ctx.tsConfig && tsConfig) {
    ctx.tsConfig = tsConfig;
  }
  if (matchesTsconfigPathPattern(importName, tsConfig)) {
    throw new Error(
      `Import "${importName}" matches a tsconfig path alias but could not be resolved to an existing file${opts.cwd ? ` from directory "${opts.cwd}"` : ""}

${ctx.logger.stringifyLogs()}`
    );
  }
  const resolvedNodeModulePath = resolveNodeModule(
    importName,
    ctx.fsMap,
    opts.cwd || ""
  );
  if (resolvedNodeModulePath) {
    ctx.logger.info(`resolvedNodeModulePath="${resolvedNodeModulePath}"`);
    ctx.logger.info(`importNodeModule("${importName}")`);
    return importNodeModule(importName, ctx, depth);
  }
  if (!importName.startsWith(".") && !importName.startsWith("/") && !importName.startsWith("@tsci/")) {
    const platform = ctx.circuit?.platform;
    if (platform?.nodeModulesResolver) {
      ctx.logger.info(
        `importNodeModule("${importName}") via nodeModulesResolver`
      );
      try {
        await importNodeModule(importName, ctx, depth);
        return;
      } catch (error) {
        ctx.logger.info(
          `nodeModulesResolver failed for "${importName}", falling back to npm CDN`
        );
      }
    }
  }
  if (importName.startsWith("@tsci/")) {
    ctx.logger.info(`importSnippet("${importName}")`);
    return importSnippet(importName, ctx, depth);
  }
  if (!importName.startsWith(".") && !importName.startsWith("/")) {
    ctx.logger.info(`importNpmPackage("${importName}")`);
    return importNpmPackage(importName, ctx, depth);
  }
  throw new Error(
    `Unresolved import "${importName}" ${opts.cwd ? `from directory "${opts.cwd}"` : ""}

${ctx.logger.stringifyLogs()}`
  );
}

// lib/runner/setupDefaultEntrypointIfNeeded.ts
import Debug6 from "debug";
var debug6 = Debug6("tsci:eval:setupDefaultEntrypointIfNeeded");
var setupDefaultEntrypointIfNeeded = (opts) => {
  if (!opts.entrypoint && !opts.mainComponentPath) {
    if ("index.tsx" in opts.fsMap) {
      opts.mainComponentPath = "index.tsx";
    } else if ("index.ts" in opts.fsMap) {
      opts.mainComponentPath = "index.ts";
    } else if (Object.keys(opts.fsMap).filter((k) => k.endsWith(".tsx")).length === 1) {
      opts.mainComponentPath = Object.keys(opts.fsMap)[0];
    } else if ("tscircuit.config.json" in opts.fsMap) {
      const configContent = opts.fsMap["tscircuit.config.json"];
      try {
        const config = JSON.parse(configContent);
        if (config.mainEntrypoint) {
          opts.entrypoint = config.mainEntrypoint;
        }
      } catch (e) {
        console.warn("Failed to parse tscircuit.config.json:", e);
      }
    } else {
      throw new Error(
        "Either entrypoint or mainComponentPath must be provided (no index file, could not infer entrypoint)"
      );
    }
  }
  if (!opts.entrypoint && opts.mainComponentPath) {
    opts.entrypoint = "entrypoint.tsx";
    const mainComponentCode = opts.fsMap[resolveFilePathOrThrow(opts.mainComponentPath, opts.fsMap)];
    if (!mainComponentCode) {
      throw new Error(
        `Main component path "${opts.mainComponentPath}" not found in fsMap. Available paths: ${Object.keys(opts.fsMap).join(", ")}`
      );
    }
    opts.fsMap[opts.entrypoint] = `
     import * as UserComponents from "./${opts.mainComponentPath}";
          
      ${opts.mainComponentName ? `
        const ComponentToRender = UserComponents["${opts.mainComponentName}"]
        ` : `const ComponentToRender = UserComponents.default || 
          Object.entries(UserComponents)
          .filter(([name]) => !name.startsWith("use"))
          .map(([_, component]) => component)[0] || (() => null);`}

           ${debug6.enabled ? `
     console.log({ UserComponents })
     console.log("ComponentToRender " + ComponentToRender.toString(),  { ComponentToRender })
     ` : ""}

      circuit.add(       
          <ComponentToRender ${opts.mainComponentProps ? `{...${JSON.stringify(opts.mainComponentProps, null, 2)}}` : ""} /> 
      );
`;
  }
  if (!opts.name && opts.mainComponentName) {
    opts.name = opts.mainComponentName;
  }
};

// lib/utils/enhance-root-circuit-error.ts
var enhanceRootCircuitHasNoChildrenError = (error, entrypoint) => {
  if (error instanceof Error && entrypoint && error.message.includes("RootCircuit has no children") && !error.message.includes('"entrypoint":')) {
    const entrypointMessage = entrypoint.startsWith("./") ? entrypoint.slice(2) : entrypoint;
    error.message = `${error.message}. "entrypoint": "${entrypointMessage}" is set in the runner configuration, entrypoints must contain "circuit.add(...)", you might be looking to use mainComponentPath instead if your file exports a component.`;
  }
  return error;
};

// lib/runner/CircuitRunner.ts
import Debug7 from "debug";

// lib/shared/obj-path.ts
function setValueAtPath(obj, path, value) {
  const keys = path.split(".");
  let current = obj;
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (i === keys.length - 1) {
      current[key] = value;
    } else {
      if (!Object.prototype.hasOwnProperty.call(current, key) || typeof current[key] !== "object" || current[key] === null || Array.isArray(current[key])) {
        current[key] = {};
      }
      current = current[key];
    }
  }
}

// lib/runner/CircuitRunner.ts
var debug7 = Debug7("tsci:eval:CircuitRunner");
var CircuitRunner = class {
  constructor(configuration = {}) {
    this._executionContext = null;
    this._circuitRunnerConfiguration = {
      snippetsApiBaseUrl: "https://registry-api.tscircuit.com",
      cjsRegistryUrl: "https://cjs.tscircuit.com",
      verbose: false
    };
    this._eventListeners = {};
    Object.assign(this._circuitRunnerConfiguration, configuration);
  }
  async version() {
    return "0.0.0";
  }
  async executeWithFsMap(ogOpts) {
    const opts = { ...ogOpts };
    if (this._circuitRunnerConfiguration.verbose) {
      Debug7.enable("tsci:eval:*");
    }
    debug7("executeWithFsMap called with:", {
      entrypoint: opts.entrypoint,
      fsMapKeys: Object.keys(opts.fsMap),
      name: opts.name
    });
    setupDefaultEntrypointIfNeeded(opts);
    debug7("entrypoint after setupDefaultEntrypointIfNeeded:", {
      entrypoint: opts.entrypoint
    });
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        name: opts.name,
        platform: this._circuitRunnerConfiguration.platform,
        projectConfig: this._circuitRunnerConfiguration.projectConfig,
        debugNamespace: this._debugNamespace
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.entrypoint = opts.entrypoint;
    this._executionContext.fsMap = normalizeFsMap(opts.fsMap);
    this._executionContext.tsConfig = getTsConfig(this._executionContext.fsMap);
    if (!this._executionContext.fsMap[opts.entrypoint]) {
      throw new Error(`Entrypoint "${opts.entrypoint}" not found`);
    }
    ;
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    const entrypoint = opts.entrypoint.startsWith("./") ? opts.entrypoint : `./${opts.entrypoint}`;
    debug7("final entrypoint:", entrypoint);
    await importEvalPath(entrypoint, this._executionContext);
  }
  async execute(code, opts = {}) {
    if (this._circuitRunnerConfiguration.verbose) {
      console.log(
        "[CircuitRunner] execute called with code length:",
        code.length
      );
    }
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        ...opts,
        platform: this._circuitRunnerConfiguration.platform,
        projectConfig: this._circuitRunnerConfiguration.projectConfig,
        debugNamespace: this._debugNamespace
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.fsMap["entrypoint.tsx"] = code;
    this._executionContext.tsConfig = getTsConfig(this._executionContext.fsMap);
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    await importEvalPath("./entrypoint.tsx", this._executionContext);
  }
  async executeComponent(component, opts = {}) {
    if (this._circuitRunnerConfiguration.verbose) {
      console.log("[CircuitRunner] executeComponent called");
    }
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        ...opts,
        platform: this._circuitRunnerConfiguration.platform,
        projectConfig: this._circuitRunnerConfiguration.projectConfig,
        debugNamespace: this._debugNamespace
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    this._executionContext.tsConfig = null;
    const element = typeof component === "function" ? component() : component;
    this._executionContext.circuit.add(element);
  }
  on(event, callback) {
    var _a;
    (_a = this._eventListeners)[event] ?? (_a[event] = []);
    this._eventListeners[event].push(callback);
    this._executionContext?.circuit.on(event, callback);
  }
  async renderUntilSettled() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    try {
      await this._executionContext.circuit.renderUntilSettled();
    } catch (error) {
      throw enhanceRootCircuitHasNoChildrenError(
        error,
        this._executionContext.entrypoint
      );
    }
  }
  async getCircuitJson() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    try {
      return this._executionContext.circuit.getCircuitJson();
    } catch (error) {
      throw enhanceRootCircuitHasNoChildrenError(
        error,
        this._executionContext.entrypoint
      );
    }
  }
  clearEventListeners() {
    if (this._executionContext?.circuit) {
      for (const event in this._eventListeners) {
        for (const listener of this._eventListeners[event]) {
          const circuit = this._executionContext.circuit;
          circuit.removeListener?.(event, listener);
        }
      }
    }
    for (const event in this._eventListeners) {
      delete this._eventListeners[event];
    }
  }
  async kill() {
    this._executionContext = null;
  }
  async setSnippetsApiBaseUrl(baseUrl) {
    this._circuitRunnerConfiguration.snippetsApiBaseUrl = baseUrl;
  }
  async setPlatformConfig(platform) {
    this._circuitRunnerConfiguration.platform = platform;
  }
  async setPlatformConfigProperty(property, value) {
    if (!this._circuitRunnerConfiguration.platform) {
      this._circuitRunnerConfiguration.platform = {};
    }
    setValueAtPath(this._circuitRunnerConfiguration.platform, property, value);
  }
  async setProjectConfig(project) {
    this._circuitRunnerConfiguration.projectConfig = project;
  }
  async setProjectConfigProperty(property, value) {
    if (!this._circuitRunnerConfiguration.projectConfig) {
      this._circuitRunnerConfiguration.projectConfig = {};
    }
    setValueAtPath(
      this._circuitRunnerConfiguration.projectConfig,
      property,
      value
    );
  }
  async enableDebug(namespace) {
    this._debugNamespace = namespace;
    if (this._executionContext) {
      const circuit = this._executionContext.circuit;
      circuit.enableDebug?.(namespace);
    }
  }
  _bindEventListeners(circuit) {
    for (const event in this._eventListeners) {
      for (const listener of this._eventListeners[event]) {
        circuit.on(event, listener);
      }
    }
  }
};

// lib/runner/runTscircuitCode.ts
async function runTscircuitCode(filesystemOrCodeString, opts) {
  if (typeof filesystemOrCodeString === "string" && !filesystemOrCodeString.includes("export")) {
    throw new Error(
      `The "export" keyword wasn't found in your provided code. You need to export a component in your code, e.g.

export default () => (
  <resistor name="R1" resistance="1k" />
)`
    );
  }
  const filesystem = typeof filesystemOrCodeString === "string" ? { "user-code.tsx": filesystemOrCodeString } : filesystemOrCodeString;
  const circuitRunner = new CircuitRunner();
  await circuitRunner.executeWithFsMap({
    fsMap: filesystem,
    ...opts
  });
  await circuitRunner.renderUntilSettled();
  return await circuitRunner.getCircuitJson();
}

// lib/runner/runTscircuitModule.ts
var runTscircuitModule = async (module, opts = {}) => {
  if (!module.startsWith("@")) {
    module = `@tsci/${module.replace(/\//, ".")}`;
  }
  const circuitJson = await runTscircuitCode(
    {
      // TODO handle exports that are not the default export by scanning
      // otherExports for components
      "user-code.tsx": `
    import Module, * as otherExports from "${module}";

    let exportName = "${opts.exportName ?? ""}"

    if ((!Module || typeof Module !== "function") && !Boolean(exportName)) {
      exportName = Object.keys(otherExports).filter(key => key[0] === key[0].toUpperCase() && typeof otherExports[key] === "function")[0]
    }

    const defaultExport = exportName ? otherExports[exportName] : Module

    if (!defaultExport) {
      throw new Error(\`No export found for module "\${module}" (tried "\${exportName ?? "default"}")\`)
    }

    export default defaultExport;
    `
    },
    {
      mainComponentProps: opts.props
    }
  );
  return circuitJson;
};
export {
  CircuitRunner,
  STATIC_ASSET_EXTENSIONS,
  isStaticAssetPath,
  runTscircuitCode,
  runTscircuitModule
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vd2Vid29ya2VyL2V4ZWN1dGlvbi1jb250ZXh0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdHNjaXJjdWl0L3BhcnRzLWVuZ2luZS9saWIvZm9vdHByaW50LXRyYW5zbGF0b3JzL2dldC1mb290cHJpbnRlci1zdHJpbmctZnJvbS1raWNhZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRzY2lyY3VpdC9wYXJ0cy1lbmdpbmUvbGliL2Zvb3RwcmludC10cmFuc2xhdG9ycy9nZXQtamxjLXBhY2thZ2UtZnJvbS1mb290cHJpbnRlci1zdHJpbmcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0c2NpcmN1aXQvcGFydHMtZW5naW5lL2xpYi9mb290cHJpbnQtdHJhbnNsYXRvcnMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0c2NpcmN1aXQvcGFydHMtZW5naW5lL2xpYi9qbGMtcGFydHMtZW5naW5lLnRzIiwgIi4uLy4uL2xpYi9nZXRQbGF0Zm9ybUNvbmZpZy50cyIsICIuLi8uLi9saWIvdXRpbHMvZHluYW1pY2FsbHktbG9hZC1kZXBlbmRlbmN5LXdpdGgtY2RuLWJhY2t1cC50cyIsICIuLi8uLi9saWIvcnVubmVyL25vcm1hbGl6ZUZzTWFwLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvdHNjb25maWdQYXRocy50cyIsICIuLi8uLi9saWIvcnVubmVyL0NpcmN1aXRSdW5uZXIudHMiLCAiLi4vLi4vbGliL3V0aWxzL2Rpcm5hbWUudHMiLCAiLi4vLi4vbGliL3V0aWxzL3Jlc29sdmVSZWxhdGl2ZVBhdGgudHMiLCAiLi4vLi4vbGliL3J1bm5lci9yZXNvbHZlRmlsZVBhdGgudHMiLCAiLi4vLi4vbGliL3V0aWxzL2dldC1pbXBvcnRzLWZyb20tY29kZS50cyIsICIuLi8uLi93ZWJ3b3JrZXIvZXZhbC1jb21waWxlZC1qcy50cyIsICIuLi8uLi93ZWJ3b3JrZXIvaW1wb3J0LWxvY2FsLWZpbGUudHMiLCAiLi4vLi4vbGliL3NoYXJlZC9zdGF0aWMtYXNzZXQtZXh0ZW5zaW9ucy50cyIsICIuLi8uLi93ZWJ3b3JrZXIvdHJhbnNmb3JtLXdpdGgtc3VjcmFzZS50cyIsICIuLi8uLi93ZWJ3b3JrZXIvaW1wb3J0LXNuaXBwZXQudHMiLCAiLi4vLi4vbGliL3V0aWxzL3Jlc29sdmUtbm9kZS1tb2R1bGUudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1ub2RlLW1vZHVsZS50cyIsICIuLi8uLi93ZWJ3b3JrZXIvaW1wb3J0LW5wbS1wYWNrYWdlLnRzIiwgIi4uLy4uL3dlYndvcmtlci9pbXBvcnQtZXZhbC1wYXRoLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkLnRzIiwgIi4uLy4uL2xpYi91dGlscy9lbmhhbmNlLXJvb3QtY2lyY3VpdC1lcnJvci50cyIsICIuLi8uLi9saWIvc2hhcmVkL29iai1wYXRoLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvcnVuVHNjaXJjdWl0Q29kZS50cyIsICIuLi8uLi9saWIvcnVubmVyL3J1blRzY2lyY3VpdE1vZHVsZS50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUm9vdENpcmN1aXQgfSBmcm9tIFwiQHRzY2lyY3VpdC9jb3JlXCJcbmltcG9ydCB0eXBlIHsgV2ViV29ya2VyQ29uZmlndXJhdGlvbiB9IGZyb20gXCJsaWIvc2hhcmVkL3R5cGVzXCJcbmltcG9ydCAqIGFzIHRzY2lyY3VpdENvcmUgZnJvbSBcIkB0c2NpcmN1aXQvY29yZVwiXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0ICogYXMgdHNjaXJjdWl0TWF0aFV0aWxzIGZyb20gXCJAdHNjaXJjdWl0L21hdGgtdXRpbHNcIlxuaW1wb3J0IHR5cGUgeyBQbGF0Zm9ybUNvbmZpZyB9IGZyb20gXCJAdHNjaXJjdWl0L3Byb3BzXCJcbmltcG9ydCB7IGdldFBsYXRmb3JtQ29uZmlnIH0gZnJvbSBcImxpYi9nZXRQbGF0Zm9ybUNvbmZpZ1wiXG5pbXBvcnQgdHlwZSB7IFRzQ29uZmlnIH0gZnJvbSBcImxpYi9ydW5uZXIvdHNjb25maWdQYXRoc1wiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDpleGVjdXRpb24tY29udGV4dFwiKVxuXG5pbnRlcmZhY2UgU3RvcmVkTG9nZ2VyIHtcbiAgaW5mbzogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZFxuICBnZXRMb2dzOiAoKSA9PiBBcnJheTx7IG1zZzogc3RyaW5nIH0+XG4gIHN0cmluZ2lmeUxvZ3M6ICgpID0+IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGlvbkNvbnRleHQgZXh0ZW5kcyBXZWJXb3JrZXJDb25maWd1cmF0aW9uIHtcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgZW50cnlwb2ludDogc3RyaW5nXG4gIHByZVN1cHBsaWVkSW1wb3J0czogUmVjb3JkPHN0cmluZywgYW55PlxuICBjaXJjdWl0OiBSb290Q2lyY3VpdFxuICBsb2dnZXI6IFN0b3JlZExvZ2dlclxuICB0c0NvbmZpZzogVHNDb25maWcgfCBudWxsXG4gIGltcG9ydFN0YWNrOiBzdHJpbmdbXVxuICBjdXJyZW50bHlJbXBvcnRpbmc6IFNldDxzdHJpbmc+XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeGVjdXRpb25Db250ZXh0KFxuICB3ZWJXb3JrZXJDb25maWd1cmF0aW9uOiBXZWJXb3JrZXJDb25maWd1cmF0aW9uLFxuICBvcHRzOiB7XG4gICAgbmFtZT86IHN0cmluZ1xuICAgIHBsYXRmb3JtPzogUGxhdGZvcm1Db25maWdcbiAgICBwcm9qZWN0Q29uZmlnPzogUGFydGlhbDxQbGF0Zm9ybUNvbmZpZz5cbiAgICBkZWJ1Z05hbWVzcGFjZT86IHN0cmluZ1xuICB9ID0ge30sXG4pOiBFeGVjdXRpb25Db250ZXh0IHtcbiAgZ2xvYmFsVGhpcy5SZWFjdCA9IFJlYWN0XG5cbiAgY29uc3QgYmFzZVBsYXRmb3JtID0gb3B0cy5wbGF0Zm9ybSB8fCBnZXRQbGF0Zm9ybUNvbmZpZygpXG4gIGNvbnN0IHBsYXRmb3JtID0gb3B0cy5wcm9qZWN0Q29uZmlnXG4gICAgPyB7IC4uLmJhc2VQbGF0Zm9ybSwgLi4ub3B0cy5wcm9qZWN0Q29uZmlnIH1cbiAgICA6IGJhc2VQbGF0Zm9ybVxuXG4gIGlmIChwbGF0Zm9ybS5wYXJ0c0VuZ2luZURpc2FibGVkKSB7XG4gICAgcGxhdGZvcm0ucGFydHNFbmdpbmUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IGNpcmN1aXQgPSBuZXcgUm9vdENpcmN1aXQoe1xuICAgIHBsYXRmb3JtLFxuICB9KVxuXG4gIGlmIChvcHRzLm5hbWUpIHtcbiAgICBjaXJjdWl0Lm5hbWUgPSBvcHRzLm5hbWVcbiAgfVxuXG4gIGlmIChvcHRzLmRlYnVnTmFtZXNwYWNlKSB7XG4gICAgY2lyY3VpdC5lbmFibGVEZWJ1ZyhvcHRzLmRlYnVnTmFtZXNwYWNlKVxuICB9XG5cbiAgY29uc3QgbG9nczogQXJyYXk8eyBtc2c6IHN0cmluZyB9PiA9IFtdXG5cbiAgcmV0dXJuIHtcbiAgICBmc01hcDoge30sXG4gICAgZW50cnlwb2ludDogXCJcIixcbiAgICBsb2dnZXI6IHtcbiAgICAgIGluZm86IChtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbG9ncy5wdXNoKHsgbXNnOiBtZXNzYWdlIH0pXG4gICAgICB9LFxuICAgICAgZ2V0TG9nczogKCkgPT4gbG9ncyxcbiAgICAgIHN0cmluZ2lmeUxvZ3M6ICgpID0+IGxvZ3MubWFwKChsb2cpID0+IGxvZy5tc2cpLmpvaW4oXCJcXG5cIiksXG4gICAgfSxcbiAgICBwcmVTdXBwbGllZEltcG9ydHM6IHtcbiAgICAgIFwiQHRzY2lyY3VpdC9jb3JlXCI6IHRzY2lyY3VpdENvcmUsXG4gICAgICB0c2NpcmN1aXQ6IHRzY2lyY3VpdENvcmUsXG4gICAgICBcIkB0c2NpcmN1aXQvbWF0aC11dGlsc1wiOiB0c2NpcmN1aXRNYXRoVXRpbHMsXG4gICAgICByZWFjdDogUmVhY3QsXG4gICAgICBkZWJ1ZzogRGVidWcsXG5cbiAgICAgIC8vIFRoaXMgaXMgdXN1YWxseSB1c2VkIGFzIGEgdHlwZSBpbXBvcnQsIHdlIGNhbiByZW1vdmUgdGhlIHNoaW0gd2hlbiB3ZVxuICAgICAgLy8gaWdub3JlIHR5cGUgaW1wb3J0cyBpbiBnZXRJbXBvcnRzRnJvbUNvZGVcbiAgICAgIFwiQHRzY2lyY3VpdC9wcm9wc1wiOiB7fSxcbiAgICB9LFxuICAgIGNpcmN1aXQsXG4gICAgdHNDb25maWc6IG51bGwsXG4gICAgaW1wb3J0U3RhY2s6IFtdLFxuICAgIGN1cnJlbnRseUltcG9ydGluZzogbmV3IFNldDxzdHJpbmc+KCksXG4gICAgLi4ud2ViV29ya2VyQ29uZmlndXJhdGlvbixcbiAgfVxufVxuIiwgIi8qKlxuICogVHJhbnNmb3JtcyBhIEtpQ2FkIGZvb3RwcmludCBzdHJpbmcgaW50byBhIGdlbmVyaWMgXCJmb290cHJpbnRlciBzdHJpbmdcIi5cbiAqIEZvciBub3csIHRoaXMgaXMgYSBzaW1wbGlmaWVkIGNvbnZlcnNpb24gdG8gYSBzdGFuZGFyZCBwYWNrYWdlIG5hbWUuXG4gKiBlLmcuIFwia2ljYWQ6UmVzaXN0b3JfU01EOlJfMDYwM18xNjA4TWV0cmljXCIgLT4gXCIwNjAzXCJcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZvb3RwcmludGVyU3RyaW5nRnJvbUtpY2FkID0gKFxuICBraWNhZEZvb3RwcmludDogc3RyaW5nLFxuKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgLy8ga2ljYWQ6UmVzaXN0b3JfU01EOlJfMDYwM18xNjA4TWV0cmljIC0+IDA2MDNcbiAgbGV0IG1hdGNoID0ga2ljYWRGb290cHJpbnQubWF0Y2goLzpbUkNdXyhcXGR7NH0pXy8pXG4gIGlmIChtYXRjaCkgcmV0dXJuIG1hdGNoWzFdXG5cbiAgLy8ga2ljYWQ6UGFja2FnZV9TTzpTT0lDLThfMy45eDQuOW1tX1AxLjI3bW0gLT4gU09JQy04XG4gIC8vIGtpY2FkOlBhY2thZ2VfVE9fU09UX1NNRDpTT1QtMjMgLT4gU09ULTIzXG4gIG1hdGNoID0ga2ljYWRGb290cHJpbnQubWF0Y2goXG4gICAgLzooU09JQy1cXGQrfFNPVC1cXGQrfFNPRC1cXGQrfFNTT1AtXFxkK3xUU1NPUC1cXGQrfFFGUC1cXGQrfFFGTi1cXGQrKS8sXG4gIClcbiAgaWYgKG1hdGNoKSByZXR1cm4gbWF0Y2hbMV1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG4iLCAiLyoqXG4gKiBUcmFuc2Zvcm1zIGEgZ2VuZXJpYyBcImZvb3RwcmludGVyIHN0cmluZ1wiIGludG8gYSBKTEMtY29tcGF0aWJsZSBwYWNrYWdlIG5hbWUuXG4gKiBlLmcuIFwiY2FwMDYwM1wiIC0+IFwiMDYwM1wiXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRKbGNQYWNrYWdlRnJvbUZvb3RwcmludGVyU3RyaW5nID0gKFxuICBmb290cHJpbnRlclN0cmluZzogc3RyaW5nLFxuKTogc3RyaW5nID0+IHtcbiAgaWYgKGZvb3RwcmludGVyU3RyaW5nLmluY2x1ZGVzKFwiY2FwXCIpKSB7XG4gICAgcmV0dXJuIGZvb3RwcmludGVyU3RyaW5nLnJlcGxhY2UoL2NhcC9nLCBcIlwiKVxuICB9XG4gIHJldHVybiBmb290cHJpbnRlclN0cmluZ1xufVxuIiwgImltcG9ydCB7IGdldEZvb3RwcmludGVyU3RyaW5nRnJvbUtpY2FkIH0gZnJvbSBcIi4vZ2V0LWZvb3RwcmludGVyLXN0cmluZy1mcm9tLWtpY2FkXCJcbmltcG9ydCB7IGdldEpsY1BhY2thZ2VGcm9tRm9vdHByaW50ZXJTdHJpbmcgfSBmcm9tIFwiLi9nZXQtamxjLXBhY2thZ2UtZnJvbS1mb290cHJpbnRlci1zdHJpbmdcIlxuXG4vKipcbiAqIEdldCBhIEpMQy1jb21wYXRpYmxlIHBhY2thZ2UgbmFtZSBmcm9tIGEgZm9vdHByaW50IHN0cmluZywgd2hpY2ggY291bGQgYmVcbiAqIGEgS2lDYWQgZm9vdHByaW50IG9yIGEgZ2VuZXJpYyBcImZvb3RwcmludGVyIHN0cmluZ1wiLlxuICovXG5leHBvcnQgY29uc3QgZ2V0SmxjcGNiUGFja2FnZU5hbWUgPSAoXG4gIGZvb3RwcmludDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKCFmb290cHJpbnQpIHJldHVybiB1bmRlZmluZWRcblxuICBpZiAoZm9vdHByaW50LnN0YXJ0c1dpdGgoXCJraWNhZDpcIikpIHtcbiAgICBjb25zdCBmb290cHJpbnRlclN0cmluZyA9IGdldEZvb3RwcmludGVyU3RyaW5nRnJvbUtpY2FkKGZvb3RwcmludClcbiAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmcpIHtcbiAgICAgIHJldHVybiBnZXRKbGNQYWNrYWdlRnJvbUZvb3RwcmludGVyU3RyaW5nKGZvb3RwcmludGVyU3RyaW5nKVxuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciB1bi1tYXRjaGVkIEtpQ2FkIHN0cmluZ3NcbiAgICByZXR1cm4gZm9vdHByaW50XG4gIH1cblxuICAvLyBOb3QgYSBLaUNhZCBzdHJpbmcsIGFzc3VtZSBpdCdzIGEgZm9vdHByaW50ZXIgc3RyaW5nXG4gIHJldHVybiBnZXRKbGNQYWNrYWdlRnJvbUZvb3RwcmludGVyU3RyaW5nKGZvb3RwcmludClcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFBhcnRzRW5naW5lLCBTdXBwbGllclBhcnROdW1iZXJzIH0gZnJvbSBcIkB0c2NpcmN1aXQvcHJvcHNcIlxuaW1wb3J0IHsgZ2V0SmxjcGNiUGFja2FnZU5hbWUgfSBmcm9tIFwiLi9mb290cHJpbnQtdHJhbnNsYXRvcnMvaW5kZXhcIlxuXG5leHBvcnQgY29uc3QgY2FjaGUgPSBuZXcgTWFwPHN0cmluZywgYW55PigpXG5cbmNvbnN0IGdldEpsY1BhcnRzQ2FjaGVkID0gYXN5bmMgKG5hbWU6IGFueSwgcGFyYW1zOiBhbnkpID0+IHtcbiAgY29uc3QgcGFyYW1TdHJpbmcgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAuLi5wYXJhbXMsXG4gICAganNvbjogXCJ0cnVlXCIsXG4gIH0pLnRvU3RyaW5nKClcbiAgaWYgKGNhY2hlLmhhcyhwYXJhbVN0cmluZykpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KHBhcmFtU3RyaW5nKVxuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgYGh0dHBzOi8vamxjc2VhcmNoLnRzY2lyY3VpdC5jb20vJHtuYW1lfS9saXN0PyR7cGFyYW1TdHJpbmd9YCxcbiAgKVxuICBjb25zdCByZXNwb25zZUpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgY2FjaGUuc2V0KHBhcmFtU3RyaW5nLCByZXNwb25zZUpzb24pXG4gIHJldHVybiByZXNwb25zZUpzb25cbn1cblxuY29uc3Qgd2l0aEJhc2ljUGFydFByZWZlcmVuY2UgPSAocGFydHM6IGFueVtdIHwgdW5kZWZpbmVkKSA9PiB7XG4gIGlmICghcGFydHMpIHJldHVybiBbXVxuICByZXR1cm4gWy4uLnBhcnRzXS5zb3J0KFxuICAgIChhLCBiKSA9PiBOdW1iZXIoYi5pc19iYXNpYyA/PyBmYWxzZSkgLSBOdW1iZXIoYS5pc19iYXNpYyA/PyBmYWxzZSksXG4gIClcbn1cblxuZXhwb3J0IGNvbnN0IGpsY1BhcnRzRW5naW5lOiBQYXJ0c0VuZ2luZSA9IHtcbiAgZmluZFBhcnQ6IGFzeW5jICh7XG4gICAgc291cmNlQ29tcG9uZW50LFxuICAgIGZvb3RwcmludGVyU3RyaW5nLFxuICB9KTogUHJvbWlzZTxTdXBwbGllclBhcnROdW1iZXJzPiA9PiB7XG4gICAgY29uc3QgamxjcGNiUGFja2FnZSA9IGdldEpsY3BjYlBhY2thZ2VOYW1lKGZvb3RwcmludGVyU3RyaW5nKVxuXG4gICAgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Jlc2lzdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgcmVzaXN0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcInJlc2lzdG9yc1wiLCB7XG4gICAgICAgIHJlc2lzdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5yZXNpc3RhbmNlLFxuICAgICAgICBwYWNrYWdlOiBqbGNwY2JQYWNrYWdlLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiB3aXRoQmFzaWNQYXJ0UHJlZmVyZW5jZShyZXNpc3RvcnMpXG4gICAgICAgICAgLm1hcCgocjogYW55KSA9PiBgQyR7ci5sY3NjfWApXG4gICAgICAgICAgLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfY2FwYWNpdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgY2FwYWNpdG9ycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJjYXBhY2l0b3JzXCIsIHtcbiAgICAgICAgY2FwYWNpdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5jYXBhY2l0YW5jZSxcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogd2l0aEJhc2ljUGFydFByZWZlcmVuY2UoY2FwYWNpdG9ycylcbiAgICAgICAgICAubWFwKChjOiBhbnkpID0+IGBDJHtjLmxjc2N9YClcbiAgICAgICAgICAuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9waW5faGVhZGVyXCJcbiAgICApIHtcbiAgICAgIGxldCBwaXRjaDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmc/LmluY2x1ZGVzKFwiX3BcIikpIHtcbiAgICAgICAgcGl0Y2ggPSBOdW1iZXIoZm9vdHByaW50ZXJTdHJpbmcuc3BsaXQoXCJfcFwiKVsxXSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXG4gICAgICAgIFwiaGVhZGVyc1wiLFxuICAgICAgICBwaXRjaFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiB3aXRoQmFzaWNQYXJ0UHJlZmVyZW5jZShoZWFkZXJzKVxuICAgICAgICAgIC5tYXAoKGg6IGFueSkgPT4gYEMke2gubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3BvdGVudGlvbWV0ZXJcIlxuICAgICkge1xuICAgICAgY29uc3QgeyBwb3RlbnRpb21ldGVycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJwb3RlbnRpb21ldGVyc1wiLCB7XG4gICAgICAgIHJlc2lzdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5tYXhfcmVzaXN0YW5jZSxcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKHBvdGVudGlvbWV0ZXJzKVxuICAgICAgICAgIC5tYXAoKHA6IGFueSkgPT4gYEMke3AubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2Rpb2RlXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgZGlvZGVzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImRpb2Rlc1wiLCB7XG4gICAgICAgIHBhY2thZ2U6IGpsY3BjYlBhY2thZ2UsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiB3aXRoQmFzaWNQYXJ0UHJlZmVyZW5jZShkaW9kZXMpXG4gICAgICAgICAgLm1hcCgoZDogYW55KSA9PiBgQyR7ZC5sY3NjfWApXG4gICAgICAgICAgLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfY2hpcFwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IGNoaXBzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImNoaXBzXCIsIHtcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKGNoaXBzKVxuICAgICAgICAgIC5tYXAoKGM6IGFueSkgPT4gYEMke2MubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3RyYW5zaXN0b3JcIlxuICAgICkge1xuICAgICAgY29uc3QgeyB0cmFuc2lzdG9ycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJ0cmFuc2lzdG9yc1wiLCB7XG4gICAgICAgIHBhY2thZ2U6IGpsY3BjYlBhY2thZ2UsXG4gICAgICAgIHRyYW5zaXN0b3JfdHlwZTogc291cmNlQ29tcG9uZW50LnRyYW5zaXN0b3JfdHlwZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKHRyYW5zaXN0b3JzKVxuICAgICAgICAgIC5tYXAoKHQ6IGFueSkgPT4gYEMke3QubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Bvd2VyX3NvdXJjZVwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHBvd2VyX3NvdXJjZXMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicG93ZXJfc291cmNlc1wiLCB7XG4gICAgICAgIHZvbHRhZ2U6IHNvdXJjZUNvbXBvbmVudC52b2x0YWdlLFxuICAgICAgICBwYWNrYWdlOiBqbGNwY2JQYWNrYWdlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogd2l0aEJhc2ljUGFydFByZWZlcmVuY2UocG93ZXJfc291cmNlcylcbiAgICAgICAgICAubWFwKChwOiBhbnkpID0+IGBDJHtwLmxjc2N9YClcbiAgICAgICAgICAuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9pbmR1Y3RvclwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IGluZHVjdG9ycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJpbmR1Y3RvcnNcIiwge1xuICAgICAgICBpbmR1Y3RhbmNlOiBzb3VyY2VDb21wb25lbnQuaW5kdWN0YW5jZSxcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKGluZHVjdG9ycylcbiAgICAgICAgICAubWFwKChpOiBhbnkpID0+IGBDJHtpLmxjc2N9YClcbiAgICAgICAgICAuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9jcnlzdGFsXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgY3J5c3RhbHMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwiY3J5c3RhbHNcIiwge1xuICAgICAgICBmcmVxdWVuY3k6IHNvdXJjZUNvbXBvbmVudC5mcmVxdWVuY3ksXG4gICAgICAgIGxvYWRfY2FwYWNpdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5sb2FkX2NhcGFjaXRhbmNlLFxuICAgICAgICBwYWNrYWdlOiBqbGNwY2JQYWNrYWdlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogd2l0aEJhc2ljUGFydFByZWZlcmVuY2UoY3J5c3RhbHMpXG4gICAgICAgICAgLm1hcCgoYzogYW55KSA9PiBgQyR7Yy5sY3NjfWApXG4gICAgICAgICAgLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbW9zZmV0XCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbW9zZmV0cyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJtb3NmZXRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgICAgbW9zZmV0X21vZGU6IHNvdXJjZUNvbXBvbmVudC5tb3NmZXRfbW9kZSxcbiAgICAgICAgY2hhbm5lbF90eXBlOiBzb3VyY2VDb21wb25lbnQuY2hhbm5lbF90eXBlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogd2l0aEJhc2ljUGFydFByZWZlcmVuY2UobW9zZmV0cylcbiAgICAgICAgICAubWFwKChtOiBhbnkpID0+IGBDJHttLmxjc2N9YClcbiAgICAgICAgICAuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9yZXNvbmF0b3JcIlxuICAgICkge1xuICAgICAgY29uc3QgeyByZXNvbmF0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcInJlc29uYXRvcnNcIiwge1xuICAgICAgICBmcmVxdWVuY3k6IHNvdXJjZUNvbXBvbmVudC5mcmVxdWVuY3ksXG4gICAgICAgIHBhY2thZ2U6IGpsY3BjYlBhY2thZ2UsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiB3aXRoQmFzaWNQYXJ0UHJlZmVyZW5jZShyZXNvbmF0b3JzKVxuICAgICAgICAgIC5tYXAoKHI6IGFueSkgPT4gYEMke3IubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3N3aXRjaFwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHN3aXRjaGVzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcInN3aXRjaGVzXCIsIHtcbiAgICAgICAgc3dpdGNoX3R5cGU6IHNvdXJjZUNvbXBvbmVudC50eXBlLFxuICAgICAgICBwYWNrYWdlOiBqbGNwY2JQYWNrYWdlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogd2l0aEJhc2ljUGFydFByZWZlcmVuY2Uoc3dpdGNoZXMpXG4gICAgICAgICAgLm1hcCgoczogYW55KSA9PiBgQyR7cy5sY3NjfWApXG4gICAgICAgICAgLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbGVkXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbGVkcyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJsZWRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKGxlZHMpXG4gICAgICAgICAgLm1hcCgobDogYW55KSA9PiBgQyR7bC5sY3NjfWApXG4gICAgICAgICAgLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfZnVzZVwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IGZ1c2VzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImZ1c2VzXCIsIHtcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKGZ1c2VzKVxuICAgICAgICAgIC5tYXAoKGw6IGFueSkgPT4gYEMke2wubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9XG4gIH0sXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBQbGF0Zm9ybUNvbmZpZywgU3BpY2VFbmdpbmUgfSBmcm9tIFwiQHRzY2lyY3VpdC9wcm9wc1wiXG5pbXBvcnQgeyBqbGNQYXJ0c0VuZ2luZSB9IGZyb20gXCJAdHNjaXJjdWl0L3BhcnRzLWVuZ2luZVwiXG5pbXBvcnQgeyBwYXJzZUtpY2FkTW9kVG9DaXJjdWl0SnNvbiB9IGZyb20gXCJraWNhZC1jb21wb25lbnQtY29udmVydGVyXCJcbmltcG9ydCB7IGR5bmFtaWNhbGx5TG9hZERlcGVuZGVuY3lXaXRoQ2RuQmFja3VwIH0gZnJvbSBcIi4vdXRpbHMvZHluYW1pY2FsbHktbG9hZC1kZXBlbmRlbmN5LXdpdGgtY2RuLWJhY2t1cFwiXG5jb25zdCBLSUNBRF9GT09UUFJJTlRfQ0FDSEVfVVJMID0gXCJodHRwczovL2tpY2FkLW1vZC1jYWNoZS50c2NpcmN1aXQuY29tXCJcblxubGV0IG5nc3BpY2VFbmdpbmVDYWNoZTogU3BpY2VFbmdpbmUgfCBudWxsID0gbnVsbFxuXG5leHBvcnQgY29uc3QgZ2V0UGxhdGZvcm1Db25maWcgPSAoKTogUGxhdGZvcm1Db25maWcgPT4gKHtcbiAgcGFydHNFbmdpbmU6IGpsY1BhcnRzRW5naW5lLFxuICBzcGljZUVuZ2luZU1hcDoge1xuICAgIG5nc3BpY2U6IHtcbiAgICAgIHNpbXVsYXRlOiBhc3luYyAoc3BpY2U6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoIW5nc3BpY2VFbmdpbmVDYWNoZSkge1xuICAgICAgICAgIGNvbnN0IGNyZWF0ZU5nc3BpY2VTcGljZUVuZ2luZSA9XG4gICAgICAgICAgICBhd2FpdCBkeW5hbWljYWxseUxvYWREZXBlbmRlbmN5V2l0aENkbkJhY2t1cChcbiAgICAgICAgICAgICAgXCJAdHNjaXJjdWl0L25nc3BpY2Utc3BpY2UtZW5naW5lXCIsXG4gICAgICAgICAgICApLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDb3VsZCBub3QgbG9hZCBuZ3NwaWNlIGVuZ2luZSBmcm9tIGxvY2FsIG5vZGVfbW9kdWxlcyBvciBDRE4gZmFsbGJhY2suXCIsXG4gICAgICAgICAgICAgICAgeyBjYXVzZTogZXJyb3IgfSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgIGlmIChjcmVhdGVOZ3NwaWNlU3BpY2VFbmdpbmUpIHtcbiAgICAgICAgICAgIG5nc3BpY2VFbmdpbmVDYWNoZSA9IGF3YWl0IGNyZWF0ZU5nc3BpY2VTcGljZUVuZ2luZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZ3NwaWNlRW5naW5lQ2FjaGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNvdWxkIG5vdCBsb2FkIG5nc3BpY2UgZW5naW5lIGZyb20gbG9jYWwgbm9kZV9tb2R1bGVzIG9yIENETiBmYWxsYmFjay5cIixcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmdzcGljZUVuZ2luZUNhY2hlLnNpbXVsYXRlKHNwaWNlKVxuICAgICAgfSxcbiAgICB9LFxuICB9LFxuICBmb290cHJpbnRMaWJyYXJ5TWFwOiB7XG4gICAga2ljYWQ6IGFzeW5jIChmb290cHJpbnROYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSBgJHtLSUNBRF9GT09UUFJJTlRfQ0FDSEVfVVJMfS8ke2Zvb3RwcmludE5hbWV9YFxuICAgICAgY29uc3QgY2lyY3VpdEpzb25VcmwgPSBgJHtiYXNlVXJsfS5jaXJjdWl0Lmpzb25gXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChjaXJjdWl0SnNvblVybClcbiAgICAgIGNvbnN0IHJhdyA9IGF3YWl0IHJlcy5qc29uKClcbiAgICAgIC8vIEZpbHRlciBwY2Jfc2lsa3NjcmVlbl90ZXh0IHRvIG9ubHkga2VlcCBlbnRyaWVzIHdpdGggdGV4dCA9PT0gXCJSRUYqKlwiXG4gICAgICAvLyBBcHBseSBmaWx0ZXJpbmcgb25seSB0byBlbGVtZW50cyBjb21pbmcgZnJvbSB0aGUga2ljYWRfbW9kX3NlcnZlciByZXNwb25zZVxuICAgICAgY29uc3QgZmlsdGVyZWQgPSBBcnJheS5pc0FycmF5KHJhdylcbiAgICAgICAgPyByYXcuZmlsdGVyKChlbCkgPT5cbiAgICAgICAgICAgIGVsPy50eXBlID09PSBcInBjYl9zaWxrc2NyZWVuX3RleHRcIiA/IGVsPy50ZXh0ID09PSBcIlJFRioqXCIgOiB0cnVlLFxuICAgICAgICAgIClcbiAgICAgICAgOiByYXdcbiAgICAgIGNvbnN0IHdybFVybCA9IGAke2Jhc2VVcmx9LndybGBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvb3RwcmludENpcmN1aXRKc29uOiBmaWx0ZXJlZCxcbiAgICAgICAgY2FkTW9kZWw6IHsgd3JsVXJsLCBtb2RlbFVuaXRUb01tU2NhbGU6IDIuNTQgfSxcbiAgICAgIH1cbiAgICB9LFxuICB9LFxuICBmb290cHJpbnRGaWxlUGFyc2VyTWFwOiB7XG4gICAga2ljYWRfbW9kOiB7XG4gICAgICBsb2FkRnJvbVVybDogYXN5bmMgKHVybDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGtpY2FkQ29udGVudCA9IGF3YWl0IGZldGNoKHVybCkudGhlbigocmVzKSA9PiByZXMudGV4dCgpKVxuICAgICAgICBjb25zdCBraWNhZEpzb24gPSBhd2FpdCBwYXJzZUtpY2FkTW9kVG9DaXJjdWl0SnNvbihraWNhZENvbnRlbnQpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm9vdHByaW50Q2lyY3VpdEpzb246IEFycmF5LmlzQXJyYXkoa2ljYWRKc29uKVxuICAgICAgICAgICAgPyBraWNhZEpzb25cbiAgICAgICAgICAgIDogW2tpY2FkSnNvbl0sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn0pXG4iLCAiZXhwb3J0IGNvbnN0IGR5bmFtaWNhbGx5TG9hZERlcGVuZGVuY3lXaXRoQ2RuQmFja3VwID0gYXN5bmMgKFxuICBwYWNrYWdlTmFtZTogc3RyaW5nLFxuKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBGaXJzdCwgdHJ5IHRvIGltcG9ydCB1c2luZyBOb2RlLmpzIHJlc29sdXRpb25cbiAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBpbXBvcnQocGFja2FnZU5hbWUpXG4gICAgcmV0dXJuIG1vZHVsZS5kZWZhdWx0XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIGxvYWQgJHtwYWNrYWdlTmFtZX0gbG9jYWxseSwgdHJ5aW5nIENETiBmYWxsYmFjay4uLmApXG4gICAgLy8gRmFsbGJhY2sgdG8gSnNEZWxpdnIgQ0ROIGZvciBicm93c2VyIGVudmlyb25tZW50c1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYGh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vJHtwYWNrYWdlTmFtZX0vK2VzbWAsXG4gICAgICApXG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBmZXRjaCAke3BhY2thZ2VOYW1lfSBmcm9tIENETjogJHtyZXMuc3RhdHVzVGV4dH1gLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBjb25zdCBjb2RlID0gYXdhaXQgcmVzLnRleHQoKVxuICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtjb2RlXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiB9KVxuICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0OiBsb2FkZWRNb2R1bGUgfSA9IGF3YWl0IGltcG9ydCh1cmwpXG4gICAgICAgIHJldHVybiBsb2FkZWRNb2R1bGVcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGNkbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDRE4gZmFsbGJhY2sgZm9yICR7cGFja2FnZU5hbWV9IGFsc28gZmFpbGVkOmAsIGNkbkVycm9yKVxuICAgICAgdGhyb3cgY2RuRXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRmlsZVBhdGgoZmlsZVBhdGg6IHN0cmluZykge1xuICBsZXQgbm9ybUZpbGVQYXRoID0gZmlsZVBhdGhcbiAgbm9ybUZpbGVQYXRoID0gbm9ybUZpbGVQYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG4gIG5vcm1GaWxlUGF0aCA9IG5vcm1GaWxlUGF0aC50cmltKClcbiAgaWYgKG5vcm1GaWxlUGF0aC5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICBub3JtRmlsZVBhdGggPSBub3JtRmlsZVBhdGguc2xpY2UoMilcbiAgfVxuICBpZiAobm9ybUZpbGVQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgbm9ybUZpbGVQYXRoID0gbm9ybUZpbGVQYXRoLnNsaWNlKDEpXG4gIH1cbiAgcmV0dXJuIG5vcm1GaWxlUGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRnNNYXAoZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pIHtcbiAgY29uc3Qgbm9ybWFsaXplZEZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgZm9yIChjb25zdCBbZnNQYXRoLCBmaWxlQ29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoZnNNYXApKSB7XG4gICAgbm9ybWFsaXplZEZzTWFwW25vcm1hbGl6ZUZpbGVQYXRoKGZzUGF0aCldID0gZmlsZUNvbnRlbnRcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZEZzTWFwXG59XG4iLCAiaW1wb3J0IHsgbm9ybWFsaXplRmlsZVBhdGggfSBmcm9tIFwiLi9ub3JtYWxpemVGc01hcFwiXG5cbmV4cG9ydCB0eXBlIFRzQ29uZmlnID0ge1xuICBjb21waWxlck9wdGlvbnM/OiB7XG4gICAgYmFzZVVybD86IHN0cmluZ1xuICAgIHBhdGhzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+XG4gICAgW2tleTogc3RyaW5nXTogdW5rbm93blxuICB9XG4gIGV4dGVuZHM/OiBzdHJpbmcgfCBzdHJpbmdbXVxuICBmaWxlcz86IHN0cmluZ1tdXG4gIHJlZmVyZW5jZXM/OiBBcnJheTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj5cbiAgaW5jbHVkZT86IHN0cmluZ1tdXG4gIGV4Y2x1ZGU/OiBzdHJpbmdbXVxuICBba2V5OiBzdHJpbmddOiB1bmtub3duXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUc0NvbmZpZyhcbiAgZnNNYXBPckFsbEZpbGVQYXRoczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZ1tdLFxuKTogVHNDb25maWcgfCBudWxsIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZnNNYXBPckFsbEZpbGVQYXRocykpIHJldHVybiBudWxsXG4gIGNvbnN0IHRzY29uZmlnQ29udGVudCA9IGZzTWFwT3JBbGxGaWxlUGF0aHNbXCJ0c2NvbmZpZy5qc29uXCJdXG4gIGlmICghdHNjb25maWdDb250ZW50KSByZXR1cm4gbnVsbFxuICB0cnkge1xuICAgIGNvbnN0IHNhbml0aXplZENvbnRlbnQgPSB0c2NvbmZpZ0NvbnRlbnQucmVwbGFjZShcbiAgICAgIC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvfFxcL1xcLy4qL2csXG4gICAgICBcIlwiLFxuICAgICkgLy8gcmVtb3ZlIGNvbW1lbnRzXG5cbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNhbml0aXplZENvbnRlbnQpIGFzIFRzQ29uZmlnXG4gICAgcmV0dXJuIHBhcnNlZFxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSB0c2NvbmZpZy5qc29uOiAke2UubWVzc2FnZX1gKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlV2l0aFRzY29uZmlnUGF0aHMob3B0czoge1xuICBpbXBvcnRQYXRoOiBzdHJpbmdcbiAgbm9ybWFsaXplZEZpbGVQYXRoTWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+XG4gIGV4dGVuc2lvbnM6IHN0cmluZ1tdXG4gIHRzQ29uZmlnOiBUc0NvbmZpZyB8IG51bGxcbn0pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgeyBpbXBvcnRQYXRoLCBub3JtYWxpemVkRmlsZVBhdGhNYXAsIGV4dGVuc2lvbnMsIHRzQ29uZmlnIH0gPSBvcHRzXG4gIGNvbnN0IHBhdGhzID0gdHNDb25maWc/LmNvbXBpbGVyT3B0aW9ucz8ucGF0aHNcbiAgaWYgKCFwYXRocykgcmV0dXJuIG51bGxcbiAgY29uc3QgYmFzZVVybCA9IHRzQ29uZmlnPy5jb21waWxlck9wdGlvbnM/LmJhc2VVcmwgfHwgXCIuXCJcblxuICBjb25zdCB0cnlSZXNvbHZlQ2FuZGlkYXRlID0gKGNhbmRpZGF0ZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZENhbmRpZGF0ZSA9IG5vcm1hbGl6ZUZpbGVQYXRoKGNhbmRpZGF0ZSlcbiAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhub3JtYWxpemVkQ2FuZGlkYXRlKSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQobm9ybWFsaXplZENhbmRpZGF0ZSkhXG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbnMpIHtcbiAgICAgIGNvbnN0IHdpdGhFeHQgPSBgJHtub3JtYWxpemVkQ2FuZGlkYXRlfS4ke2V4dH1gXG4gICAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyh3aXRoRXh0KSkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplZEZpbGVQYXRoTWFwLmdldCh3aXRoRXh0KSFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZvciAoY29uc3QgW2FsaWFzLCB0YXJnZXRzXSBvZiBPYmplY3QuZW50cmllcyhwYXRocykpIHtcbiAgICAvLyBTdXBwb3J0IHBhdHRlcm5zIGxpa2UgXCJAc3JjLypcIiBvciBcInV0aWxzLypcIiBhbmQgYWxzbyBleGFjdCBtYXRjaGVzIHdpdGhvdXQgXCIqXCJcbiAgICBjb25zdCBoYXNXaWxkY2FyZCA9IGFsaWFzLmluY2x1ZGVzKFwiKlwiKVxuICAgIGlmIChoYXNXaWxkY2FyZCkge1xuICAgICAgY29uc3QgW3ByZWZpeCwgc3VmZml4XSA9IGFsaWFzLnNwbGl0KFwiKlwiKVxuICAgICAgaWYgKFxuICAgICAgICAhaW1wb3J0UGF0aC5zdGFydHNXaXRoKHByZWZpeCkgfHxcbiAgICAgICAgIWltcG9ydFBhdGguZW5kc1dpdGgoc3VmZml4IHx8IFwiXCIpXG4gICAgICApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJNYXRjaCA9IGltcG9ydFBhdGguc2xpY2UoXG4gICAgICAgIHByZWZpeC5sZW5ndGgsXG4gICAgICAgIGltcG9ydFBhdGgubGVuZ3RoIC0gKHN1ZmZpeCA/IHN1ZmZpeC5sZW5ndGggOiAwKSxcbiAgICAgIClcbiAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgY29uc3QgcmVwbGFjZWQgPSB0YXJnZXQucmVwbGFjZShcIipcIiwgc3Rhck1hdGNoKVxuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPVxuICAgICAgICAgIGJhc2VVcmwgJiYgIXJlcGxhY2VkLnN0YXJ0c1dpdGgoXCIuL1wiKSAmJiAhcmVwbGFjZWQuc3RhcnRzV2l0aChcIi9cIilcbiAgICAgICAgICAgID8gYCR7YmFzZVVybH0vJHtyZXBsYWNlZH1gXG4gICAgICAgICAgICA6IHJlcGxhY2VkXG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gdHJ5UmVzb2x2ZUNhbmRpZGF0ZShjYW5kaWRhdGUpXG4gICAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbXBvcnRQYXRoICE9PSBhbGlhcykgY29udGludWVcbiAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID1cbiAgICAgICAgICBiYXNlVXJsICYmICF0YXJnZXQuc3RhcnRzV2l0aChcIi4vXCIpICYmICF0YXJnZXQuc3RhcnRzV2l0aChcIi9cIilcbiAgICAgICAgICAgID8gYCR7YmFzZVVybH0vJHt0YXJnZXR9YFxuICAgICAgICAgICAgOiB0YXJnZXRcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB0cnlSZXNvbHZlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCByZXNvbHZlZFBhdGhGcm9tQmFzZVVybCA9IHJlc29sdmVXaXRoQmFzZVVybCh7XG4gICAgaW1wb3J0UGF0aCxcbiAgICBub3JtYWxpemVkRmlsZVBhdGhNYXAsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICB0c0NvbmZpZyxcbiAgfSlcblxuICBpZiAocmVzb2x2ZWRQYXRoRnJvbUJhc2VVcmwpIHJldHVybiByZXNvbHZlZFBhdGhGcm9tQmFzZVVybFxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlV2l0aEJhc2VVcmwob3B0czoge1xuICBpbXBvcnRQYXRoOiBzdHJpbmdcbiAgbm9ybWFsaXplZEZpbGVQYXRoTWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+XG4gIGV4dGVuc2lvbnM6IHN0cmluZ1tdXG4gIHRzQ29uZmlnOiBUc0NvbmZpZyB8IG51bGxcbn0pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgeyBpbXBvcnRQYXRoLCBub3JtYWxpemVkRmlsZVBhdGhNYXAsIGV4dGVuc2lvbnMsIHRzQ29uZmlnIH0gPSBvcHRzXG4gIGNvbnN0IGJhc2VVcmwgPSB0c0NvbmZpZz8uY29tcGlsZXJPcHRpb25zPy5iYXNlVXJsXG4gIGlmICghYmFzZVVybCkgcmV0dXJuIG51bGxcblxuICBjb25zdCBmaWxlUGF0aFRvUmVzb2x2ZSA9IGAke2Jhc2VVcmx9LyR7aW1wb3J0UGF0aH1gXG4gIGNvbnN0IG5vcm1hbGl6ZWRGaWxlUGF0aCA9IG5vcm1hbGl6ZUZpbGVQYXRoKGZpbGVQYXRoVG9SZXNvbHZlKVxuXG4gIGlmIChub3JtYWxpemVkRmlsZVBhdGhNYXAuaGFzKG5vcm1hbGl6ZWRGaWxlUGF0aCkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplZEZpbGVQYXRoTWFwLmdldChub3JtYWxpemVkRmlsZVBhdGgpIVxuICB9XG5cbiAgZm9yIChjb25zdCBleHQgb2YgZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IHdpdGhFeHQgPSBgJHtub3JtYWxpemVkRmlsZVBhdGh9LiR7ZXh0fWBcbiAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyh3aXRoRXh0KSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQod2l0aEV4dCkhXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXNUc2NvbmZpZ1BhdGhQYXR0ZXJuKFxuICBpbXBvcnRQYXRoOiBzdHJpbmcsXG4gIHRzQ29uZmlnOiBUc0NvbmZpZyB8IG51bGwsXG4pOiBib29sZWFuIHtcbiAgY29uc3QgcGF0aHMgPSB0c0NvbmZpZz8uY29tcGlsZXJPcHRpb25zPy5wYXRoc1xuICBpZiAoIXBhdGhzKSByZXR1cm4gZmFsc2VcblxuICBmb3IgKGNvbnN0IFthbGlhc10gb2YgT2JqZWN0LmVudHJpZXMocGF0aHMpKSB7XG4gICAgY29uc3QgaGFzV2lsZGNhcmQgPSBhbGlhcy5pbmNsdWRlcyhcIipcIilcbiAgICBpZiAoaGFzV2lsZGNhcmQpIHtcbiAgICAgIGNvbnN0IFtwcmVmaXgsIHN1ZmZpeF0gPSBhbGlhcy5zcGxpdChcIipcIilcbiAgICAgIGlmIChpbXBvcnRQYXRoLnN0YXJ0c1dpdGgocHJlZml4KSAmJiBpbXBvcnRQYXRoLmVuZHNXaXRoKHN1ZmZpeCB8fCBcIlwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW1wb3J0UGF0aCA9PT0gYWxpYXMpIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBBbnlDaXJjdWl0RWxlbWVudCB9IGZyb20gXCJjaXJjdWl0LWpzb25cIlxuaW1wb3J0IHR5cGUge1xuICBDaXJjdWl0UnVubmVyQXBpLFxuICBDaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbixcbn0gZnJvbSBcImxpYi9zaGFyZWQvdHlwZXNcIlxuaW1wb3J0IHR5cGUgeyBQbGF0Zm9ybUNvbmZpZyB9IGZyb20gXCJAdHNjaXJjdWl0L3Byb3BzXCJcbmltcG9ydCB7IGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi4vLi4vd2Vid29ya2VyL2V4ZWN1dGlvbi1jb250ZXh0XCJcbmltcG9ydCB7IG5vcm1hbGl6ZUZzTWFwIH0gZnJvbSBcIi4vbm9ybWFsaXplRnNNYXBcIlxuaW1wb3J0IHsgZ2V0VHNDb25maWcgfSBmcm9tIFwiLi90c2NvbmZpZ1BhdGhzXCJcbmltcG9ydCB0eXBlIHsgUm9vdENpcmN1aXQgfSBmcm9tIFwiQHRzY2lyY3VpdC9jb3JlXCJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBpbXBvcnRFdmFsUGF0aCB9IGZyb20gXCJ3ZWJ3b3JrZXIvaW1wb3J0LWV2YWwtcGF0aFwiXG5pbXBvcnQgeyBzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQgfSBmcm9tIFwiLi9zZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWRcIlxuaW1wb3J0IHsgZW5oYW5jZVJvb3RDaXJjdWl0SGFzTm9DaGlsZHJlbkVycm9yIH0gZnJvbSBcImxpYi91dGlscy9lbmhhbmNlLXJvb3QtY2lyY3VpdC1lcnJvclwiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcbmltcG9ydCB7IHNldFZhbHVlQXRQYXRoIH0gZnJvbSBcImxpYi9zaGFyZWQvb2JqLXBhdGhcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOkNpcmN1aXRSdW5uZXJcIilcblxuZXhwb3J0IGNsYXNzIENpcmN1aXRSdW5uZXIgaW1wbGVtZW50cyBDaXJjdWl0UnVubmVyQXBpIHtcbiAgX2V4ZWN1dGlvbkNvbnRleHQ6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQ+IHwgbnVsbCA9IG51bGxcbiAgX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uOiBDaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICBzbmlwcGV0c0FwaUJhc2VVcmw6IFwiaHR0cHM6Ly9yZWdpc3RyeS1hcGkudHNjaXJjdWl0LmNvbVwiLFxuICAgIGNqc1JlZ2lzdHJ5VXJsOiBcImh0dHBzOi8vY2pzLnRzY2lyY3VpdC5jb21cIixcbiAgICB2ZXJib3NlOiBmYWxzZSxcbiAgfVxuICBfZXZlbnRMaXN0ZW5lcnM6IFJlY29yZDxzdHJpbmcsICgoLi4uYXJnczogYW55W10pID0+IHZvaWQpW10+ID0ge31cbiAgX2RlYnVnTmFtZXNwYWNlOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uOiBQYXJ0aWFsPENpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uPiA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiwgY29uZmlndXJhdGlvbilcbiAgfVxuXG4gIGFzeW5jIHZlcnNpb24oKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gXCIwLjAuMFwiXG4gIH1cblxuICBhc3luYyBleGVjdXRlV2l0aEZzTWFwKG9nT3B0czoge1xuICAgIGVudHJ5cG9pbnQ/OiBzdHJpbmdcbiAgICBtYWluQ29tcG9uZW50UGF0aD86IHN0cmluZ1xuICAgIG1haW5Db21wb25lbnROYW1lPzogc3RyaW5nXG4gICAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBuYW1lPzogc3RyaW5nXG4gICAgbWFpbkNvbXBvbmVudFByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4ub2dPcHRzIH1cblxuICAgIGlmICh0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgICBEZWJ1Zy5lbmFibGUoXCJ0c2NpOmV2YWw6KlwiKVxuICAgIH1cblxuICAgIGRlYnVnKFwiZXhlY3V0ZVdpdGhGc01hcCBjYWxsZWQgd2l0aDpcIiwge1xuICAgICAgZW50cnlwb2ludDogb3B0cy5lbnRyeXBvaW50LFxuICAgICAgZnNNYXBLZXlzOiBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKSxcbiAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICB9KVxuXG4gICAgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkKG9wdHMpXG5cbiAgICBkZWJ1ZyhcImVudHJ5cG9pbnQgYWZ0ZXIgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkOlwiLCB7XG4gICAgICBlbnRyeXBvaW50OiBvcHRzLmVudHJ5cG9pbnQsXG4gICAgfSlcblxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQgPSBjcmVhdGVFeGVjdXRpb25Db250ZXh0KFxuICAgICAgdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgICAgcGxhdGZvcm06IHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtLFxuICAgICAgICBwcm9qZWN0Q29uZmlnOiB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi5wcm9qZWN0Q29uZmlnLFxuICAgICAgICBkZWJ1Z05hbWVzcGFjZTogdGhpcy5fZGVidWdOYW1lc3BhY2UsXG4gICAgICB9LFxuICAgIClcbiAgICB0aGlzLl9iaW5kRXZlbnRMaXN0ZW5lcnModGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0KVxuXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5lbnRyeXBvaW50ID0gb3B0cy5lbnRyeXBvaW50IVxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuZnNNYXAgPSBub3JtYWxpemVGc01hcChvcHRzLmZzTWFwKVxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQudHNDb25maWcgPSBnZXRUc0NvbmZpZyh0aGlzLl9leGVjdXRpb25Db250ZXh0LmZzTWFwKVxuICAgIGlmICghdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5mc01hcFtvcHRzLmVudHJ5cG9pbnQhXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnRyeXBvaW50IFwiJHtvcHRzLmVudHJ5cG9pbnR9XCIgbm90IGZvdW5kYClcbiAgICB9XG4gICAgOyhnbG9iYWxUaGlzIGFzIGFueSkuX190c2NpcmN1aXRfY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdFxuXG4gICAgY29uc3QgZW50cnlwb2ludCA9IG9wdHMuZW50cnlwb2ludCEuc3RhcnRzV2l0aChcIi4vXCIpXG4gICAgICA/IG9wdHMuZW50cnlwb2ludFxuICAgICAgOiBgLi8ke29wdHMuZW50cnlwb2ludH1gXG5cbiAgICBkZWJ1ZyhcImZpbmFsIGVudHJ5cG9pbnQ6XCIsIGVudHJ5cG9pbnQpXG4gICAgYXdhaXQgaW1wb3J0RXZhbFBhdGgoZW50cnlwb2ludCEsIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQpXG4gIH1cblxuICBhc3luYyBleGVjdXRlKGNvZGU6IHN0cmluZywgb3B0czogeyBuYW1lPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCJbQ2lyY3VpdFJ1bm5lcl0gZXhlY3V0ZSBjYWxsZWQgd2l0aCBjb2RlIGxlbmd0aDpcIixcbiAgICAgICAgY29kZS5sZW5ndGgsXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dCA9IGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQoXG4gICAgICB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbixcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgcGxhdGZvcm06IHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtLFxuICAgICAgICBwcm9qZWN0Q29uZmlnOiB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi5wcm9qZWN0Q29uZmlnLFxuICAgICAgICBkZWJ1Z05hbWVzcGFjZTogdGhpcy5fZGVidWdOYW1lc3BhY2UsXG4gICAgICB9LFxuICAgIClcbiAgICB0aGlzLl9iaW5kRXZlbnRMaXN0ZW5lcnModGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0KVxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuZnNNYXBbXCJlbnRyeXBvaW50LnRzeFwiXSA9IGNvZGVcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0LnRzQ29uZmlnID0gZ2V0VHNDb25maWcodGhpcy5fZXhlY3V0aW9uQ29udGV4dC5mc01hcClcbiAgICA7KGdsb2JhbFRoaXMgYXMgYW55KS5fX3RzY2lyY3VpdF9jaXJjdWl0ID0gdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0XG5cbiAgICBhd2FpdCBpbXBvcnRFdmFsUGF0aChcIi4vZW50cnlwb2ludC50c3hcIiwgdGhpcy5fZXhlY3V0aW9uQ29udGV4dClcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGVDb21wb25lbnQoY29tcG9uZW50OiBhbnksIG9wdHM6IHsgbmFtZT86IHN0cmluZyB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24udmVyYm9zZSkge1xuICAgICAgY29uc29sZS5sb2coXCJbQ2lyY3VpdFJ1bm5lcl0gZXhlY3V0ZUNvbXBvbmVudCBjYWxsZWRcIilcbiAgICB9XG5cbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0ID0gY3JlYXRlRXhlY3V0aW9uQ29udGV4dChcbiAgICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLFxuICAgICAge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBwbGF0Zm9ybTogdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0sXG4gICAgICAgIHByb2plY3RDb25maWc6IHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnByb2plY3RDb25maWcsXG4gICAgICAgIGRlYnVnTmFtZXNwYWNlOiB0aGlzLl9kZWJ1Z05hbWVzcGFjZSxcbiAgICAgIH0sXG4gICAgKVxuICAgIHRoaXMuX2JpbmRFdmVudExpc3RlbmVycyh0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQpXG4gICAgOyhnbG9iYWxUaGlzIGFzIGFueSkuX190c2NpcmN1aXRfY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdFxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQudHNDb25maWcgPSBudWxsXG5cbiAgICBjb25zdCBlbGVtZW50ID0gdHlwZW9mIGNvbXBvbmVudCA9PT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50KCkgOiBjb21wb25lbnRcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQuYWRkKGVsZW1lbnQgYXMgYW55KVxuICB9XG5cbiAgb24oZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCkge1xuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XSA/Pz0gW11cbiAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0ucHVzaChjYWxsYmFjaylcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0Py5jaXJjdWl0Lm9uKGV2ZW50IGFzIGFueSwgY2FsbGJhY2spXG4gIH1cblxuICBhc3luYyByZW5kZXJVbnRpbFNldHRsZWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLl9leGVjdXRpb25Db250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaXJjdWl0IGhhcyBiZWVuIGNyZWF0ZWRcIilcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdC5yZW5kZXJVbnRpbFNldHRsZWQoKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlbmhhbmNlUm9vdENpcmN1aXRIYXNOb0NoaWxkcmVuRXJyb3IoXG4gICAgICAgIGVycm9yLFxuICAgICAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0LmVudHJ5cG9pbnQsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0Q2lyY3VpdEpzb24oKTogUHJvbWlzZTxBbnlDaXJjdWl0RWxlbWVudFtdPiB7XG4gICAgaWYgKCF0aGlzLl9leGVjdXRpb25Db250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaXJjdWl0IGhhcyBiZWVuIGNyZWF0ZWRcIilcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQuZ2V0Q2lyY3VpdEpzb24oKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlbmhhbmNlUm9vdENpcmN1aXRIYXNOb0NoaWxkcmVuRXJyb3IoXG4gICAgICAgIGVycm9yLFxuICAgICAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0LmVudHJ5cG9pbnQsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY2xlYXJFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5fZXhlY3V0aW9uQ29udGV4dD8uY2lyY3VpdCkge1xuICAgICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGNvbnN0IGNpcmN1aXQgPSB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQgYXMgdW5rbm93biBhcyB7XG4gICAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb21wbGV4aXR5L25vQmFubmVkVHlwZXM6IDxleHBsYW5hdGlvbj5cbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyPzogKGV2ZW50OiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikgPT4gdm9pZFxuICAgICAgICAgIH1cbiAgICAgICAgICBjaXJjdWl0LnJlbW92ZUxpc3RlbmVyPy4oZXZlbnQsIGxpc3RlbmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGtpbGwoKSB7XG4gICAgLy8gQ2xlYW51cCByZXNvdXJjZXNcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0ID0gbnVsbFxuICB9XG5cbiAgYXN5bmMgc2V0U25pcHBldHNBcGlCYXNlVXJsKGJhc2VVcmw6IHN0cmluZykge1xuICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnNuaXBwZXRzQXBpQmFzZVVybCA9IGJhc2VVcmxcbiAgfVxuXG4gIGFzeW5jIHNldFBsYXRmb3JtQ29uZmlnKHBsYXRmb3JtOiBQbGF0Zm9ybUNvbmZpZykge1xuICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtID0gcGxhdGZvcm1cbiAgfVxuXG4gIGFzeW5jIHNldFBsYXRmb3JtQ29uZmlnUHJvcGVydHkocHJvcGVydHk6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGlmICghdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0pIHtcbiAgICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtID0ge31cbiAgICB9XG4gICAgc2V0VmFsdWVBdFBhdGgodGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0sIHByb3BlcnR5LCB2YWx1ZSlcbiAgfVxuXG4gIGFzeW5jIHNldFByb2plY3RDb25maWcocHJvamVjdDogUGFydGlhbDxQbGF0Zm9ybUNvbmZpZz4pIHtcbiAgICB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi5wcm9qZWN0Q29uZmlnID0gcHJvamVjdFxuICB9XG5cbiAgYXN5bmMgc2V0UHJvamVjdENvbmZpZ1Byb3BlcnR5KHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICBpZiAoIXRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnByb2plY3RDb25maWcpIHtcbiAgICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnByb2plY3RDb25maWcgPSB7fVxuICAgIH1cbiAgICBzZXRWYWx1ZUF0UGF0aChcbiAgICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnByb2plY3RDb25maWcsXG4gICAgICBwcm9wZXJ0eSxcbiAgICAgIHZhbHVlLFxuICAgIClcbiAgfVxuXG4gIGFzeW5jIGVuYWJsZURlYnVnKG5hbWVzcGFjZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fZGVidWdOYW1lc3BhY2UgPSBuYW1lc3BhY2VcbiAgICBpZiAodGhpcy5fZXhlY3V0aW9uQ29udGV4dCkge1xuICAgICAgY29uc3QgY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdCBhcyBhbnlcbiAgICAgIGNpcmN1aXQuZW5hYmxlRGVidWc/LihuYW1lc3BhY2UpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfYmluZEV2ZW50TGlzdGVuZXJzKGNpcmN1aXQ6IFJvb3RDaXJjdWl0KSB7XG4gICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgY2lyY3VpdC5vbihldmVudCBhcyBhbnksIGxpc3RlbmVyIGFzIGFueSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsICIvKipcbiAqIFJldHVybnMgdGhlIGRpcmVjdG9yeSBuYW1lIG9mIGEgcGF0aCwgc2ltaWxhciB0byBOb2RlLmpzIHBhdGguZGlybmFtZVxuICogV29ya3Mgb24gYm90aCBVbml4IGFuZCBXaW5kb3dzIHBhdGhzXG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBleHRyYWN0IHRoZSBkaXJlY3RvcnkgZnJvbVxuICogQHJldHVybnMgVGhlIGRpcmVjdG9yeSBwYXJ0IG9mIHRoZSBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXJuYW1lKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghcGF0aCkgcmV0dXJuIFwiLlwiXG5cbiAgLy8gTm9ybWFsaXplIHBhdGggc2VwYXJhdG9ycyB0byBmb3J3YXJkIHNsYXNoZXNcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG5cbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXNcbiAgY29uc3QgY2xlYW5QYXRoID0gbm9ybWFsaXplZFBhdGgucmVwbGFjZSgvXFwvKyQvLCBcIlwiKVxuXG4gIC8vIElmIHRoZXJlIGFyZSBubyBzbGFzaGVzLCByZXR1cm4gXCIuXCJcbiAgaWYgKGNsZWFuUGF0aC5pbmRleE9mKFwiL1wiKSA9PT0gLTEpIHJldHVybiBcIi5cIlxuXG4gIC8vIFJldHVybiBldmVyeXRoaW5nIHVwIHRvIHRoZSBsYXN0IHNsYXNoXG4gIHJldHVybiBjbGVhblBhdGguc3Vic3RyaW5nKDAsIGNsZWFuUGF0aC5sYXN0SW5kZXhPZihcIi9cIikpIHx8IFwiL1wiXG59XG4iLCAiaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gXCIuL2Rpcm5hbWVcIlxuXG4vKipcbiAqIFJlc29sdmUgYW4gaW1wb3J0UGF0aCByZWxhdGl2ZSB0byBhIGN3ZCwgc3VwcG9ydGluZyAuLi8sIC4vIGFuZCBhYnNvbHV0ZSBwYXRocy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVSZWxhdGl2ZVBhdGgoaW1wb3J0UGF0aDogc3RyaW5nLCBjd2Q6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIEhhbmRsZSBwYXJlbnQgZGlyZWN0b3J5IG5hdmlnYXRpb25cbiAgaWYgKGltcG9ydFBhdGguc3RhcnRzV2l0aChcIi4uL1wiKSkge1xuICAgIGNvbnN0IHBhcmVudERpciA9IGRpcm5hbWUoY3dkKVxuICAgIHJldHVybiByZXNvbHZlUmVsYXRpdmVQYXRoKGltcG9ydFBhdGguc2xpY2UoMyksIHBhcmVudERpcilcbiAgfVxuICAvLyBIYW5kbGUgY3VycmVudCBkaXJlY3RvcnlcbiAgaWYgKGltcG9ydFBhdGguc3RhcnRzV2l0aChcIi4vXCIpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVSZWxhdGl2ZVBhdGgoaW1wb3J0UGF0aC5zbGljZSgyKSwgY3dkKVxuICB9XG4gIC8vIEhhbmRsZSBhYnNvbHV0ZSBwYXRoXG4gIGlmIChpbXBvcnRQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIGltcG9ydFBhdGguc2xpY2UoMSlcbiAgfVxuICAvLyBIYW5kbGUgcmVsYXRpdmUgcGF0aFxuICByZXR1cm4gYCR7Y3dkfS8ke2ltcG9ydFBhdGh9YFxufVxuIiwgImltcG9ydCB7IG5vcm1hbGl6ZUZpbGVQYXRoIH0gZnJvbSBcIi4vbm9ybWFsaXplRnNNYXBcIlxuaW1wb3J0IHsgcmVzb2x2ZVJlbGF0aXZlUGF0aCB9IGZyb20gXCJsaWIvdXRpbHMvcmVzb2x2ZVJlbGF0aXZlUGF0aFwiXG5pbXBvcnQge1xuICByZXNvbHZlV2l0aFRzY29uZmlnUGF0aHMsXG4gIHR5cGUgVHNDb25maWcsXG4gIHJlc29sdmVXaXRoQmFzZVVybCxcbn0gZnJvbSBcIi4vdHNjb25maWdQYXRoc1wiXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmlsZVBhdGggPSAoXG4gIHVua25vd25GaWxlUGF0aDogc3RyaW5nLFxuICBmc01hcE9yQWxsRmlsZVBhdGhzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgc3RyaW5nW10sXG4gIGN3ZD86IHN0cmluZyxcbiAgb3B0czogeyB0c0NvbmZpZz86IFRzQ29uZmlnIHwgbnVsbCB9ID0ge30sXG4pID0+IHtcbiAgLy8gSGFuZGxlIHBhcmVudCBkaXJlY3RvcnkgbmF2aWdhdGlvbiBwcm9wZXJseVxuICBjb25zdCByZXNvbHZlZFBhdGggPSBjd2RcbiAgICA/IHJlc29sdmVSZWxhdGl2ZVBhdGgodW5rbm93bkZpbGVQYXRoLCBjd2QpXG4gICAgOiB1bmtub3duRmlsZVBhdGhcblxuICBjb25zdCBmaWxlUGF0aHMgPSBuZXcgU2V0KFxuICAgIEFycmF5LmlzQXJyYXkoZnNNYXBPckFsbEZpbGVQYXRocylcbiAgICAgID8gZnNNYXBPckFsbEZpbGVQYXRoc1xuICAgICAgOiBPYmplY3Qua2V5cyhmc01hcE9yQWxsRmlsZVBhdGhzKSxcbiAgKVxuXG4gIGlmIChmaWxlUGF0aHMuaGFzKHJlc29sdmVkUGF0aCkpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRQYXRoXG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkRmlsZVBhdGhNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXG4gIGZvciAoY29uc3QgZmlsZVBhdGggb2YgZmlsZVBhdGhzKSB7XG4gICAgbm9ybWFsaXplZEZpbGVQYXRoTWFwLnNldChub3JtYWxpemVGaWxlUGF0aChmaWxlUGF0aCksIGZpbGVQYXRoKVxuICB9XG5cbiAgY29uc3Qgbm9ybWFsaXplZFJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUZpbGVQYXRoKHJlc29sdmVkUGF0aClcblxuICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhub3JtYWxpemVkUmVzb2x2ZWRQYXRoKSkge1xuICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KG5vcm1hbGl6ZWRSZXNvbHZlZFBhdGgpIVxuICB9XG5cbiAgLy8gU2VhcmNoIGZvciBmaWxlIHdpdGggYSBzZXQgb2YgZGlmZmVyZW50IGV4dGVuc2lvbnNcbiAgY29uc3QgZXh0ZW5zaW9uID0gW1widHN4XCIsIFwidHNcIiwgXCJqc29uXCIsIFwianNcIiwgXCJqc3hcIiwgXCJvYmpcIiwgXCJnbHRmXCIsIFwiZ2xiXCJdXG4gIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbikge1xuICAgIGNvbnN0IHBvc3NpYmxlRmlsZVBhdGggPSBgJHtub3JtYWxpemVkUmVzb2x2ZWRQYXRofS4ke2V4dH1gXG4gICAgaWYgKG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5oYXMocG9zc2libGVGaWxlUGF0aCkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KHBvc3NpYmxlRmlsZVBhdGgpIVxuICAgIH1cbiAgfVxuXG4gIC8vIFRyeSByZXNvbHZpbmcgdXNpbmcgdHNjb25maWcgXCJwYXRoc1wiIG1hcHBpbmcgd2hlbiB0aGUgaW1wb3J0IGlzIG5vbi1yZWxhdGl2ZVxuICBjb25zdCB0c0NvbmZpZyA9IG9wdHMudHNDb25maWcgPz8gbnVsbFxuXG4gIGlmICghdW5rbm93bkZpbGVQYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSAmJiAhdW5rbm93bkZpbGVQYXRoLnN0YXJ0c1dpdGgoXCIuLi9cIikpIHtcbiAgICBjb25zdCByZXNvbHZlZFBhdGhGcm9tUGF0aHMgPSByZXNvbHZlV2l0aFRzY29uZmlnUGF0aHMoe1xuICAgICAgaW1wb3J0UGF0aDogdW5rbm93bkZpbGVQYXRoLFxuICAgICAgbm9ybWFsaXplZEZpbGVQYXRoTWFwLFxuICAgICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9uLFxuICAgICAgdHNDb25maWcsXG4gICAgfSlcbiAgICBpZiAocmVzb2x2ZWRQYXRoRnJvbVBhdGhzKSByZXR1cm4gcmVzb2x2ZWRQYXRoRnJvbVBhdGhzXG5cbiAgICBjb25zdCByZXNvbHZlZFBhdGhGcm9tQmFzZVVybCA9IHJlc29sdmVXaXRoQmFzZVVybCh7XG4gICAgICBpbXBvcnRQYXRoOiB1bmtub3duRmlsZVBhdGgsXG4gICAgICBub3JtYWxpemVkRmlsZVBhdGhNYXAsXG4gICAgICBleHRlbnNpb25zOiBleHRlbnNpb24sXG4gICAgICB0c0NvbmZpZyxcbiAgICB9KVxuICAgIGlmIChyZXNvbHZlZFBhdGhGcm9tQmFzZVVybCkgcmV0dXJuIHJlc29sdmVkUGF0aEZyb21CYXNlVXJsXG4gIH1cblxuICAvLyBDaGVjayBpZiBpdCdzIGFuIGFic29sdXRlIGltcG9ydFxuICBpZiAoIXVua25vd25GaWxlUGF0aC5zdGFydHNXaXRoKFwiLi9cIikgJiYgIXVua25vd25GaWxlUGF0aC5zdGFydHNXaXRoKFwiLi4vXCIpKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFVua25vd25GaWxlUGF0aCA9IG5vcm1hbGl6ZUZpbGVQYXRoKHVua25vd25GaWxlUGF0aClcbiAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhub3JtYWxpemVkVW5rbm93bkZpbGVQYXRoKSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQobm9ybWFsaXplZFVua25vd25GaWxlUGF0aCkhXG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbikge1xuICAgICAgY29uc3QgcG9zc2libGVGaWxlUGF0aCA9IGAke25vcm1hbGl6ZWRVbmtub3duRmlsZVBhdGh9LiR7ZXh0fWBcbiAgICAgIGlmIChub3JtYWxpemVkRmlsZVBhdGhNYXAuaGFzKHBvc3NpYmxlRmlsZVBhdGgpKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KHBvc3NpYmxlRmlsZVBhdGgpIVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmlsZVBhdGhPclRocm93ID0gKFxuICB1bmtub3duRmlsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXBPckFsbEZpbGVQYXRoczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZ1tdLFxuICBjd2Q/OiBzdHJpbmcsXG4gIG9wdHM6IHsgdHNDb25maWc/OiBUc0NvbmZpZyB8IG51bGwgfSA9IHt9LFxuKSA9PiB7XG4gIGNvbnN0IHJlc29sdmVkRmlsZVBhdGggPSByZXNvbHZlRmlsZVBhdGgoXG4gICAgdW5rbm93bkZpbGVQYXRoLFxuICAgIGZzTWFwT3JBbGxGaWxlUGF0aHMsXG4gICAgY3dkLFxuICAgIG9wdHMsXG4gIClcbiAgaWYgKCFyZXNvbHZlZEZpbGVQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZpbGUgbm90IGZvdW5kIFwiJHt1bmtub3duRmlsZVBhdGh9XCIsIGF2YWlsYWJsZSBwYXRoczpcXG5cXG4ke09iamVjdC5rZXlzKGZzTWFwT3JBbGxGaWxlUGF0aHMpLmpvaW4oXCIsIFwiKX1gLFxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRGaWxlUGF0aFxufVxuIiwgImV4cG9ydCBjb25zdCBnZXRJbXBvcnRzRnJvbUNvZGUgPSAoY29kZTogc3RyaW5nKTogc3RyaW5nW10gPT4ge1xuICAvLyBNYXRjaCBiYXNpYyBpbXBvcnQgcGF0dGVybnMgaW5jbHVkaW5nIGNvbWJpbmVkIGRlZmF1bHQgYW5kIG5hbWVzcGFjZSBpbXBvcnRzXG4gIGNvbnN0IGltcG9ydFJlZ2V4ID1cbiAgICAvXlxccyppbXBvcnRcXHMrKD86KD86W1xcd1xcc10rLFxccyopPyg/OlxcKlxccythc1xccytbXFx3XFxzXSt8XFx7W1xcc1xcdyxdK1xcfXxcXHcrKVxccytmcm9tXFxzKik/WydcIl0oLis/KVsnXCJdL2dtXG4gIGNvbnN0IGltcG9ydHM6IHN0cmluZ1tdID0gW11cbiAgbGV0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsXG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0Fzc2lnbkluRXhwcmVzc2lvbnM6IDxleHBsYW5hdGlvbj5cbiAgd2hpbGUgKChtYXRjaCA9IGltcG9ydFJlZ2V4LmV4ZWMoY29kZSkpICE9PSBudWxsKSB7XG4gICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF1cbiAgICBpZiAoL15cXHMqaW1wb3J0XFxzK3R5cGVcXGIvLnRlc3QoZnVsbE1hdGNoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaW1wb3J0cy5wdXNoKG1hdGNoWzFdKVxuICB9XG5cbiAgLy8gTWF0Y2ggcmUtZXhwb3J0c1xuICBjb25zdCByZUV4cG9ydFJlZ2V4ID1cbiAgICAvXlxccypleHBvcnRcXHMrKD86dHlwZVxccyspPyg/OlxcKlxccythc1xccytbXFx3JF0rfFxcKnxcXHtbXn1dK1xcfSlcXHMrZnJvbVxccypbJ1wiXSguKz8pWydcIl0vZ21cbiAgbGV0IHJlRXhwb3J0TWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGxcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0Fzc2lnbkluRXhwcmVzc2lvbnM6IDxleHBsYW5hdGlvbj5cbiAgd2hpbGUgKChyZUV4cG9ydE1hdGNoID0gcmVFeHBvcnRSZWdleC5leGVjKGNvZGUpKSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGZ1bGxNYXRjaCA9IHJlRXhwb3J0TWF0Y2hbMF1cbiAgICBpZiAoL15cXHMqZXhwb3J0XFxzK3R5cGVcXGIvLnRlc3QoZnVsbE1hdGNoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaW1wb3J0cy5wdXNoKHJlRXhwb3J0TWF0Y2hbMV0pXG4gIH1cblxuICByZXR1cm4gaW1wb3J0c1xufVxuIiwgImltcG9ydCB7IHJlc29sdmVGaWxlUGF0aCB9IGZyb20gXCJsaWIvcnVubmVyL3Jlc29sdmVGaWxlUGF0aFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsQ29tcGlsZWRKcyhcbiAgY29tcGlsZWRDb2RlOiBzdHJpbmcsXG4gIHByZVN1cHBsaWVkSW1wb3J0czogUmVjb3JkPHN0cmluZywgYW55PixcbiAgY3dkPzogc3RyaW5nLFxuKSB7XG4gIDsoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fdHNjaXJjdWl0X3JlcXVpcmUgPSAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRGaWxlUGF0aCA9IHJlc29sdmVGaWxlUGF0aChuYW1lLCBwcmVTdXBwbGllZEltcG9ydHMsIGN3ZClcblxuICAgIGNvbnN0IGhhc1Jlc29sdmVkRmlsZVBhdGggPVxuICAgICAgcmVzb2x2ZWRGaWxlUGF0aCAmJiBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWRGaWxlUGF0aF1cblxuICAgIGlmICghcHJlU3VwcGxpZWRJbXBvcnRzW25hbWVdICYmICFoYXNSZXNvbHZlZEZpbGVQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEltcG9ydCBcIiR7bmFtZX1cIiBub3QgZm91bmQgJHtjd2QgPyBgaW4gXCIke2N3ZH1cImAgOiBcIlwifWApXG4gICAgfVxuXG4gICAgY29uc3QgbW9kID1cbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tuYW1lXSB8fCBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWRGaWxlUGF0aCFdXG4gICAgcmV0dXJuIG5ldyBQcm94eShtb2QsIHtcbiAgICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmRlZmF1bHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhcmdldC5fX2VzTW9kdWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgdGFyZ2V0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcm9wID09PSBcIl9fZXNNb2R1bGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ29tcG9uZW50IFwiJHtTdHJpbmcocHJvcCl9XCIgaXMgbm90IGV4cG9ydGVkIGJ5IFwiJHtuYW1lfVwiYCxcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3AgYXMga2V5b2YgdHlwZW9mIHRhcmdldF1cbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGZ1bmN0aW9uQm9keSA9IGBcbiAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgdmFyIHJlcXVpcmUgPSBnbG9iYWxUaGlzLl9fdHNjaXJjdWl0X3JlcXVpcmU7XG4gIHZhciBtb2R1bGUgPSB7IGV4cG9ydHMgfTtcbiAgdmFyIGNpcmN1aXQgPSBnbG9iYWxUaGlzLl9fdHNjaXJjdWl0X2NpcmN1aXQ7XG4gICR7Y29tcGlsZWRDb2RlfTtcbiAgcmV0dXJuIG1vZHVsZTtgLnRyaW0oKVxuICByZXR1cm4gRnVuY3Rpb24oZnVuY3Rpb25Cb2R5KS5jYWxsKGdsb2JhbFRoaXMpXG59XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZUZpbGVQYXRoT3JUaHJvdyB9IGZyb20gXCJsaWIvcnVubmVyL3Jlc29sdmVGaWxlUGF0aFwiXG5pbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSBcImxpYi91dGlscy9kaXJuYW1lXCJcbmltcG9ydCB7IGdldEltcG9ydHNGcm9tQ29kZSB9IGZyb20gXCJsaWIvdXRpbHMvZ2V0LWltcG9ydHMtZnJvbS1jb2RlXCJcbmltcG9ydCB7IGV2YWxDb21waWxlZEpzIH0gZnJvbSBcIi4vZXZhbC1jb21waWxlZC1qc1wiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgeyBpbXBvcnRFdmFsUGF0aCB9IGZyb20gXCIuL2ltcG9ydC1ldmFsLXBhdGhcIlxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiXG5pbXBvcnQgeyBpc1N0YXRpY0Fzc2V0UGF0aCB9IGZyb20gXCJsaWIvc2hhcmVkL3N0YXRpYy1hc3NldC1leHRlbnNpb25zXCJcbmltcG9ydCB7IHRyYW5zZm9ybVdpdGhTdWNyYXNlIH0gZnJvbSBcIi4vdHJhbnNmb3JtLXdpdGgtc3VjcmFzZVwiXG5pbXBvcnQgeyBLaWNhZFRvQ2lyY3VpdEpzb25Db252ZXJ0ZXIgfSBmcm9tIFwia2ljYWQtdG8tY2lyY3VpdC1qc29uXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDppbXBvcnQtbG9jYWwtZmlsZVwiKVxuXG5leHBvcnQgY29uc3QgaW1wb3J0TG9jYWxGaWxlID0gYXN5bmMgKFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSA9PiB7XG4gIGRlYnVnKFwiaW1wb3J0TG9jYWxGaWxlIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgaW1wb3J0TmFtZSxcbiAgfSlcblxuICBjb25zdCB7IGZzTWFwLCBwcmVTdXBwbGllZEltcG9ydHMsIGltcG9ydFN0YWNrLCBjdXJyZW50bHlJbXBvcnRpbmcgfSA9IGN0eFxuXG4gIGNvbnN0IGZzUGF0aCA9IHJlc29sdmVGaWxlUGF0aE9yVGhyb3coaW1wb3J0TmFtZSwgZnNNYXAsIHVuZGVmaW5lZCwge1xuICAgIHRzQ29uZmlnOiBjdHgudHNDb25maWcsXG4gIH0pXG4gIGRlYnVnKFwiZnNQYXRoOlwiLCBmc1BhdGgpXG4gIGlmIChjdXJyZW50bHlJbXBvcnRpbmcuaGFzKGZzUGF0aCkpIHtcbiAgICBjb25zdCBjeWNsZVN0YXJ0SW5kZXggPSBpbXBvcnRTdGFjay5pbmRleE9mKGZzUGF0aClcbiAgICBjb25zdCBjeWNsZVBhdGggPVxuICAgICAgY3ljbGVTdGFydEluZGV4ID49IDBcbiAgICAgICAgPyBpbXBvcnRTdGFjay5zbGljZShjeWNsZVN0YXJ0SW5kZXgpLmNvbmNhdChmc1BhdGgpXG4gICAgICAgIDogWy4uLmltcG9ydFN0YWNrLCBmc1BhdGhdXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQgd2hpbGUgaW1wb3J0aW5nIFwiJHtmc1BhdGh9XCIuIFRoZSBmb2xsb3dpbmcgaW1wb3J0IGNoYWluIGZvcm1zIGEgY3ljbGU6XFxuXFxuJHtjeWNsZVBhdGguam9pbihcbiAgICAgICAgXCIgLT4gXCIsXG4gICAgICApfWAsXG4gICAgKVxuICB9XG5cbiAgaWYgKCFjdHguZnNNYXBbZnNQYXRoXSkge1xuICAgIGRlYnVnKFwiZnNQYXRoIG5vdCBmb3VuZCBpbiBmc01hcDpcIiwgZnNQYXRoKVxuICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSBcIiR7ZnNQYXRofVwiIG5vdCBmb3VuZGApXG4gIH1cbiAgY29uc3QgZmlsZUNvbnRlbnQgPSBmc01hcFtmc1BhdGhdXG4gIGRlYnVnKFwiZmlsZUNvbnRlbnQ6XCIsIGZpbGVDb250ZW50Py5zbGljZSgwLCAxMDApKVxuICBjdXJyZW50bHlJbXBvcnRpbmcuYWRkKGZzUGF0aClcbiAgaW1wb3J0U3RhY2sucHVzaChmc1BhdGgpXG4gIHRyeSB7XG4gICAgaWYgKGZzUGF0aC5lbmRzV2l0aChcIi5qc29uXCIpKSB7XG4gICAgICBjb25zdCBqc29uRGF0YSA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnQpXG4gICAgICBwcmVTdXBwbGllZEltcG9ydHNbZnNQYXRoXSA9IHtcbiAgICAgICAgX19lc01vZHVsZTogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdDoganNvbkRhdGEsXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmc1BhdGguZW5kc1dpdGgoXCIua2ljYWRfcGNiXCIpKSB7XG4gICAgICBjb25zdCBjb252ZXJ0ZXIgPSBuZXcgS2ljYWRUb0NpcmN1aXRKc29uQ29udmVydGVyKClcbiAgICAgIGNvbnZlcnRlci5hZGRGaWxlKGZzUGF0aCwgZmlsZUNvbnRlbnQpXG4gICAgICBjb252ZXJ0ZXIucnVuVW50aWxGaW5pc2hlZCgpXG4gICAgICBjb25zdCBjaXJjdWl0SnNvbiA9IGNvbnZlcnRlci5nZXRPdXRwdXQoKVxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ZzUGF0aF0gPSB7XG4gICAgICAgIF9fZXNNb2R1bGU6IHRydWUsXG4gICAgICAgIGNpcmN1aXRKc29uOiBjaXJjdWl0SnNvbixcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU3RhdGljQXNzZXRQYXRoKGZzUGF0aCkpIHtcbiAgICAgIGxldCBzdGF0aWNVcmw6IHN0cmluZ1xuXG4gICAgICBpZiAoZmlsZUNvbnRlbnQgPT09IFwiX19TVEFUSUNfQVNTRVRfX1wiKSB7XG4gICAgICAgIC8vIFBsYWNlaG9sZGVyOiB1c2UgcHJvamVjdEJhc2VVcmwgZm9yIHN0YXRpYyBmaWxlIGltcG9ydHNcbiAgICAgICAgY29uc3QgcGxhdGZvcm1Db25maWcgPSBjdHguY2lyY3VpdC5wbGF0Zm9ybVxuICAgICAgICBzdGF0aWNVcmwgPSBgJHtwbGF0Zm9ybUNvbmZpZz8ucHJvamVjdEJhc2VVcmwgPz8gXCJcIn0vJHtcbiAgICAgICAgICBmc1BhdGguc3RhcnRzV2l0aChcIi4vXCIpID8gZnNQYXRoLnNsaWNlKDIpIDogZnNQYXRoXG4gICAgICAgIH1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBY3R1YWwgZmlsZSBjb250ZW50OiBjcmVhdGUgYSBibG9iIFVSTFxuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2ZpbGVDb250ZW50XSwge1xuICAgICAgICAgIHR5cGU6IGZzUGF0aC5lbmRzV2l0aChcIi5raWNhZF9tb2RcIilcbiAgICAgICAgICAgID8gXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgICAgIDogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIixcbiAgICAgICAgfSlcbiAgICAgICAgc3RhdGljVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAgfVxuXG4gICAgICBwcmVTdXBwbGllZEltcG9ydHNbZnNQYXRoXSA9IHtcbiAgICAgICAgX19lc01vZHVsZTogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdDogc3RhdGljVXJsLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnNQYXRoLmVuZHNXaXRoKFwiLnRzeFwiKSB8fCBmc1BhdGguZW5kc1dpdGgoXCIudHNcIikpIHtcbiAgICAgIGNvbnN0IGltcG9ydE5hbWVzID0gZ2V0SW1wb3J0c0Zyb21Db2RlKGZpbGVDb250ZW50KVxuXG4gICAgICBmb3IgKGNvbnN0IGltcG9ydE5hbWUgb2YgaW1wb3J0TmFtZXMpIHtcbiAgICAgICAgaWYgKCFwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0pIHtcbiAgICAgICAgICBhd2FpdCBpbXBvcnRFdmFsUGF0aChpbXBvcnROYW1lLCBjdHgsIGRlcHRoICsgMSwge1xuICAgICAgICAgICAgY3dkOiBkaXJuYW1lKGZzUGF0aCksXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZENvZGUgPSB0cmFuc2Zvcm1XaXRoU3VjcmFzZShmaWxlQ29udGVudCwgZnNQYXRoKVxuICAgICAgICBkZWJ1ZyhcImV2YWxDb21waWxlZEpzIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgICAgICAgY29kZTogdHJhbnNmb3JtZWRDb2RlLnNsaWNlKDAsIDEwMCksXG4gICAgICAgICAgZGlybmFtZTogZGlybmFtZShmc1BhdGgpLFxuICAgICAgICB9KVxuICAgICAgICBjb25zdCBpbXBvcnRSdW5SZXN1bHQgPSBldmFsQ29tcGlsZWRKcyhcbiAgICAgICAgICB0cmFuc2Zvcm1lZENvZGUsXG4gICAgICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzLFxuICAgICAgICAgIGRpcm5hbWUoZnNQYXRoKSxcbiAgICAgICAgKVxuICAgICAgICBkZWJ1ZyhcImltcG9ydFJ1blJlc3VsdDpcIiwge1xuICAgICAgICAgIGZzUGF0aCxcbiAgICAgICAgICBpbXBvcnRSdW5SZXN1bHQsXG4gICAgICAgIH0pXG4gICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmc1BhdGhdID0gaW1wb3J0UnVuUmVzdWx0LmV4cG9ydHNcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFdmFsIGNvbXBpbGVkIGpzIGVycm9yIGZvciBcIiR7aW1wb3J0TmFtZX1cIjogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZzUGF0aC5lbmRzV2l0aChcIi5qc1wiKSkge1xuICAgICAgLy8gRm9yIC5qcyBmaWxlcywgZXNwZWNpYWxseSBmcm9tIG5vZGVfbW9kdWxlcywgd2UgbmVlZCB0byB0cmFuc2Zvcm0gdGhlbVxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ZzUGF0aF0gPSBldmFsQ29tcGlsZWRKcyhcbiAgICAgICAgdHJhbnNmb3JtV2l0aFN1Y3Jhc2UoZmlsZUNvbnRlbnQsIGZzUGF0aCksXG4gICAgICAgIHByZVN1cHBsaWVkSW1wb3J0cyxcbiAgICAgICAgZGlybmFtZShmc1BhdGgpLFxuICAgICAgKS5leHBvcnRzXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFVuc3VwcG9ydGVkIGZpbGUgZXh0ZW5zaW9uIFwiJHtmc1BhdGguc3BsaXQoXCIuXCIpLnBvcCgpfVwiIGZvciBcIiR7ZnNQYXRofVwiYCxcbiAgICAgIClcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgaW1wb3J0U3RhY2sucG9wKClcbiAgICBjdXJyZW50bHlJbXBvcnRpbmcuZGVsZXRlKGZzUGF0aClcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBTVEFUSUNfQVNTRVRfRVhURU5TSU9OUyA9IFtcbiAgXCIuZ2xiXCIsXG4gIFwiLmtpY2FkX21vZFwiLFxuICBcIi5nbHRmXCIsXG4gIFwiLm9ialwiLFxuICBcIi5zdGxcIixcbl1cblxuZXhwb3J0IGNvbnN0IGlzU3RhdGljQXNzZXRQYXRoID0gKHBhdGg6IHN0cmluZykgPT5cbiAgU1RBVElDX0FTU0VUX0VYVEVOU0lPTlMuc29tZSgoZXh0KSA9PiBwYXRoLmVuZHNXaXRoKGV4dCkpXG4iLCAiaW1wb3J0IHsgdHJhbnNmb3JtLCB0eXBlIFRyYW5zZm9ybSBhcyBTdWNyYXNlVHJhbnNmb3JtIH0gZnJvbSBcInN1Y3Jhc2VcIlxuXG5jb25zdCBUU19FWFRFTlNJT05TID0gbmV3IFNldChbXCIudHNcIiwgXCIudHN4XCIsIFwiLm10c1wiLCBcIi5jdHNcIl0pXG5jb25zdCBKU1hfRVhURU5TSU9OUyA9IG5ldyBTZXQoW1wiLnRzeFwiLCBcIi5qc3hcIiwgXCIudHNcIl0pXG5jb25zdCBUWVBFX1NUQVJfRVhQT1JUX1JFR0VYID1cbiAgL15cXHMqZXhwb3J0XFxzK3R5cGVcXHMrXFwqXFxzKyg/OmFzXFxzK1tcXHckXStcXHMrKT9mcm9tXFxzK1snXCJdW14nXCJdK1snXCJdXFxzKjs/XFxzKiQvZ2ltXG5cbmNvbnN0IHN0cmlwVHlwZVN0YXJFeHBvcnRzID0gKGNvZGU6IHN0cmluZykgPT5cbiAgY29kZS5yZXBsYWNlKFRZUEVfU1RBUl9FWFBPUlRfUkVHRVgsIFwiXCIpXG5cbmNvbnN0IHN0cmlwUXVlcnlBbmRIYXNoID0gKGZpbGVQYXRoOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgcXVlcnlJbmRleCA9IGZpbGVQYXRoLmluZGV4T2YoXCI/XCIpXG4gIGNvbnN0IGhhc2hJbmRleCA9IGZpbGVQYXRoLmluZGV4T2YoXCIjXCIpXG5cbiAgbGV0IGVuZEluZGV4ID0gZmlsZVBhdGgubGVuZ3RoXG5cbiAgaWYgKHF1ZXJ5SW5kZXggIT09IC0xICYmIGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBlbmRJbmRleCA9IE1hdGgubWluKHF1ZXJ5SW5kZXgsIGhhc2hJbmRleClcbiAgfSBlbHNlIGlmIChxdWVyeUluZGV4ICE9PSAtMSkge1xuICAgIGVuZEluZGV4ID0gcXVlcnlJbmRleFxuICB9IGVsc2UgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBlbmRJbmRleCA9IGhhc2hJbmRleFxuICB9XG5cbiAgcmV0dXJuIGZpbGVQYXRoLnNsaWNlKDAsIGVuZEluZGV4KVxufVxuXG5jb25zdCBnZXRFeHRlbnNpb24gPSAoZmlsZVBhdGg6IHN0cmluZykgPT4ge1xuICBjb25zdCBub3JtYWxpemVkUGF0aCA9IHN0cmlwUXVlcnlBbmRIYXNoKGZpbGVQYXRoKVxuICBjb25zdCBsYXN0RG90SW5kZXggPSBub3JtYWxpemVkUGF0aC5sYXN0SW5kZXhPZihcIi5cIilcblxuICBpZiAobGFzdERvdEluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBcIlwiXG4gIH1cblxuICBjb25zdCBsYXN0U2xhc2hJbmRleCA9IE1hdGgubWF4KFxuICAgIG5vcm1hbGl6ZWRQYXRoLmxhc3RJbmRleE9mKFwiL1wiKSxcbiAgICBub3JtYWxpemVkUGF0aC5sYXN0SW5kZXhPZihcIlxcXFxcIiksXG4gIClcblxuICBpZiAobGFzdFNsYXNoSW5kZXggPiBsYXN0RG90SW5kZXgpIHtcbiAgICByZXR1cm4gXCJcIlxuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWRQYXRoLnNsaWNlKGxhc3REb3RJbmRleCkudG9Mb3dlckNhc2UoKVxufVxuXG5jb25zdCBnZXRUcmFuc2Zvcm1zRm9yRmlsZVBhdGggPSAoZmlsZVBhdGg6IHN0cmluZykgPT4ge1xuICBjb25zdCBleHRlbnNpb24gPSBnZXRFeHRlbnNpb24oZmlsZVBhdGgpXG5cbiAgY29uc3QgdHJhbnNmb3JtczogU3VjcmFzZVRyYW5zZm9ybVtdID0gW1wiaW1wb3J0c1wiXVxuXG4gIGlmIChUU19FWFRFTlNJT05TLmhhcyhleHRlbnNpb24pKSB7XG4gICAgdHJhbnNmb3Jtcy51bnNoaWZ0KFwidHlwZXNjcmlwdFwiKVxuICB9XG5cbiAgaWYgKEpTWF9FWFRFTlNJT05TLmhhcyhleHRlbnNpb24pKSB7XG4gICAgdHJhbnNmb3Jtcy5wdXNoKFwianN4XCIpXG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3Jtc1xufVxuXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtV2l0aFN1Y3Jhc2UgPSAoY29kZTogc3RyaW5nLCBmaWxlUGF0aDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHRyYW5zZm9ybXMgPSBnZXRUcmFuc2Zvcm1zRm9yRmlsZVBhdGgoZmlsZVBhdGgpXG4gIGNvbnN0IHNhbml0aXplZENvZGUgPSBzdHJpcFR5cGVTdGFyRXhwb3J0cyhjb2RlKVxuICBjb25zdCB7IGNvZGU6IHRyYW5zZm9ybWVkQ29kZSB9ID0gdHJhbnNmb3JtKHNhbml0aXplZENvZGUsIHtcbiAgICBmaWxlUGF0aCxcbiAgICBwcm9kdWN0aW9uOiB0cnVlLFxuICAgIHRyYW5zZm9ybXMsXG4gIH0pXG5cbiAgcmV0dXJuIHRyYW5zZm9ybWVkQ29kZVxufVxuIiwgImltcG9ydCB7IGV2YWxDb21waWxlZEpzIH0gZnJvbSBcIi4vZXZhbC1jb21waWxlZC1qc1wiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRTbmlwcGV0KFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSB7XG4gIGNvbnN0IHsgcHJlU3VwcGxpZWRJbXBvcnRzIH0gPSBjdHhcbiAgY29uc3QgZnVsbFNuaXBwZXROYW1lID0gaW1wb3J0TmFtZS5yZXBsYWNlKFwiQHRzY2kvXCIsIFwiXCIpLnJlcGxhY2UoXCIuXCIsIFwiL1wiKVxuXG4gIGNvbnN0IHsgY2pzLCBlcnJvciB9ID0gYXdhaXQgZ2xvYmFsVGhpc1xuICAgIC5mZXRjaChgJHtjdHguY2pzUmVnaXN0cnlVcmx9LyR7ZnVsbFNuaXBwZXROYW1lfWApXG4gICAgLnRoZW4oYXN5bmMgKHJlcykgPT4gKHsgY2pzOiBhd2FpdCByZXMudGV4dCgpLCBlcnJvcjogbnVsbCB9KSlcbiAgICAuY2F0Y2goKGUpID0+ICh7IGVycm9yOiBlLCBjanM6IG51bGwgfSkpXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGltcG9ydFwiLCBpbXBvcnROYW1lLCBlcnJvcilcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRyeSB7XG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWVdID0gZXZhbENvbXBpbGVkSnMoXG4gICAgICBjanMhLFxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzLFxuICAgICkuZXhwb3J0c1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGltcG9ydGluZyBzbmlwcGV0XCIsIGUpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSBcIi4vZGlybmFtZVwiXG5cbmludGVyZmFjZSBQYWNrYWdlSnNvbiB7XG4gIG1haW4/OiBzdHJpbmdcbiAgbW9kdWxlPzogc3RyaW5nXG4gIGV4cG9ydHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PlxufVxuXG5pbnRlcmZhY2UgTm9kZVJlc29sdXRpb25Db250ZXh0IHtcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgZXh0ZW5zaW9uczogc3RyaW5nW11cbiAgYmFzZVBhdGg6IHN0cmluZ1xuICBtb2R1bGVQYXRoOiBzdHJpbmdcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChcbiAgbW9kdWxlUGF0aDogc3RyaW5nLFxuICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgYmFzZVBhdGg6IHN0cmluZyxcbik6IE5vZGVSZXNvbHV0aW9uQ29udGV4dCB7XG4gIHJldHVybiB7XG4gICAgZnNNYXAsXG4gICAgZXh0ZW5zaW9uczogW1wiLmpzXCIsIFwiLmpzeFwiLCBcIi50c1wiLCBcIi50c3hcIiwgXCIuanNvblwiXSxcbiAgICBiYXNlUGF0aCxcbiAgICBtb2R1bGVQYXRoLFxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQYWNrYWdlSnNvbihub2RlTW9kdWxlc1BhdGg6IHN0cmluZywgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gYCR7bm9kZU1vZHVsZXNQYXRofS9wYWNrYWdlLmpzb25gXG4gIGlmICghY3R4LmZzTWFwW3BhY2thZ2VKc29uUGF0aF0pIHJldHVybiBudWxsXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY3R4LmZzTWFwW3BhY2thZ2VKc29uUGF0aF0pIGFzIFBhY2thZ2VKc29uXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5UmVzb2x2ZVdpdGhFeHRlbnNpb25zKFxuICBwYXRoOiBzdHJpbmcsXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChjdHguZnNNYXBbcGF0aF0pIHJldHVybiBwYXRoXG5cbiAgZm9yIChjb25zdCBleHQgb2YgY3R4LmV4dGVuc2lvbnMpIHtcbiAgICBjb25zdCBwYXRoV2l0aEV4dCA9IHBhdGgucmVwbGFjZSgvXFwuanMkfFxcLmpzeCQvLCBcIlwiKSArIGV4dFxuICAgIGlmIChjdHguZnNNYXBbcGF0aFdpdGhFeHRdKSByZXR1cm4gcGF0aFdpdGhFeHRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiByZXNvbHZlRXhwb3J0UGF0aChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIGV4cG9ydFBhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgZnVsbEV4cG9ydFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9LyR7ZXhwb3J0UGF0aC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIil9YFxuICByZXR1cm4gdHJ5UmVzb2x2ZVdpdGhFeHRlbnNpb25zKGZ1bGxFeHBvcnRQYXRoLCBjdHgpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYWNrYWdlRXhwb3J0cyhcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbixcbiAgcmVtYWluaW5nUGF0aDogc3RyaW5nLFxuICBjdHg6IE5vZGVSZXNvbHV0aW9uQ29udGV4dCxcbik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoIXBhY2thZ2VKc29uLmV4cG9ydHMpIHJldHVybiBudWxsXG5cbiAgLy8gSGFuZGxlIGRlZmF1bHQgZXhwb3J0IGNvbmRpdGlvblxuICBjb25zdCBkZWZhdWx0RXhwb3J0ID0gcGFja2FnZUpzb24uZXhwb3J0c1tcIi5cIl1cbiAgaWYgKHJlbWFpbmluZ1BhdGggPT09IFwiXCIgJiYgZGVmYXVsdEV4cG9ydCkge1xuICAgIGlmICh0eXBlb2YgZGVmYXVsdEV4cG9ydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRXhwb3J0UGF0aChub2RlTW9kdWxlc1BhdGgsIGRlZmF1bHRFeHBvcnQsIGN0eClcbiAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIHN1YnBhdGggZXhwb3J0c1xuICBjb25zdCBzdWJwYXRoRXhwb3J0ID0gcmVtYWluaW5nUGF0aFxuICAgID8gcGFja2FnZUpzb24uZXhwb3J0c1tgLi8ke3JlbWFpbmluZ1BhdGh9YF1cbiAgICA6IG51bGxcbiAgaWYgKHN1YnBhdGhFeHBvcnQgJiYgdHlwZW9mIHN1YnBhdGhFeHBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVFeHBvcnRQYXRoKG5vZGVNb2R1bGVzUGF0aCwgc3VicGF0aEV4cG9ydCwgY3R4KVxuICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gIH1cblxuICAvLyBIYW5kbGUgY29uZGl0aW9uYWwgZXhwb3J0c1xuICBjb25zdCBpbXBvcnRFeHBvcnQgPSBwYWNrYWdlSnNvbi5leHBvcnRzW1wiaW1wb3J0XCJdXG4gIGlmIChcbiAgICByZW1haW5pbmdQYXRoID09PSBcIlwiICYmXG4gICAgaW1wb3J0RXhwb3J0ICYmXG4gICAgdHlwZW9mIGltcG9ydEV4cG9ydCA9PT0gXCJzdHJpbmdcIlxuICApIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVFeHBvcnRQYXRoKG5vZGVNb2R1bGVzUGF0aCwgaW1wb3J0RXhwb3J0LCBjdHgpXG4gICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWRcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYWNrYWdlRW50cnlQb2ludChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbixcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgZW50cnlQb2ludCA9IHBhY2thZ2VKc29uLm1vZHVsZSB8fCBwYWNrYWdlSnNvbi5tYWluIHx8IFwiaW5kZXguanNcIlxuICBjb25zdCBmdWxsUGF0aCA9IGAke25vZGVNb2R1bGVzUGF0aH0vJHtlbnRyeVBvaW50fWBcbiAgcmV0dXJuIHRyeVJlc29sdmVXaXRoRXh0ZW5zaW9ucyhmdWxsUGF0aCwgY3R4KVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVtYWluaW5nUGF0aChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHJlbWFpbmluZ1BhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFyZW1haW5pbmdQYXRoKSB7XG4gICAgLy8gVHJ5IGluZGV4IGZpbGVzIGluIHRoZSBtb2R1bGUgcm9vdFxuICAgIGZvciAoY29uc3QgZXh0IG9mIGN0eC5leHRlbnNpb25zKSB7XG4gICAgICBjb25zdCBpbmRleFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9L2luZGV4JHtleHR9YFxuICAgICAgaWYgKGN0eC5mc01hcFtpbmRleFBhdGhdKSByZXR1cm4gaW5kZXhQYXRoXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBmdWxsUGF0aCA9IGAke25vZGVNb2R1bGVzUGF0aH0vJHtyZW1haW5pbmdQYXRofWBcbiAgY29uc3QgZGlyZWN0TWF0Y2ggPSB0cnlSZXNvbHZlV2l0aEV4dGVuc2lvbnMoZnVsbFBhdGgsIGN0eClcbiAgaWYgKGRpcmVjdE1hdGNoKSByZXR1cm4gZGlyZWN0TWF0Y2hcblxuICAvLyBUcnkgaW5kZXggZmlsZXNcbiAgZm9yIChjb25zdCBleHQgb2YgY3R4LmV4dGVuc2lvbnMpIHtcbiAgICBjb25zdCBpbmRleFBhdGggPSBgJHtmdWxsUGF0aH0vaW5kZXgke2V4dH1gXG4gICAgaWYgKGN0eC5mc01hcFtpbmRleFBhdGhdKSByZXR1cm4gaW5kZXhQYXRoXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGVNb2R1bGVJblBhdGgoXG4gIHNlYXJjaFBhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgbW9kdWxlUGFydHMgPSBjdHgubW9kdWxlUGF0aC5zcGxpdChcIi9cIilcbiAgY29uc3Qgc2NvcGUgPSBtb2R1bGVQYXJ0c1swXS5zdGFydHNXaXRoKFwiQFwiKVxuICAgID8gbW9kdWxlUGFydHMuc2xpY2UoMCwgMikuam9pbihcIi9cIilcbiAgICA6IG1vZHVsZVBhcnRzWzBdXG4gIGNvbnN0IHJlbWFpbmluZ1BhdGggPSBtb2R1bGVQYXJ0cy5zbGljZShzY29wZS5pbmNsdWRlcyhcIi9cIikgPyAyIDogMSkuam9pbihcIi9cIilcbiAgY29uc3Qgbm9kZU1vZHVsZXNQYXRoID0gYCR7c2VhcmNoUGF0aCA9PSBcIi5cIiA/IFwiXCIgOiBgJHtzZWFyY2hQYXRofS9gfW5vZGVfbW9kdWxlcy8ke3Njb3BlfWBcblxuICAvLyBUcnkgdG8gZmluZCBwYWNrYWdlLmpzb25cbiAgY29uc3QgcGFja2FnZUpzb24gPSBmaW5kUGFja2FnZUpzb24obm9kZU1vZHVsZXNQYXRoLCBjdHgpXG4gIGlmIChwYWNrYWdlSnNvbikge1xuICAgIC8vIFRyeSByZXNvbHZpbmcgdGhyb3VnaCBleHBvcnRzIGZpZWxkXG4gICAgY29uc3QgZXhwb3J0c1Jlc29sdXRpb24gPSByZXNvbHZlUGFja2FnZUV4cG9ydHMoXG4gICAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgICBwYWNrYWdlSnNvbixcbiAgICAgIHJlbWFpbmluZ1BhdGgsXG4gICAgICBjdHgsXG4gICAgKVxuICAgIGlmIChleHBvcnRzUmVzb2x1dGlvbikgcmV0dXJuIGV4cG9ydHNSZXNvbHV0aW9uXG5cbiAgICAvLyBUcnkgcmVzb2x2aW5nIHRocm91Z2ggbWFpbi9tb2R1bGUgZmllbGRzXG4gICAgY29uc3QgZW50cnlQb2ludFJlc29sdXRpb24gPSByZXNvbHZlUGFja2FnZUVudHJ5UG9pbnQoXG4gICAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgICBwYWNrYWdlSnNvbixcbiAgICAgIGN0eCxcbiAgICApXG4gICAgaWYgKGVudHJ5UG9pbnRSZXNvbHV0aW9uKSByZXR1cm4gZW50cnlQb2ludFJlc29sdXRpb25cbiAgfVxuXG4gIC8vIFRyeSByZXNvbHZpbmcgcmVtYWluaW5nIHBhdGhcbiAgY29uc3QgcmVtYWluaW5nUGF0aFJlc29sdXRpb24gPSByZXNvbHZlUmVtYWluaW5nUGF0aChcbiAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgcmVtYWluaW5nUGF0aCxcbiAgICBjdHgsXG4gIClcbiAgaWYgKHJlbWFpbmluZ1BhdGhSZXNvbHV0aW9uKSByZXR1cm4gcmVtYWluaW5nUGF0aFJlc29sdXRpb25cblxuICAvLyBJZiBub3QgZm91bmQgYW5kIHdlIGhhdmUgYSBwYXJlbnQgZGlyZWN0b3J5LCB0cnkgdGhlcmVcbiAgY29uc3QgcGFyZW50UGF0aCA9IGRpcm5hbWUoc2VhcmNoUGF0aClcbiAgaWYgKHBhcmVudFBhdGggJiYgcGFyZW50UGF0aCAhPT0gc2VhcmNoUGF0aCkge1xuICAgIHJldHVybiByZXNvbHZlTm9kZU1vZHVsZUluUGF0aChwYXJlbnRQYXRoLCBjdHgpXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU5vZGVNb2R1bGUoXG4gIG1vZHVsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gIGJhc2VQYXRoOiBzdHJpbmcsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgY3R4ID0gY3JlYXRlQ29udGV4dChtb2R1bGVQYXRoLCBmc01hcCwgYmFzZVBhdGgpXG4gIHJldHVybiByZXNvbHZlTm9kZU1vZHVsZUluUGF0aChjdHguYmFzZVBhdGgsIGN0eClcbn1cbiIsICJpbXBvcnQgeyByZXNvbHZlTm9kZU1vZHVsZSB9IGZyb20gXCJsaWIvdXRpbHMvcmVzb2x2ZS1ub2RlLW1vZHVsZVwiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgeyBpbXBvcnRMb2NhbEZpbGUgfSBmcm9tIFwiLi9pbXBvcnQtbG9jYWwtZmlsZVwiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDppbXBvcnQtbm9kZS1tb2R1bGVcIilcblxuZXhwb3J0IGNvbnN0IGltcG9ydE5vZGVNb2R1bGUgPSBhc3luYyAoXG4gIGltcG9ydE5hbWU6IHN0cmluZyxcbiAgY3R4OiBFeGVjdXRpb25Db250ZXh0LFxuICBkZXB0aCA9IDAsXG4pID0+IHtcbiAgY29uc3QgeyBwcmVTdXBwbGllZEltcG9ydHMgfSA9IGN0eFxuXG4gIGlmIChwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkTm9kZU1vZHVsZVBhdGggPSByZXNvbHZlTm9kZU1vZHVsZShpbXBvcnROYW1lLCBjdHguZnNNYXAsIFwiXCIpXG5cbiAgaWYgKCFyZXNvbHZlZE5vZGVNb2R1bGVQYXRoKSB7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBjdHguY2lyY3VpdD8ucGxhdGZvcm1cbiAgICBpZiAocGxhdGZvcm0/Lm5vZGVNb2R1bGVzUmVzb2x2ZXIpIHtcbiAgICAgIGRlYnVnKGBBdHRlbXB0aW5nIHRvIHJlc29sdmUgXCIke2ltcG9ydE5hbWV9XCIgdXNpbmcgbm9kZU1vZHVsZXNSZXNvbHZlcmApXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgcGxhdGZvcm0ubm9kZU1vZHVsZXNSZXNvbHZlcihpbXBvcnROYW1lKVxuXG4gICAgICAgIGlmIChmaWxlQ29udGVudCkge1xuICAgICAgICAgIGRlYnVnKGBTdWNjZXNzZnVsbHkgcmVzb2x2ZWQgXCIke2ltcG9ydE5hbWV9XCIgdmlhIG5vZGVNb2R1bGVzUmVzb2x2ZXJgKVxuXG4gICAgICAgICAgLy8gQWRkIHRoZSByZXNvbHZlZCBjb250ZW50IHRvIGZzTWFwIHdpdGggYSBzeW50aGV0aWMgcGF0aFxuICAgICAgICAgIC8vIEFkZCAudHMgZXh0ZW5zaW9uIHRvIGVuc3VyZSBpdCdzIHRyZWF0ZWQgYXMgYSBtb2R1bGUgZmlsZVxuICAgICAgICAgIGNvbnN0IHN5bnRoZXRpY1BhdGggPSBgbm9kZV9tb2R1bGVzLyR7aW1wb3J0TmFtZX0udHNgXG4gICAgICAgICAgY3R4LmZzTWFwW3N5bnRoZXRpY1BhdGhdID0gZmlsZUNvbnRlbnRcblxuICAgICAgICAgIC8vIEltcG9ydCB0aGUgZmlsZSB1c2luZyB0aGUgbm9ybWFsIGZsb3dcbiAgICAgICAgICBhd2FpdCBpbXBvcnRMb2NhbEZpbGUoc3ludGhldGljUGF0aCwgY3R4LCBkZXB0aClcblxuICAgICAgICAgIC8vIE1hcCB0aGUgaW1wb3J0IG5hbWUgdG8gdGhlIHJlc29sdmVkIG1vZHVsZVxuICAgICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSA9IHByZVN1cHBsaWVkSW1wb3J0c1tzeW50aGV0aWNQYXRoXVxuXG4gICAgICAgICAgLy8gQWxzbyBtYXAgd2l0aG91dCBub2RlX21vZHVsZXMgcHJlZml4XG4gICAgICAgICAgY29uc3QgdW5wcmVmaXhlZFBhdGggPSBzeW50aGV0aWNQYXRoLnJlcGxhY2UoL15ub2RlX21vZHVsZXNcXC8vLCBcIlwiKVxuICAgICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1t1bnByZWZpeGVkUGF0aF0gPSBwcmVTdXBwbGllZEltcG9ydHNbc3ludGhldGljUGF0aF1cblxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoYG5vZGVNb2R1bGVzUmVzb2x2ZXIgcmV0dXJuZWQgbnVsbCBmb3IgXCIke2ltcG9ydE5hbWV9XCJgKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGVidWcoYG5vZGVNb2R1bGVzUmVzb2x2ZXIgZmFpbGVkIGZvciBcIiR7aW1wb3J0TmFtZX1cIjpgLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgbW9kdWxlIFwiJHtpbXBvcnROYW1lfVwiIG5vdCBmb3VuZGApXG4gIH1cblxuICAvLyBVc2UgaW1wb3J0TG9jYWxGaWxlIHRvIGhhbmRsZSB0aGUgbm9kZSBtb2R1bGVcbiAgYXdhaXQgaW1wb3J0TG9jYWxGaWxlKHJlc29sdmVkTm9kZU1vZHVsZVBhdGgsIGN0eCwgZGVwdGgpXG5cbiAgLy8gTWFwIHRoZSBvcmlnaW5hbCBpbXBvcnQgbmFtZSB0byB0aGUgcmVzb2x2ZWQgbW9kdWxlJ3MgZXhwb3J0c1xuICBwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0gPSBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWROb2RlTW9kdWxlUGF0aF1cblxuICAvLyBNYXAgd2l0aG91dCBub2RlX21vZHVsZXMgcHJlZml4IGZvciBkaXJlY3QgaW1wb3J0c1xuICBjb25zdCB1bnByZWZpeGVkUGF0aCA9IHJlc29sdmVkTm9kZU1vZHVsZVBhdGgucmVwbGFjZSgvXm5vZGVfbW9kdWxlc1xcLy8sIFwiXCIpXG4gIHByZVN1cHBsaWVkSW1wb3J0c1t1bnByZWZpeGVkUGF0aF0gPVxuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuXG4gIC8vIEhhbmRsZSBpbmRleCBmaWxlcyBzcGVjaWFsbHlcbiAgaWYgKFxuICAgIHJlc29sdmVkTm9kZU1vZHVsZVBhdGguZW5kc1dpdGgoXCIvaW5kZXgudHN4XCIpIHx8XG4gICAgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5lbmRzV2l0aChcIi9pbmRleC50c1wiKSB8fFxuICAgIHJlc29sdmVkTm9kZU1vZHVsZVBhdGguZW5kc1dpdGgoXCIvaW5kZXguanNcIilcbiAgKSB7XG4gICAgY29uc3QgZGlyUGF0aCA9IHJlc29sdmVkTm9kZU1vZHVsZVBhdGgucmVwbGFjZSgvXFwvaW5kZXhcXC4odHN4P3xqcykkLywgXCJcIilcbiAgICBjb25zdCB1bnByZWZpeGVkRGlyUGF0aCA9IGRpclBhdGgucmVwbGFjZSgvXm5vZGVfbW9kdWxlc1xcLy8sIFwiXCIpXG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW3VucHJlZml4ZWREaXJQYXRoXSA9XG4gICAgICBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWROb2RlTW9kdWxlUGF0aF1cblxuICAgIC8vIEhhbmRsZSBzY29wZWQgcGFja2FnZXNcbiAgICBpZiAodW5wcmVmaXhlZERpclBhdGguc3RhcnRzV2l0aChcIkBcIikpIHtcbiAgICAgIGNvbnN0IHNjb3BlUGFydHMgPSB1bnByZWZpeGVkRGlyUGF0aC5zcGxpdChcIi9cIilcbiAgICAgIGlmIChzY29wZVBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlZE5hbWUgPSBgJHtzY29wZVBhcnRzWzBdfS8ke3Njb3BlUGFydHNbMV19YFxuICAgICAgICBwcmVTdXBwbGllZEltcG9ydHNbc2NvcGVkTmFtZV0gPVxuICAgICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IGV2YWxDb21waWxlZEpzIH0gZnJvbSBcIi4vZXZhbC1jb21waWxlZC1qc1wiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSBcImxpYi91dGlscy9kaXJuYW1lXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuaW1wb3J0IHsgZ2V0SW1wb3J0c0Zyb21Db2RlIH0gZnJvbSBcImxpYi91dGlscy9nZXQtaW1wb3J0cy1mcm9tLWNvZGVcIlxuaW1wb3J0IHsgaW1wb3J0RXZhbFBhdGggfSBmcm9tIFwiLi9pbXBvcnQtZXZhbC1wYXRoXCJcbmltcG9ydCB7IHRyYW5zZm9ybVdpdGhTdWNyYXNlIH0gZnJvbSBcIi4vdHJhbnNmb3JtLXdpdGgtc3VjcmFzZVwiXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJ0c2NpOmV2YWw6aW1wb3J0LW5wbS1wYWNrYWdlXCIpXG5cbmZ1bmN0aW9uIGV4dHJhY3RQYWNrYWdlUGF0aEZyb21KU0RlbGl2cih1cmw6IHN0cmluZykge1xuICBjb25zdCBwcmVmaXggPSBcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vXCJcbiAgaWYgKHVybC5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKS5yZXBsYWNlKC9cXC9cXCtlc20kLywgXCJcIilcbiAgfVxuICByZXR1cm4gdXJsXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnROcG1QYWNrYWdlKFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSB7XG4gIGRlYnVnKGBpbXBvcnRpbmcgbnBtIHBhY2thZ2U6ICR7aW1wb3J0TmFtZX1gKVxuICBjb25zdCB7IHByZVN1cHBsaWVkSW1wb3J0cyB9ID0gY3R4XG5cbiAgaWYgKHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSkgcmV0dXJuXG5cbiAgY29uc3QgbnBtQ2RuVXJsID0gYGh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vJHtpbXBvcnROYW1lfS8rZXNtYFxuXG4gIGxldCBmaW5hbFVybDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIGNvbnN0IHsgY29udGVudCwgZXJyb3IgfSA9IGF3YWl0IGdsb2JhbFRoaXNcbiAgICAuZmV0Y2gobnBtQ2RuVXJsKVxuICAgIC50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgIGZpbmFsVXJsID0gcmVzLnVybFxuICAgICAgaWYgKCFyZXMub2spXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGZldGNoIFwiJHtpbXBvcnROYW1lfVwiIGZyb20ganNkZWxpdnI6ICR7cmVzLnN0YXR1c1RleHR9XFxuXFxuJHtjdHgubG9nZ2VyLnN0cmluZ2lmeUxvZ3MoKX1gLFxuICAgICAgICApXG4gICAgICByZXR1cm4geyBjb250ZW50OiBhd2FpdCByZXMudGV4dCgpLCBlcnJvcjogbnVsbCB9XG4gICAgfSlcbiAgICAuY2F0Y2goKGUpID0+ICh7IGVycm9yOiBlLCBjb250ZW50OiBudWxsIH0pKVxuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBucG0gaW1wb3J0XCIsIGltcG9ydE5hbWUsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cblxuICBjb25zdCBmaW5hbEltcG9ydE5hbWUgPSBleHRyYWN0UGFja2FnZVBhdGhGcm9tSlNEZWxpdnIoZmluYWxVcmwhKVxuICBjb25zdCBjd2QgPSBkaXJuYW1lKGZpbmFsSW1wb3J0TmFtZSlcblxuICBjb25zdCBpbXBvcnROYW1lcyA9IGdldEltcG9ydHNGcm9tQ29kZShjb250ZW50ISlcbiAgZm9yIChjb25zdCBzdWJJbXBvcnROYW1lIG9mIGltcG9ydE5hbWVzKSB7XG4gICAgaWYgKCFwcmVTdXBwbGllZEltcG9ydHNbc3ViSW1wb3J0TmFtZV0pIHtcbiAgICAgIGF3YWl0IGltcG9ydEV2YWxQYXRoKHN1YkltcG9ydE5hbWUsIGN0eCwgZGVwdGggKyAxLCB7XG4gICAgICAgIGN3ZCxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdHJhbnNmb3JtZWRDb2RlID0gdHJhbnNmb3JtV2l0aFN1Y3Jhc2UoXG4gICAgY29udGVudCEsXG4gICAgZmluYWxJbXBvcnROYW1lIHx8IGltcG9ydE5hbWUsXG4gIClcbiAgdHJ5IHtcbiAgICBjb25zdCBleHBvcnRzID0gZXZhbENvbXBpbGVkSnMoXG4gICAgICB0cmFuc2Zvcm1lZENvZGUsXG4gICAgICBwcmVTdXBwbGllZEltcG9ydHMsXG4gICAgICBjd2QsXG4gICAgKS5leHBvcnRzXG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWVdID0gZXhwb3J0c1xuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmaW5hbEltcG9ydE5hbWVdID0gZXhwb3J0c1xuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmaW5hbFVybCFdID0gZXhwb3J0c1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXZhbCBucG0gcGFja2FnZSBlcnJvciBmb3IgXCIke2ltcG9ydE5hbWV9XCI6ICR7ZS5tZXNzYWdlfVxcblxcbiR7Y3R4LmxvZ2dlci5zdHJpbmdpZnlMb2dzKCl9YCxcbiAgICApXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgeyBpbXBvcnRMb2NhbEZpbGUgfSBmcm9tIFwiLi9pbXBvcnQtbG9jYWwtZmlsZVwiXG5pbXBvcnQgeyBpbXBvcnRTbmlwcGV0IH0gZnJvbSBcIi4vaW1wb3J0LXNuaXBwZXRcIlxuaW1wb3J0IHsgcmVzb2x2ZUZpbGVQYXRoIH0gZnJvbSBcImxpYi9ydW5uZXIvcmVzb2x2ZUZpbGVQYXRoXCJcbmltcG9ydCB7IHJlc29sdmVOb2RlTW9kdWxlIH0gZnJvbSBcImxpYi91dGlscy9yZXNvbHZlLW5vZGUtbW9kdWxlXCJcbmltcG9ydCB7IGltcG9ydE5vZGVNb2R1bGUgfSBmcm9tIFwiLi9pbXBvcnQtbm9kZS1tb2R1bGVcIlxuaW1wb3J0IHsgaW1wb3J0TnBtUGFja2FnZSB9IGZyb20gXCIuL2ltcG9ydC1ucG0tcGFja2FnZVwiXG5pbXBvcnQge1xuICBnZXRUc0NvbmZpZyxcbiAgbWF0Y2hlc1RzY29uZmlnUGF0aFBhdHRlcm4sXG59IGZyb20gXCJsaWIvcnVubmVyL3RzY29uZmlnUGF0aHNcIlxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJ0c2NpOmV2YWw6aW1wb3J0LWV2YWwtcGF0aFwiKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0RXZhbFBhdGgoXG4gIGltcG9ydE5hbWU6IHN0cmluZyxcbiAgY3R4OiBFeGVjdXRpb25Db250ZXh0LFxuICBkZXB0aCA9IDAsXG4gIG9wdHM6IHtcbiAgICBjd2Q/OiBzdHJpbmdcbiAgfSA9IHt9LFxuKSB7XG4gIGRlYnVnKFwiaW1wb3J0RXZhbFBhdGggY2FsbGVkIHdpdGg6XCIsIHtcbiAgICBpbXBvcnROYW1lLFxuICAgIGRlcHRoLFxuICAgIG9wdHMsXG4gIH0pXG4gIGN0eC5sb2dnZXIuaW5mbyhcbiAgICBgaW1wb3J0RXZhbFBhdGgoXCIke2ltcG9ydE5hbWV9XCIsIHtjd2Q6IFwiJHtvcHRzLmN3ZH1cIiwgZGVwdGg6ICR7ZGVwdGh9fSlgLFxuICApXG5cbiAgZGVidWcoYCR7XCIgIFwiLnJlcGVhdChkZXB0aCl9XHUyN0ExXHVGRTBGYCwgaW1wb3J0TmFtZSlcbiAgY29uc3QgeyBwcmVTdXBwbGllZEltcG9ydHMgfSA9IGN0eFxuXG4gIGlmIChwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0pIHtcbiAgICBjdHgubG9nZ2VyLmluZm8oYEltcG9ydCBcIiR7aW1wb3J0TmFtZX1cIiBpbiBwcmVTdXBwbGllZEltcG9ydHNbMV1gKVxuICAgIHJldHVyblxuICB9XG4gIGlmIChpbXBvcnROYW1lLnN0YXJ0c1dpdGgoXCIuL1wiKSAmJiBwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZS5zbGljZSgyKV0pIHtcbiAgICBjdHgubG9nZ2VyLmluZm8oYEltcG9ydCBcIiR7aW1wb3J0TmFtZX1cIiBpbiBwcmVTdXBwbGllZEltcG9ydHNbMl1gKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGRlcHRoID4gMzApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTWF4IGRlcHRoIGZvciBpbXBvcnRzIHJlYWNoZWQgKDMwKSBJbXBvcnQgUGF0aDogJHtjdHguaW1wb3J0U3RhY2suam9pbihcIiAtPiBcIil9YCxcbiAgICApXG4gIH1cblxuICBpZiAoaW1wb3J0TmFtZS5zdGFydHNXaXRoKFwiL25wbS9cIikpIHtcbiAgICBjb25zdCBwa2dOYW1lID0gaW1wb3J0TmFtZS5yZXBsYWNlKC9eXFwvbnBtXFwvLywgXCJcIikucmVwbGFjZSgvXFwvXFwrZXNtJC8sIFwiXCIpXG4gICAgY3R4LmxvZ2dlci5pbmZvKGBpbXBvcnROcG1QYWNrYWdlKFwiJHtwa2dOYW1lfVwiKWApXG4gICAgYXdhaXQgaW1wb3J0TnBtUGFja2FnZShwa2dOYW1lLCBjdHgsIGRlcHRoKVxuICAgIGNvbnN0IHBrZyA9IHByZVN1cHBsaWVkSW1wb3J0c1twa2dOYW1lXVxuICAgIGlmIChwa2cpIHtcbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSA9IHBrZ1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkTG9jYWxJbXBvcnRQYXRoID0gcmVzb2x2ZUZpbGVQYXRoKFxuICAgIGltcG9ydE5hbWUsXG4gICAgY3R4LmZzTWFwLFxuICAgIG9wdHMuY3dkLFxuICAgIHsgdHNDb25maWc6IGN0eC50c0NvbmZpZyB9LFxuICApXG4gIGlmIChyZXNvbHZlZExvY2FsSW1wb3J0UGF0aCkge1xuICAgIGN0eC5sb2dnZXIuaW5mbyhgaW1wb3J0TG9jYWxGaWxlKFwiJHtyZXNvbHZlZExvY2FsSW1wb3J0UGF0aH1cIilgKVxuICAgIGF3YWl0IGltcG9ydExvY2FsRmlsZShyZXNvbHZlZExvY2FsSW1wb3J0UGF0aCwgY3R4LCBkZXB0aClcbiAgICAvLyBNYXAgdGhlIG9yaWdpbmFsIGltcG9ydCBuYW1lICh3aGljaCBtaWdodCBiZSBhIHRzY29uZmlnIHBhdGggYWxpYXMpIHRvIHRoZSByZXNvbHZlZCBtb2R1bGVcbiAgICBpZiAoaW1wb3J0TmFtZSAhPT0gcmVzb2x2ZWRMb2NhbEltcG9ydFBhdGgpIHtcbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSA9XG4gICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZExvY2FsSW1wb3J0UGF0aF1cbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGlzIG1hdGNoZXMgYSB0c2NvbmZpZyBwYXRoIHBhdHRlcm4gYnV0IGZhaWxlZCB0byByZXNvbHZlXG4gIC8vIElmIHNvLCB0aHJvdyBhbiBlcnJvciBpbnN0ZWFkIG9mIGZhbGxpbmcgYmFjayB0byBucG1cbiAgY29uc3QgdHNDb25maWcgPSBjdHgudHNDb25maWcgPz8gZ2V0VHNDb25maWcoY3R4LmZzTWFwKVxuICBpZiAoIWN0eC50c0NvbmZpZyAmJiB0c0NvbmZpZykge1xuICAgIGN0eC50c0NvbmZpZyA9IHRzQ29uZmlnXG4gIH1cbiAgaWYgKG1hdGNoZXNUc2NvbmZpZ1BhdGhQYXR0ZXJuKGltcG9ydE5hbWUsIHRzQ29uZmlnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbXBvcnQgXCIke2ltcG9ydE5hbWV9XCIgbWF0Y2hlcyBhIHRzY29uZmlnIHBhdGggYWxpYXMgYnV0IGNvdWxkIG5vdCBiZSByZXNvbHZlZCB0byBhbiBleGlzdGluZyBmaWxlJHtvcHRzLmN3ZCA/IGAgZnJvbSBkaXJlY3RvcnkgXCIke29wdHMuY3dkfVwiYCA6IFwiXCJ9XFxuXFxuJHtjdHgubG9nZ2VyLnN0cmluZ2lmeUxvZ3MoKX1gLFxuICAgIClcbiAgfVxuXG4gIC8vIFRyeSB0byByZXNvbHZlIGZyb20gbm9kZV9tb2R1bGVzXG4gIGNvbnN0IHJlc29sdmVkTm9kZU1vZHVsZVBhdGggPSByZXNvbHZlTm9kZU1vZHVsZShcbiAgICBpbXBvcnROYW1lLFxuICAgIGN0eC5mc01hcCxcbiAgICBvcHRzLmN3ZCB8fCBcIlwiLFxuICApXG4gIGlmIChyZXNvbHZlZE5vZGVNb2R1bGVQYXRoKSB7XG4gICAgY3R4LmxvZ2dlci5pbmZvKGByZXNvbHZlZE5vZGVNb2R1bGVQYXRoPVwiJHtyZXNvbHZlZE5vZGVNb2R1bGVQYXRofVwiYClcbiAgICBjdHgubG9nZ2VyLmluZm8oYGltcG9ydE5vZGVNb2R1bGUoXCIke2ltcG9ydE5hbWV9XCIpYClcbiAgICByZXR1cm4gaW1wb3J0Tm9kZU1vZHVsZShpbXBvcnROYW1lLCBjdHgsIGRlcHRoKVxuICB9XG5cbiAgLy8gSWYgbm90IGZvdW5kIGluIGZzTWFwIGJ1dCBtaWdodCBiZSBhIG5vZGUgbW9kdWxlLCB0cnkgaW1wb3J0Tm9kZU1vZHVsZVxuICAvLyB3aGljaCB3aWxsIGF0dGVtcHQgdG8gdXNlIG5vZGVNb2R1bGVzUmVzb2x2ZXIgaWYgY29uZmlndXJlZFxuICBpZiAoXG4gICAgIWltcG9ydE5hbWUuc3RhcnRzV2l0aChcIi5cIikgJiZcbiAgICAhaW1wb3J0TmFtZS5zdGFydHNXaXRoKFwiL1wiKSAmJlxuICAgICFpbXBvcnROYW1lLnN0YXJ0c1dpdGgoXCJAdHNjaS9cIilcbiAgKSB7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBjdHguY2lyY3VpdD8ucGxhdGZvcm1cbiAgICBpZiAocGxhdGZvcm0/Lm5vZGVNb2R1bGVzUmVzb2x2ZXIpIHtcbiAgICAgIGN0eC5sb2dnZXIuaW5mbyhcbiAgICAgICAgYGltcG9ydE5vZGVNb2R1bGUoXCIke2ltcG9ydE5hbWV9XCIpIHZpYSBub2RlTW9kdWxlc1Jlc29sdmVyYCxcbiAgICAgIClcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGltcG9ydE5vZGVNb2R1bGUoaW1wb3J0TmFtZSwgY3R4LCBkZXB0aClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjdHgubG9nZ2VyLmluZm8oXG4gICAgICAgICAgYG5vZGVNb2R1bGVzUmVzb2x2ZXIgZmFpbGVkIGZvciBcIiR7aW1wb3J0TmFtZX1cIiwgZmFsbGluZyBiYWNrIHRvIG5wbSBDRE5gLFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGltcG9ydE5hbWUuc3RhcnRzV2l0aChcIkB0c2NpL1wiKSkge1xuICAgIGN0eC5sb2dnZXIuaW5mbyhgaW1wb3J0U25pcHBldChcIiR7aW1wb3J0TmFtZX1cIilgKVxuICAgIHJldHVybiBpbXBvcnRTbmlwcGV0KGltcG9ydE5hbWUsIGN0eCwgZGVwdGgpXG4gIH1cblxuICBpZiAoIWltcG9ydE5hbWUuc3RhcnRzV2l0aChcIi5cIikgJiYgIWltcG9ydE5hbWUuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICBjdHgubG9nZ2VyLmluZm8oYGltcG9ydE5wbVBhY2thZ2UoXCIke2ltcG9ydE5hbWV9XCIpYClcbiAgICByZXR1cm4gaW1wb3J0TnBtUGFja2FnZShpbXBvcnROYW1lLCBjdHgsIGRlcHRoKVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBVbnJlc29sdmVkIGltcG9ydCBcIiR7aW1wb3J0TmFtZX1cIiAke29wdHMuY3dkID8gYGZyb20gZGlyZWN0b3J5IFwiJHtvcHRzLmN3ZH1cImAgOiBcIlwifVxcblxcbiR7Y3R4LmxvZ2dlci5zdHJpbmdpZnlMb2dzKCl9YCxcbiAgKVxufVxuIiwgImltcG9ydCB7IHJlc29sdmVGaWxlUGF0aE9yVGhyb3cgfSBmcm9tIFwiLi9yZXNvbHZlRmlsZVBhdGhcIlxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJ0c2NpOmV2YWw6c2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkXCIpXG5cbmV4cG9ydCBjb25zdCBzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQgPSAob3B0czoge1xuICBlbnRyeXBvaW50Pzogc3RyaW5nXG4gIGZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIG1haW5Db21wb25lbnRQYXRoPzogc3RyaW5nXG4gIG1haW5Db21wb25lbnROYW1lPzogc3RyaW5nXG4gIG5hbWU/OiBzdHJpbmdcbiAgbWFpbkNvbXBvbmVudFByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxufSkgPT4ge1xuICBpZiAoIW9wdHMuZW50cnlwb2ludCAmJiAhb3B0cy5tYWluQ29tcG9uZW50UGF0aCkge1xuICAgIGlmIChcImluZGV4LnRzeFwiIGluIG9wdHMuZnNNYXApIHtcbiAgICAgIG9wdHMubWFpbkNvbXBvbmVudFBhdGggPSBcImluZGV4LnRzeFwiXG4gICAgfSBlbHNlIGlmIChcImluZGV4LnRzXCIgaW4gb3B0cy5mc01hcCkge1xuICAgICAgb3B0cy5tYWluQ29tcG9uZW50UGF0aCA9IFwiaW5kZXgudHNcIlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKS5maWx0ZXIoKGspID0+IGsuZW5kc1dpdGgoXCIudHN4XCIpKS5sZW5ndGggPT09IDFcbiAgICApIHtcbiAgICAgIG9wdHMubWFpbkNvbXBvbmVudFBhdGggPSBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKVswXVxuICAgIH0gZWxzZSBpZiAoXCJ0c2NpcmN1aXQuY29uZmlnLmpzb25cIiBpbiBvcHRzLmZzTWFwKSB7XG4gICAgICBjb25zdCBjb25maWdDb250ZW50ID0gb3B0cy5mc01hcFtcInRzY2lyY3VpdC5jb25maWcuanNvblwiXVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gSlNPTi5wYXJzZShjb25maWdDb250ZW50KVxuICAgICAgICBpZiAoY29uZmlnLm1haW5FbnRyeXBvaW50KSB7XG4gICAgICAgICAgb3B0cy5lbnRyeXBvaW50ID0gY29uZmlnLm1haW5FbnRyeXBvaW50XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIHRzY2lyY3VpdC5jb25maWcuanNvbjpcIiwgZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkVpdGhlciBlbnRyeXBvaW50IG9yIG1haW5Db21wb25lbnRQYXRoIG11c3QgYmUgcHJvdmlkZWQgKG5vIGluZGV4IGZpbGUsIGNvdWxkIG5vdCBpbmZlciBlbnRyeXBvaW50KVwiLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGlmICghb3B0cy5lbnRyeXBvaW50ICYmIG9wdHMubWFpbkNvbXBvbmVudFBhdGgpIHtcbiAgICBvcHRzLmVudHJ5cG9pbnQgPSBcImVudHJ5cG9pbnQudHN4XCJcbiAgICBjb25zdCBtYWluQ29tcG9uZW50Q29kZSA9XG4gICAgICBvcHRzLmZzTWFwW3Jlc29sdmVGaWxlUGF0aE9yVGhyb3cob3B0cy5tYWluQ29tcG9uZW50UGF0aCwgb3B0cy5mc01hcCldXG4gICAgaWYgKCFtYWluQ29tcG9uZW50Q29kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTWFpbiBjb21wb25lbnQgcGF0aCBcIiR7b3B0cy5tYWluQ29tcG9uZW50UGF0aH1cIiBub3QgZm91bmQgaW4gZnNNYXAuIEF2YWlsYWJsZSBwYXRoczogJHtPYmplY3Qua2V5cyhvcHRzLmZzTWFwKS5qb2luKFwiLCBcIil9YCxcbiAgICAgIClcbiAgICB9XG4gICAgb3B0cy5mc01hcFtvcHRzLmVudHJ5cG9pbnRdID0gYFxuICAgICBpbXBvcnQgKiBhcyBVc2VyQ29tcG9uZW50cyBmcm9tIFwiLi8ke29wdHMubWFpbkNvbXBvbmVudFBhdGh9XCI7XG4gICAgICAgICAgXG4gICAgICAke1xuICAgICAgICBvcHRzLm1haW5Db21wb25lbnROYW1lXG4gICAgICAgICAgPyBgXG4gICAgICAgIGNvbnN0IENvbXBvbmVudFRvUmVuZGVyID0gVXNlckNvbXBvbmVudHNbXCIke29wdHMubWFpbkNvbXBvbmVudE5hbWV9XCJdXG4gICAgICAgIGBcbiAgICAgICAgICA6IGBjb25zdCBDb21wb25lbnRUb1JlbmRlciA9IFVzZXJDb21wb25lbnRzLmRlZmF1bHQgfHwgXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoVXNlckNvbXBvbmVudHMpXG4gICAgICAgICAgLmZpbHRlcigoW25hbWVdKSA9PiAhbmFtZS5zdGFydHNXaXRoKFwidXNlXCIpKVxuICAgICAgICAgIC5tYXAoKFtfLCBjb21wb25lbnRdKSA9PiBjb21wb25lbnQpWzBdIHx8ICgoKSA9PiBudWxsKTtgXG4gICAgICB9XG5cbiAgICAgICAgICAgJHtcbiAgICAgICAgICAgICBkZWJ1Zy5lbmFibGVkXG4gICAgICAgICAgICAgICA/IGBcbiAgICAgY29uc29sZS5sb2coeyBVc2VyQ29tcG9uZW50cyB9KVxuICAgICBjb25zb2xlLmxvZyhcIkNvbXBvbmVudFRvUmVuZGVyIFwiICsgQ29tcG9uZW50VG9SZW5kZXIudG9TdHJpbmcoKSwgIHsgQ29tcG9uZW50VG9SZW5kZXIgfSlcbiAgICAgYFxuICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgIH1cblxuICAgICAgY2lyY3VpdC5hZGQoICAgICAgIFxuICAgICAgICAgIDxDb21wb25lbnRUb1JlbmRlciAke29wdHMubWFpbkNvbXBvbmVudFByb3BzID8gYHsuLi4ke0pTT04uc3RyaW5naWZ5KG9wdHMubWFpbkNvbXBvbmVudFByb3BzLCBudWxsLCAyKX19YCA6IFwiXCJ9IC8+IFxuICAgICAgKTtcbmBcbiAgfVxuXG4gIGlmICghb3B0cy5uYW1lICYmIG9wdHMubWFpbkNvbXBvbmVudE5hbWUpIHtcbiAgICBvcHRzLm5hbWUgPSBvcHRzLm1haW5Db21wb25lbnROYW1lXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgZW5oYW5jZVJvb3RDaXJjdWl0SGFzTm9DaGlsZHJlbkVycm9yID0gKFxuICBlcnJvcjogdW5rbm93bixcbiAgZW50cnlwb2ludD86IHN0cmluZyxcbikgPT4ge1xuICBpZiAoXG4gICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgIGVudHJ5cG9pbnQgJiZcbiAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiUm9vdENpcmN1aXQgaGFzIG5vIGNoaWxkcmVuXCIpICYmXG4gICAgIWVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1wiZW50cnlwb2ludFwiOicpXG4gICkge1xuICAgIGNvbnN0IGVudHJ5cG9pbnRNZXNzYWdlID0gZW50cnlwb2ludC5zdGFydHNXaXRoKFwiLi9cIilcbiAgICAgID8gZW50cnlwb2ludC5zbGljZSgyKVxuICAgICAgOiBlbnRyeXBvaW50XG4gICAgZXJyb3IubWVzc2FnZSA9IGAke2Vycm9yLm1lc3NhZ2V9LiBcImVudHJ5cG9pbnRcIjogXCIke2VudHJ5cG9pbnRNZXNzYWdlfVwiIGlzIHNldCBpbiB0aGUgcnVubmVyIGNvbmZpZ3VyYXRpb24sIGVudHJ5cG9pbnRzIG11c3QgY29udGFpbiBcImNpcmN1aXQuYWRkKC4uLilcIiwgeW91IG1pZ2h0IGJlIGxvb2tpbmcgdG8gdXNlIG1haW5Db21wb25lbnRQYXRoIGluc3RlYWQgaWYgeW91ciBmaWxlIGV4cG9ydHMgYSBjb21wb25lbnQuYFxuICB9XG5cbiAgcmV0dXJuIGVycm9yXG59XG4iLCAiLyoqXG4gKiBHZXQgYWxsIHBhdGhzIG9mIGFuIG9iamVjdFxuICpcbiAqIGdldE9iamVjdFBhdGhzKHsgYTogeyBiOiAyLCBjOiB7IGQ6IDMgfSB9LCBlOiA1IH0pXG4gKlxuICogLy8gT3V0cHV0OiBbJ2EuYicsICdhLmMuZCcsICdlJ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9iamVjdFBhdGhzKFxuICBvYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIHByZWZpeCA9IFwiXCIsXG4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHBhdGhzOiBzdHJpbmdbXSA9IFtdXG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV1cbiAgICBjb25zdCBwYXRoID0gcHJlZml4ID8gYCR7cHJlZml4fS4ke2tleX1gIDoga2V5XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY29uc3Qgc3ViUGF0aHMgPSBnZXRPYmplY3RQYXRocyh2YWx1ZSwgcGF0aClcbiAgICAgIHBhdGhzLnB1c2goLi4uc3ViUGF0aHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzLnB1c2gocGF0aClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0aHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlQXRQYXRoKG9iajogUmVjb3JkPHN0cmluZywgYW55PiwgcGF0aDogc3RyaW5nKTogYW55IHtcbiAgY29uc3Qga2V5cyA9IHBhdGguc3BsaXQoXCIuXCIpXG4gIGxldCBjdXJyZW50ID0gb2JqXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjdXJyZW50ID0gY3VycmVudFtrZXldXG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRcbn1cbi8qKlxuICogU2V0IGEgdmFsdWUgYXQgYSBwYXRoIGluIGFuIG9iamVjdFxuICpcbiAqIHNldFZhbHVlQXRQYXRoKHsgYTogeyBiOiAyIH0gfSwgXCJhLmMuZFwiLCA1KVxuICpcbiAqIC8vIE91dHB1dDogeyBhOiB7IGI6IDIsIGM6IHsgZDogNSB9IH0gfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VmFsdWVBdFBhdGgoXG4gIG9iajogUmVjb3JkPHN0cmluZywgYW55PixcbiAgcGF0aDogc3RyaW5nLFxuICB2YWx1ZTogYW55LFxuKSB7XG4gIGNvbnN0IGtleXMgPSBwYXRoLnNwbGl0KFwiLlwiKVxuICBsZXQgY3VycmVudCA9IG9ialxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG5cbiAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgbGFzdCBrZXksIHNldCB0aGUgdmFsdWUuXG4gICAgaWYgKGkgPT09IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgY3VycmVudFtrZXldID0gdmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0IG9yIGlzIG5vdCBhbiBvYmplY3QgKGF2b2lkIG92ZXJ3cml0aW5nIGFycmF5cyksIGNyZWF0ZSBhIG5ldyBvYmplY3RcbiAgICAgIGlmIChcbiAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJyZW50LCBrZXkpIHx8XG4gICAgICAgIHR5cGVvZiBjdXJyZW50W2tleV0gIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgY3VycmVudFtrZXldID09PSBudWxsIHx8XG4gICAgICAgIEFycmF5LmlzQXJyYXkoY3VycmVudFtrZXldKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRba2V5XSA9IHt9XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudFtrZXldXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgQ2lyY3VpdFJ1bm5lciB9IGZyb20gXCIuL0NpcmN1aXRSdW5uZXJcIlxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuVHNjaXJjdWl0Q29kZShcbiAgZmlsZXN5c3RlbU9yQ29kZVN0cmluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZyxcbiAgb3B0cz86IE9taXQ8UGFyYW1ldGVyczxDaXJjdWl0UnVubmVyW1wiZXhlY3V0ZVdpdGhGc01hcFwiXT5bMF0sIFwiZnNNYXBcIj4sXG4pIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nID09PSBcInN0cmluZ1wiICYmXG4gICAgIWZpbGVzeXN0ZW1PckNvZGVTdHJpbmcuaW5jbHVkZXMoXCJleHBvcnRcIilcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBcImV4cG9ydFwiIGtleXdvcmQgd2Fzbid0IGZvdW5kIGluIHlvdXIgcHJvdmlkZWQgY29kZS4gWW91IG5lZWQgdG8gZXhwb3J0IGEgY29tcG9uZW50IGluIHlvdXIgY29kZSwgZS5nLlxcblxcbmV4cG9ydCBkZWZhdWx0ICgpID0+IChcXG4gIDxyZXNpc3RvciBuYW1lPVwiUjFcIiByZXNpc3RhbmNlPVwiMWtcIiAvPlxcbilgLFxuICAgIClcbiAgfVxuICBjb25zdCBmaWxlc3lzdGVtID1cbiAgICB0eXBlb2YgZmlsZXN5c3RlbU9yQ29kZVN0cmluZyA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyB7IFwidXNlci1jb2RlLnRzeFwiOiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nIH1cbiAgICAgIDogZmlsZXN5c3RlbU9yQ29kZVN0cmluZ1xuXG4gIGNvbnN0IGNpcmN1aXRSdW5uZXIgPSBuZXcgQ2lyY3VpdFJ1bm5lcigpXG5cbiAgYXdhaXQgY2lyY3VpdFJ1bm5lci5leGVjdXRlV2l0aEZzTWFwKHtcbiAgICBmc01hcDogZmlsZXN5c3RlbSxcbiAgICAuLi5vcHRzLFxuICB9KVxuXG4gIGF3YWl0IGNpcmN1aXRSdW5uZXIucmVuZGVyVW50aWxTZXR0bGVkKClcblxuICByZXR1cm4gYXdhaXQgY2lyY3VpdFJ1bm5lci5nZXRDaXJjdWl0SnNvbigpXG59XG4iLCAiaW1wb3J0IHsgcnVuVHNjaXJjdWl0Q29kZSB9IGZyb20gXCIuL3J1blRzY2lyY3VpdENvZGVcIlxuXG5leHBvcnQgY29uc3QgcnVuVHNjaXJjdWl0TW9kdWxlID0gYXN5bmMgKFxuICBtb2R1bGU6IHN0cmluZyxcbiAgb3B0czogeyBwcm9wcz86IFJlY29yZDxzdHJpbmcsIGFueT47IGV4cG9ydE5hbWU/OiBzdHJpbmcgfSA9IHt9LFxuKSA9PiB7XG4gIGlmICghbW9kdWxlLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgbW9kdWxlID0gYEB0c2NpLyR7bW9kdWxlLnJlcGxhY2UoL1xcLy8sIFwiLlwiKX1gXG4gIH1cbiAgY29uc3QgY2lyY3VpdEpzb24gPSBhd2FpdCBydW5Uc2NpcmN1aXRDb2RlKFxuICAgIHtcbiAgICAgIC8vIFRPRE8gaGFuZGxlIGV4cG9ydHMgdGhhdCBhcmUgbm90IHRoZSBkZWZhdWx0IGV4cG9ydCBieSBzY2FubmluZ1xuICAgICAgLy8gb3RoZXJFeHBvcnRzIGZvciBjb21wb25lbnRzXG4gICAgICBcInVzZXItY29kZS50c3hcIjogYFxuICAgIGltcG9ydCBNb2R1bGUsICogYXMgb3RoZXJFeHBvcnRzIGZyb20gXCIke21vZHVsZX1cIjtcblxuICAgIGxldCBleHBvcnROYW1lID0gXCIke29wdHMuZXhwb3J0TmFtZSA/PyBcIlwifVwiXG5cbiAgICBpZiAoKCFNb2R1bGUgfHwgdHlwZW9mIE1vZHVsZSAhPT0gXCJmdW5jdGlvblwiKSAmJiAhQm9vbGVhbihleHBvcnROYW1lKSkge1xuICAgICAgZXhwb3J0TmFtZSA9IE9iamVjdC5rZXlzKG90aGVyRXhwb3J0cykuZmlsdGVyKGtleSA9PiBrZXlbMF0gPT09IGtleVswXS50b1VwcGVyQ2FzZSgpICYmIHR5cGVvZiBvdGhlckV4cG9ydHNba2V5XSA9PT0gXCJmdW5jdGlvblwiKVswXVxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRFeHBvcnQgPSBleHBvcnROYW1lID8gb3RoZXJFeHBvcnRzW2V4cG9ydE5hbWVdIDogTW9kdWxlXG5cbiAgICBpZiAoIWRlZmF1bHRFeHBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXGBObyBleHBvcnQgZm91bmQgZm9yIG1vZHVsZSBcIlxcJHttb2R1bGV9XCIgKHRyaWVkIFwiXFwke2V4cG9ydE5hbWUgPz8gXCJkZWZhdWx0XCJ9XCIpXFxgKVxuICAgIH1cblxuICAgIGV4cG9ydCBkZWZhdWx0IGRlZmF1bHRFeHBvcnQ7XG4gICAgYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIG1haW5Db21wb25lbnRQcm9wczogb3B0cy5wcm9wcyxcbiAgICB9LFxuICApXG4gIHJldHVybiBjaXJjdWl0SnNvblxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjtBQUFBLFNBQVMsbUJBQW1CO0FBRTVCLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksV0FBVztBQUN2QixZQUFZLHdCQUF3Qjs7O0FDQzdCLElBQU0sZ0NBQWdDLENBQzNDLG1CQUN1QjtBQUV2QixNQUFJLFFBQVEsZUFBZSxNQUFNLGdCQUFnQjtBQUNqRCxNQUFJLE1BQU8sUUFBTyxNQUFNLENBQUM7QUFJekIsVUFBUSxlQUFlO0FBQUEsSUFDckI7QUFBQSxFQUNGO0FBQ0EsTUFBSSxNQUFPLFFBQU8sTUFBTSxDQUFDO0FBRXpCLFNBQU87QUFDVDs7O0FDaEJPLElBQU0scUNBQXFDLENBQ2hELHNCQUNXO0FBQ1gsTUFBSSxrQkFBa0IsU0FBUyxLQUFLLEdBQUc7QUFDckMsV0FBTyxrQkFBa0IsUUFBUSxRQUFRLEVBQUU7QUFBQSxFQUM3QztBQUNBLFNBQU87QUFDVDs7O0FDSk8sSUFBTSx1QkFBdUIsQ0FDbEMsY0FDdUI7QUFDdkIsTUFBSSxDQUFDLFVBQVcsUUFBTztBQUV2QixNQUFJLFVBQVUsV0FBVyxRQUFRLEdBQUc7QUFDbEMsVUFBTSxvQkFBb0IsOEJBQThCLFNBQVM7QUFDakUsUUFBSSxtQkFBbUI7QUFDckIsYUFBTyxtQ0FBbUMsaUJBQWlCO0FBQUEsSUFDN0Q7QUFHQSxXQUFPO0FBQUEsRUFDVDtBQUdBLFNBQU8sbUNBQW1DLFNBQVM7QUFDckQ7OztBQ3JCTyxJQUFNLFFBQVEsb0JBQUksSUFBaUI7QUFFMUMsSUFBTSxvQkFBb0IsT0FBTyxNQUFXLFdBQWdCO0FBQzFELFFBQU0sY0FBYyxJQUFJLGdCQUFnQjtBQUFBLElBQ3RDLEdBQUc7QUFBQSxJQUNILE1BQU07QUFBQSxFQUNSLENBQUMsRUFBRSxTQUFTO0FBQ1osTUFBSSxNQUFNLElBQUksV0FBVyxH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QUFjO0FBRXhDLFFBQU0sY0FBYyxpQkFBaUI7QUFBQSxJQUNuQyxPQUFPO0FBQUEsSUFDUCxHQUFHO0FBQUEsRUFDTCxDQUFDO0FBRUQsUUFBTSxjQUFjLG1CQUFtQjtBQUV2QyxTQUFPLE1BQU0sY0FBYyxlQUFlO0FBQzVDOzs7QUMzQk8sSUFBTSxxQkFBcUIsT0FDaEMsUUFDQSxPQUE2RCxDQUFDLE1BQzNEO0FBQ0gsTUFBSSxDQUFDLE9BQU8sV0FBVyxHQUFHLEdBQUc7QUFDM0IsYUFBUyxTQUFTLE9BQU8sUUFBUSxNQUFNLEdBQUcsQ0FBQztBQUFBLEVBQzdDO0FBQ0EsUUFBTSxjQUFjLE1BQU07QUFBQSxJQUN4QjtBQUFBO0FBQUE7QUFBQSxNQUdFLGlCQUFpQjtBQUFBLDZDQUNzQixNQUFNO0FBQUE7QUFBQSx3QkFFM0IsS0FBSyxjQUFjLEVBQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBY3pDO0FBQUEsSUFDQTtBQUFBLE1BQ0Usb0JBQW9CLEtBQUs7QUFBQSxJQUMzQjtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7IiwKICAibmFtZXMiOiBbIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImltcG9ydE5hbWUiLCAiRGVidWciLCAiZGVidWciLCAidW5wcmVmaXhlZFBhdGgiLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciXQp9Cg==