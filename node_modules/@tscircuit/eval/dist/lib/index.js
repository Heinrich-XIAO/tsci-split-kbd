// webworker/execution-context.ts
import { RootCircuit } from "@tscircuit/core";
import * as tscircuitCore from "@tscircuit/core";
import * as React from "react";
import * as tscircuitMathUtils from "@tscircuit/math-utils";

// node_modules/@tscircuit/parts-engine/lib/footprint-translators/get-footprinter-string-from-kicad.ts
var getFootprinterStringFromKicad = (kicadFootprint) => {
  let match = kicadFootprint.match(/:[RC]_(\d{4})_/);
  if (match) return match[1];
  match = kicadFootprint.match(
    /:(SOIC-\d+|SOT-\d+|SOD-\d+|SSOP-\d+|TSSOP-\d+|QFP-\d+|QFN-\d+)/
  );
  if (match) return match[1];
  return void 0;
};

// node_modules/@tscircuit/parts-engine/lib/footprint-translators/get-jlc-package-from-footprinter-string.ts
var getJlcPackageFromFootprinterString = (footprinterString) => {
  if (footprinterString.includes("cap")) {
    return footprinterString.replace(/cap/g, "");
  }
  return footprinterString;
};

// node_modules/@tscircuit/parts-engine/lib/footprint-translators/index.ts
var getJlcpcbPackageName = (footprint) => {
  if (!footprint) return void 0;
  if (footprint.startsWith("kicad:")) {
    const footprinterString = getFootprinterStringFromKicad(footprint);
    if (footprinterString) {
      return getJlcPackageFromFootprinterString(footprinterString);
    }
    return footprint;
  }
  return getJlcPackageFromFootprinterString(footprint);
};

// node_modules/@tscircuit/parts-engine/lib/jlc-parts-engine.ts
var cache = /* @__PURE__ */ new Map();
var getJlcPartsCached = async (name, params) => {
  const paramString = new URLSearchParams({
    ...params,
    json: "true"
  }).toString();
  if (cache.has(paramString)) {
    return cache.get(paramString);
  }
  const response = await fetch(
    `https://jlcsearch.tscircuit.com/${name}/list?${paramString}`
  );
  const responseJson = await response.json();
  cache.set(paramString, responseJson);
  return responseJson;
};
var withBasicPartPreference = (parts) => {
  if (!parts) return [];
  return [...parts].sort(
    (a, b) => Number(b.is_basic ?? false) - Number(a.is_basic ?? false)
  );
};
var jlcPartsEngine = {
  findPart: async ({
    sourceComponent,
    footprinterString
  }) => {
    const jlcpcbPackage = getJlcpcbPackageName(footprinterString);
    if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resistor") {
      const { resistors } = await getJlcPartsCached("resistors", {
        resistance: sourceComponent.resistance,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(resistors).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_capacitor") {
      const { capacitors } = await getJlcPartsCached("capacitors", {
        capacitance: sourceComponent.capacitance,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(capacitors).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_pin_header") {
      let pitch;
      if (footprinterString?.includes("_p")) {
        pitch = Number(footprinterString.split("_p")[1]);
      }
      const { headers } = await getJlcPartsCached(
        "headers",
        pitch ? {
          pitch,
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        } : {
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        }
      );
      return {
        jlcpcb: withBasicPartPreference(headers).map((h) => `C${h.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_potentiometer") {
      const { potentiometers } = await getJlcPartsCached("potentiometers", {
        resistance: sourceComponent.max_resistance,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(potentiometers).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_diode") {
      const { diodes } = await getJlcPartsCached("diodes", {
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(diodes).map((d) => `C${d.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_chip") {
      const { chips } = await getJlcPartsCached("chips", {
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(chips).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_transistor") {
      const { transistors } = await getJlcPartsCached("transistors", {
        package: jlcpcbPackage,
        transistor_type: sourceComponent.transistor_type
      });
      return {
        jlcpcb: withBasicPartPreference(transistors).map((t) => `C${t.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_power_source") {
      const { power_sources } = await getJlcPartsCached("power_sources", {
        voltage: sourceComponent.voltage,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(power_sources).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_inductor") {
      const { inductors } = await getJlcPartsCached("inductors", {
        inductance: sourceComponent.inductance,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(inductors).map((i) => `C${i.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_crystal") {
      const { crystals } = await getJlcPartsCached("crystals", {
        frequency: sourceComponent.frequency,
        load_capacitance: sourceComponent.load_capacitance,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(crystals).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_mosfet") {
      const { mosfets } = await getJlcPartsCached("mosfets", {
        package: jlcpcbPackage,
        mosfet_mode: sourceComponent.mosfet_mode,
        channel_type: sourceComponent.channel_type
      });
      return {
        jlcpcb: withBasicPartPreference(mosfets).map((m) => `C${m.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resonator") {
      const { resonators } = await getJlcPartsCached("resonators", {
        frequency: sourceComponent.frequency,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(resonators).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_switch") {
      const { switches } = await getJlcPartsCached("switches", {
        switch_type: sourceComponent.type,
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(switches).map((s) => `C${s.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_led") {
      const { leds } = await getJlcPartsCached("leds", {
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(leds).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_fuse") {
      const { fuses } = await getJlcPartsCached("fuses", {
        package: jlcpcbPackage
      });
      return {
        jlcpcb: withBasicPartPreference(fuses).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    }
    return {};
  }
};

// lib/getPlatformConfig.ts
import { parseKicadModToCircuitJson } from "kicad-component-converter";

// lib/utils/dynamically-load-dependency-with-cdn-backup.ts
var dynamicallyLoadDependencyWithCdnBackup = async (packageName) => {
  try {
    const module = await import(packageName);
    return module.default;
  } catch (e) {
    console.log(`Failed to load ${packageName} locally, trying CDN fallback...`);
    try {
      const res = await fetch(
        `https://cdn.jsdelivr.net/npm/${packageName}/+esm`
      );
      if (!res.ok) {
        throw new Error(
          `Failed to fetch ${packageName} from CDN: ${res.statusText}`
        );
      }
      const code = await res.text();
      const blob = new Blob([code], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      try {
        const { default: loadedModule } = await import(url);
        return loadedModule;
      } finally {
        URL.revokeObjectURL(url);
      }
    } catch (cdnError) {
      console.error(`CDN fallback for ${packageName} also failed:`, cdnError);
      throw cdnError;
    }
  }
};

// lib/getPlatformConfig.ts
var KICAD_FOOTPRINT_CACHE_URL = "https://kicad-mod-cache.tscircuit.com";
var ngspiceEngineCache = null;
var getPlatformConfig = () => ({
  partsEngine: jlcPartsEngine,
  spiceEngineMap: {
    ngspice: {
      simulate: async (spice) => {
        if (!ngspiceEngineCache) {
          const createNgspiceSpiceEngine = await dynamicallyLoadDependencyWithCdnBackup(
            "@tscircuit/ngspice-spice-engine"
          ).catch((error) => {
            throw new Error(
              "Could not load ngspice engine from local node_modules or CDN fallback.",
              { cause: error }
            );
          });
          if (createNgspiceSpiceEngine) {
            ngspiceEngineCache = await createNgspiceSpiceEngine();
          }
        }
        if (!ngspiceEngineCache) {
          throw new Error(
            "Could not load ngspice engine from local node_modules or CDN fallback."
          );
        }
        return ngspiceEngineCache.simulate(spice);
      }
    }
  },
  footprintLibraryMap: {
    kicad: async (footprintName) => {
      const baseUrl = `${KICAD_FOOTPRINT_CACHE_URL}/${footprintName}`;
      const circuitJsonUrl = `${baseUrl}.circuit.json`;
      const res = await fetch(circuitJsonUrl);
      const raw = await res.json();
      const filtered = Array.isArray(raw) ? raw.filter(
        (el) => el?.type === "pcb_silkscreen_text" ? el?.text === "REF**" : true
      ) : raw;
      const wrlUrl = `${baseUrl}.wrl`;
      return {
        footprintCircuitJson: filtered,
        cadModel: { wrlUrl, modelUnitToMmScale: 2.54 }
      };
    }
  },
  footprintFileParserMap: {
    kicad_mod: {
      loadFromUrl: async (url) => {
        const kicadContent = await fetch(url).then((res) => res.text());
        const kicadJson = await parseKicadModToCircuitJson(kicadContent);
        return {
          footprintCircuitJson: Array.isArray(kicadJson) ? kicadJson : [kicadJson]
        };
      }
    }
  }
});

// webworker/execution-context.ts
import Debug from "debug";
var debug = Debug("tsci:eval:execution-context");
function createExecutionContext(webWorkerConfiguration, opts = {}) {
  globalThis.React = React;
  const basePlatform = opts.platform || getPlatformConfig();
  const platform = opts.projectConfig ? { ...basePlatform, ...opts.projectConfig } : basePlatform;
  if (platform.partsEngineDisabled) {
    platform.partsEngine = void 0;
  }
  const circuit = new RootCircuit({
    platform
  });
  if (opts.name) {
    circuit.name = opts.name;
  }
  if (opts.debugNamespace) {
    circuit.enableDebug(opts.debugNamespace);
  }
  const logs = [];
  return {
    fsMap: {},
    entrypoint: "",
    logger: {
      info: (message) => {
        logs.push({ msg: message });
      },
      getLogs: () => logs,
      stringifyLogs: () => logs.map((log) => log.msg).join("\n")
    },
    preSuppliedImports: {
      "@tscircuit/core": tscircuitCore,
      tscircuit: tscircuitCore,
      "@tscircuit/math-utils": tscircuitMathUtils,
      react: React,
      debug: Debug,
      // This is usually used as a type import, we can remove the shim when we
      // ignore type imports in getImportsFromCode
      "@tscircuit/props": {}
    },
    circuit,
    tsConfig: null,
    importStack: [],
    currentlyImporting: /* @__PURE__ */ new Set(),
    ...webWorkerConfiguration
  };
}

// lib/runner/normalizeFsMap.ts
function normalizeFilePath(filePath) {
  let normFilePath = filePath;
  normFilePath = normFilePath.replace(/\\/g, "/");
  normFilePath = normFilePath.trim();
  if (normFilePath.startsWith("./")) {
    normFilePath = normFilePath.slice(2);
  }
  if (normFilePath.startsWith("/")) {
    normFilePath = normFilePath.slice(1);
  }
  return normFilePath;
}
function normalizeFsMap(fsMap) {
  const normalizedFsMap = {};
  for (const [fsPath, fileContent] of Object.entries(fsMap)) {
    normalizedFsMap[normalizeFilePath(fsPath)] = fileContent;
  }
  return normalizedFsMap;
}

// lib/runner/tsconfigPaths.ts
function getTsConfig(fsMapOrAllFilePaths) {
  if (Array.isArray(fsMapOrAllFilePaths)) return null;
  const tsconfigContent = fsMapOrAllFilePaths["tsconfig.json"];
  if (!tsconfigContent) return null;
  try {
    const sanitizedContent = tsconfigContent.replace(
      /\/\*[\s\S]*?\*\/|\/\/.*/g,
      ""
    );
    const parsed = JSON.parse(sanitizedContent);
    return parsed;
  } catch (e) {
    throw new Error(`Failed to parse tsconfig.json: ${e.message}`);
  }
}
function resolveWithTsconfigPaths(opts) {
  const { importPath, normalizedFilePathMap, extensions, tsConfig } = opts;
  const paths = tsConfig?.compilerOptions?.paths;
  if (!paths) return null;
  const baseUrl = tsConfig?.compilerOptions?.baseUrl || ".";
  const tryResolveCandidate = (candidate) => {
    const normalizedCandidate = normalizeFilePath(candidate);
    if (normalizedFilePathMap.has(normalizedCandidate)) {
      return normalizedFilePathMap.get(normalizedCandidate);
    }
    for (const ext of extensions) {
      const withExt = `${normalizedCandidate}.${ext}`;
      if (normalizedFilePathMap.has(withExt)) {
        return normalizedFilePathMap.get(withExt);
      }
    }
    return null;
  };
  for (const [alias, targets] of Object.entries(paths)) {
    const hasWildcard = alias.includes("*");
    if (hasWildcard) {
      const [prefix, suffix] = alias.split("*");
      if (!importPath.startsWith(prefix) || !importPath.endsWith(suffix || "")) {
        continue;
      }
      const starMatch = importPath.slice(
        prefix.length,
        importPath.length - (suffix ? suffix.length : 0)
      );
      for (const target of targets) {
        const replaced = target.replace("*", starMatch);
        const candidate = baseUrl && !replaced.startsWith("./") && !replaced.startsWith("/") ? `${baseUrl}/${replaced}` : replaced;
        const resolved = tryResolveCandidate(candidate);
        if (resolved) return resolved;
      }
    } else {
      if (importPath !== alias) continue;
      for (const target of targets) {
        const candidate = baseUrl && !target.startsWith("./") && !target.startsWith("/") ? `${baseUrl}/${target}` : target;
        const resolved = tryResolveCandidate(candidate);
        if (resolved) return resolved;
      }
    }
  }
  const resolvedPathFromBaseUrl = resolveWithBaseUrl({
    importPath,
    normalizedFilePathMap,
    extensions,
    tsConfig
  });
  if (resolvedPathFromBaseUrl) return resolvedPathFromBaseUrl;
  return null;
}
function resolveWithBaseUrl(opts) {
  const { importPath, normalizedFilePathMap, extensions, tsConfig } = opts;
  const baseUrl = tsConfig?.compilerOptions?.baseUrl;
  if (!baseUrl) return null;
  const filePathToResolve = `${baseUrl}/${importPath}`;
  const normalizedFilePath = normalizeFilePath(filePathToResolve);
  if (normalizedFilePathMap.has(normalizedFilePath)) {
    return normalizedFilePathMap.get(normalizedFilePath);
  }
  for (const ext of extensions) {
    const withExt = `${normalizedFilePath}.${ext}`;
    if (normalizedFilePathMap.has(withExt)) {
      return normalizedFilePathMap.get(withExt);
    }
  }
  return null;
}
function matchesTsconfigPathPattern(importPath, tsConfig) {
  const paths = tsConfig?.compilerOptions?.paths;
  if (!paths) return false;
  for (const [alias] of Object.entries(paths)) {
    const hasWildcard = alias.includes("*");
    if (hasWildcard) {
      const [prefix, suffix] = alias.split("*");
      if (importPath.startsWith(prefix) && importPath.endsWith(suffix || "")) {
        return true;
      }
    } else {
      if (importPath === alias) return true;
    }
  }
  return false;
}

// lib/runner/CircuitRunner.ts
import "react";

// lib/utils/dirname.ts
function dirname(path) {
  if (!path) return ".";
  const normalizedPath = path.replace(/\\/g, "/");
  const cleanPath = normalizedPath.replace(/\/+$/, "");
  if (cleanPath.indexOf("/") === -1) return ".";
  return cleanPath.substring(0, cleanPath.lastIndexOf("/")) || "/";
}

// lib/utils/resolveRelativePath.ts
function resolveRelativePath(importPath, cwd) {
  if (importPath.startsWith("../")) {
    const parentDir = dirname(cwd);
    return resolveRelativePath(importPath.slice(3), parentDir);
  }
  if (importPath.startsWith("./")) {
    return resolveRelativePath(importPath.slice(2), cwd);
  }
  if (importPath.startsWith("/")) {
    return importPath.slice(1);
  }
  return `${cwd}/${importPath}`;
}

// lib/runner/resolveFilePath.ts
var resolveFilePath = (unknownFilePath, fsMapOrAllFilePaths, cwd, opts = {}) => {
  const resolvedPath = cwd ? resolveRelativePath(unknownFilePath, cwd) : unknownFilePath;
  const filePaths = new Set(
    Array.isArray(fsMapOrAllFilePaths) ? fsMapOrAllFilePaths : Object.keys(fsMapOrAllFilePaths)
  );
  if (filePaths.has(resolvedPath)) {
    return resolvedPath;
  }
  const normalizedFilePathMap = /* @__PURE__ */ new Map();
  for (const filePath of filePaths) {
    normalizedFilePathMap.set(normalizeFilePath(filePath), filePath);
  }
  const normalizedResolvedPath = normalizeFilePath(resolvedPath);
  if (normalizedFilePathMap.has(normalizedResolvedPath)) {
    return normalizedFilePathMap.get(normalizedResolvedPath);
  }
  const extension = ["tsx", "ts", "json", "js", "jsx", "obj", "gltf", "glb"];
  for (const ext of extension) {
    const possibleFilePath = `${normalizedResolvedPath}.${ext}`;
    if (normalizedFilePathMap.has(possibleFilePath)) {
      return normalizedFilePathMap.get(possibleFilePath);
    }
  }
  const tsConfig = opts.tsConfig ?? null;
  if (!unknownFilePath.startsWith("./") && !unknownFilePath.startsWith("../")) {
    const resolvedPathFromPaths = resolveWithTsconfigPaths({
      importPath: unknownFilePath,
      normalizedFilePathMap,
      extensions: extension,
      tsConfig
    });
    if (resolvedPathFromPaths) return resolvedPathFromPaths;
    const resolvedPathFromBaseUrl = resolveWithBaseUrl({
      importPath: unknownFilePath,
      normalizedFilePathMap,
      extensions: extension,
      tsConfig
    });
    if (resolvedPathFromBaseUrl) return resolvedPathFromBaseUrl;
  }
  if (!unknownFilePath.startsWith("./") && !unknownFilePath.startsWith("../")) {
    const normalizedUnknownFilePath = normalizeFilePath(unknownFilePath);
    if (normalizedFilePathMap.has(normalizedUnknownFilePath)) {
      return normalizedFilePathMap.get(normalizedUnknownFilePath);
    }
    for (const ext of extension) {
      const possibleFilePath = `${normalizedUnknownFilePath}.${ext}`;
      if (normalizedFilePathMap.has(possibleFilePath)) {
        return normalizedFilePathMap.get(possibleFilePath);
      }
    }
  }
  return null;
};
var resolveFilePathOrThrow = (unknownFilePath, fsMapOrAllFilePaths, cwd, opts = {}) => {
  const resolvedFilePath = resolveFilePath(
    unknownFilePath,
    fsMapOrAllFilePaths,
    cwd,
    opts
  );
  if (!resolvedFilePath) {
    throw new Error(
      `File not found "${unknownFilePath}", available paths:

${Object.keys(fsMapOrAllFilePaths).join(", ")}`
    );
  }
  return resolvedFilePath;
};

// lib/utils/get-imports-from-code.ts
var getImportsFromCode = (code) => {
  const importRegex = /^\s*import\s+(?:(?:[\w\s]+,\s*)?(?:\*\s+as\s+[\w\s]+|\{[\s\w,]+\}|\w+)\s+from\s*)?['"](.+?)['"]/gm;
  const imports = [];
  let match;
  while ((match = importRegex.exec(code)) !== null) {
    const fullMatch = match[0];
    if (/^\s*import\s+type\b/.test(fullMatch)) {
      continue;
    }
    imports.push(match[1]);
  }
  const reExportRegex = /^\s*export\s+(?:type\s+)?(?:\*\s+as\s+[\w$]+|\*|\{[^}]+\})\s+from\s*['"](.+?)['"]/gm;
  let reExportMatch;
  while ((reExportMatch = reExportRegex.exec(code)) !== null) {
    const fullMatch = reExportMatch[0];
    if (/^\s*export\s+type\b/.test(fullMatch)) {
      continue;
    }
    imports.push(reExportMatch[1]);
  }
  return imports;
};

// webworker/eval-compiled-js.ts
function evalCompiledJs(compiledCode, preSuppliedImports, cwd) {
  ;
  globalThis.__tscircuit_require = (name) => {
    const resolvedFilePath = resolveFilePath(name, preSuppliedImports, cwd);
    const hasResolvedFilePath = resolvedFilePath && preSuppliedImports[resolvedFilePath];
    if (!preSuppliedImports[name] && !hasResolvedFilePath) {
      throw new Error(`Import "${name}" not found ${cwd ? `in "${cwd}"` : ""}`);
    }
    const mod = preSuppliedImports[name] || preSuppliedImports[resolvedFilePath];
    return new Proxy(mod, {
      get(target, prop) {
        if (!(prop in target)) {
          if (prop === "default") {
            if (target.default !== void 0) {
              return target.default;
            }
            if (target.__esModule) {
              return void 0;
            }
            if (typeof target === "function" || typeof target === "object") {
              return target;
            }
            return void 0;
          }
          if (prop === "__esModule") {
            return true;
          }
          throw new Error(
            `Component "${String(prop)}" is not exported by "${name}"`
          );
        }
        return target[prop];
      }
    });
  };
  const functionBody = `
  var exports = {};
  var require = globalThis.__tscircuit_require;
  var module = { exports };
  var circuit = globalThis.__tscircuit_circuit;
  ${compiledCode};
  return module;`.trim();
  return Function(functionBody).call(globalThis);
}

// webworker/import-local-file.ts
import Debug2 from "debug";

// lib/shared/static-asset-extensions.ts
var STATIC_ASSET_EXTENSIONS = [
  ".glb",
  ".kicad_mod",
  ".gltf",
  ".obj",
  ".stl"
];
var isStaticAssetPath = (path) => STATIC_ASSET_EXTENSIONS.some((ext) => path.endsWith(ext));

// webworker/transform-with-sucrase.ts
import { transform } from "sucrase";
var TS_EXTENSIONS = /* @__PURE__ */ new Set([".ts", ".tsx", ".mts", ".cts"]);
var JSX_EXTENSIONS = /* @__PURE__ */ new Set([".tsx", ".jsx", ".ts"]);
var TYPE_STAR_EXPORT_REGEX = /^\s*export\s+type\s+\*\s+(?:as\s+[\w$]+\s+)?from\s+['"][^'"]+['"]\s*;?\s*$/gim;
var stripTypeStarExports = (code) => code.replace(TYPE_STAR_EXPORT_REGEX, "");
var stripQueryAndHash = (filePath) => {
  const queryIndex = filePath.indexOf("?");
  const hashIndex = filePath.indexOf("#");
  let endIndex = filePath.length;
  if (queryIndex !== -1 && hashIndex !== -1) {
    endIndex = Math.min(queryIndex, hashIndex);
  } else if (queryIndex !== -1) {
    endIndex = queryIndex;
  } else if (hashIndex !== -1) {
    endIndex = hashIndex;
  }
  return filePath.slice(0, endIndex);
};
var getExtension = (filePath) => {
  const normalizedPath = stripQueryAndHash(filePath);
  const lastDotIndex = normalizedPath.lastIndexOf(".");
  if (lastDotIndex === -1) {
    return "";
  }
  const lastSlashIndex = Math.max(
    normalizedPath.lastIndexOf("/"),
    normalizedPath.lastIndexOf("\\")
  );
  if (lastSlashIndex > lastDotIndex) {
    return "";
  }
  return normalizedPath.slice(lastDotIndex).toLowerCase();
};
var getTransformsForFilePath = (filePath) => {
  const extension = getExtension(filePath);
  const transforms = ["imports"];
  if (TS_EXTENSIONS.has(extension)) {
    transforms.unshift("typescript");
  }
  if (JSX_EXTENSIONS.has(extension)) {
    transforms.push("jsx");
  }
  return transforms;
};
var transformWithSucrase = (code, filePath) => {
  const transforms = getTransformsForFilePath(filePath);
  const sanitizedCode = stripTypeStarExports(code);
  const { code: transformedCode } = transform(sanitizedCode, {
    filePath,
    production: true,
    transforms
  });
  return transformedCode;
};

// webworker/import-local-file.ts
import { KicadToCircuitJsonConverter } from "kicad-to-circuit-json";
var debug2 = Debug2("tsci:eval:import-local-file");
var importLocalFile = async (importName, ctx, depth = 0) => {
  debug2("importLocalFile called with:", {
    importName
  });
  const { fsMap, preSuppliedImports, importStack, currentlyImporting } = ctx;
  const fsPath = resolveFilePathOrThrow(importName, fsMap, void 0, {
    tsConfig: ctx.tsConfig
  });
  debug2("fsPath:", fsPath);
  if (currentlyImporting.has(fsPath)) {
    const cycleStartIndex = importStack.indexOf(fsPath);
    const cyclePath = cycleStartIndex >= 0 ? importStack.slice(cycleStartIndex).concat(fsPath) : [...importStack, fsPath];
    throw new Error(
      `Circular dependency detected while importing "${fsPath}". The following import chain forms a cycle:

${cyclePath.join(
        " -> "
      )}`
    );
  }
  if (!ctx.fsMap[fsPath]) {
    debug2("fsPath not found in fsMap:", fsPath);
    throw new Error(`File "${fsPath}" not found`);
  }
  const fileContent = fsMap[fsPath];
  debug2("fileContent:", fileContent?.slice(0, 100));
  currentlyImporting.add(fsPath);
  importStack.push(fsPath);
  try {
    if (fsPath.endsWith(".json")) {
      const jsonData = JSON.parse(fileContent);
      preSuppliedImports[fsPath] = {
        __esModule: true,
        default: jsonData
      };
    } else if (fsPath.endsWith(".kicad_pcb")) {
      const converter = new KicadToCircuitJsonConverter();
      converter.addFile(fsPath, fileContent);
      converter.runUntilFinished();
      const circuitJson = converter.getOutput();
      preSuppliedImports[fsPath] = {
        __esModule: true,
        circuitJson
      };
    } else if (isStaticAssetPath(fsPath)) {
      let staticUrl;
      if (fileContent === "__STATIC_ASSET__") {
        const platformConfig = ctx.circuit.platform;
        staticUrl = `${platformConfig?.projectBaseUrl ?? ""}/${fsPath.startsWith("./") ? fsPath.slice(2) : fsPath}`;
      } else {
        const blob = new Blob([fileContent], {
          type: fsPath.endsWith(".kicad_mod") ? "text/plain" : "application/octet-stream"
        });
        staticUrl = URL.createObjectURL(blob);
      }
      preSuppliedImports[fsPath] = {
        __esModule: true,
        default: staticUrl
      };
    } else if (fsPath.endsWith(".tsx") || fsPath.endsWith(".ts")) {
      const importNames = getImportsFromCode(fileContent);
      for (const importName2 of importNames) {
        if (!preSuppliedImports[importName2]) {
          await importEvalPath(importName2, ctx, depth + 1, {
            cwd: dirname(fsPath)
          });
        }
      }
      try {
        const transformedCode = transformWithSucrase(fileContent, fsPath);
        debug2("evalCompiledJs called with:", {
          code: transformedCode.slice(0, 100),
          dirname: dirname(fsPath)
        });
        const importRunResult = evalCompiledJs(
          transformedCode,
          preSuppliedImports,
          dirname(fsPath)
        );
        debug2("importRunResult:", {
          fsPath,
          importRunResult
        });
        preSuppliedImports[fsPath] = importRunResult.exports;
      } catch (error) {
        throw new Error(
          `Eval compiled js error for "${importName}": ${error.message}`
        );
      }
    } else if (fsPath.endsWith(".js")) {
      preSuppliedImports[fsPath] = evalCompiledJs(
        transformWithSucrase(fileContent, fsPath),
        preSuppliedImports,
        dirname(fsPath)
      ).exports;
    } else {
      throw new Error(
        `Unsupported file extension "${fsPath.split(".").pop()}" for "${fsPath}"`
      );
    }
  } finally {
    importStack.pop();
    currentlyImporting.delete(fsPath);
  }
};

// webworker/import-snippet.ts
async function importSnippet(importName, ctx, depth = 0) {
  const { preSuppliedImports } = ctx;
  const fullSnippetName = importName.replace("@tsci/", "").replace(".", "/");
  const { cjs, error } = await globalThis.fetch(`${ctx.cjsRegistryUrl}/${fullSnippetName}`).then(async (res) => ({ cjs: await res.text(), error: null })).catch((e) => ({ error: e, cjs: null }));
  if (error) {
    console.error("Error fetching import", importName, error);
    return;
  }
  try {
    preSuppliedImports[importName] = evalCompiledJs(
      cjs,
      preSuppliedImports
    ).exports;
  } catch (e) {
    console.error("Error importing snippet", e);
  }
}

// lib/utils/resolve-node-module.ts
function createContext(modulePath, fsMap, basePath) {
  return {
    fsMap,
    extensions: [".js", ".jsx", ".ts", ".tsx", ".json"],
    basePath,
    modulePath
  };
}
function findPackageJson(nodeModulesPath, ctx) {
  const packageJsonPath = `${nodeModulesPath}/package.json`;
  if (!ctx.fsMap[packageJsonPath]) return null;
  try {
    return JSON.parse(ctx.fsMap[packageJsonPath]);
  } catch {
    return null;
  }
}
function tryResolveWithExtensions(path, ctx) {
  if (ctx.fsMap[path]) return path;
  for (const ext of ctx.extensions) {
    const pathWithExt = path.replace(/\.js$|\.jsx$/, "") + ext;
    if (ctx.fsMap[pathWithExt]) return pathWithExt;
  }
  return null;
}
function resolveExportPath(nodeModulesPath, exportPath, ctx) {
  const fullExportPath = `${nodeModulesPath}/${exportPath.replace(/^\.\//, "")}`;
  return tryResolveWithExtensions(fullExportPath, ctx);
}
function resolvePackageExports(nodeModulesPath, packageJson, remainingPath, ctx) {
  if (!packageJson.exports) return null;
  const defaultExport = packageJson.exports["."];
  if (remainingPath === "" && defaultExport) {
    if (typeof defaultExport === "string") {
      const resolved = resolveExportPath(nodeModulesPath, defaultExport, ctx);
      if (resolved) return resolved;
    }
  }
  const subpathExport = remainingPath ? packageJson.exports[`./${remainingPath}`] : null;
  if (subpathExport && typeof subpathExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, subpathExport, ctx);
    if (resolved) return resolved;
  }
  const importExport = packageJson.exports["import"];
  if (remainingPath === "" && importExport && typeof importExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, importExport, ctx);
    if (resolved) return resolved;
  }
  return null;
}
function resolvePackageEntryPoint(nodeModulesPath, packageJson, ctx) {
  const entryPoint = packageJson.module || packageJson.main || "index.js";
  const fullPath = `${nodeModulesPath}/${entryPoint}`;
  return tryResolveWithExtensions(fullPath, ctx);
}
function resolveRemainingPath(nodeModulesPath, remainingPath, ctx) {
  if (!remainingPath) {
    for (const ext of ctx.extensions) {
      const indexPath = `${nodeModulesPath}/index${ext}`;
      if (ctx.fsMap[indexPath]) return indexPath;
    }
    return null;
  }
  const fullPath = `${nodeModulesPath}/${remainingPath}`;
  const directMatch = tryResolveWithExtensions(fullPath, ctx);
  if (directMatch) return directMatch;
  for (const ext of ctx.extensions) {
    const indexPath = `${fullPath}/index${ext}`;
    if (ctx.fsMap[indexPath]) return indexPath;
  }
  return null;
}
function resolveNodeModuleInPath(searchPath, ctx) {
  const moduleParts = ctx.modulePath.split("/");
  const scope = moduleParts[0].startsWith("@") ? moduleParts.slice(0, 2).join("/") : moduleParts[0];
  const remainingPath = moduleParts.slice(scope.includes("/") ? 2 : 1).join("/");
  const nodeModulesPath = `${searchPath == "." ? "" : `${searchPath}/`}node_modules/${scope}`;
  const packageJson = findPackageJson(nodeModulesPath, ctx);
  if (packageJson) {
    const exportsResolution = resolvePackageExports(
      nodeModulesPath,
      packageJson,
      remainingPath,
      ctx
    );
    if (exportsResolution) return exportsResolution;
    const entryPointResolution = resolvePackageEntryPoint(
      nodeModulesPath,
      packageJson,
      ctx
    );
    if (entryPointResolution) return entryPointResolution;
  }
  const remainingPathResolution = resolveRemainingPath(
    nodeModulesPath,
    remainingPath,
    ctx
  );
  if (remainingPathResolution) return remainingPathResolution;
  const parentPath = dirname(searchPath);
  if (parentPath && parentPath !== searchPath) {
    return resolveNodeModuleInPath(parentPath, ctx);
  }
  return null;
}
function resolveNodeModule(modulePath, fsMap, basePath) {
  const ctx = createContext(modulePath, fsMap, basePath);
  return resolveNodeModuleInPath(ctx.basePath, ctx);
}

// webworker/import-node-module.ts
import Debug3 from "debug";
var debug3 = Debug3("tsci:eval:import-node-module");
var importNodeModule = async (importName, ctx, depth = 0) => {
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) {
    return;
  }
  const resolvedNodeModulePath = resolveNodeModule(importName, ctx.fsMap, "");
  if (!resolvedNodeModulePath) {
    const platform = ctx.circuit?.platform;
    if (platform?.nodeModulesResolver) {
      debug3(`Attempting to resolve "${importName}" using nodeModulesResolver`);
      try {
        const fileContent = await platform.nodeModulesResolver(importName);
        if (fileContent) {
          debug3(`Successfully resolved "${importName}" via nodeModulesResolver`);
          const syntheticPath = `node_modules/${importName}.ts`;
          ctx.fsMap[syntheticPath] = fileContent;
          await importLocalFile(syntheticPath, ctx, depth);
          preSuppliedImports[importName] = preSuppliedImports[syntheticPath];
          const unprefixedPath2 = syntheticPath.replace(/^node_modules\//, "");
          preSuppliedImports[unprefixedPath2] = preSuppliedImports[syntheticPath];
          return;
        }
        debug3(`nodeModulesResolver returned null for "${importName}"`);
      } catch (error) {
        debug3(`nodeModulesResolver failed for "${importName}":`, error);
      }
    }
    throw new Error(`Node module "${importName}" not found`);
  }
  await importLocalFile(resolvedNodeModulePath, ctx, depth);
  preSuppliedImports[importName] = preSuppliedImports[resolvedNodeModulePath];
  const unprefixedPath = resolvedNodeModulePath.replace(/^node_modules\//, "");
  preSuppliedImports[unprefixedPath] = preSuppliedImports[resolvedNodeModulePath];
  if (resolvedNodeModulePath.endsWith("/index.tsx") || resolvedNodeModulePath.endsWith("/index.ts") || resolvedNodeModulePath.endsWith("/index.js")) {
    const dirPath = resolvedNodeModulePath.replace(/\/index\.(tsx?|js)$/, "");
    const unprefixedDirPath = dirPath.replace(/^node_modules\//, "");
    preSuppliedImports[unprefixedDirPath] = preSuppliedImports[resolvedNodeModulePath];
    if (unprefixedDirPath.startsWith("@")) {
      const scopeParts = unprefixedDirPath.split("/");
      if (scopeParts.length >= 2) {
        const scopedName = `${scopeParts[0]}/${scopeParts[1]}`;
        preSuppliedImports[scopedName] = preSuppliedImports[resolvedNodeModulePath];
      }
    }
  }
};

// webworker/import-npm-package.ts
import Debug4 from "debug";
var debug4 = Debug4("tsci:eval:import-npm-package");
function extractPackagePathFromJSDelivr(url) {
  const prefix = "https://cdn.jsdelivr.net/npm/";
  if (url.startsWith(prefix)) {
    return url.substring(prefix.length).replace(/\/\+esm$/, "");
  }
  return url;
}
async function importNpmPackage(importName, ctx, depth = 0) {
  debug4(`importing npm package: ${importName}`);
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) return;
  const npmCdnUrl = `https://cdn.jsdelivr.net/npm/${importName}/+esm`;
  let finalUrl;
  const { content, error } = await globalThis.fetch(npmCdnUrl).then(async (res) => {
    finalUrl = res.url;
    if (!res.ok)
      throw new Error(
        `Could not fetch "${importName}" from jsdelivr: ${res.statusText}

${ctx.logger.stringifyLogs()}`
      );
    return { content: await res.text(), error: null };
  }).catch((e) => ({ error: e, content: null }));
  if (error) {
    console.error("Error fetching npm import", importName, error);
    throw error;
  }
  const finalImportName = extractPackagePathFromJSDelivr(finalUrl);
  const cwd = dirname(finalImportName);
  const importNames = getImportsFromCode(content);
  for (const subImportName of importNames) {
    if (!preSuppliedImports[subImportName]) {
      await importEvalPath(subImportName, ctx, depth + 1, {
        cwd
      });
    }
  }
  const transformedCode = transformWithSucrase(
    content,
    finalImportName || importName
  );
  try {
    const exports = evalCompiledJs(
      transformedCode,
      preSuppliedImports,
      cwd
    ).exports;
    preSuppliedImports[importName] = exports;
    preSuppliedImports[finalImportName] = exports;
    preSuppliedImports[finalUrl] = exports;
  } catch (e) {
    throw new Error(
      `Eval npm package error for "${importName}": ${e.message}

${ctx.logger.stringifyLogs()}`
    );
  }
}

// webworker/import-eval-path.ts
import Debug5 from "debug";
var debug5 = Debug5("tsci:eval:import-eval-path");
async function importEvalPath(importName, ctx, depth = 0, opts = {}) {
  debug5("importEvalPath called with:", {
    importName,
    depth,
    opts
  });
  ctx.logger.info(
    `importEvalPath("${importName}", {cwd: "${opts.cwd}", depth: ${depth}})`
  );
  debug5(`${"  ".repeat(depth)}\u27A1\uFE0F`, importName);
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) {
    ctx.logger.info(`Import "${importName}" in preSuppliedImports[1]`);
    return;
  }
  if (importName.startsWith("./") && preSuppliedImports[importName.slice(2)]) {
    ctx.logger.info(`Import "${importName}" in preSuppliedImports[2]`);
    return;
  }
  if (depth > 30) {
    throw new Error(
      `Max depth for imports reached (30) Import Path: ${ctx.importStack.join(" -> ")}`
    );
  }
  if (importName.startsWith("/npm/")) {
    const pkgName = importName.replace(/^\/npm\//, "").replace(/\/\+esm$/, "");
    ctx.logger.info(`importNpmPackage("${pkgName}")`);
    await importNpmPackage(pkgName, ctx, depth);
    const pkg = preSuppliedImports[pkgName];
    if (pkg) {
      preSuppliedImports[importName] = pkg;
    }
    return;
  }
  const resolvedLocalImportPath = resolveFilePath(
    importName,
    ctx.fsMap,
    opts.cwd,
    { tsConfig: ctx.tsConfig }
  );
  if (resolvedLocalImportPath) {
    ctx.logger.info(`importLocalFile("${resolvedLocalImportPath}")`);
    await importLocalFile(resolvedLocalImportPath, ctx, depth);
    if (importName !== resolvedLocalImportPath) {
      preSuppliedImports[importName] = preSuppliedImports[resolvedLocalImportPath];
    }
    return;
  }
  const tsConfig = ctx.tsConfig ?? getTsConfig(ctx.fsMap);
  if (!ctx.tsConfig && tsConfig) {
    ctx.tsConfig = tsConfig;
  }
  if (matchesTsconfigPathPattern(importName, tsConfig)) {
    throw new Error(
      `Import "${importName}" matches a tsconfig path alias but could not be resolved to an existing file${opts.cwd ? ` from directory "${opts.cwd}"` : ""}

${ctx.logger.stringifyLogs()}`
    );
  }
  const resolvedNodeModulePath = resolveNodeModule(
    importName,
    ctx.fsMap,
    opts.cwd || ""
  );
  if (resolvedNodeModulePath) {
    ctx.logger.info(`resolvedNodeModulePath="${resolvedNodeModulePath}"`);
    ctx.logger.info(`importNodeModule("${importName}")`);
    return importNodeModule(importName, ctx, depth);
  }
  if (!importName.startsWith(".") && !importName.startsWith("/") && !importName.startsWith("@tsci/")) {
    const platform = ctx.circuit?.platform;
    if (platform?.nodeModulesResolver) {
      ctx.logger.info(
        `importNodeModule("${importName}") via nodeModulesResolver`
      );
      try {
        await importNodeModule(importName, ctx, depth);
        return;
      } catch (error) {
        ctx.logger.info(
          `nodeModulesResolver failed for "${importName}", falling back to npm CDN`
        );
      }
    }
  }
  if (importName.startsWith("@tsci/")) {
    ctx.logger.info(`importSnippet("${importName}")`);
    return importSnippet(importName, ctx, depth);
  }
  if (!importName.startsWith(".") && !importName.startsWith("/")) {
    ctx.logger.info(`importNpmPackage("${importName}")`);
    return importNpmPackage(importName, ctx, depth);
  }
  throw new Error(
    `Unresolved import "${importName}" ${opts.cwd ? `from directory "${opts.cwd}"` : ""}

${ctx.logger.stringifyLogs()}`
  );
}

// lib/runner/setupDefaultEntrypointIfNeeded.ts
import Debug6 from "debug";
var debug6 = Debug6("tsci:eval:setupDefaultEntrypointIfNeeded");
var setupDefaultEntrypointIfNeeded = (opts) => {
  if (!opts.entrypoint && !opts.mainComponentPath) {
    if ("index.tsx" in opts.fsMap) {
      opts.mainComponentPath = "index.tsx";
    } else if ("index.ts" in opts.fsMap) {
      opts.mainComponentPath = "index.ts";
    } else if (Object.keys(opts.fsMap).filter((k) => k.endsWith(".tsx")).length === 1) {
      opts.mainComponentPath = Object.keys(opts.fsMap)[0];
    } else if ("tscircuit.config.json" in opts.fsMap) {
      const configContent = opts.fsMap["tscircuit.config.json"];
      try {
        const config = JSON.parse(configContent);
        if (config.mainEntrypoint) {
          opts.entrypoint = config.mainEntrypoint;
        }
      } catch (e) {
        console.warn("Failed to parse tscircuit.config.json:", e);
      }
    } else {
      throw new Error(
        "Either entrypoint or mainComponentPath must be provided (no index file, could not infer entrypoint)"
      );
    }
  }
  if (!opts.entrypoint && opts.mainComponentPath) {
    opts.entrypoint = "entrypoint.tsx";
    const mainComponentCode = opts.fsMap[resolveFilePathOrThrow(opts.mainComponentPath, opts.fsMap)];
    if (!mainComponentCode) {
      throw new Error(
        `Main component path "${opts.mainComponentPath}" not found in fsMap. Available paths: ${Object.keys(opts.fsMap).join(", ")}`
      );
    }
    opts.fsMap[opts.entrypoint] = `
     import * as UserComponents from "./${opts.mainComponentPath}";
          
      ${opts.mainComponentName ? `
        const ComponentToRender = UserComponents["${opts.mainComponentName}"]
        ` : `const ComponentToRender = UserComponents.default || 
          Object.entries(UserComponents)
          .filter(([name]) => !name.startsWith("use"))
          .map(([_, component]) => component)[0] || (() => null);`}

           ${debug6.enabled ? `
     console.log({ UserComponents })
     console.log("ComponentToRender " + ComponentToRender.toString(),  { ComponentToRender })
     ` : ""}

      circuit.add(       
          <ComponentToRender ${opts.mainComponentProps ? `{...${JSON.stringify(opts.mainComponentProps, null, 2)}}` : ""} /> 
      );
`;
  }
  if (!opts.name && opts.mainComponentName) {
    opts.name = opts.mainComponentName;
  }
};

// lib/utils/enhance-root-circuit-error.ts
var enhanceRootCircuitHasNoChildrenError = (error, entrypoint) => {
  if (error instanceof Error && entrypoint && error.message.includes("RootCircuit has no children") && !error.message.includes('"entrypoint":')) {
    const entrypointMessage = entrypoint.startsWith("./") ? entrypoint.slice(2) : entrypoint;
    error.message = `${error.message}. "entrypoint": "${entrypointMessage}" is set in the runner configuration, entrypoints must contain "circuit.add(...)", you might be looking to use mainComponentPath instead if your file exports a component.`;
  }
  return error;
};

// lib/runner/CircuitRunner.ts
import Debug7 from "debug";

// lib/shared/obj-path.ts
function getObjectPaths(obj, prefix = "") {
  const paths = [];
  for (const key in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, key)) {
      continue;
    }
    const value = obj[key];
    const path = prefix ? `${prefix}.${key}` : key;
    if (value !== null && typeof value === "object" && !Array.isArray(value)) {
      const subPaths = getObjectPaths(value, path);
      paths.push(...subPaths);
    } else {
      paths.push(path);
    }
  }
  return paths;
}
function getValueAtPath(obj, path) {
  const keys = path.split(".");
  let current = obj;
  for (const key of keys) {
    current = current[key];
  }
  return current;
}
function setValueAtPath(obj, path, value) {
  const keys = path.split(".");
  let current = obj;
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (i === keys.length - 1) {
      current[key] = value;
    } else {
      if (!Object.prototype.hasOwnProperty.call(current, key) || typeof current[key] !== "object" || current[key] === null || Array.isArray(current[key])) {
        current[key] = {};
      }
      current = current[key];
    }
  }
}

// lib/runner/CircuitRunner.ts
var debug7 = Debug7("tsci:eval:CircuitRunner");
var CircuitRunner = class {
  constructor(configuration = {}) {
    this._executionContext = null;
    this._circuitRunnerConfiguration = {
      snippetsApiBaseUrl: "https://registry-api.tscircuit.com",
      cjsRegistryUrl: "https://cjs.tscircuit.com",
      verbose: false
    };
    this._eventListeners = {};
    Object.assign(this._circuitRunnerConfiguration, configuration);
  }
  async version() {
    return "0.0.0";
  }
  async executeWithFsMap(ogOpts) {
    const opts = { ...ogOpts };
    if (this._circuitRunnerConfiguration.verbose) {
      Debug7.enable("tsci:eval:*");
    }
    debug7("executeWithFsMap called with:", {
      entrypoint: opts.entrypoint,
      fsMapKeys: Object.keys(opts.fsMap),
      name: opts.name
    });
    setupDefaultEntrypointIfNeeded(opts);
    debug7("entrypoint after setupDefaultEntrypointIfNeeded:", {
      entrypoint: opts.entrypoint
    });
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        name: opts.name,
        platform: this._circuitRunnerConfiguration.platform,
        projectConfig: this._circuitRunnerConfiguration.projectConfig,
        debugNamespace: this._debugNamespace
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.entrypoint = opts.entrypoint;
    this._executionContext.fsMap = normalizeFsMap(opts.fsMap);
    this._executionContext.tsConfig = getTsConfig(this._executionContext.fsMap);
    if (!this._executionContext.fsMap[opts.entrypoint]) {
      throw new Error(`Entrypoint "${opts.entrypoint}" not found`);
    }
    ;
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    const entrypoint = opts.entrypoint.startsWith("./") ? opts.entrypoint : `./${opts.entrypoint}`;
    debug7("final entrypoint:", entrypoint);
    await importEvalPath(entrypoint, this._executionContext);
  }
  async execute(code, opts = {}) {
    if (this._circuitRunnerConfiguration.verbose) {
      console.log(
        "[CircuitRunner] execute called with code length:",
        code.length
      );
    }
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        ...opts,
        platform: this._circuitRunnerConfiguration.platform,
        projectConfig: this._circuitRunnerConfiguration.projectConfig,
        debugNamespace: this._debugNamespace
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.fsMap["entrypoint.tsx"] = code;
    this._executionContext.tsConfig = getTsConfig(this._executionContext.fsMap);
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    await importEvalPath("./entrypoint.tsx", this._executionContext);
  }
  async executeComponent(component, opts = {}) {
    if (this._circuitRunnerConfiguration.verbose) {
      console.log("[CircuitRunner] executeComponent called");
    }
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        ...opts,
        platform: this._circuitRunnerConfiguration.platform,
        projectConfig: this._circuitRunnerConfiguration.projectConfig,
        debugNamespace: this._debugNamespace
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    this._executionContext.tsConfig = null;
    const element = typeof component === "function" ? component() : component;
    this._executionContext.circuit.add(element);
  }
  on(event, callback) {
    var _a;
    (_a = this._eventListeners)[event] ?? (_a[event] = []);
    this._eventListeners[event].push(callback);
    this._executionContext?.circuit.on(event, callback);
  }
  async renderUntilSettled() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    try {
      await this._executionContext.circuit.renderUntilSettled();
    } catch (error) {
      throw enhanceRootCircuitHasNoChildrenError(
        error,
        this._executionContext.entrypoint
      );
    }
  }
  async getCircuitJson() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    try {
      return this._executionContext.circuit.getCircuitJson();
    } catch (error) {
      throw enhanceRootCircuitHasNoChildrenError(
        error,
        this._executionContext.entrypoint
      );
    }
  }
  clearEventListeners() {
    if (this._executionContext?.circuit) {
      for (const event in this._eventListeners) {
        for (const listener of this._eventListeners[event]) {
          const circuit = this._executionContext.circuit;
          circuit.removeListener?.(event, listener);
        }
      }
    }
    for (const event in this._eventListeners) {
      delete this._eventListeners[event];
    }
  }
  async kill() {
    this._executionContext = null;
  }
  async setSnippetsApiBaseUrl(baseUrl) {
    this._circuitRunnerConfiguration.snippetsApiBaseUrl = baseUrl;
  }
  async setPlatformConfig(platform) {
    this._circuitRunnerConfiguration.platform = platform;
  }
  async setPlatformConfigProperty(property, value) {
    if (!this._circuitRunnerConfiguration.platform) {
      this._circuitRunnerConfiguration.platform = {};
    }
    setValueAtPath(this._circuitRunnerConfiguration.platform, property, value);
  }
  async setProjectConfig(project) {
    this._circuitRunnerConfiguration.projectConfig = project;
  }
  async setProjectConfigProperty(property, value) {
    if (!this._circuitRunnerConfiguration.projectConfig) {
      this._circuitRunnerConfiguration.projectConfig = {};
    }
    setValueAtPath(
      this._circuitRunnerConfiguration.projectConfig,
      property,
      value
    );
  }
  async enableDebug(namespace) {
    this._debugNamespace = namespace;
    if (this._executionContext) {
      const circuit = this._executionContext.circuit;
      circuit.enableDebug?.(namespace);
    }
  }
  _bindEventListeners(circuit) {
    for (const event in this._eventListeners) {
      for (const listener of this._eventListeners[event]) {
        circuit.on(event, listener);
      }
    }
  }
};

// lib/runner/runTscircuitCode.ts
async function runTscircuitCode(filesystemOrCodeString, opts) {
  if (typeof filesystemOrCodeString === "string" && !filesystemOrCodeString.includes("export")) {
    throw new Error(
      `The "export" keyword wasn't found in your provided code. You need to export a component in your code, e.g.

export default () => (
  <resistor name="R1" resistance="1k" />
)`
    );
  }
  const filesystem = typeof filesystemOrCodeString === "string" ? { "user-code.tsx": filesystemOrCodeString } : filesystemOrCodeString;
  const circuitRunner = new CircuitRunner();
  await circuitRunner.executeWithFsMap({
    fsMap: filesystem,
    ...opts
  });
  await circuitRunner.renderUntilSettled();
  return await circuitRunner.getCircuitJson();
}

// lib/runner/runTscircuitModule.ts
var runTscircuitModule = async (module, opts = {}) => {
  if (!module.startsWith("@")) {
    module = `@tsci/${module.replace(/\//, ".")}`;
  }
  const circuitJson = await runTscircuitCode(
    {
      // TODO handle exports that are not the default export by scanning
      // otherExports for components
      "user-code.tsx": `
    import Module, * as otherExports from "${module}";

    let exportName = "${opts.exportName ?? ""}"

    if ((!Module || typeof Module !== "function") && !Boolean(exportName)) {
      exportName = Object.keys(otherExports).filter(key => key[0] === key[0].toUpperCase() && typeof otherExports[key] === "function")[0]
    }

    const defaultExport = exportName ? otherExports[exportName] : Module

    if (!defaultExport) {
      throw new Error(\`No export found for module "\${module}" (tried "\${exportName ?? "default"}")\`)
    }

    export default defaultExport;
    `
    },
    {
      mainComponentProps: opts.props
    }
  );
  return circuitJson;
};

// lib/worker.ts
import * as Comlink from "comlink";
var createCircuitWebWorker = async (configuration) => {
  const existingWorker = globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER;
  if (existingWorker && typeof existingWorker.kill === "function") {
    if (configuration.verbose) {
      console.log("[Worker] Killing previous global worker instance...");
    }
    try {
      await existingWorker.kill();
    } catch (e) {
      if (configuration.verbose) {
        console.warn(
          "[Worker] Error killing previous global worker instance:",
          e
        );
      }
      if (globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER === existingWorker) {
        globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = void 0;
      }
    }
  }
  if (configuration.verbose) {
    console.log(
      "[Worker] Creating circuit web worker with config:",
      configuration
    );
  }
  let workerBlobUrl = configuration.webWorkerBlobUrl ?? configuration.webWorkerUrl;
  if (!workerBlobUrl) {
    const cdnUrl = `https://cdn.jsdelivr.net/npm/@tscircuit/eval@${configuration.evalVersion ?? "latest"}/dist/webworker/entrypoint.js`;
    const workerBlob = await globalThis.fetch(cdnUrl).then((res) => res.blob());
    workerBlobUrl = URL.createObjectURL(workerBlob);
  }
  const rawWorker = new Worker(workerBlobUrl, { type: "module" });
  let workerInitError;
  rawWorker.addEventListener("error", (event) => {
    console.error("[Worker] Error in worker", event);
    workerInitError = event;
  });
  rawWorker.addEventListener("unhandledrejection", (event) => {
    console.error("[Worker] Unhandled rejection in worker", event);
  });
  rawWorker.addEventListener("messageerror", (event) => {
    console.error("[Worker] Message error in worker", event);
  });
  const earlyMessageHandler = (event) => {
    console.log("[Worker] Message in worker", event);
  };
  rawWorker.addEventListener("message", earlyMessageHandler);
  rawWorker.addEventListener("message", async (event) => {
    const data = event.data;
    if (data?.type !== "worker_fetch") return;
    try {
      const response = await globalThis.fetch(data.input, data.init);
      const body = await response.text();
      rawWorker.postMessage({
        type: "worker_fetch_result",
        requestId: data.requestId,
        success: true,
        response: {
          body,
          status: response.status,
          statusText: response.statusText,
          headers: (() => {
            const obj = {};
            response.headers.forEach((value, key) => {
              obj[key] = value;
            });
            return obj;
          })()
        }
      });
    } catch (err) {
      rawWorker.postMessage({
        type: "worker_fetch_result",
        requestId: data.requestId,
        success: false,
        error: {
          name: err.name,
          message: err.message,
          stack: err.stack
        }
      });
    }
  });
  if (workerInitError) {
    throw workerInitError;
  }
  const comlinkWorker = Comlink.wrap(rawWorker);
  rawWorker.removeEventListener("message", earlyMessageHandler);
  function serializeReactElement(element) {
    if (!element || typeof element !== "object") {
      return element;
    }
    if (element.type && element.props !== void 0) {
      return {
        __isSerializedReactElement: true,
        type: element.type,
        props: serializeProps(element.props),
        key: element.key
      };
    }
    return element;
  }
  function serializeProps(props) {
    if (!props || typeof props !== "object") {
      return props;
    }
    const serialized = {};
    for (const [key, value] of Object.entries(props)) {
      if (key === "children") {
        if (Array.isArray(value)) {
          serialized.children = value.map(serializeReactElement);
        } else {
          serialized.children = serializeReactElement(value);
        }
      } else {
        serialized[key] = value;
      }
    }
    return serialized;
  }
  if (configuration.enableFetchProxy) {
    rawWorker.postMessage({ type: "override_global_fetch" });
  }
  if (configuration.snippetsApiBaseUrl) {
    await comlinkWorker.setSnippetsApiBaseUrl(configuration.snippetsApiBaseUrl);
  }
  const maybeProxy = (value) => {
    if (typeof value === "function") {
      return Comlink.proxy(value);
    }
    return value;
  };
  if (configuration.platform) {
    for (const path of getObjectPaths(configuration.platform)) {
      await comlinkWorker.setPlatformConfigProperty(
        path,
        maybeProxy(getValueAtPath(configuration.platform, path))
      ).catch((e) => {
        throw new Error(
          `Error setting platform config property ${path}: ${e instanceof Error ? e.message : String(e)}`
        );
      });
    }
  }
  if (configuration.projectConfig) {
    for (const path of getObjectPaths(configuration.projectConfig)) {
      await comlinkWorker.setProjectConfigProperty(
        path,
        maybeProxy(getValueAtPath(configuration.projectConfig, path))
      ).catch((e) => {
        throw new Error(
          `Error setting project config property ${path}: ${e instanceof Error ? e.message : String(e)}`
        );
      });
    }
  }
  let isTerminated = false;
  const wrapper = {
    clearEventListeners: comlinkWorker.clearEventListeners.bind(comlinkWorker),
    enableDebug: async (...args) => {
      if (isTerminated) {
        throw new Error("CircuitWebWorker was terminated, can't enableDebug");
      }
      return comlinkWorker.enableDebug.bind(comlinkWorker)(...args);
    },
    version: comlinkWorker.version.bind(comlinkWorker),
    execute: async (...args) => {
      if (isTerminated) {
        throw new Error("CircuitWebWorker was terminated, can't execute");
      }
      return comlinkWorker.execute.bind(comlinkWorker)(...args);
    },
    executeComponent: async (component) => {
      if (isTerminated) {
        throw new Error(
          "CircuitWebWorker was terminated, can't executeComponent"
        );
      }
      if (typeof component === "function") {
        return comlinkWorker.executeComponent.bind(comlinkWorker)(component);
      }
      if (component && typeof component === "object" && component.type) {
        const serializedElement = serializeReactElement(component);
        return comlinkWorker.executeComponent.bind(comlinkWorker)(
          serializedElement
        );
      }
      return comlinkWorker.executeComponent.bind(comlinkWorker)(component);
    },
    executeWithFsMap: async (...args) => {
      if (isTerminated) {
        throw new Error(
          "CircuitWebWorker was terminated, can't executeWithFsMap"
        );
      }
      return comlinkWorker.executeWithFsMap.bind(comlinkWorker)(...args);
    },
    renderUntilSettled: comlinkWorker.renderUntilSettled.bind(comlinkWorker),
    getCircuitJson: comlinkWorker.getCircuitJson.bind(comlinkWorker),
    on: (event, callback) => {
      const proxiedCallback = Comlink.proxy(callback);
      comlinkWorker.on(event, proxiedCallback);
    },
    kill: async () => {
      comlinkWorker[Comlink.releaseProxy]();
      rawWorker.terminate();
      isTerminated = true;
      if (globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER === wrapper) {
        globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = void 0;
      }
    }
  };
  wrapper.__rawWorker = rawWorker;
  globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = wrapper;
  return wrapper;
};

// lib/getPossibleEntrypointComponentPaths.ts
var getPossibleEntrypointComponentPaths = (fsMap) => {
  const normalizedFsMap = {};
  for (const [path, content] of Object.entries(fsMap)) {
    normalizedFsMap[normalizeFilePath(path)] = content;
  }
  const possible = /* @__PURE__ */ new Set();
  if ("tscircuit.config.json" in normalizedFsMap) {
    try {
      const config = JSON.parse(normalizedFsMap["tscircuit.config.json"]);
      if (typeof config.mainEntrypoint === "string") {
        possible.add(normalizeFilePath(config.mainEntrypoint));
      }
    } catch {
    }
  }
  if (normalizedFsMap["index.tsx"]) possible.add("index.tsx");
  if (normalizedFsMap["index.ts"]) possible.add("index.ts");
  const circuitFiles = Object.keys(normalizedFsMap).filter(
    (k) => k.endsWith(".circuit.tsx")
  );
  for (const file of circuitFiles) {
    possible.add(file);
  }
  const tsxFiles = Object.keys(normalizedFsMap).filter(
    (k) => k.endsWith(".tsx")
  );
  if (tsxFiles.length === 1) {
    possible.add(tsxFiles[0]);
  }
  return Array.from(possible);
};
export {
  CircuitRunner,
  STATIC_ASSET_EXTENSIONS,
  createCircuitWebWorker,
  getImportsFromCode,
  getPlatformConfig,
  getPossibleEntrypointComponentPaths,
  isStaticAssetPath,
  runTscircuitCode,
  runTscircuitModule
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vd2Vid29ya2VyL2V4ZWN1dGlvbi1jb250ZXh0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdHNjaXJjdWl0L3BhcnRzLWVuZ2luZS9saWIvZm9vdHByaW50LXRyYW5zbGF0b3JzL2dldC1mb290cHJpbnRlci1zdHJpbmctZnJvbS1raWNhZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRzY2lyY3VpdC9wYXJ0cy1lbmdpbmUvbGliL2Zvb3RwcmludC10cmFuc2xhdG9ycy9nZXQtamxjLXBhY2thZ2UtZnJvbS1mb290cHJpbnRlci1zdHJpbmcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0c2NpcmN1aXQvcGFydHMtZW5naW5lL2xpYi9mb290cHJpbnQtdHJhbnNsYXRvcnMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0c2NpcmN1aXQvcGFydHMtZW5naW5lL2xpYi9qbGMtcGFydHMtZW5naW5lLnRzIiwgIi4uLy4uL2xpYi9nZXRQbGF0Zm9ybUNvbmZpZy50cyIsICIuLi8uLi9saWIvdXRpbHMvZHluYW1pY2FsbHktbG9hZC1kZXBlbmRlbmN5LXdpdGgtY2RuLWJhY2t1cC50cyIsICIuLi8uLi9saWIvcnVubmVyL25vcm1hbGl6ZUZzTWFwLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvdHNjb25maWdQYXRocy50cyIsICIuLi8uLi9saWIvcnVubmVyL0NpcmN1aXRSdW5uZXIudHMiLCAiLi4vLi4vbGliL3V0aWxzL2Rpcm5hbWUudHMiLCAiLi4vLi4vbGliL3V0aWxzL3Jlc29sdmVSZWxhdGl2ZVBhdGgudHMiLCAiLi4vLi4vbGliL3J1bm5lci9yZXNvbHZlRmlsZVBhdGgudHMiLCAiLi4vLi4vbGliL3V0aWxzL2dldC1pbXBvcnRzLWZyb20tY29kZS50cyIsICIuLi8uLi93ZWJ3b3JrZXIvZXZhbC1jb21waWxlZC1qcy50cyIsICIuLi8uLi93ZWJ3b3JrZXIvaW1wb3J0LWxvY2FsLWZpbGUudHMiLCAiLi4vLi4vbGliL3NoYXJlZC9zdGF0aWMtYXNzZXQtZXh0ZW5zaW9ucy50cyIsICIuLi8uLi93ZWJ3b3JrZXIvdHJhbnNmb3JtLXdpdGgtc3VjcmFzZS50cyIsICIuLi8uLi93ZWJ3b3JrZXIvaW1wb3J0LXNuaXBwZXQudHMiLCAiLi4vLi4vbGliL3V0aWxzL3Jlc29sdmUtbm9kZS1tb2R1bGUudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1ub2RlLW1vZHVsZS50cyIsICIuLi8uLi93ZWJ3b3JrZXIvaW1wb3J0LW5wbS1wYWNrYWdlLnRzIiwgIi4uLy4uL3dlYndvcmtlci9pbXBvcnQtZXZhbC1wYXRoLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkLnRzIiwgIi4uLy4uL2xpYi91dGlscy9lbmhhbmNlLXJvb3QtY2lyY3VpdC1lcnJvci50cyIsICIuLi8uLi9saWIvc2hhcmVkL29iai1wYXRoLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvcnVuVHNjaXJjdWl0Q29kZS50cyIsICIuLi8uLi9saWIvcnVubmVyL3J1blRzY2lyY3VpdE1vZHVsZS50cyIsICIuLi8uLi9saWIvd29ya2VyLnRzIiwgIi4uLy4uL2xpYi9nZXRQb3NzaWJsZUVudHJ5cG9pbnRDb21wb25lbnRQYXRocy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUm9vdENpcmN1aXQgfSBmcm9tIFwiQHRzY2lyY3VpdC9jb3JlXCJcbmltcG9ydCB0eXBlIHsgV2ViV29ya2VyQ29uZmlndXJhdGlvbiB9IGZyb20gXCJsaWIvc2hhcmVkL3R5cGVzXCJcbmltcG9ydCAqIGFzIHRzY2lyY3VpdENvcmUgZnJvbSBcIkB0c2NpcmN1aXQvY29yZVwiXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0ICogYXMgdHNjaXJjdWl0TWF0aFV0aWxzIGZyb20gXCJAdHNjaXJjdWl0L21hdGgtdXRpbHNcIlxuaW1wb3J0IHR5cGUgeyBQbGF0Zm9ybUNvbmZpZyB9IGZyb20gXCJAdHNjaXJjdWl0L3Byb3BzXCJcbmltcG9ydCB7IGdldFBsYXRmb3JtQ29uZmlnIH0gZnJvbSBcImxpYi9nZXRQbGF0Zm9ybUNvbmZpZ1wiXG5pbXBvcnQgdHlwZSB7IFRzQ29uZmlnIH0gZnJvbSBcImxpYi9ydW5uZXIvdHNjb25maWdQYXRoc1wiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDpleGVjdXRpb24tY29udGV4dFwiKVxuXG5pbnRlcmZhY2UgU3RvcmVkTG9nZ2VyIHtcbiAgaW5mbzogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZFxuICBnZXRMb2dzOiAoKSA9PiBBcnJheTx7IG1zZzogc3RyaW5nIH0+XG4gIHN0cmluZ2lmeUxvZ3M6ICgpID0+IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGlvbkNvbnRleHQgZXh0ZW5kcyBXZWJXb3JrZXJDb25maWd1cmF0aW9uIHtcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgZW50cnlwb2ludDogc3RyaW5nXG4gIHByZVN1cHBsaWVkSW1wb3J0czogUmVjb3JkPHN0cmluZywgYW55PlxuICBjaXJjdWl0OiBSb290Q2lyY3VpdFxuICBsb2dnZXI6IFN0b3JlZExvZ2dlclxuICB0c0NvbmZpZzogVHNDb25maWcgfCBudWxsXG4gIGltcG9ydFN0YWNrOiBzdHJpbmdbXVxuICBjdXJyZW50bHlJbXBvcnRpbmc6IFNldDxzdHJpbmc+XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeGVjdXRpb25Db250ZXh0KFxuICB3ZWJXb3JrZXJDb25maWd1cmF0aW9uOiBXZWJXb3JrZXJDb25maWd1cmF0aW9uLFxuICBvcHRzOiB7XG4gICAgbmFtZT86IHN0cmluZ1xuICAgIHBsYXRmb3JtPzogUGxhdGZvcm1Db25maWdcbiAgICBwcm9qZWN0Q29uZmlnPzogUGFydGlhbDxQbGF0Zm9ybUNvbmZpZz5cbiAgICBkZWJ1Z05hbWVzcGFjZT86IHN0cmluZ1xuICB9ID0ge30sXG4pOiBFeGVjdXRpb25Db250ZXh0IHtcbiAgZ2xvYmFsVGhpcy5SZWFjdCA9IFJlYWN0XG5cbiAgY29uc3QgYmFzZVBsYXRmb3JtID0gb3B0cy5wbGF0Zm9ybSB8fCBnZXRQbGF0Zm9ybUNvbmZpZygpXG4gIGNvbnN0IHBsYXRmb3JtID0gb3B0cy5wcm9qZWN0Q29uZmlnXG4gICAgPyB7IC4uLmJhc2VQbGF0Zm9ybSwgLi4ub3B0cy5wcm9qZWN0Q29uZmlnIH1cbiAgICA6IGJhc2VQbGF0Zm9ybVxuXG4gIGlmIChwbGF0Zm9ybS5wYXJ0c0VuZ2luZURpc2FibGVkKSB7XG4gICAgcGxhdGZvcm0ucGFydHNFbmdpbmUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IGNpcmN1aXQgPSBuZXcgUm9vdENpcmN1aXQoe1xuICAgIHBsYXRmb3JtLFxuICB9KVxuXG4gIGlmIChvcHRzLm5hbWUpIHtcbiAgICBjaXJjdWl0Lm5hbWUgPSBvcHRzLm5hbWVcbiAgfVxuXG4gIGlmIChvcHRzLmRlYnVnTmFtZXNwYWNlKSB7XG4gICAgY2lyY3VpdC5lbmFibGVEZWJ1ZyhvcHRzLmRlYnVnTmFtZXNwYWNlKVxuICB9XG5cbiAgY29uc3QgbG9nczogQXJyYXk8eyBtc2c6IHN0cmluZyB9PiA9IFtdXG5cbiAgcmV0dXJuIHtcbiAgICBmc01hcDoge30sXG4gICAgZW50cnlwb2ludDogXCJcIixcbiAgICBsb2dnZXI6IHtcbiAgICAgIGluZm86IChtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbG9ncy5wdXNoKHsgbXNnOiBtZXNzYWdlIH0pXG4gICAgICB9LFxuICAgICAgZ2V0TG9nczogKCkgPT4gbG9ncyxcbiAgICAgIHN0cmluZ2lmeUxvZ3M6ICgpID0+IGxvZ3MubWFwKChsb2cpID0+IGxvZy5tc2cpLmpvaW4oXCJcXG5cIiksXG4gICAgfSxcbiAgICBwcmVTdXBwbGllZEltcG9ydHM6IHtcbiAgICAgIFwiQHRzY2lyY3VpdC9jb3JlXCI6IHRzY2lyY3VpdENvcmUsXG4gICAgICB0c2NpcmN1aXQ6IHRzY2lyY3VpdENvcmUsXG4gICAgICBcIkB0c2NpcmN1aXQvbWF0aC11dGlsc1wiOiB0c2NpcmN1aXRNYXRoVXRpbHMsXG4gICAgICByZWFjdDogUmVhY3QsXG4gICAgICBkZWJ1ZzogRGVidWcsXG5cbiAgICAgIC8vIFRoaXMgaXMgdXN1YWxseSB1c2VkIGFzIGEgdHlwZSBpbXBvcnQsIHdlIGNhbiByZW1vdmUgdGhlIHNoaW0gd2hlbiB3ZVxuICAgICAgLy8gaWdub3JlIHR5cGUgaW1wb3J0cyBpbiBnZXRJbXBvcnRzRnJvbUNvZGVcbiAgICAgIFwiQHRzY2lyY3VpdC9wcm9wc1wiOiB7fSxcbiAgICB9LFxuICAgIGNpcmN1aXQsXG4gICAgdHNDb25maWc6IG51bGwsXG4gICAgaW1wb3J0U3RhY2s6IFtdLFxuICAgIGN1cnJlbnRseUltcG9ydGluZzogbmV3IFNldDxzdHJpbmc+KCksXG4gICAgLi4ud2ViV29ya2VyQ29uZmlndXJhdGlvbixcbiAgfVxufVxuIiwgIi8qKlxuICogVHJhbnNmb3JtcyBhIEtpQ2FkIGZvb3RwcmludCBzdHJpbmcgaW50byBhIGdlbmVyaWMgXCJmb290cHJpbnRlciBzdHJpbmdcIi5cbiAqIEZvciBub3csIHRoaXMgaXMgYSBzaW1wbGlmaWVkIGNvbnZlcnNpb24gdG8gYSBzdGFuZGFyZCBwYWNrYWdlIG5hbWUuXG4gKiBlLmcuIFwia2ljYWQ6UmVzaXN0b3JfU01EOlJfMDYwM18xNjA4TWV0cmljXCIgLT4gXCIwNjAzXCJcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZvb3RwcmludGVyU3RyaW5nRnJvbUtpY2FkID0gKFxuICBraWNhZEZvb3RwcmludDogc3RyaW5nLFxuKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgLy8ga2ljYWQ6UmVzaXN0b3JfU01EOlJfMDYwM18xNjA4TWV0cmljIC0+IDA2MDNcbiAgbGV0IG1hdGNoID0ga2ljYWRGb290cHJpbnQubWF0Y2goLzpbUkNdXyhcXGR7NH0pXy8pXG4gIGlmIChtYXRjaCkgcmV0dXJuIG1hdGNoWzFdXG5cbiAgLy8ga2ljYWQ6UGFja2FnZV9TTzpTT0lDLThfMy45eDQuOW1tX1AxLjI3bW0gLT4gU09JQy04XG4gIC8vIGtpY2FkOlBhY2thZ2VfVE9fU09UX1NNRDpTT1QtMjMgLT4gU09ULTIzXG4gIG1hdGNoID0ga2ljYWRGb290cHJpbnQubWF0Y2goXG4gICAgLzooU09JQy1cXGQrfFNPVC1cXGQrfFNPRC1cXGQrfFNTT1AtXFxkK3xUU1NPUC1cXGQrfFFGUC1cXGQrfFFGTi1cXGQrKS8sXG4gIClcbiAgaWYgKG1hdGNoKSByZXR1cm4gbWF0Y2hbMV1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG4iLCAiLyoqXG4gKiBUcmFuc2Zvcm1zIGEgZ2VuZXJpYyBcImZvb3RwcmludGVyIHN0cmluZ1wiIGludG8gYSBKTEMtY29tcGF0aWJsZSBwYWNrYWdlIG5hbWUuXG4gKiBlLmcuIFwiY2FwMDYwM1wiIC0+IFwiMDYwM1wiXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRKbGNQYWNrYWdlRnJvbUZvb3RwcmludGVyU3RyaW5nID0gKFxuICBmb290cHJpbnRlclN0cmluZzogc3RyaW5nLFxuKTogc3RyaW5nID0+IHtcbiAgaWYgKGZvb3RwcmludGVyU3RyaW5nLmluY2x1ZGVzKFwiY2FwXCIpKSB7XG4gICAgcmV0dXJuIGZvb3RwcmludGVyU3RyaW5nLnJlcGxhY2UoL2NhcC9nLCBcIlwiKVxuICB9XG4gIHJldHVybiBmb290cHJpbnRlclN0cmluZ1xufVxuIiwgImltcG9ydCB7IGdldEZvb3RwcmludGVyU3RyaW5nRnJvbUtpY2FkIH0gZnJvbSBcIi4vZ2V0LWZvb3RwcmludGVyLXN0cmluZy1mcm9tLWtpY2FkXCJcbmltcG9ydCB7IGdldEpsY1BhY2thZ2VGcm9tRm9vdHByaW50ZXJTdHJpbmcgfSBmcm9tIFwiLi9nZXQtamxjLXBhY2thZ2UtZnJvbS1mb290cHJpbnRlci1zdHJpbmdcIlxuXG4vKipcbiAqIEdldCBhIEpMQy1jb21wYXRpYmxlIHBhY2thZ2UgbmFtZSBmcm9tIGEgZm9vdHByaW50IHN0cmluZywgd2hpY2ggY291bGQgYmVcbiAqIGEgS2lDYWQgZm9vdHByaW50IG9yIGEgZ2VuZXJpYyBcImZvb3RwcmludGVyIHN0cmluZ1wiLlxuICovXG5leHBvcnQgY29uc3QgZ2V0SmxjcGNiUGFja2FnZU5hbWUgPSAoXG4gIGZvb3RwcmludDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKCFmb290cHJpbnQpIHJldHVybiB1bmRlZmluZWRcblxuICBpZiAoZm9vdHByaW50LnN0YXJ0c1dpdGgoXCJraWNhZDpcIikpIHtcbiAgICBjb25zdCBmb290cHJpbnRlclN0cmluZyA9IGdldEZvb3RwcmludGVyU3RyaW5nRnJvbUtpY2FkKGZvb3RwcmludClcbiAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmcpIHtcbiAgICAgIHJldHVybiBnZXRKbGNQYWNrYWdlRnJvbUZvb3RwcmludGVyU3RyaW5nKGZvb3RwcmludGVyU3RyaW5nKVxuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciB1bi1tYXRjaGVkIEtpQ2FkIHN0cmluZ3NcbiAgICByZXR1cm4gZm9vdHByaW50XG4gIH1cblxuICAvLyBOb3QgYSBLaUNhZCBzdHJpbmcsIGFzc3VtZSBpdCdzIGEgZm9vdHByaW50ZXIgc3RyaW5nXG4gIHJldHVybiBnZXRKbGNQYWNrYWdlRnJvbUZvb3RwcmludGVyU3RyaW5nKGZvb3RwcmludClcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFBhcnRzRW5naW5lLCBTdXBwbGllclBhcnROdW1iZXJzIH0gZnJvbSBcIkB0c2NpcmN1aXQvcHJvcHNcIlxuaW1wb3J0IHsgZ2V0SmxjcGNiUGFja2FnZU5hbWUgfSBmcm9tIFwiLi9mb290cHJpbnQtdHJhbnNsYXRvcnMvaW5kZXhcIlxuXG5leHBvcnQgY29uc3QgY2FjaGUgPSBuZXcgTWFwPHN0cmluZywgYW55PigpXG5cbmNvbnN0IGdldEpsY1BhcnRzQ2FjaGVkID0gYXN5bmMgKG5hbWU6IGFueSwgcGFyYW1zOiBhbnkpID0+IHtcbiAgY29uc3QgcGFyYW1TdHJpbmcgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAuLi5wYXJhbXMsXG4gICAganNvbjogXCJ0cnVlXCIsXG4gIH0pLnRvU3RyaW5nKClcbiAgaWYgKGNhY2hlLmhhcyhwYXJhbVN0cmluZykpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KHBhcmFtU3RyaW5nKVxuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgYGh0dHBzOi8vamxjc2VhcmNoLnRzY2lyY3VpdC5jb20vJHtuYW1lfS9saXN0PyR7cGFyYW1TdHJpbmd9YCxcbiAgKVxuICBjb25zdCByZXNwb25zZUpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgY2FjaGUuc2V0KHBhcmFtU3RyaW5nLCByZXNwb25zZUpzb24pXG4gIHJldHVybiByZXNwb25zZUpzb25cbn1cblxuY29uc3Qgd2l0aEJhc2ljUGFydFByZWZlcmVuY2UgPSAocGFydHM6IGFueVtdIHwgdW5kZWZpbmVkKSA9PiB7XG4gIGlmICghcGFydHMpIHJldHVybiBbXVxuICByZXR1cm4gWy4uLnBhcnRzXS5zb3J0KFxuICAgIChhLCBiKSA9PiBOdW1iZXIoYi5pc19iYXNpYyA/PyBmYWxzZSkgLSBOdW1iZXIoYS5pc19iYXNpYyA/PyBmYWxzZSksXG4gIClcbn1cblxuZXhwb3J0IGNvbnN0IGpsY1BhcnRzRW5naW5lOiBQYXJ0c0VuZ2luZSA9IHtcbiAgZmluZFBhcnQ6IGFzeW5jICh7XG4gICAgc291cmNlQ29tcG9uZW50LFxuICAgIGZvb3RwcmludGVyU3RyaW5nLFxuICB9KTogUHJvbWlzZTxTdXBwbGllclBhcnROdW1iZXJzPiA9PiB7XG4gICAgY29uc3QgamxjcGNiUGFja2FnZSA9IGdldEpsY3BjYlBhY2thZ2VOYW1lKGZvb3RwcmludGVyU3RyaW5nKVxuXG4gICAgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Jlc2lzdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgcmVzaXN0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcInJlc2lzdG9yc1wiLCB7XG4gICAgICAgIHJlc2lzdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5yZXNpc3RhbmNlLFxuICAgICAgICBwYWNrYWdlOiBqbGNwY2JQYWNrYWdlLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiB3aXRoQmFzaWNQYXJ0UHJlZmVyZW5jZShyZXNpc3RvcnMpXG4gICAgICAgICAgLm1hcCgocjogYW55KSA9PiBgQyR7ci5sY3NjfWApXG4gICAgICAgICAgLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfY2FwYWNpdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgY2FwYWNpdG9ycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJjYXBhY2l0b3JzXCIsIHtcbiAgICAgICAgY2FwYWNpdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5jYXBhY2l0YW5jZSxcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogd2l0aEJhc2ljUGFydFByZWZlcmVuY2UoY2FwYWNpdG9ycylcbiAgICAgICAgICAubWFwKChjOiBhbnkpID0+IGBDJHtjLmxjc2N9YClcbiAgICAgICAgICAuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9waW5faGVhZGVyXCJcbiAgICApIHtcbiAgICAgIGxldCBwaXRjaDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmc/LmluY2x1ZGVzKFwiX3BcIikpIHtcbiAgICAgICAgcGl0Y2ggPSBOdW1iZXIoZm9vdHByaW50ZXJTdHJpbmcuc3BsaXQoXCJfcFwiKVsxXSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXG4gICAgICAgIFwiaGVhZGVyc1wiLFxuICAgICAgICBwaXRjaFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiB3aXRoQmFzaWNQYXJ0UHJlZmVyZW5jZShoZWFkZXJzKVxuICAgICAgICAgIC5tYXAoKGg6IGFueSkgPT4gYEMke2gubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3BvdGVudGlvbWV0ZXJcIlxuICAgICkge1xuICAgICAgY29uc3QgeyBwb3RlbnRpb21ldGVycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJwb3RlbnRpb21ldGVyc1wiLCB7XG4gICAgICAgIHJlc2lzdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5tYXhfcmVzaXN0YW5jZSxcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKHBvdGVudGlvbWV0ZXJzKVxuICAgICAgICAgIC5tYXAoKHA6IGFueSkgPT4gYEMke3AubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2Rpb2RlXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgZGlvZGVzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImRpb2Rlc1wiLCB7XG4gICAgICAgIHBhY2thZ2U6IGpsY3BjYlBhY2thZ2UsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiB3aXRoQmFzaWNQYXJ0UHJlZmVyZW5jZShkaW9kZXMpXG4gICAgICAgICAgLm1hcCgoZDogYW55KSA9PiBgQyR7ZC5sY3NjfWApXG4gICAgICAgICAgLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfY2hpcFwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IGNoaXBzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImNoaXBzXCIsIHtcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKGNoaXBzKVxuICAgICAgICAgIC5tYXAoKGM6IGFueSkgPT4gYEMke2MubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3RyYW5zaXN0b3JcIlxuICAgICkge1xuICAgICAgY29uc3QgeyB0cmFuc2lzdG9ycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJ0cmFuc2lzdG9yc1wiLCB7XG4gICAgICAgIHBhY2thZ2U6IGpsY3BjYlBhY2thZ2UsXG4gICAgICAgIHRyYW5zaXN0b3JfdHlwZTogc291cmNlQ29tcG9uZW50LnRyYW5zaXN0b3JfdHlwZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKHRyYW5zaXN0b3JzKVxuICAgICAgICAgIC5tYXAoKHQ6IGFueSkgPT4gYEMke3QubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Bvd2VyX3NvdXJjZVwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHBvd2VyX3NvdXJjZXMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicG93ZXJfc291cmNlc1wiLCB7XG4gICAgICAgIHZvbHRhZ2U6IHNvdXJjZUNvbXBvbmVudC52b2x0YWdlLFxuICAgICAgICBwYWNrYWdlOiBqbGNwY2JQYWNrYWdlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogd2l0aEJhc2ljUGFydFByZWZlcmVuY2UocG93ZXJfc291cmNlcylcbiAgICAgICAgICAubWFwKChwOiBhbnkpID0+IGBDJHtwLmxjc2N9YClcbiAgICAgICAgICAuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9pbmR1Y3RvclwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IGluZHVjdG9ycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJpbmR1Y3RvcnNcIiwge1xuICAgICAgICBpbmR1Y3RhbmNlOiBzb3VyY2VDb21wb25lbnQuaW5kdWN0YW5jZSxcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKGluZHVjdG9ycylcbiAgICAgICAgICAubWFwKChpOiBhbnkpID0+IGBDJHtpLmxjc2N9YClcbiAgICAgICAgICAuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9jcnlzdGFsXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgY3J5c3RhbHMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwiY3J5c3RhbHNcIiwge1xuICAgICAgICBmcmVxdWVuY3k6IHNvdXJjZUNvbXBvbmVudC5mcmVxdWVuY3ksXG4gICAgICAgIGxvYWRfY2FwYWNpdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5sb2FkX2NhcGFjaXRhbmNlLFxuICAgICAgICBwYWNrYWdlOiBqbGNwY2JQYWNrYWdlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogd2l0aEJhc2ljUGFydFByZWZlcmVuY2UoY3J5c3RhbHMpXG4gICAgICAgICAgLm1hcCgoYzogYW55KSA9PiBgQyR7Yy5sY3NjfWApXG4gICAgICAgICAgLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbW9zZmV0XCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbW9zZmV0cyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJtb3NmZXRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgICAgbW9zZmV0X21vZGU6IHNvdXJjZUNvbXBvbmVudC5tb3NmZXRfbW9kZSxcbiAgICAgICAgY2hhbm5lbF90eXBlOiBzb3VyY2VDb21wb25lbnQuY2hhbm5lbF90eXBlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogd2l0aEJhc2ljUGFydFByZWZlcmVuY2UobW9zZmV0cylcbiAgICAgICAgICAubWFwKChtOiBhbnkpID0+IGBDJHttLmxjc2N9YClcbiAgICAgICAgICAuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9yZXNvbmF0b3JcIlxuICAgICkge1xuICAgICAgY29uc3QgeyByZXNvbmF0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcInJlc29uYXRvcnNcIiwge1xuICAgICAgICBmcmVxdWVuY3k6IHNvdXJjZUNvbXBvbmVudC5mcmVxdWVuY3ksXG4gICAgICAgIHBhY2thZ2U6IGpsY3BjYlBhY2thZ2UsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiB3aXRoQmFzaWNQYXJ0UHJlZmVyZW5jZShyZXNvbmF0b3JzKVxuICAgICAgICAgIC5tYXAoKHI6IGFueSkgPT4gYEMke3IubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3N3aXRjaFwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHN3aXRjaGVzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcInN3aXRjaGVzXCIsIHtcbiAgICAgICAgc3dpdGNoX3R5cGU6IHNvdXJjZUNvbXBvbmVudC50eXBlLFxuICAgICAgICBwYWNrYWdlOiBqbGNwY2JQYWNrYWdlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogd2l0aEJhc2ljUGFydFByZWZlcmVuY2Uoc3dpdGNoZXMpXG4gICAgICAgICAgLm1hcCgoczogYW55KSA9PiBgQyR7cy5sY3NjfWApXG4gICAgICAgICAgLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbGVkXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbGVkcyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJsZWRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKGxlZHMpXG4gICAgICAgICAgLm1hcCgobDogYW55KSA9PiBgQyR7bC5sY3NjfWApXG4gICAgICAgICAgLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfZnVzZVwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IGZ1c2VzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImZ1c2VzXCIsIHtcbiAgICAgICAgcGFja2FnZTogamxjcGNiUGFja2FnZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IHdpdGhCYXNpY1BhcnRQcmVmZXJlbmNlKGZ1c2VzKVxuICAgICAgICAgIC5tYXAoKGw6IGFueSkgPT4gYEMke2wubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9XG4gIH0sXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBQbGF0Zm9ybUNvbmZpZywgU3BpY2VFbmdpbmUgfSBmcm9tIFwiQHRzY2lyY3VpdC9wcm9wc1wiXG5pbXBvcnQgeyBqbGNQYXJ0c0VuZ2luZSB9IGZyb20gXCJAdHNjaXJjdWl0L3BhcnRzLWVuZ2luZVwiXG5pbXBvcnQgeyBwYXJzZUtpY2FkTW9kVG9DaXJjdWl0SnNvbiB9IGZyb20gXCJraWNhZC1jb21wb25lbnQtY29udmVydGVyXCJcbmltcG9ydCB7IGR5bmFtaWNhbGx5TG9hZERlcGVuZGVuY3lXaXRoQ2RuQmFja3VwIH0gZnJvbSBcIi4vdXRpbHMvZHluYW1pY2FsbHktbG9hZC1kZXBlbmRlbmN5LXdpdGgtY2RuLWJhY2t1cFwiXG5jb25zdCBLSUNBRF9GT09UUFJJTlRfQ0FDSEVfVVJMID0gXCJodHRwczovL2tpY2FkLW1vZC1jYWNoZS50c2NpcmN1aXQuY29tXCJcblxubGV0IG5nc3BpY2VFbmdpbmVDYWNoZTogU3BpY2VFbmdpbmUgfCBudWxsID0gbnVsbFxuXG5leHBvcnQgY29uc3QgZ2V0UGxhdGZvcm1Db25maWcgPSAoKTogUGxhdGZvcm1Db25maWcgPT4gKHtcbiAgcGFydHNFbmdpbmU6IGpsY1BhcnRzRW5naW5lLFxuICBzcGljZUVuZ2luZU1hcDoge1xuICAgIG5nc3BpY2U6IHtcbiAgICAgIHNpbXVsYXRlOiBhc3luYyAoc3BpY2U6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoIW5nc3BpY2VFbmdpbmVDYWNoZSkge1xuICAgICAgICAgIGNvbnN0IGNyZWF0ZU5nc3BpY2VTcGljZUVuZ2luZSA9XG4gICAgICAgICAgICBhd2FpdCBkeW5hbWljYWxseUxvYWREZXBlbmRlbmN5V2l0aENkbkJhY2t1cChcbiAgICAgICAgICAgICAgXCJAdHNjaXJjdWl0L25nc3BpY2Utc3BpY2UtZW5naW5lXCIsXG4gICAgICAgICAgICApLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDb3VsZCBub3QgbG9hZCBuZ3NwaWNlIGVuZ2luZSBmcm9tIGxvY2FsIG5vZGVfbW9kdWxlcyBvciBDRE4gZmFsbGJhY2suXCIsXG4gICAgICAgICAgICAgICAgeyBjYXVzZTogZXJyb3IgfSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgIGlmIChjcmVhdGVOZ3NwaWNlU3BpY2VFbmdpbmUpIHtcbiAgICAgICAgICAgIG5nc3BpY2VFbmdpbmVDYWNoZSA9IGF3YWl0IGNyZWF0ZU5nc3BpY2VTcGljZUVuZ2luZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZ3NwaWNlRW5naW5lQ2FjaGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNvdWxkIG5vdCBsb2FkIG5nc3BpY2UgZW5naW5lIGZyb20gbG9jYWwgbm9kZV9tb2R1bGVzIG9yIENETiBmYWxsYmFjay5cIixcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmdzcGljZUVuZ2luZUNhY2hlLnNpbXVsYXRlKHNwaWNlKVxuICAgICAgfSxcbiAgICB9LFxuICB9LFxuICBmb290cHJpbnRMaWJyYXJ5TWFwOiB7XG4gICAga2ljYWQ6IGFzeW5jIChmb290cHJpbnROYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSBgJHtLSUNBRF9GT09UUFJJTlRfQ0FDSEVfVVJMfS8ke2Zvb3RwcmludE5hbWV9YFxuICAgICAgY29uc3QgY2lyY3VpdEpzb25VcmwgPSBgJHtiYXNlVXJsfS5jaXJjdWl0Lmpzb25gXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChjaXJjdWl0SnNvblVybClcbiAgICAgIGNvbnN0IHJhdyA9IGF3YWl0IHJlcy5qc29uKClcbiAgICAgIC8vIEZpbHRlciBwY2Jfc2lsa3NjcmVlbl90ZXh0IHRvIG9ubHkga2VlcCBlbnRyaWVzIHdpdGggdGV4dCA9PT0gXCJSRUYqKlwiXG4gICAgICAvLyBBcHBseSBmaWx0ZXJpbmcgb25seSB0byBlbGVtZW50cyBjb21pbmcgZnJvbSB0aGUga2ljYWRfbW9kX3NlcnZlciByZXNwb25zZVxuICAgICAgY29uc3QgZmlsdGVyZWQgPSBBcnJheS5pc0FycmF5KHJhdylcbiAgICAgICAgPyByYXcuZmlsdGVyKChlbCkgPT5cbiAgICAgICAgICAgIGVsPy50eXBlID09PSBcInBjYl9zaWxrc2NyZWVuX3RleHRcIiA/IGVsPy50ZXh0ID09PSBcIlJFRioqXCIgOiB0cnVlLFxuICAgICAgICAgIClcbiAgICAgICAgOiByYXdcbiAgICAgIGNvbnN0IHdybFVybCA9IGAke2Jhc2VVcmx9LndybGBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvb3RwcmludENpcmN1aXRKc29uOiBmaWx0ZXJlZCxcbiAgICAgICAgY2FkTW9kZWw6IHsgd3JsVXJsLCBtb2RlbFVuaXRUb01tU2NhbGU6IDIuNTQgfSxcbiAgICAgIH1cbiAgICB9LFxuICB9LFxuICBmb290cHJpbnRGaWxlUGFyc2VyTWFwOiB7XG4gICAga2ljYWRfbW9kOiB7XG4gICAgICBsb2FkRnJvbVVybDogYXN5bmMgKHVybDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGtpY2FkQ29udGVudCA9IGF3YWl0IGZldGNoKHVybCkudGhlbigocmVzKSA9PiByZXMudGV4dCgpKVxuICAgICAgICBjb25zdCBraWNhZEpzb24gPSBhd2FpdCBwYXJzZUtpY2FkTW9kVG9DaXJjdWl0SnNvbihraWNhZENvbnRlbnQpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm9vdHByaW50Q2lyY3VpdEpzb246IEFycmF5LmlzQXJyYXkoa2ljYWRKc29uKVxuICAgICAgICAgICAgPyBraWNhZEpzb25cbiAgICAgICAgICAgIDogW2tpY2FkSnNvbl0sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn0pXG4iLCAiZXhwb3J0IGNvbnN0IGR5bmFtaWNhbGx5TG9hZERlcGVuZGVuY3lXaXRoQ2RuQmFja3VwID0gYXN5bmMgKFxuICBwYWNrYWdlTmFtZTogc3RyaW5nLFxuKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBGaXJzdCwgdHJ5IHRvIGltcG9ydCB1c2luZyBOb2RlLmpzIHJlc29sdXRpb25cbiAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBpbXBvcnQocGFja2FnZU5hbWUpXG4gICAgcmV0dXJuIG1vZHVsZS5kZWZhdWx0XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIGxvYWQgJHtwYWNrYWdlTmFtZX0gbG9jYWxseSwgdHJ5aW5nIENETiBmYWxsYmFjay4uLmApXG4gICAgLy8gRmFsbGJhY2sgdG8gSnNEZWxpdnIgQ0ROIGZvciBicm93c2VyIGVudmlyb25tZW50c1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYGh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vJHtwYWNrYWdlTmFtZX0vK2VzbWAsXG4gICAgICApXG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBmZXRjaCAke3BhY2thZ2VOYW1lfSBmcm9tIENETjogJHtyZXMuc3RhdHVzVGV4dH1gLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBjb25zdCBjb2RlID0gYXdhaXQgcmVzLnRleHQoKVxuICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtjb2RlXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiB9KVxuICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0OiBsb2FkZWRNb2R1bGUgfSA9IGF3YWl0IGltcG9ydCh1cmwpXG4gICAgICAgIHJldHVybiBsb2FkZWRNb2R1bGVcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGNkbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDRE4gZmFsbGJhY2sgZm9yICR7cGFja2FnZU5hbWV9IGFsc28gZmFpbGVkOmAsIGNkbkVycm9yKVxuICAgICAgdGhyb3cgY2RuRXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRmlsZVBhdGgoZmlsZVBhdGg6IHN0cmluZykge1xuICBsZXQgbm9ybUZpbGVQYXRoID0gZmlsZVBhdGhcbiAgbm9ybUZpbGVQYXRoID0gbm9ybUZpbGVQYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG4gIG5vcm1GaWxlUGF0aCA9IG5vcm1GaWxlUGF0aC50cmltKClcbiAgaWYgKG5vcm1GaWxlUGF0aC5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICBub3JtRmlsZVBhdGggPSBub3JtRmlsZVBhdGguc2xpY2UoMilcbiAgfVxuICBpZiAobm9ybUZpbGVQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgbm9ybUZpbGVQYXRoID0gbm9ybUZpbGVQYXRoLnNsaWNlKDEpXG4gIH1cbiAgcmV0dXJuIG5vcm1GaWxlUGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRnNNYXAoZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pIHtcbiAgY29uc3Qgbm9ybWFsaXplZEZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgZm9yIChjb25zdCBbZnNQYXRoLCBmaWxlQ29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoZnNNYXApKSB7XG4gICAgbm9ybWFsaXplZEZzTWFwW25vcm1hbGl6ZUZpbGVQYXRoKGZzUGF0aCldID0gZmlsZUNvbnRlbnRcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZEZzTWFwXG59XG4iLCAiaW1wb3J0IHsgbm9ybWFsaXplRmlsZVBhdGggfSBmcm9tIFwiLi9ub3JtYWxpemVGc01hcFwiXG5cbmV4cG9ydCB0eXBlIFRzQ29uZmlnID0ge1xuICBjb21waWxlck9wdGlvbnM/OiB7XG4gICAgYmFzZVVybD86IHN0cmluZ1xuICAgIHBhdGhzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+XG4gICAgW2tleTogc3RyaW5nXTogdW5rbm93blxuICB9XG4gIGV4dGVuZHM/OiBzdHJpbmcgfCBzdHJpbmdbXVxuICBmaWxlcz86IHN0cmluZ1tdXG4gIHJlZmVyZW5jZXM/OiBBcnJheTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj5cbiAgaW5jbHVkZT86IHN0cmluZ1tdXG4gIGV4Y2x1ZGU/OiBzdHJpbmdbXVxuICBba2V5OiBzdHJpbmddOiB1bmtub3duXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUc0NvbmZpZyhcbiAgZnNNYXBPckFsbEZpbGVQYXRoczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZ1tdLFxuKTogVHNDb25maWcgfCBudWxsIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZnNNYXBPckFsbEZpbGVQYXRocykpIHJldHVybiBudWxsXG4gIGNvbnN0IHRzY29uZmlnQ29udGVudCA9IGZzTWFwT3JBbGxGaWxlUGF0aHNbXCJ0c2NvbmZpZy5qc29uXCJdXG4gIGlmICghdHNjb25maWdDb250ZW50KSByZXR1cm4gbnVsbFxuICB0cnkge1xuICAgIGNvbnN0IHNhbml0aXplZENvbnRlbnQgPSB0c2NvbmZpZ0NvbnRlbnQucmVwbGFjZShcbiAgICAgIC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvfFxcL1xcLy4qL2csXG4gICAgICBcIlwiLFxuICAgICkgLy8gcmVtb3ZlIGNvbW1lbnRzXG5cbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNhbml0aXplZENvbnRlbnQpIGFzIFRzQ29uZmlnXG4gICAgcmV0dXJuIHBhcnNlZFxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSB0c2NvbmZpZy5qc29uOiAke2UubWVzc2FnZX1gKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlV2l0aFRzY29uZmlnUGF0aHMob3B0czoge1xuICBpbXBvcnRQYXRoOiBzdHJpbmdcbiAgbm9ybWFsaXplZEZpbGVQYXRoTWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+XG4gIGV4dGVuc2lvbnM6IHN0cmluZ1tdXG4gIHRzQ29uZmlnOiBUc0NvbmZpZyB8IG51bGxcbn0pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgeyBpbXBvcnRQYXRoLCBub3JtYWxpemVkRmlsZVBhdGhNYXAsIGV4dGVuc2lvbnMsIHRzQ29uZmlnIH0gPSBvcHRzXG4gIGNvbnN0IHBhdGhzID0gdHNDb25maWc/LmNvbXBpbGVyT3B0aW9ucz8ucGF0aHNcbiAgaWYgKCFwYXRocykgcmV0dXJuIG51bGxcbiAgY29uc3QgYmFzZVVybCA9IHRzQ29uZmlnPy5jb21waWxlck9wdGlvbnM/LmJhc2VVcmwgfHwgXCIuXCJcblxuICBjb25zdCB0cnlSZXNvbHZlQ2FuZGlkYXRlID0gKGNhbmRpZGF0ZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZENhbmRpZGF0ZSA9IG5vcm1hbGl6ZUZpbGVQYXRoKGNhbmRpZGF0ZSlcbiAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhub3JtYWxpemVkQ2FuZGlkYXRlKSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQobm9ybWFsaXplZENhbmRpZGF0ZSkhXG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbnMpIHtcbiAgICAgIGNvbnN0IHdpdGhFeHQgPSBgJHtub3JtYWxpemVkQ2FuZGlkYXRlfS4ke2V4dH1gXG4gICAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyh3aXRoRXh0KSkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplZEZpbGVQYXRoTWFwLmdldCh3aXRoRXh0KSFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZvciAoY29uc3QgW2FsaWFzLCB0YXJnZXRzXSBvZiBPYmplY3QuZW50cmllcyhwYXRocykpIHtcbiAgICAvLyBTdXBwb3J0IHBhdHRlcm5zIGxpa2UgXCJAc3JjLypcIiBvciBcInV0aWxzLypcIiBhbmQgYWxzbyBleGFjdCBtYXRjaGVzIHdpdGhvdXQgXCIqXCJcbiAgICBjb25zdCBoYXNXaWxkY2FyZCA9IGFsaWFzLmluY2x1ZGVzKFwiKlwiKVxuICAgIGlmIChoYXNXaWxkY2FyZCkge1xuICAgICAgY29uc3QgW3ByZWZpeCwgc3VmZml4XSA9IGFsaWFzLnNwbGl0KFwiKlwiKVxuICAgICAgaWYgKFxuICAgICAgICAhaW1wb3J0UGF0aC5zdGFydHNXaXRoKHByZWZpeCkgfHxcbiAgICAgICAgIWltcG9ydFBhdGguZW5kc1dpdGgoc3VmZml4IHx8IFwiXCIpXG4gICAgICApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJNYXRjaCA9IGltcG9ydFBhdGguc2xpY2UoXG4gICAgICAgIHByZWZpeC5sZW5ndGgsXG4gICAgICAgIGltcG9ydFBhdGgubGVuZ3RoIC0gKHN1ZmZpeCA/IHN1ZmZpeC5sZW5ndGggOiAwKSxcbiAgICAgIClcbiAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgY29uc3QgcmVwbGFjZWQgPSB0YXJnZXQucmVwbGFjZShcIipcIiwgc3Rhck1hdGNoKVxuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPVxuICAgICAgICAgIGJhc2VVcmwgJiYgIXJlcGxhY2VkLnN0YXJ0c1dpdGgoXCIuL1wiKSAmJiAhcmVwbGFjZWQuc3RhcnRzV2l0aChcIi9cIilcbiAgICAgICAgICAgID8gYCR7YmFzZVVybH0vJHtyZXBsYWNlZH1gXG4gICAgICAgICAgICA6IHJlcGxhY2VkXG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gdHJ5UmVzb2x2ZUNhbmRpZGF0ZShjYW5kaWRhdGUpXG4gICAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbXBvcnRQYXRoICE9PSBhbGlhcykgY29udGludWVcbiAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID1cbiAgICAgICAgICBiYXNlVXJsICYmICF0YXJnZXQuc3RhcnRzV2l0aChcIi4vXCIpICYmICF0YXJnZXQuc3RhcnRzV2l0aChcIi9cIilcbiAgICAgICAgICAgID8gYCR7YmFzZVVybH0vJHt0YXJnZXR9YFxuICAgICAgICAgICAgOiB0YXJnZXRcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB0cnlSZXNvbHZlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCByZXNvbHZlZFBhdGhGcm9tQmFzZVVybCA9IHJlc29sdmVXaXRoQmFzZVVybCh7XG4gICAgaW1wb3J0UGF0aCxcbiAgICBub3JtYWxpemVkRmlsZVBhdGhNYXAsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICB0c0NvbmZpZyxcbiAgfSlcblxuICBpZiAocmVzb2x2ZWRQYXRoRnJvbUJhc2VVcmwpIHJldHVybiByZXNvbHZlZFBhdGhGcm9tQmFzZVVybFxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlV2l0aEJhc2VVcmwob3B0czoge1xuICBpbXBvcnRQYXRoOiBzdHJpbmdcbiAgbm9ybWFsaXplZEZpbGVQYXRoTWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+XG4gIGV4dGVuc2lvbnM6IHN0cmluZ1tdXG4gIHRzQ29uZmlnOiBUc0NvbmZpZyB8IG51bGxcbn0pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgeyBpbXBvcnRQYXRoLCBub3JtYWxpemVkRmlsZVBhdGhNYXAsIGV4dGVuc2lvbnMsIHRzQ29uZmlnIH0gPSBvcHRzXG4gIGNvbnN0IGJhc2VVcmwgPSB0c0NvbmZpZz8uY29tcGlsZXJPcHRpb25zPy5iYXNlVXJsXG4gIGlmICghYmFzZVVybCkgcmV0dXJuIG51bGxcblxuICBjb25zdCBmaWxlUGF0aFRvUmVzb2x2ZSA9IGAke2Jhc2VVcmx9LyR7aW1wb3J0UGF0aH1gXG4gIGNvbnN0IG5vcm1hbGl6ZWRGaWxlUGF0aCA9IG5vcm1hbGl6ZUZpbGVQYXRoKGZpbGVQYXRoVG9SZXNvbHZlKVxuXG4gIGlmIChub3JtYWxpemVkRmlsZVBhdGhNYXAuaGFzKG5vcm1hbGl6ZWRGaWxlUGF0aCkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplZEZpbGVQYXRoTWFwLmdldChub3JtYWxpemVkRmlsZVBhdGgpIVxuICB9XG5cbiAgZm9yIChjb25zdCBleHQgb2YgZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IHdpdGhFeHQgPSBgJHtub3JtYWxpemVkRmlsZVBhdGh9LiR7ZXh0fWBcbiAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyh3aXRoRXh0KSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQod2l0aEV4dCkhXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXNUc2NvbmZpZ1BhdGhQYXR0ZXJuKFxuICBpbXBvcnRQYXRoOiBzdHJpbmcsXG4gIHRzQ29uZmlnOiBUc0NvbmZpZyB8IG51bGwsXG4pOiBib29sZWFuIHtcbiAgY29uc3QgcGF0aHMgPSB0c0NvbmZpZz8uY29tcGlsZXJPcHRpb25zPy5wYXRoc1xuICBpZiAoIXBhdGhzKSByZXR1cm4gZmFsc2VcblxuICBmb3IgKGNvbnN0IFthbGlhc10gb2YgT2JqZWN0LmVudHJpZXMocGF0aHMpKSB7XG4gICAgY29uc3QgaGFzV2lsZGNhcmQgPSBhbGlhcy5pbmNsdWRlcyhcIipcIilcbiAgICBpZiAoaGFzV2lsZGNhcmQpIHtcbiAgICAgIGNvbnN0IFtwcmVmaXgsIHN1ZmZpeF0gPSBhbGlhcy5zcGxpdChcIipcIilcbiAgICAgIGlmIChpbXBvcnRQYXRoLnN0YXJ0c1dpdGgocHJlZml4KSAmJiBpbXBvcnRQYXRoLmVuZHNXaXRoKHN1ZmZpeCB8fCBcIlwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW1wb3J0UGF0aCA9PT0gYWxpYXMpIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBBbnlDaXJjdWl0RWxlbWVudCB9IGZyb20gXCJjaXJjdWl0LWpzb25cIlxuaW1wb3J0IHR5cGUge1xuICBDaXJjdWl0UnVubmVyQXBpLFxuICBDaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbixcbn0gZnJvbSBcImxpYi9zaGFyZWQvdHlwZXNcIlxuaW1wb3J0IHR5cGUgeyBQbGF0Zm9ybUNvbmZpZyB9IGZyb20gXCJAdHNjaXJjdWl0L3Byb3BzXCJcbmltcG9ydCB7IGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi4vLi4vd2Vid29ya2VyL2V4ZWN1dGlvbi1jb250ZXh0XCJcbmltcG9ydCB7IG5vcm1hbGl6ZUZzTWFwIH0gZnJvbSBcIi4vbm9ybWFsaXplRnNNYXBcIlxuaW1wb3J0IHsgZ2V0VHNDb25maWcgfSBmcm9tIFwiLi90c2NvbmZpZ1BhdGhzXCJcbmltcG9ydCB0eXBlIHsgUm9vdENpcmN1aXQgfSBmcm9tIFwiQHRzY2lyY3VpdC9jb3JlXCJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBpbXBvcnRFdmFsUGF0aCB9IGZyb20gXCJ3ZWJ3b3JrZXIvaW1wb3J0LWV2YWwtcGF0aFwiXG5pbXBvcnQgeyBzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQgfSBmcm9tIFwiLi9zZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWRcIlxuaW1wb3J0IHsgZW5oYW5jZVJvb3RDaXJjdWl0SGFzTm9DaGlsZHJlbkVycm9yIH0gZnJvbSBcImxpYi91dGlscy9lbmhhbmNlLXJvb3QtY2lyY3VpdC1lcnJvclwiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcbmltcG9ydCB7IHNldFZhbHVlQXRQYXRoIH0gZnJvbSBcImxpYi9zaGFyZWQvb2JqLXBhdGhcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOkNpcmN1aXRSdW5uZXJcIilcblxuZXhwb3J0IGNsYXNzIENpcmN1aXRSdW5uZXIgaW1wbGVtZW50cyBDaXJjdWl0UnVubmVyQXBpIHtcbiAgX2V4ZWN1dGlvbkNvbnRleHQ6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQ+IHwgbnVsbCA9IG51bGxcbiAgX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uOiBDaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICBzbmlwcGV0c0FwaUJhc2VVcmw6IFwiaHR0cHM6Ly9yZWdpc3RyeS1hcGkudHNjaXJjdWl0LmNvbVwiLFxuICAgIGNqc1JlZ2lzdHJ5VXJsOiBcImh0dHBzOi8vY2pzLnRzY2lyY3VpdC5jb21cIixcbiAgICB2ZXJib3NlOiBmYWxzZSxcbiAgfVxuICBfZXZlbnRMaXN0ZW5lcnM6IFJlY29yZDxzdHJpbmcsICgoLi4uYXJnczogYW55W10pID0+IHZvaWQpW10+ID0ge31cbiAgX2RlYnVnTmFtZXNwYWNlOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uOiBQYXJ0aWFsPENpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uPiA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiwgY29uZmlndXJhdGlvbilcbiAgfVxuXG4gIGFzeW5jIHZlcnNpb24oKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gXCIwLjAuMFwiXG4gIH1cblxuICBhc3luYyBleGVjdXRlV2l0aEZzTWFwKG9nT3B0czoge1xuICAgIGVudHJ5cG9pbnQ/OiBzdHJpbmdcbiAgICBtYWluQ29tcG9uZW50UGF0aD86IHN0cmluZ1xuICAgIG1haW5Db21wb25lbnROYW1lPzogc3RyaW5nXG4gICAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBuYW1lPzogc3RyaW5nXG4gICAgbWFpbkNvbXBvbmVudFByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4ub2dPcHRzIH1cblxuICAgIGlmICh0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgICBEZWJ1Zy5lbmFibGUoXCJ0c2NpOmV2YWw6KlwiKVxuICAgIH1cblxuICAgIGRlYnVnKFwiZXhlY3V0ZVdpdGhGc01hcCBjYWxsZWQgd2l0aDpcIiwge1xuICAgICAgZW50cnlwb2ludDogb3B0cy5lbnRyeXBvaW50LFxuICAgICAgZnNNYXBLZXlzOiBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKSxcbiAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICB9KVxuXG4gICAgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkKG9wdHMpXG5cbiAgICBkZWJ1ZyhcImVudHJ5cG9pbnQgYWZ0ZXIgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkOlwiLCB7XG4gICAgICBlbnRyeXBvaW50OiBvcHRzLmVudHJ5cG9pbnQsXG4gICAgfSlcblxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQgPSBjcmVhdGVFeGVjdXRpb25Db250ZXh0KFxuICAgICAgdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgICAgcGxhdGZvcm06IHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtLFxuICAgICAgICBwcm9qZWN0Q29uZmlnOiB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi5wcm9qZWN0Q29uZmlnLFxuICAgICAgICBkZWJ1Z05hbWVzcGFjZTogdGhpcy5fZGVidWdOYW1lc3BhY2UsXG4gICAgICB9LFxuICAgIClcbiAgICB0aGlzLl9iaW5kRXZlbnRMaXN0ZW5lcnModGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0KVxuXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5lbnRyeXBvaW50ID0gb3B0cy5lbnRyeXBvaW50IVxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuZnNNYXAgPSBub3JtYWxpemVGc01hcChvcHRzLmZzTWFwKVxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQudHNDb25maWcgPSBnZXRUc0NvbmZpZyh0aGlzLl9leGVjdXRpb25Db250ZXh0LmZzTWFwKVxuICAgIGlmICghdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5mc01hcFtvcHRzLmVudHJ5cG9pbnQhXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnRyeXBvaW50IFwiJHtvcHRzLmVudHJ5cG9pbnR9XCIgbm90IGZvdW5kYClcbiAgICB9XG4gICAgOyhnbG9iYWxUaGlzIGFzIGFueSkuX190c2NpcmN1aXRfY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdFxuXG4gICAgY29uc3QgZW50cnlwb2ludCA9IG9wdHMuZW50cnlwb2ludCEuc3RhcnRzV2l0aChcIi4vXCIpXG4gICAgICA/IG9wdHMuZW50cnlwb2ludFxuICAgICAgOiBgLi8ke29wdHMuZW50cnlwb2ludH1gXG5cbiAgICBkZWJ1ZyhcImZpbmFsIGVudHJ5cG9pbnQ6XCIsIGVudHJ5cG9pbnQpXG4gICAgYXdhaXQgaW1wb3J0RXZhbFBhdGgoZW50cnlwb2ludCEsIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQpXG4gIH1cblxuICBhc3luYyBleGVjdXRlKGNvZGU6IHN0cmluZywgb3B0czogeyBuYW1lPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCJbQ2lyY3VpdFJ1bm5lcl0gZXhlY3V0ZSBjYWxsZWQgd2l0aCBjb2RlIGxlbmd0aDpcIixcbiAgICAgICAgY29kZS5sZW5ndGgsXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dCA9IGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQoXG4gICAgICB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbixcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgcGxhdGZvcm06IHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtLFxuICAgICAgICBwcm9qZWN0Q29uZmlnOiB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi5wcm9qZWN0Q29uZmlnLFxuICAgICAgICBkZWJ1Z05hbWVzcGFjZTogdGhpcy5fZGVidWdOYW1lc3BhY2UsXG4gICAgICB9LFxuICAgIClcbiAgICB0aGlzLl9iaW5kRXZlbnRMaXN0ZW5lcnModGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0KVxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuZnNNYXBbXCJlbnRyeXBvaW50LnRzeFwiXSA9IGNvZGVcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0LnRzQ29uZmlnID0gZ2V0VHNDb25maWcodGhpcy5fZXhlY3V0aW9uQ29udGV4dC5mc01hcClcbiAgICA7KGdsb2JhbFRoaXMgYXMgYW55KS5fX3RzY2lyY3VpdF9jaXJjdWl0ID0gdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0XG5cbiAgICBhd2FpdCBpbXBvcnRFdmFsUGF0aChcIi4vZW50cnlwb2ludC50c3hcIiwgdGhpcy5fZXhlY3V0aW9uQ29udGV4dClcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGVDb21wb25lbnQoY29tcG9uZW50OiBhbnksIG9wdHM6IHsgbmFtZT86IHN0cmluZyB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24udmVyYm9zZSkge1xuICAgICAgY29uc29sZS5sb2coXCJbQ2lyY3VpdFJ1bm5lcl0gZXhlY3V0ZUNvbXBvbmVudCBjYWxsZWRcIilcbiAgICB9XG5cbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0ID0gY3JlYXRlRXhlY3V0aW9uQ29udGV4dChcbiAgICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLFxuICAgICAge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBwbGF0Zm9ybTogdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0sXG4gICAgICAgIHByb2plY3RDb25maWc6IHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnByb2plY3RDb25maWcsXG4gICAgICAgIGRlYnVnTmFtZXNwYWNlOiB0aGlzLl9kZWJ1Z05hbWVzcGFjZSxcbiAgICAgIH0sXG4gICAgKVxuICAgIHRoaXMuX2JpbmRFdmVudExpc3RlbmVycyh0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQpXG4gICAgOyhnbG9iYWxUaGlzIGFzIGFueSkuX190c2NpcmN1aXRfY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdFxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQudHNDb25maWcgPSBudWxsXG5cbiAgICBjb25zdCBlbGVtZW50ID0gdHlwZW9mIGNvbXBvbmVudCA9PT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50KCkgOiBjb21wb25lbnRcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQuYWRkKGVsZW1lbnQgYXMgYW55KVxuICB9XG5cbiAgb24oZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCkge1xuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XSA/Pz0gW11cbiAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0ucHVzaChjYWxsYmFjaylcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0Py5jaXJjdWl0Lm9uKGV2ZW50IGFzIGFueSwgY2FsbGJhY2spXG4gIH1cblxuICBhc3luYyByZW5kZXJVbnRpbFNldHRsZWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLl9leGVjdXRpb25Db250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaXJjdWl0IGhhcyBiZWVuIGNyZWF0ZWRcIilcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdC5yZW5kZXJVbnRpbFNldHRsZWQoKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlbmhhbmNlUm9vdENpcmN1aXRIYXNOb0NoaWxkcmVuRXJyb3IoXG4gICAgICAgIGVycm9yLFxuICAgICAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0LmVudHJ5cG9pbnQsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0Q2lyY3VpdEpzb24oKTogUHJvbWlzZTxBbnlDaXJjdWl0RWxlbWVudFtdPiB7XG4gICAgaWYgKCF0aGlzLl9leGVjdXRpb25Db250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaXJjdWl0IGhhcyBiZWVuIGNyZWF0ZWRcIilcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQuZ2V0Q2lyY3VpdEpzb24oKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlbmhhbmNlUm9vdENpcmN1aXRIYXNOb0NoaWxkcmVuRXJyb3IoXG4gICAgICAgIGVycm9yLFxuICAgICAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0LmVudHJ5cG9pbnQsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY2xlYXJFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5fZXhlY3V0aW9uQ29udGV4dD8uY2lyY3VpdCkge1xuICAgICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGNvbnN0IGNpcmN1aXQgPSB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQgYXMgdW5rbm93biBhcyB7XG4gICAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb21wbGV4aXR5L25vQmFubmVkVHlwZXM6IDxleHBsYW5hdGlvbj5cbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyPzogKGV2ZW50OiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikgPT4gdm9pZFxuICAgICAgICAgIH1cbiAgICAgICAgICBjaXJjdWl0LnJlbW92ZUxpc3RlbmVyPy4oZXZlbnQsIGxpc3RlbmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGtpbGwoKSB7XG4gICAgLy8gQ2xlYW51cCByZXNvdXJjZXNcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0ID0gbnVsbFxuICB9XG5cbiAgYXN5bmMgc2V0U25pcHBldHNBcGlCYXNlVXJsKGJhc2VVcmw6IHN0cmluZykge1xuICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnNuaXBwZXRzQXBpQmFzZVVybCA9IGJhc2VVcmxcbiAgfVxuXG4gIGFzeW5jIHNldFBsYXRmb3JtQ29uZmlnKHBsYXRmb3JtOiBQbGF0Zm9ybUNvbmZpZykge1xuICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtID0gcGxhdGZvcm1cbiAgfVxuXG4gIGFzeW5jIHNldFBsYXRmb3JtQ29uZmlnUHJvcGVydHkocHJvcGVydHk6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGlmICghdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0pIHtcbiAgICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtID0ge31cbiAgICB9XG4gICAgc2V0VmFsdWVBdFBhdGgodGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0sIHByb3BlcnR5LCB2YWx1ZSlcbiAgfVxuXG4gIGFzeW5jIHNldFByb2plY3RDb25maWcocHJvamVjdDogUGFydGlhbDxQbGF0Zm9ybUNvbmZpZz4pIHtcbiAgICB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi5wcm9qZWN0Q29uZmlnID0gcHJvamVjdFxuICB9XG5cbiAgYXN5bmMgc2V0UHJvamVjdENvbmZpZ1Byb3BlcnR5KHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICBpZiAoIXRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnByb2plY3RDb25maWcpIHtcbiAgICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnByb2plY3RDb25maWcgPSB7fVxuICAgIH1cbiAgICBzZXRWYWx1ZUF0UGF0aChcbiAgICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnByb2plY3RDb25maWcsXG4gICAgICBwcm9wZXJ0eSxcbiAgICAgIHZhbHVlLFxuICAgIClcbiAgfVxuXG4gIGFzeW5jIGVuYWJsZURlYnVnKG5hbWVzcGFjZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fZGVidWdOYW1lc3BhY2UgPSBuYW1lc3BhY2VcbiAgICBpZiAodGhpcy5fZXhlY3V0aW9uQ29udGV4dCkge1xuICAgICAgY29uc3QgY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdCBhcyBhbnlcbiAgICAgIGNpcmN1aXQuZW5hYmxlRGVidWc/LihuYW1lc3BhY2UpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfYmluZEV2ZW50TGlzdGVuZXJzKGNpcmN1aXQ6IFJvb3RDaXJjdWl0KSB7XG4gICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgY2lyY3VpdC5vbihldmVudCBhcyBhbnksIGxpc3RlbmVyIGFzIGFueSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsICIvKipcbiAqIFJldHVybnMgdGhlIGRpcmVjdG9yeSBuYW1lIG9mIGEgcGF0aCwgc2ltaWxhciB0byBOb2RlLmpzIHBhdGguZGlybmFtZVxuICogV29ya3Mgb24gYm90aCBVbml4IGFuZCBXaW5kb3dzIHBhdGhzXG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBleHRyYWN0IHRoZSBkaXJlY3RvcnkgZnJvbVxuICogQHJldHVybnMgVGhlIGRpcmVjdG9yeSBwYXJ0IG9mIHRoZSBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXJuYW1lKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghcGF0aCkgcmV0dXJuIFwiLlwiXG5cbiAgLy8gTm9ybWFsaXplIHBhdGggc2VwYXJhdG9ycyB0byBmb3J3YXJkIHNsYXNoZXNcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG5cbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXNcbiAgY29uc3QgY2xlYW5QYXRoID0gbm9ybWFsaXplZFBhdGgucmVwbGFjZSgvXFwvKyQvLCBcIlwiKVxuXG4gIC8vIElmIHRoZXJlIGFyZSBubyBzbGFzaGVzLCByZXR1cm4gXCIuXCJcbiAgaWYgKGNsZWFuUGF0aC5pbmRleE9mKFwiL1wiKSA9PT0gLTEpIHJldHVybiBcIi5cIlxuXG4gIC8vIFJldHVybiBldmVyeXRoaW5nIHVwIHRvIHRoZSBsYXN0IHNsYXNoXG4gIHJldHVybiBjbGVhblBhdGguc3Vic3RyaW5nKDAsIGNsZWFuUGF0aC5sYXN0SW5kZXhPZihcIi9cIikpIHx8IFwiL1wiXG59XG4iLCAiaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gXCIuL2Rpcm5hbWVcIlxuXG4vKipcbiAqIFJlc29sdmUgYW4gaW1wb3J0UGF0aCByZWxhdGl2ZSB0byBhIGN3ZCwgc3VwcG9ydGluZyAuLi8sIC4vIGFuZCBhYnNvbHV0ZSBwYXRocy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVSZWxhdGl2ZVBhdGgoaW1wb3J0UGF0aDogc3RyaW5nLCBjd2Q6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIEhhbmRsZSBwYXJlbnQgZGlyZWN0b3J5IG5hdmlnYXRpb25cbiAgaWYgKGltcG9ydFBhdGguc3RhcnRzV2l0aChcIi4uL1wiKSkge1xuICAgIGNvbnN0IHBhcmVudERpciA9IGRpcm5hbWUoY3dkKVxuICAgIHJldHVybiByZXNvbHZlUmVsYXRpdmVQYXRoKGltcG9ydFBhdGguc2xpY2UoMyksIHBhcmVudERpcilcbiAgfVxuICAvLyBIYW5kbGUgY3VycmVudCBkaXJlY3RvcnlcbiAgaWYgKGltcG9ydFBhdGguc3RhcnRzV2l0aChcIi4vXCIpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVSZWxhdGl2ZVBhdGgoaW1wb3J0UGF0aC5zbGljZSgyKSwgY3dkKVxuICB9XG4gIC8vIEhhbmRsZSBhYnNvbHV0ZSBwYXRoXG4gIGlmIChpbXBvcnRQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIGltcG9ydFBhdGguc2xpY2UoMSlcbiAgfVxuICAvLyBIYW5kbGUgcmVsYXRpdmUgcGF0aFxuICByZXR1cm4gYCR7Y3dkfS8ke2ltcG9ydFBhdGh9YFxufVxuIiwgImltcG9ydCB7IG5vcm1hbGl6ZUZpbGVQYXRoIH0gZnJvbSBcIi4vbm9ybWFsaXplRnNNYXBcIlxuaW1wb3J0IHsgcmVzb2x2ZVJlbGF0aXZlUGF0aCB9IGZyb20gXCJsaWIvdXRpbHMvcmVzb2x2ZVJlbGF0aXZlUGF0aFwiXG5pbXBvcnQge1xuICByZXNvbHZlV2l0aFRzY29uZmlnUGF0aHMsXG4gIHR5cGUgVHNDb25maWcsXG4gIHJlc29sdmVXaXRoQmFzZVVybCxcbn0gZnJvbSBcIi4vdHNjb25maWdQYXRoc1wiXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmlsZVBhdGggPSAoXG4gIHVua25vd25GaWxlUGF0aDogc3RyaW5nLFxuICBmc01hcE9yQWxsRmlsZVBhdGhzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgc3RyaW5nW10sXG4gIGN3ZD86IHN0cmluZyxcbiAgb3B0czogeyB0c0NvbmZpZz86IFRzQ29uZmlnIHwgbnVsbCB9ID0ge30sXG4pID0+IHtcbiAgLy8gSGFuZGxlIHBhcmVudCBkaXJlY3RvcnkgbmF2aWdhdGlvbiBwcm9wZXJseVxuICBjb25zdCByZXNvbHZlZFBhdGggPSBjd2RcbiAgICA/IHJlc29sdmVSZWxhdGl2ZVBhdGgodW5rbm93bkZpbGVQYXRoLCBjd2QpXG4gICAgOiB1bmtub3duRmlsZVBhdGhcblxuICBjb25zdCBmaWxlUGF0aHMgPSBuZXcgU2V0KFxuICAgIEFycmF5LmlzQXJyYXkoZnNNYXBPckFsbEZpbGVQYXRocylcbiAgICAgID8gZnNNYXBPckFsbEZpbGVQYXRoc1xuICAgICAgOiBPYmplY3Qua2V5cyhmc01hcE9yQWxsRmlsZVBhdGhzKSxcbiAgKVxuXG4gIGlmIChmaWxlUGF0aHMuaGFzKHJlc29sdmVkUGF0aCkpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRQYXRoXG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkRmlsZVBhdGhNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXG4gIGZvciAoY29uc3QgZmlsZVBhdGggb2YgZmlsZVBhdGhzKSB7XG4gICAgbm9ybWFsaXplZEZpbGVQYXRoTWFwLnNldChub3JtYWxpemVGaWxlUGF0aChmaWxlUGF0aCksIGZpbGVQYXRoKVxuICB9XG5cbiAgY29uc3Qgbm9ybWFsaXplZFJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUZpbGVQYXRoKHJlc29sdmVkUGF0aClcblxuICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhub3JtYWxpemVkUmVzb2x2ZWRQYXRoKSkge1xuICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KG5vcm1hbGl6ZWRSZXNvbHZlZFBhdGgpIVxuICB9XG5cbiAgLy8gU2VhcmNoIGZvciBmaWxlIHdpdGggYSBzZXQgb2YgZGlmZmVyZW50IGV4dGVuc2lvbnNcbiAgY29uc3QgZXh0ZW5zaW9uID0gW1widHN4XCIsIFwidHNcIiwgXCJqc29uXCIsIFwianNcIiwgXCJqc3hcIiwgXCJvYmpcIiwgXCJnbHRmXCIsIFwiZ2xiXCJdXG4gIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbikge1xuICAgIGNvbnN0IHBvc3NpYmxlRmlsZVBhdGggPSBgJHtub3JtYWxpemVkUmVzb2x2ZWRQYXRofS4ke2V4dH1gXG4gICAgaWYgKG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5oYXMocG9zc2libGVGaWxlUGF0aCkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KHBvc3NpYmxlRmlsZVBhdGgpIVxuICAgIH1cbiAgfVxuXG4gIC8vIFRyeSByZXNvbHZpbmcgdXNpbmcgdHNjb25maWcgXCJwYXRoc1wiIG1hcHBpbmcgd2hlbiB0aGUgaW1wb3J0IGlzIG5vbi1yZWxhdGl2ZVxuICBjb25zdCB0c0NvbmZpZyA9IG9wdHMudHNDb25maWcgPz8gbnVsbFxuXG4gIGlmICghdW5rbm93bkZpbGVQYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSAmJiAhdW5rbm93bkZpbGVQYXRoLnN0YXJ0c1dpdGgoXCIuLi9cIikpIHtcbiAgICBjb25zdCByZXNvbHZlZFBhdGhGcm9tUGF0aHMgPSByZXNvbHZlV2l0aFRzY29uZmlnUGF0aHMoe1xuICAgICAgaW1wb3J0UGF0aDogdW5rbm93bkZpbGVQYXRoLFxuICAgICAgbm9ybWFsaXplZEZpbGVQYXRoTWFwLFxuICAgICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9uLFxuICAgICAgdHNDb25maWcsXG4gICAgfSlcbiAgICBpZiAocmVzb2x2ZWRQYXRoRnJvbVBhdGhzKSByZXR1cm4gcmVzb2x2ZWRQYXRoRnJvbVBhdGhzXG5cbiAgICBjb25zdCByZXNvbHZlZFBhdGhGcm9tQmFzZVVybCA9IHJlc29sdmVXaXRoQmFzZVVybCh7XG4gICAgICBpbXBvcnRQYXRoOiB1bmtub3duRmlsZVBhdGgsXG4gICAgICBub3JtYWxpemVkRmlsZVBhdGhNYXAsXG4gICAgICBleHRlbnNpb25zOiBleHRlbnNpb24sXG4gICAgICB0c0NvbmZpZyxcbiAgICB9KVxuICAgIGlmIChyZXNvbHZlZFBhdGhGcm9tQmFzZVVybCkgcmV0dXJuIHJlc29sdmVkUGF0aEZyb21CYXNlVXJsXG4gIH1cblxuICAvLyBDaGVjayBpZiBpdCdzIGFuIGFic29sdXRlIGltcG9ydFxuICBpZiAoIXVua25vd25GaWxlUGF0aC5zdGFydHNXaXRoKFwiLi9cIikgJiYgIXVua25vd25GaWxlUGF0aC5zdGFydHNXaXRoKFwiLi4vXCIpKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFVua25vd25GaWxlUGF0aCA9IG5vcm1hbGl6ZUZpbGVQYXRoKHVua25vd25GaWxlUGF0aClcbiAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhub3JtYWxpemVkVW5rbm93bkZpbGVQYXRoKSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQobm9ybWFsaXplZFVua25vd25GaWxlUGF0aCkhXG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbikge1xuICAgICAgY29uc3QgcG9zc2libGVGaWxlUGF0aCA9IGAke25vcm1hbGl6ZWRVbmtub3duRmlsZVBhdGh9LiR7ZXh0fWBcbiAgICAgIGlmIChub3JtYWxpemVkRmlsZVBhdGhNYXAuaGFzKHBvc3NpYmxlRmlsZVBhdGgpKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KHBvc3NpYmxlRmlsZVBhdGgpIVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmlsZVBhdGhPclRocm93ID0gKFxuICB1bmtub3duRmlsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXBPckFsbEZpbGVQYXRoczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZ1tdLFxuICBjd2Q/OiBzdHJpbmcsXG4gIG9wdHM6IHsgdHNDb25maWc/OiBUc0NvbmZpZyB8IG51bGwgfSA9IHt9LFxuKSA9PiB7XG4gIGNvbnN0IHJlc29sdmVkRmlsZVBhdGggPSByZXNvbHZlRmlsZVBhdGgoXG4gICAgdW5rbm93bkZpbGVQYXRoLFxuICAgIGZzTWFwT3JBbGxGaWxlUGF0aHMsXG4gICAgY3dkLFxuICAgIG9wdHMsXG4gIClcbiAgaWYgKCFyZXNvbHZlZEZpbGVQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZpbGUgbm90IGZvdW5kIFwiJHt1bmtub3duRmlsZVBhdGh9XCIsIGF2YWlsYWJsZSBwYXRoczpcXG5cXG4ke09iamVjdC5rZXlzKGZzTWFwT3JBbGxGaWxlUGF0aHMpLmpvaW4oXCIsIFwiKX1gLFxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRGaWxlUGF0aFxufVxuIiwgImV4cG9ydCBjb25zdCBnZXRJbXBvcnRzRnJvbUNvZGUgPSAoY29kZTogc3RyaW5nKTogc3RyaW5nW10gPT4ge1xuICAvLyBNYXRjaCBiYXNpYyBpbXBvcnQgcGF0dGVybnMgaW5jbHVkaW5nIGNvbWJpbmVkIGRlZmF1bHQgYW5kIG5hbWVzcGFjZSBpbXBvcnRzXG4gIGNvbnN0IGltcG9ydFJlZ2V4ID1cbiAgICAvXlxccyppbXBvcnRcXHMrKD86KD86W1xcd1xcc10rLFxccyopPyg/OlxcKlxccythc1xccytbXFx3XFxzXSt8XFx7W1xcc1xcdyxdK1xcfXxcXHcrKVxccytmcm9tXFxzKik/WydcIl0oLis/KVsnXCJdL2dtXG4gIGNvbnN0IGltcG9ydHM6IHN0cmluZ1tdID0gW11cbiAgbGV0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsXG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0Fzc2lnbkluRXhwcmVzc2lvbnM6IDxleHBsYW5hdGlvbj5cbiAgd2hpbGUgKChtYXRjaCA9IGltcG9ydFJlZ2V4LmV4ZWMoY29kZSkpICE9PSBudWxsKSB7XG4gICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF1cbiAgICBpZiAoL15cXHMqaW1wb3J0XFxzK3R5cGVcXGIvLnRlc3QoZnVsbE1hdGNoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaW1wb3J0cy5wdXNoKG1hdGNoWzFdKVxuICB9XG5cbiAgLy8gTWF0Y2ggcmUtZXhwb3J0c1xuICBjb25zdCByZUV4cG9ydFJlZ2V4ID1cbiAgICAvXlxccypleHBvcnRcXHMrKD86dHlwZVxccyspPyg/OlxcKlxccythc1xccytbXFx3JF0rfFxcKnxcXHtbXn1dK1xcfSlcXHMrZnJvbVxccypbJ1wiXSguKz8pWydcIl0vZ21cbiAgbGV0IHJlRXhwb3J0TWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGxcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0Fzc2lnbkluRXhwcmVzc2lvbnM6IDxleHBsYW5hdGlvbj5cbiAgd2hpbGUgKChyZUV4cG9ydE1hdGNoID0gcmVFeHBvcnRSZWdleC5leGVjKGNvZGUpKSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGZ1bGxNYXRjaCA9IHJlRXhwb3J0TWF0Y2hbMF1cbiAgICBpZiAoL15cXHMqZXhwb3J0XFxzK3R5cGVcXGIvLnRlc3QoZnVsbE1hdGNoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaW1wb3J0cy5wdXNoKHJlRXhwb3J0TWF0Y2hbMV0pXG4gIH1cblxuICByZXR1cm4gaW1wb3J0c1xufVxuIiwgImltcG9ydCB7IHJlc29sdmVGaWxlUGF0aCB9IGZyb20gXCJsaWIvcnVubmVyL3Jlc29sdmVGaWxlUGF0aFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsQ29tcGlsZWRKcyhcbiAgY29tcGlsZWRDb2RlOiBzdHJpbmcsXG4gIHByZVN1cHBsaWVkSW1wb3J0czogUmVjb3JkPHN0cmluZywgYW55PixcbiAgY3dkPzogc3RyaW5nLFxuKSB7XG4gIDsoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fdHNjaXJjdWl0X3JlcXVpcmUgPSAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRGaWxlUGF0aCA9IHJlc29sdmVGaWxlUGF0aChuYW1lLCBwcmVTdXBwbGllZEltcG9ydHMsIGN3ZClcblxuICAgIGNvbnN0IGhhc1Jlc29sdmVkRmlsZVBhdGggPVxuICAgICAgcmVzb2x2ZWRGaWxlUGF0aCAmJiBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWRGaWxlUGF0aF1cblxuICAgIGlmICghcHJlU3VwcGxpZWRJbXBvcnRzW25hbWVdICYmICFoYXNSZXNvbHZlZEZpbGVQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEltcG9ydCBcIiR7bmFtZX1cIiBub3QgZm91bmQgJHtjd2QgPyBgaW4gXCIke2N3ZH1cImAgOiBcIlwifWApXG4gICAgfVxuXG4gICAgY29uc3QgbW9kID1cbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tuYW1lXSB8fCBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWRGaWxlUGF0aCFdXG4gICAgcmV0dXJuIG5ldyBQcm94eShtb2QsIHtcbiAgICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmRlZmF1bHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhcmdldC5fX2VzTW9kdWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgdGFyZ2V0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcm9wID09PSBcIl9fZXNNb2R1bGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ29tcG9uZW50IFwiJHtTdHJpbmcocHJvcCl9XCIgaXMgbm90IGV4cG9ydGVkIGJ5IFwiJHtuYW1lfVwiYCxcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3AgYXMga2V5b2YgdHlwZW9mIHRhcmdldF1cbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGZ1bmN0aW9uQm9keSA9IGBcbiAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgdmFyIHJlcXVpcmUgPSBnbG9iYWxUaGlzLl9fdHNjaXJjdWl0X3JlcXVpcmU7XG4gIHZhciBtb2R1bGUgPSB7IGV4cG9ydHMgfTtcbiAgdmFyIGNpcmN1aXQgPSBnbG9iYWxUaGlzLl9fdHNjaXJjdWl0X2NpcmN1aXQ7XG4gICR7Y29tcGlsZWRDb2RlfTtcbiAgcmV0dXJuIG1vZHVsZTtgLnRyaW0oKVxuICByZXR1cm4gRnVuY3Rpb24oZnVuY3Rpb25Cb2R5KS5jYWxsKGdsb2JhbFRoaXMpXG59XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZUZpbGVQYXRoT3JUaHJvdyB9IGZyb20gXCJsaWIvcnVubmVyL3Jlc29sdmVGaWxlUGF0aFwiXG5pbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSBcImxpYi91dGlscy9kaXJuYW1lXCJcbmltcG9ydCB7IGdldEltcG9ydHNGcm9tQ29kZSB9IGZyb20gXCJsaWIvdXRpbHMvZ2V0LWltcG9ydHMtZnJvbS1jb2RlXCJcbmltcG9ydCB7IGV2YWxDb21waWxlZEpzIH0gZnJvbSBcIi4vZXZhbC1jb21waWxlZC1qc1wiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgeyBpbXBvcnRFdmFsUGF0aCB9IGZyb20gXCIuL2ltcG9ydC1ldmFsLXBhdGhcIlxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiXG5pbXBvcnQgeyBpc1N0YXRpY0Fzc2V0UGF0aCB9IGZyb20gXCJsaWIvc2hhcmVkL3N0YXRpYy1hc3NldC1leHRlbnNpb25zXCJcbmltcG9ydCB7IHRyYW5zZm9ybVdpdGhTdWNyYXNlIH0gZnJvbSBcIi4vdHJhbnNmb3JtLXdpdGgtc3VjcmFzZVwiXG5pbXBvcnQgeyBLaWNhZFRvQ2lyY3VpdEpzb25Db252ZXJ0ZXIgfSBmcm9tIFwia2ljYWQtdG8tY2lyY3VpdC1qc29uXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDppbXBvcnQtbG9jYWwtZmlsZVwiKVxuXG5leHBvcnQgY29uc3QgaW1wb3J0TG9jYWxGaWxlID0gYXN5bmMgKFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSA9PiB7XG4gIGRlYnVnKFwiaW1wb3J0TG9jYWxGaWxlIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgaW1wb3J0TmFtZSxcbiAgfSlcblxuICBjb25zdCB7IGZzTWFwLCBwcmVTdXBwbGllZEltcG9ydHMsIGltcG9ydFN0YWNrLCBjdXJyZW50bHlJbXBvcnRpbmcgfSA9IGN0eFxuXG4gIGNvbnN0IGZzUGF0aCA9IHJlc29sdmVGaWxlUGF0aE9yVGhyb3coaW1wb3J0TmFtZSwgZnNNYXAsIHVuZGVmaW5lZCwge1xuICAgIHRzQ29uZmlnOiBjdHgudHNDb25maWcsXG4gIH0pXG4gIGRlYnVnKFwiZnNQYXRoOlwiLCBmc1BhdGgpXG4gIGlmIChjdXJyZW50bHlJbXBvcnRpbmcuaGFzKGZzUGF0aCkpIHtcbiAgICBjb25zdCBjeWNsZVN0YXJ0SW5kZXggPSBpbXBvcnRTdGFjay5pbmRleE9mKGZzUGF0aClcbiAgICBjb25zdCBjeWNsZVBhdGggPVxuICAgICAgY3ljbGVTdGFydEluZGV4ID49IDBcbiAgICAgICAgPyBpbXBvcnRTdGFjay5zbGljZShjeWNsZVN0YXJ0SW5kZXgpLmNvbmNhdChmc1BhdGgpXG4gICAgICAgIDogWy4uLmltcG9ydFN0YWNrLCBmc1BhdGhdXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQgd2hpbGUgaW1wb3J0aW5nIFwiJHtmc1BhdGh9XCIuIFRoZSBmb2xsb3dpbmcgaW1wb3J0IGNoYWluIGZvcm1zIGEgY3ljbGU6XFxuXFxuJHtjeWNsZVBhdGguam9pbihcbiAgICAgICAgXCIgLT4gXCIsXG4gICAgICApfWAsXG4gICAgKVxuICB9XG5cbiAgaWYgKCFjdHguZnNNYXBbZnNQYXRoXSkge1xuICAgIGRlYnVnKFwiZnNQYXRoIG5vdCBmb3VuZCBpbiBmc01hcDpcIiwgZnNQYXRoKVxuICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSBcIiR7ZnNQYXRofVwiIG5vdCBmb3VuZGApXG4gIH1cbiAgY29uc3QgZmlsZUNvbnRlbnQgPSBmc01hcFtmc1BhdGhdXG4gIGRlYnVnKFwiZmlsZUNvbnRlbnQ6XCIsIGZpbGVDb250ZW50Py5zbGljZSgwLCAxMDApKVxuICBjdXJyZW50bHlJbXBvcnRpbmcuYWRkKGZzUGF0aClcbiAgaW1wb3J0U3RhY2sucHVzaChmc1BhdGgpXG4gIHRyeSB7XG4gICAgaWYgKGZzUGF0aC5lbmRzV2l0aChcIi5qc29uXCIpKSB7XG4gICAgICBjb25zdCBqc29uRGF0YSA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnQpXG4gICAgICBwcmVTdXBwbGllZEltcG9ydHNbZnNQYXRoXSA9IHtcbiAgICAgICAgX19lc01vZHVsZTogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdDoganNvbkRhdGEsXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmc1BhdGguZW5kc1dpdGgoXCIua2ljYWRfcGNiXCIpKSB7XG4gICAgICBjb25zdCBjb252ZXJ0ZXIgPSBuZXcgS2ljYWRUb0NpcmN1aXRKc29uQ29udmVydGVyKClcbiAgICAgIGNvbnZlcnRlci5hZGRGaWxlKGZzUGF0aCwgZmlsZUNvbnRlbnQpXG4gICAgICBjb252ZXJ0ZXIucnVuVW50aWxGaW5pc2hlZCgpXG4gICAgICBjb25zdCBjaXJjdWl0SnNvbiA9IGNvbnZlcnRlci5nZXRPdXRwdXQoKVxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ZzUGF0aF0gPSB7XG4gICAgICAgIF9fZXNNb2R1bGU6IHRydWUsXG4gICAgICAgIGNpcmN1aXRKc29uOiBjaXJjdWl0SnNvbixcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU3RhdGljQXNzZXRQYXRoKGZzUGF0aCkpIHtcbiAgICAgIGxldCBzdGF0aWNVcmw6IHN0cmluZ1xuXG4gICAgICBpZiAoZmlsZUNvbnRlbnQgPT09IFwiX19TVEFUSUNfQVNTRVRfX1wiKSB7XG4gICAgICAgIC8vIFBsYWNlaG9sZGVyOiB1c2UgcHJvamVjdEJhc2VVcmwgZm9yIHN0YXRpYyBmaWxlIGltcG9ydHNcbiAgICAgICAgY29uc3QgcGxhdGZvcm1Db25maWcgPSBjdHguY2lyY3VpdC5wbGF0Zm9ybVxuICAgICAgICBzdGF0aWNVcmwgPSBgJHtwbGF0Zm9ybUNvbmZpZz8ucHJvamVjdEJhc2VVcmwgPz8gXCJcIn0vJHtcbiAgICAgICAgICBmc1BhdGguc3RhcnRzV2l0aChcIi4vXCIpID8gZnNQYXRoLnNsaWNlKDIpIDogZnNQYXRoXG4gICAgICAgIH1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBY3R1YWwgZmlsZSBjb250ZW50OiBjcmVhdGUgYSBibG9iIFVSTFxuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2ZpbGVDb250ZW50XSwge1xuICAgICAgICAgIHR5cGU6IGZzUGF0aC5lbmRzV2l0aChcIi5raWNhZF9tb2RcIilcbiAgICAgICAgICAgID8gXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgICAgIDogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIixcbiAgICAgICAgfSlcbiAgICAgICAgc3RhdGljVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAgfVxuXG4gICAgICBwcmVTdXBwbGllZEltcG9ydHNbZnNQYXRoXSA9IHtcbiAgICAgICAgX19lc01vZHVsZTogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdDogc3RhdGljVXJsLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnNQYXRoLmVuZHNXaXRoKFwiLnRzeFwiKSB8fCBmc1BhdGguZW5kc1dpdGgoXCIudHNcIikpIHtcbiAgICAgIGNvbnN0IGltcG9ydE5hbWVzID0gZ2V0SW1wb3J0c0Zyb21Db2RlKGZpbGVDb250ZW50KVxuXG4gICAgICBmb3IgKGNvbnN0IGltcG9ydE5hbWUgb2YgaW1wb3J0TmFtZXMpIHtcbiAgICAgICAgaWYgKCFwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0pIHtcbiAgICAgICAgICBhd2FpdCBpbXBvcnRFdmFsUGF0aChpbXBvcnROYW1lLCBjdHgsIGRlcHRoICsgMSwge1xuICAgICAgICAgICAgY3dkOiBkaXJuYW1lKGZzUGF0aCksXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZENvZGUgPSB0cmFuc2Zvcm1XaXRoU3VjcmFzZShmaWxlQ29udGVudCwgZnNQYXRoKVxuICAgICAgICBkZWJ1ZyhcImV2YWxDb21waWxlZEpzIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgICAgICAgY29kZTogdHJhbnNmb3JtZWRDb2RlLnNsaWNlKDAsIDEwMCksXG4gICAgICAgICAgZGlybmFtZTogZGlybmFtZShmc1BhdGgpLFxuICAgICAgICB9KVxuICAgICAgICBjb25zdCBpbXBvcnRSdW5SZXN1bHQgPSBldmFsQ29tcGlsZWRKcyhcbiAgICAgICAgICB0cmFuc2Zvcm1lZENvZGUsXG4gICAgICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzLFxuICAgICAgICAgIGRpcm5hbWUoZnNQYXRoKSxcbiAgICAgICAgKVxuICAgICAgICBkZWJ1ZyhcImltcG9ydFJ1blJlc3VsdDpcIiwge1xuICAgICAgICAgIGZzUGF0aCxcbiAgICAgICAgICBpbXBvcnRSdW5SZXN1bHQsXG4gICAgICAgIH0pXG4gICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmc1BhdGhdID0gaW1wb3J0UnVuUmVzdWx0LmV4cG9ydHNcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFdmFsIGNvbXBpbGVkIGpzIGVycm9yIGZvciBcIiR7aW1wb3J0TmFtZX1cIjogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZzUGF0aC5lbmRzV2l0aChcIi5qc1wiKSkge1xuICAgICAgLy8gRm9yIC5qcyBmaWxlcywgZXNwZWNpYWxseSBmcm9tIG5vZGVfbW9kdWxlcywgd2UgbmVlZCB0byB0cmFuc2Zvcm0gdGhlbVxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ZzUGF0aF0gPSBldmFsQ29tcGlsZWRKcyhcbiAgICAgICAgdHJhbnNmb3JtV2l0aFN1Y3Jhc2UoZmlsZUNvbnRlbnQsIGZzUGF0aCksXG4gICAgICAgIHByZVN1cHBsaWVkSW1wb3J0cyxcbiAgICAgICAgZGlybmFtZShmc1BhdGgpLFxuICAgICAgKS5leHBvcnRzXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFVuc3VwcG9ydGVkIGZpbGUgZXh0ZW5zaW9uIFwiJHtmc1BhdGguc3BsaXQoXCIuXCIpLnBvcCgpfVwiIGZvciBcIiR7ZnNQYXRofVwiYCxcbiAgICAgIClcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgaW1wb3J0U3RhY2sucG9wKClcbiAgICBjdXJyZW50bHlJbXBvcnRpbmcuZGVsZXRlKGZzUGF0aClcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBTVEFUSUNfQVNTRVRfRVhURU5TSU9OUyA9IFtcbiAgXCIuZ2xiXCIsXG4gIFwiLmtpY2FkX21vZFwiLFxuICBcIi5nbHRmXCIsXG4gIFwiLm9ialwiLFxuICBcIi5zdGxcIixcbl1cblxuZXhwb3J0IGNvbnN0IGlzU3RhdGljQXNzZXRQYXRoID0gKHBhdGg6IHN0cmluZykgPT5cbiAgU1RBVElDX0FTU0VUX0VYVEVOU0lPTlMuc29tZSgoZXh0KSA9PiBwYXRoLmVuZHNXaXRoKGV4dCkpXG4iLCAiaW1wb3J0IHsgdHJhbnNmb3JtLCB0eXBlIFRyYW5zZm9ybSBhcyBTdWNyYXNlVHJhbnNmb3JtIH0gZnJvbSBcInN1Y3Jhc2VcIlxuXG5jb25zdCBUU19FWFRFTlNJT05TID0gbmV3IFNldChbXCIudHNcIiwgXCIudHN4XCIsIFwiLm10c1wiLCBcIi5jdHNcIl0pXG5jb25zdCBKU1hfRVhURU5TSU9OUyA9IG5ldyBTZXQoW1wiLnRzeFwiLCBcIi5qc3hcIiwgXCIudHNcIl0pXG5jb25zdCBUWVBFX1NUQVJfRVhQT1JUX1JFR0VYID1cbiAgL15cXHMqZXhwb3J0XFxzK3R5cGVcXHMrXFwqXFxzKyg/OmFzXFxzK1tcXHckXStcXHMrKT9mcm9tXFxzK1snXCJdW14nXCJdK1snXCJdXFxzKjs/XFxzKiQvZ2ltXG5cbmNvbnN0IHN0cmlwVHlwZVN0YXJFeHBvcnRzID0gKGNvZGU6IHN0cmluZykgPT5cbiAgY29kZS5yZXBsYWNlKFRZUEVfU1RBUl9FWFBPUlRfUkVHRVgsIFwiXCIpXG5cbmNvbnN0IHN0cmlwUXVlcnlBbmRIYXNoID0gKGZpbGVQYXRoOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgcXVlcnlJbmRleCA9IGZpbGVQYXRoLmluZGV4T2YoXCI/XCIpXG4gIGNvbnN0IGhhc2hJbmRleCA9IGZpbGVQYXRoLmluZGV4T2YoXCIjXCIpXG5cbiAgbGV0IGVuZEluZGV4ID0gZmlsZVBhdGgubGVuZ3RoXG5cbiAgaWYgKHF1ZXJ5SW5kZXggIT09IC0xICYmIGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBlbmRJbmRleCA9IE1hdGgubWluKHF1ZXJ5SW5kZXgsIGhhc2hJbmRleClcbiAgfSBlbHNlIGlmIChxdWVyeUluZGV4ICE9PSAtMSkge1xuICAgIGVuZEluZGV4ID0gcXVlcnlJbmRleFxuICB9IGVsc2UgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBlbmRJbmRleCA9IGhhc2hJbmRleFxuICB9XG5cbiAgcmV0dXJuIGZpbGVQYXRoLnNsaWNlKDAsIGVuZEluZGV4KVxufVxuXG5jb25zdCBnZXRFeHRlbnNpb24gPSAoZmlsZVBhdGg6IHN0cmluZykgPT4ge1xuICBjb25zdCBub3JtYWxpemVkUGF0aCA9IHN0cmlwUXVlcnlBbmRIYXNoKGZpbGVQYXRoKVxuICBjb25zdCBsYXN0RG90SW5kZXggPSBub3JtYWxpemVkUGF0aC5sYXN0SW5kZXhPZihcIi5cIilcblxuICBpZiAobGFzdERvdEluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBcIlwiXG4gIH1cblxuICBjb25zdCBsYXN0U2xhc2hJbmRleCA9IE1hdGgubWF4KFxuICAgIG5vcm1hbGl6ZWRQYXRoLmxhc3RJbmRleE9mKFwiL1wiKSxcbiAgICBub3JtYWxpemVkUGF0aC5sYXN0SW5kZXhPZihcIlxcXFxcIiksXG4gIClcblxuICBpZiAobGFzdFNsYXNoSW5kZXggPiBsYXN0RG90SW5kZXgpIHtcbiAgICByZXR1cm4gXCJcIlxuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWRQYXRoLnNsaWNlKGxhc3REb3RJbmRleCkudG9Mb3dlckNhc2UoKVxufVxuXG5jb25zdCBnZXRUcmFuc2Zvcm1zRm9yRmlsZVBhdGggPSAoZmlsZVBhdGg6IHN0cmluZykgPT4ge1xuICBjb25zdCBleHRlbnNpb24gPSBnZXRFeHRlbnNpb24oZmlsZVBhdGgpXG5cbiAgY29uc3QgdHJhbnNmb3JtczogU3VjcmFzZVRyYW5zZm9ybVtdID0gW1wiaW1wb3J0c1wiXVxuXG4gIGlmIChUU19FWFRFTlNJT05TLmhhcyhleHRlbnNpb24pKSB7XG4gICAgdHJhbnNmb3Jtcy51bnNoaWZ0KFwidHlwZXNjcmlwdFwiKVxuICB9XG5cbiAgaWYgKEpTWF9FWFRFTlNJT05TLmhhcyhleHRlbnNpb24pKSB7XG4gICAgdHJhbnNmb3Jtcy5wdXNoKFwianN4XCIpXG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3Jtc1xufVxuXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtV2l0aFN1Y3Jhc2UgPSAoY29kZTogc3RyaW5nLCBmaWxlUGF0aDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHRyYW5zZm9ybXMgPSBnZXRUcmFuc2Zvcm1zRm9yRmlsZVBhdGgoZmlsZVBhdGgpXG4gIGNvbnN0IHNhbml0aXplZENvZGUgPSBzdHJpcFR5cGVTdGFyRXhwb3J0cyhjb2RlKVxuICBjb25zdCB7IGNvZGU6IHRyYW5zZm9ybWVkQ29kZSB9ID0gdHJhbnNmb3JtKHNhbml0aXplZENvZGUsIHtcbiAgICBmaWxlUGF0aCxcbiAgICBwcm9kdWN0aW9uOiB0cnVlLFxuICAgIHRyYW5zZm9ybXMsXG4gIH0pXG5cbiAgcmV0dXJuIHRyYW5zZm9ybWVkQ29kZVxufVxuIiwgImltcG9ydCB7IGV2YWxDb21waWxlZEpzIH0gZnJvbSBcIi4vZXZhbC1jb21waWxlZC1qc1wiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRTbmlwcGV0KFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSB7XG4gIGNvbnN0IHsgcHJlU3VwcGxpZWRJbXBvcnRzIH0gPSBjdHhcbiAgY29uc3QgZnVsbFNuaXBwZXROYW1lID0gaW1wb3J0TmFtZS5yZXBsYWNlKFwiQHRzY2kvXCIsIFwiXCIpLnJlcGxhY2UoXCIuXCIsIFwiL1wiKVxuXG4gIGNvbnN0IHsgY2pzLCBlcnJvciB9ID0gYXdhaXQgZ2xvYmFsVGhpc1xuICAgIC5mZXRjaChgJHtjdHguY2pzUmVnaXN0cnlVcmx9LyR7ZnVsbFNuaXBwZXROYW1lfWApXG4gICAgLnRoZW4oYXN5bmMgKHJlcykgPT4gKHsgY2pzOiBhd2FpdCByZXMudGV4dCgpLCBlcnJvcjogbnVsbCB9KSlcbiAgICAuY2F0Y2goKGUpID0+ICh7IGVycm9yOiBlLCBjanM6IG51bGwgfSkpXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGltcG9ydFwiLCBpbXBvcnROYW1lLCBlcnJvcilcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRyeSB7XG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWVdID0gZXZhbENvbXBpbGVkSnMoXG4gICAgICBjanMhLFxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzLFxuICAgICkuZXhwb3J0c1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGltcG9ydGluZyBzbmlwcGV0XCIsIGUpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSBcIi4vZGlybmFtZVwiXG5cbmludGVyZmFjZSBQYWNrYWdlSnNvbiB7XG4gIG1haW4/OiBzdHJpbmdcbiAgbW9kdWxlPzogc3RyaW5nXG4gIGV4cG9ydHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PlxufVxuXG5pbnRlcmZhY2UgTm9kZVJlc29sdXRpb25Db250ZXh0IHtcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgZXh0ZW5zaW9uczogc3RyaW5nW11cbiAgYmFzZVBhdGg6IHN0cmluZ1xuICBtb2R1bGVQYXRoOiBzdHJpbmdcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChcbiAgbW9kdWxlUGF0aDogc3RyaW5nLFxuICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgYmFzZVBhdGg6IHN0cmluZyxcbik6IE5vZGVSZXNvbHV0aW9uQ29udGV4dCB7XG4gIHJldHVybiB7XG4gICAgZnNNYXAsXG4gICAgZXh0ZW5zaW9uczogW1wiLmpzXCIsIFwiLmpzeFwiLCBcIi50c1wiLCBcIi50c3hcIiwgXCIuanNvblwiXSxcbiAgICBiYXNlUGF0aCxcbiAgICBtb2R1bGVQYXRoLFxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQYWNrYWdlSnNvbihub2RlTW9kdWxlc1BhdGg6IHN0cmluZywgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gYCR7bm9kZU1vZHVsZXNQYXRofS9wYWNrYWdlLmpzb25gXG4gIGlmICghY3R4LmZzTWFwW3BhY2thZ2VKc29uUGF0aF0pIHJldHVybiBudWxsXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY3R4LmZzTWFwW3BhY2thZ2VKc29uUGF0aF0pIGFzIFBhY2thZ2VKc29uXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5UmVzb2x2ZVdpdGhFeHRlbnNpb25zKFxuICBwYXRoOiBzdHJpbmcsXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChjdHguZnNNYXBbcGF0aF0pIHJldHVybiBwYXRoXG5cbiAgZm9yIChjb25zdCBleHQgb2YgY3R4LmV4dGVuc2lvbnMpIHtcbiAgICBjb25zdCBwYXRoV2l0aEV4dCA9IHBhdGgucmVwbGFjZSgvXFwuanMkfFxcLmpzeCQvLCBcIlwiKSArIGV4dFxuICAgIGlmIChjdHguZnNNYXBbcGF0aFdpdGhFeHRdKSByZXR1cm4gcGF0aFdpdGhFeHRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiByZXNvbHZlRXhwb3J0UGF0aChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIGV4cG9ydFBhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgZnVsbEV4cG9ydFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9LyR7ZXhwb3J0UGF0aC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIil9YFxuICByZXR1cm4gdHJ5UmVzb2x2ZVdpdGhFeHRlbnNpb25zKGZ1bGxFeHBvcnRQYXRoLCBjdHgpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYWNrYWdlRXhwb3J0cyhcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbixcbiAgcmVtYWluaW5nUGF0aDogc3RyaW5nLFxuICBjdHg6IE5vZGVSZXNvbHV0aW9uQ29udGV4dCxcbik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoIXBhY2thZ2VKc29uLmV4cG9ydHMpIHJldHVybiBudWxsXG5cbiAgLy8gSGFuZGxlIGRlZmF1bHQgZXhwb3J0IGNvbmRpdGlvblxuICBjb25zdCBkZWZhdWx0RXhwb3J0ID0gcGFja2FnZUpzb24uZXhwb3J0c1tcIi5cIl1cbiAgaWYgKHJlbWFpbmluZ1BhdGggPT09IFwiXCIgJiYgZGVmYXVsdEV4cG9ydCkge1xuICAgIGlmICh0eXBlb2YgZGVmYXVsdEV4cG9ydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRXhwb3J0UGF0aChub2RlTW9kdWxlc1BhdGgsIGRlZmF1bHRFeHBvcnQsIGN0eClcbiAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIHN1YnBhdGggZXhwb3J0c1xuICBjb25zdCBzdWJwYXRoRXhwb3J0ID0gcmVtYWluaW5nUGF0aFxuICAgID8gcGFja2FnZUpzb24uZXhwb3J0c1tgLi8ke3JlbWFpbmluZ1BhdGh9YF1cbiAgICA6IG51bGxcbiAgaWYgKHN1YnBhdGhFeHBvcnQgJiYgdHlwZW9mIHN1YnBhdGhFeHBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVFeHBvcnRQYXRoKG5vZGVNb2R1bGVzUGF0aCwgc3VicGF0aEV4cG9ydCwgY3R4KVxuICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gIH1cblxuICAvLyBIYW5kbGUgY29uZGl0aW9uYWwgZXhwb3J0c1xuICBjb25zdCBpbXBvcnRFeHBvcnQgPSBwYWNrYWdlSnNvbi5leHBvcnRzW1wiaW1wb3J0XCJdXG4gIGlmIChcbiAgICByZW1haW5pbmdQYXRoID09PSBcIlwiICYmXG4gICAgaW1wb3J0RXhwb3J0ICYmXG4gICAgdHlwZW9mIGltcG9ydEV4cG9ydCA9PT0gXCJzdHJpbmdcIlxuICApIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVFeHBvcnRQYXRoKG5vZGVNb2R1bGVzUGF0aCwgaW1wb3J0RXhwb3J0LCBjdHgpXG4gICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWRcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYWNrYWdlRW50cnlQb2ludChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbixcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgZW50cnlQb2ludCA9IHBhY2thZ2VKc29uLm1vZHVsZSB8fCBwYWNrYWdlSnNvbi5tYWluIHx8IFwiaW5kZXguanNcIlxuICBjb25zdCBmdWxsUGF0aCA9IGAke25vZGVNb2R1bGVzUGF0aH0vJHtlbnRyeVBvaW50fWBcbiAgcmV0dXJuIHRyeVJlc29sdmVXaXRoRXh0ZW5zaW9ucyhmdWxsUGF0aCwgY3R4KVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVtYWluaW5nUGF0aChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHJlbWFpbmluZ1BhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFyZW1haW5pbmdQYXRoKSB7XG4gICAgLy8gVHJ5IGluZGV4IGZpbGVzIGluIHRoZSBtb2R1bGUgcm9vdFxuICAgIGZvciAoY29uc3QgZXh0IG9mIGN0eC5leHRlbnNpb25zKSB7XG4gICAgICBjb25zdCBpbmRleFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9L2luZGV4JHtleHR9YFxuICAgICAgaWYgKGN0eC5mc01hcFtpbmRleFBhdGhdKSByZXR1cm4gaW5kZXhQYXRoXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBmdWxsUGF0aCA9IGAke25vZGVNb2R1bGVzUGF0aH0vJHtyZW1haW5pbmdQYXRofWBcbiAgY29uc3QgZGlyZWN0TWF0Y2ggPSB0cnlSZXNvbHZlV2l0aEV4dGVuc2lvbnMoZnVsbFBhdGgsIGN0eClcbiAgaWYgKGRpcmVjdE1hdGNoKSByZXR1cm4gZGlyZWN0TWF0Y2hcblxuICAvLyBUcnkgaW5kZXggZmlsZXNcbiAgZm9yIChjb25zdCBleHQgb2YgY3R4LmV4dGVuc2lvbnMpIHtcbiAgICBjb25zdCBpbmRleFBhdGggPSBgJHtmdWxsUGF0aH0vaW5kZXgke2V4dH1gXG4gICAgaWYgKGN0eC5mc01hcFtpbmRleFBhdGhdKSByZXR1cm4gaW5kZXhQYXRoXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGVNb2R1bGVJblBhdGgoXG4gIHNlYXJjaFBhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgbW9kdWxlUGFydHMgPSBjdHgubW9kdWxlUGF0aC5zcGxpdChcIi9cIilcbiAgY29uc3Qgc2NvcGUgPSBtb2R1bGVQYXJ0c1swXS5zdGFydHNXaXRoKFwiQFwiKVxuICAgID8gbW9kdWxlUGFydHMuc2xpY2UoMCwgMikuam9pbihcIi9cIilcbiAgICA6IG1vZHVsZVBhcnRzWzBdXG4gIGNvbnN0IHJlbWFpbmluZ1BhdGggPSBtb2R1bGVQYXJ0cy5zbGljZShzY29wZS5pbmNsdWRlcyhcIi9cIikgPyAyIDogMSkuam9pbihcIi9cIilcbiAgY29uc3Qgbm9kZU1vZHVsZXNQYXRoID0gYCR7c2VhcmNoUGF0aCA9PSBcIi5cIiA/IFwiXCIgOiBgJHtzZWFyY2hQYXRofS9gfW5vZGVfbW9kdWxlcy8ke3Njb3BlfWBcblxuICAvLyBUcnkgdG8gZmluZCBwYWNrYWdlLmpzb25cbiAgY29uc3QgcGFja2FnZUpzb24gPSBmaW5kUGFja2FnZUpzb24obm9kZU1vZHVsZXNQYXRoLCBjdHgpXG4gIGlmIChwYWNrYWdlSnNvbikge1xuICAgIC8vIFRyeSByZXNvbHZpbmcgdGhyb3VnaCBleHBvcnRzIGZpZWxkXG4gICAgY29uc3QgZXhwb3J0c1Jlc29sdXRpb24gPSByZXNvbHZlUGFja2FnZUV4cG9ydHMoXG4gICAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgICBwYWNrYWdlSnNvbixcbiAgICAgIHJlbWFpbmluZ1BhdGgsXG4gICAgICBjdHgsXG4gICAgKVxuICAgIGlmIChleHBvcnRzUmVzb2x1dGlvbikgcmV0dXJuIGV4cG9ydHNSZXNvbHV0aW9uXG5cbiAgICAvLyBUcnkgcmVzb2x2aW5nIHRocm91Z2ggbWFpbi9tb2R1bGUgZmllbGRzXG4gICAgY29uc3QgZW50cnlQb2ludFJlc29sdXRpb24gPSByZXNvbHZlUGFja2FnZUVudHJ5UG9pbnQoXG4gICAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgICBwYWNrYWdlSnNvbixcbiAgICAgIGN0eCxcbiAgICApXG4gICAgaWYgKGVudHJ5UG9pbnRSZXNvbHV0aW9uKSByZXR1cm4gZW50cnlQb2ludFJlc29sdXRpb25cbiAgfVxuXG4gIC8vIFRyeSByZXNvbHZpbmcgcmVtYWluaW5nIHBhdGhcbiAgY29uc3QgcmVtYWluaW5nUGF0aFJlc29sdXRpb24gPSByZXNvbHZlUmVtYWluaW5nUGF0aChcbiAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgcmVtYWluaW5nUGF0aCxcbiAgICBjdHgsXG4gIClcbiAgaWYgKHJlbWFpbmluZ1BhdGhSZXNvbHV0aW9uKSByZXR1cm4gcmVtYWluaW5nUGF0aFJlc29sdXRpb25cblxuICAvLyBJZiBub3QgZm91bmQgYW5kIHdlIGhhdmUgYSBwYXJlbnQgZGlyZWN0b3J5LCB0cnkgdGhlcmVcbiAgY29uc3QgcGFyZW50UGF0aCA9IGRpcm5hbWUoc2VhcmNoUGF0aClcbiAgaWYgKHBhcmVudFBhdGggJiYgcGFyZW50UGF0aCAhPT0gc2VhcmNoUGF0aCkge1xuICAgIHJldHVybiByZXNvbHZlTm9kZU1vZHVsZUluUGF0aChwYXJlbnRQYXRoLCBjdHgpXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU5vZGVNb2R1bGUoXG4gIG1vZHVsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gIGJhc2VQYXRoOiBzdHJpbmcsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgY3R4ID0gY3JlYXRlQ29udGV4dChtb2R1bGVQYXRoLCBmc01hcCwgYmFzZVBhdGgpXG4gIHJldHVybiByZXNvbHZlTm9kZU1vZHVsZUluUGF0aChjdHguYmFzZVBhdGgsIGN0eClcbn1cbiIsICJpbXBvcnQgeyByZXNvbHZlTm9kZU1vZHVsZSB9IGZyb20gXCJsaWIvdXRpbHMvcmVzb2x2ZS1ub2RlLW1vZHVsZVwiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgeyBpbXBvcnRMb2NhbEZpbGUgfSBmcm9tIFwiLi9pbXBvcnQtbG9jYWwtZmlsZVwiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDppbXBvcnQtbm9kZS1tb2R1bGVcIilcblxuZXhwb3J0IGNvbnN0IGltcG9ydE5vZGVNb2R1bGUgPSBhc3luYyAoXG4gIGltcG9ydE5hbWU6IHN0cmluZyxcbiAgY3R4OiBFeGVjdXRpb25Db250ZXh0LFxuICBkZXB0aCA9IDAsXG4pID0+IHtcbiAgY29uc3QgeyBwcmVTdXBwbGllZEltcG9ydHMgfSA9IGN0eFxuXG4gIGlmIChwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkTm9kZU1vZHVsZVBhdGggPSByZXNvbHZlTm9kZU1vZHVsZShpbXBvcnROYW1lLCBjdHguZnNNYXAsIFwiXCIpXG5cbiAgaWYgKCFyZXNvbHZlZE5vZGVNb2R1bGVQYXRoKSB7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBjdHguY2lyY3VpdD8ucGxhdGZvcm1cbiAgICBpZiAocGxhdGZvcm0/Lm5vZGVNb2R1bGVzUmVzb2x2ZXIpIHtcbiAgICAgIGRlYnVnKGBBdHRlbXB0aW5nIHRvIHJlc29sdmUgXCIke2ltcG9ydE5hbWV9XCIgdXNpbmcgbm9kZU1vZHVsZXNSZXNvbHZlcmApXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgcGxhdGZvcm0ubm9kZU1vZHVsZXNSZXNvbHZlcihpbXBvcnROYW1lKVxuXG4gICAgICAgIGlmIChmaWxlQ29udGVudCkge1xuICAgICAgICAgIGRlYnVnKGBTdWNjZXNzZnVsbHkgcmVzb2x2ZWQgXCIke2ltcG9ydE5hbWV9XCIgdmlhIG5vZGVNb2R1bGVzUmVzb2x2ZXJgKVxuXG4gICAgICAgICAgLy8gQWRkIHRoZSByZXNvbHZlZCBjb250ZW50IHRvIGZzTWFwIHdpdGggYSBzeW50aGV0aWMgcGF0aFxuICAgICAgICAgIC8vIEFkZCAudHMgZXh0ZW5zaW9uIHRvIGVuc3VyZSBpdCdzIHRyZWF0ZWQgYXMgYSBtb2R1bGUgZmlsZVxuICAgICAgICAgIGNvbnN0IHN5bnRoZXRpY1BhdGggPSBgbm9kZV9tb2R1bGVzLyR7aW1wb3J0TmFtZX0udHNgXG4gICAgICAgICAgY3R4LmZzTWFwW3N5bnRoZXRpY1BhdGhdID0gZmlsZUNvbnRlbnRcblxuICAgICAgICAgIC8vIEltcG9ydCB0aGUgZmlsZSB1c2luZyB0aGUgbm9ybWFsIGZsb3dcbiAgICAgICAgICBhd2FpdCBpbXBvcnRMb2NhbEZpbGUoc3ludGhldGljUGF0aCwgY3R4LCBkZXB0aClcblxuICAgICAgICAgIC8vIE1hcCB0aGUgaW1wb3J0IG5hbWUgdG8gdGhlIHJlc29sdmVkIG1vZHVsZVxuICAgICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSA9IHByZVN1cHBsaWVkSW1wb3J0c1tzeW50aGV0aWNQYXRoXVxuXG4gICAgICAgICAgLy8gQWxzbyBtYXAgd2l0aG91dCBub2RlX21vZHVsZXMgcHJlZml4XG4gICAgICAgICAgY29uc3QgdW5wcmVmaXhlZFBhdGggPSBzeW50aGV0aWNQYXRoLnJlcGxhY2UoL15ub2RlX21vZHVsZXNcXC8vLCBcIlwiKVxuICAgICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1t1bnByZWZpeGVkUGF0aF0gPSBwcmVTdXBwbGllZEltcG9ydHNbc3ludGhldGljUGF0aF1cblxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoYG5vZGVNb2R1bGVzUmVzb2x2ZXIgcmV0dXJuZWQgbnVsbCBmb3IgXCIke2ltcG9ydE5hbWV9XCJgKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGVidWcoYG5vZGVNb2R1bGVzUmVzb2x2ZXIgZmFpbGVkIGZvciBcIiR7aW1wb3J0TmFtZX1cIjpgLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgbW9kdWxlIFwiJHtpbXBvcnROYW1lfVwiIG5vdCBmb3VuZGApXG4gIH1cblxuICAvLyBVc2UgaW1wb3J0TG9jYWxGaWxlIHRvIGhhbmRsZSB0aGUgbm9kZSBtb2R1bGVcbiAgYXdhaXQgaW1wb3J0TG9jYWxGaWxlKHJlc29sdmVkTm9kZU1vZHVsZVBhdGgsIGN0eCwgZGVwdGgpXG5cbiAgLy8gTWFwIHRoZSBvcmlnaW5hbCBpbXBvcnQgbmFtZSB0byB0aGUgcmVzb2x2ZWQgbW9kdWxlJ3MgZXhwb3J0c1xuICBwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0gPSBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWROb2RlTW9kdWxlUGF0aF1cblxuICAvLyBNYXAgd2l0aG91dCBub2RlX21vZHVsZXMgcHJlZml4IGZvciBkaXJlY3QgaW1wb3J0c1xuICBjb25zdCB1bnByZWZpeGVkUGF0aCA9IHJlc29sdmVkTm9kZU1vZHVsZVBhdGgucmVwbGFjZSgvXm5vZGVfbW9kdWxlc1xcLy8sIFwiXCIpXG4gIHByZVN1cHBsaWVkSW1wb3J0c1t1bnByZWZpeGVkUGF0aF0gPVxuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuXG4gIC8vIEhhbmRsZSBpbmRleCBmaWxlcyBzcGVjaWFsbHlcbiAgaWYgKFxuICAgIHJlc29sdmVkTm9kZU1vZHVsZVBhdGguZW5kc1dpdGgoXCIvaW5kZXgudHN4XCIpIHx8XG4gICAgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5lbmRzV2l0aChcIi9pbmRleC50c1wiKSB8fFxuICAgIHJlc29sdmVkTm9kZU1vZHVsZVBhdGguZW5kc1dpdGgoXCIvaW5kZXguanNcIilcbiAgKSB7XG4gICAgY29uc3QgZGlyUGF0aCA9IHJlc29sdmVkTm9kZU1vZHVsZVBhdGgucmVwbGFjZSgvXFwvaW5kZXhcXC4odHN4P3xqcykkLywgXCJcIilcbiAgICBjb25zdCB1bnByZWZpeGVkRGlyUGF0aCA9IGRpclBhdGgucmVwbGFjZSgvXm5vZGVfbW9kdWxlc1xcLy8sIFwiXCIpXG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW3VucHJlZml4ZWREaXJQYXRoXSA9XG4gICAgICBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWROb2RlTW9kdWxlUGF0aF1cblxuICAgIC8vIEhhbmRsZSBzY29wZWQgcGFja2FnZXNcbiAgICBpZiAodW5wcmVmaXhlZERpclBhdGguc3RhcnRzV2l0aChcIkBcIikpIHtcbiAgICAgIGNvbnN0IHNjb3BlUGFydHMgPSB1bnByZWZpeGVkRGlyUGF0aC5zcGxpdChcIi9cIilcbiAgICAgIGlmIChzY29wZVBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlZE5hbWUgPSBgJHtzY29wZVBhcnRzWzBdfS8ke3Njb3BlUGFydHNbMV19YFxuICAgICAgICBwcmVTdXBwbGllZEltcG9ydHNbc2NvcGVkTmFtZV0gPVxuICAgICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IGV2YWxDb21waWxlZEpzIH0gZnJvbSBcIi4vZXZhbC1jb21waWxlZC1qc1wiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSBcImxpYi91dGlscy9kaXJuYW1lXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuaW1wb3J0IHsgZ2V0SW1wb3J0c0Zyb21Db2RlIH0gZnJvbSBcImxpYi91dGlscy9nZXQtaW1wb3J0cy1mcm9tLWNvZGVcIlxuaW1wb3J0IHsgaW1wb3J0RXZhbFBhdGggfSBmcm9tIFwiLi9pbXBvcnQtZXZhbC1wYXRoXCJcbmltcG9ydCB7IHRyYW5zZm9ybVdpdGhTdWNyYXNlIH0gZnJvbSBcIi4vdHJhbnNmb3JtLXdpdGgtc3VjcmFzZVwiXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJ0c2NpOmV2YWw6aW1wb3J0LW5wbS1wYWNrYWdlXCIpXG5cbmZ1bmN0aW9uIGV4dHJhY3RQYWNrYWdlUGF0aEZyb21KU0RlbGl2cih1cmw6IHN0cmluZykge1xuICBjb25zdCBwcmVmaXggPSBcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vXCJcbiAgaWYgKHVybC5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKS5yZXBsYWNlKC9cXC9cXCtlc20kLywgXCJcIilcbiAgfVxuICByZXR1cm4gdXJsXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnROcG1QYWNrYWdlKFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSB7XG4gIGRlYnVnKGBpbXBvcnRpbmcgbnBtIHBhY2thZ2U6ICR7aW1wb3J0TmFtZX1gKVxuICBjb25zdCB7IHByZVN1cHBsaWVkSW1wb3J0cyB9ID0gY3R4XG5cbiAgaWYgKHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSkgcmV0dXJuXG5cbiAgY29uc3QgbnBtQ2RuVXJsID0gYGh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vJHtpbXBvcnROYW1lfS8rZXNtYFxuXG4gIGxldCBmaW5hbFVybDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIGNvbnN0IHsgY29udGVudCwgZXJyb3IgfSA9IGF3YWl0IGdsb2JhbFRoaXNcbiAgICAuZmV0Y2gobnBtQ2RuVXJsKVxuICAgIC50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgIGZpbmFsVXJsID0gcmVzLnVybFxuICAgICAgaWYgKCFyZXMub2spXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGZldGNoIFwiJHtpbXBvcnROYW1lfVwiIGZyb20ganNkZWxpdnI6ICR7cmVzLnN0YXR1c1RleHR9XFxuXFxuJHtjdHgubG9nZ2VyLnN0cmluZ2lmeUxvZ3MoKX1gLFxuICAgICAgICApXG4gICAgICByZXR1cm4geyBjb250ZW50OiBhd2FpdCByZXMudGV4dCgpLCBlcnJvcjogbnVsbCB9XG4gICAgfSlcbiAgICAuY2F0Y2goKGUpID0+ICh7IGVycm9yOiBlLCBjb250ZW50OiBudWxsIH0pKVxuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBucG0gaW1wb3J0XCIsIGltcG9ydE5hbWUsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cblxuICBjb25zdCBmaW5hbEltcG9ydE5hbWUgPSBleHRyYWN0UGFja2FnZVBhdGhGcm9tSlNEZWxpdnIoZmluYWxVcmwhKVxuICBjb25zdCBjd2QgPSBkaXJuYW1lKGZpbmFsSW1wb3J0TmFtZSlcblxuICBjb25zdCBpbXBvcnROYW1lcyA9IGdldEltcG9ydHNGcm9tQ29kZShjb250ZW50ISlcbiAgZm9yIChjb25zdCBzdWJJbXBvcnROYW1lIG9mIGltcG9ydE5hbWVzKSB7XG4gICAgaWYgKCFwcmVTdXBwbGllZEltcG9ydHNbc3ViSW1wb3J0TmFtZV0pIHtcbiAgICAgIGF3YWl0IGltcG9ydEV2YWxQYXRoKHN1YkltcG9ydE5hbWUsIGN0eCwgZGVwdGggKyAxLCB7XG4gICAgICAgIGN3ZCxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdHJhbnNmb3JtZWRDb2RlID0gdHJhbnNmb3JtV2l0aFN1Y3Jhc2UoXG4gICAgY29udGVudCEsXG4gICAgZmluYWxJbXBvcnROYW1lIHx8IGltcG9ydE5hbWUsXG4gIClcbiAgdHJ5IHtcbiAgICBjb25zdCBleHBvcnRzID0gZXZhbENvbXBpbGVkSnMoXG4gICAgICB0cmFuc2Zvcm1lZENvZGUsXG4gICAgICBwcmVTdXBwbGllZEltcG9ydHMsXG4gICAgICBjd2QsXG4gICAgKS5leHBvcnRzXG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWVdID0gZXhwb3J0c1xuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmaW5hbEltcG9ydE5hbWVdID0gZXhwb3J0c1xuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmaW5hbFVybCFdID0gZXhwb3J0c1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXZhbCBucG0gcGFja2FnZSBlcnJvciBmb3IgXCIke2ltcG9ydE5hbWV9XCI6ICR7ZS5tZXNzYWdlfVxcblxcbiR7Y3R4LmxvZ2dlci5zdHJpbmdpZnlMb2dzKCl9YCxcbiAgICApXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgeyBpbXBvcnRMb2NhbEZpbGUgfSBmcm9tIFwiLi9pbXBvcnQtbG9jYWwtZmlsZVwiXG5pbXBvcnQgeyBpbXBvcnRTbmlwcGV0IH0gZnJvbSBcIi4vaW1wb3J0LXNuaXBwZXRcIlxuaW1wb3J0IHsgcmVzb2x2ZUZpbGVQYXRoIH0gZnJvbSBcImxpYi9ydW5uZXIvcmVzb2x2ZUZpbGVQYXRoXCJcbmltcG9ydCB7IHJlc29sdmVOb2RlTW9kdWxlIH0gZnJvbSBcImxpYi91dGlscy9yZXNvbHZlLW5vZGUtbW9kdWxlXCJcbmltcG9ydCB7IGltcG9ydE5vZGVNb2R1bGUgfSBmcm9tIFwiLi9pbXBvcnQtbm9kZS1tb2R1bGVcIlxuaW1wb3J0IHsgaW1wb3J0TnBtUGFja2FnZSB9IGZyb20gXCIuL2ltcG9ydC1ucG0tcGFja2FnZVwiXG5pbXBvcnQge1xuICBnZXRUc0NvbmZpZyxcbiAgbWF0Y2hlc1RzY29uZmlnUGF0aFBhdHRlcm4sXG59IGZyb20gXCJsaWIvcnVubmVyL3RzY29uZmlnUGF0aHNcIlxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJ0c2NpOmV2YWw6aW1wb3J0LWV2YWwtcGF0aFwiKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0RXZhbFBhdGgoXG4gIGltcG9ydE5hbWU6IHN0cmluZyxcbiAgY3R4OiBFeGVjdXRpb25Db250ZXh0LFxuICBkZXB0aCA9IDAsXG4gIG9wdHM6IHtcbiAgICBjd2Q/OiBzdHJpbmdcbiAgfSA9IHt9LFxuKSB7XG4gIGRlYnVnKFwiaW1wb3J0RXZhbFBhdGggY2FsbGVkIHdpdGg6XCIsIHtcbiAgICBpbXBvcnROYW1lLFxuICAgIGRlcHRoLFxuICAgIG9wdHMsXG4gIH0pXG4gIGN0eC5sb2dnZXIuaW5mbyhcbiAgICBgaW1wb3J0RXZhbFBhdGgoXCIke2ltcG9ydE5hbWV9XCIsIHtjd2Q6IFwiJHtvcHRzLmN3ZH1cIiwgZGVwdGg6ICR7ZGVwdGh9fSlgLFxuICApXG5cbiAgZGVidWcoYCR7XCIgIFwiLnJlcGVhdChkZXB0aCl9XHUyN0ExXHVGRTBGYCwgaW1wb3J0TmFtZSlcbiAgY29uc3QgeyBwcmVTdXBwbGllZEltcG9ydHMgfSA9IGN0eFxuXG4gIGlmIChwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0pIHtcbiAgICBjdHgubG9nZ2VyLmluZm8oYEltcG9ydCBcIiR7aW1wb3J0TmFtZX1cIiBpbiBwcmVTdXBwbGllZEltcG9ydHNbMV1gKVxuICAgIHJldHVyblxuICB9XG4gIGlmIChpbXBvcnROYW1lLnN0YXJ0c1dpdGgoXCIuL1wiKSAmJiBwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZS5zbGljZSgyKV0pIHtcbiAgICBjdHgubG9nZ2VyLmluZm8oYEltcG9ydCBcIiR7aW1wb3J0TmFtZX1cIiBpbiBwcmVTdXBwbGllZEltcG9ydHNbMl1gKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGRlcHRoID4gMzApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTWF4IGRlcHRoIGZvciBpbXBvcnRzIHJlYWNoZWQgKDMwKSBJbXBvcnQgUGF0aDogJHtjdHguaW1wb3J0U3RhY2suam9pbihcIiAtPiBcIil9YCxcbiAgICApXG4gIH1cblxuICBpZiAoaW1wb3J0TmFtZS5zdGFydHNXaXRoKFwiL25wbS9cIikpIHtcbiAgICBjb25zdCBwa2dOYW1lID0gaW1wb3J0TmFtZS5yZXBsYWNlKC9eXFwvbnBtXFwvLywgXCJcIikucmVwbGFjZSgvXFwvXFwrZXNtJC8sIFwiXCIpXG4gICAgY3R4LmxvZ2dlci5pbmZvKGBpbXBvcnROcG1QYWNrYWdlKFwiJHtwa2dOYW1lfVwiKWApXG4gICAgYXdhaXQgaW1wb3J0TnBtUGFja2FnZShwa2dOYW1lLCBjdHgsIGRlcHRoKVxuICAgIGNvbnN0IHBrZyA9IHByZVN1cHBsaWVkSW1wb3J0c1twa2dOYW1lXVxuICAgIGlmIChwa2cpIHtcbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSA9IHBrZ1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkTG9jYWxJbXBvcnRQYXRoID0gcmVzb2x2ZUZpbGVQYXRoKFxuICAgIGltcG9ydE5hbWUsXG4gICAgY3R4LmZzTWFwLFxuICAgIG9wdHMuY3dkLFxuICAgIHsgdHNDb25maWc6IGN0eC50c0NvbmZpZyB9LFxuICApXG4gIGlmIChyZXNvbHZlZExvY2FsSW1wb3J0UGF0aCkge1xuICAgIGN0eC5sb2dnZXIuaW5mbyhgaW1wb3J0TG9jYWxGaWxlKFwiJHtyZXNvbHZlZExvY2FsSW1wb3J0UGF0aH1cIilgKVxuICAgIGF3YWl0IGltcG9ydExvY2FsRmlsZShyZXNvbHZlZExvY2FsSW1wb3J0UGF0aCwgY3R4LCBkZXB0aClcbiAgICAvLyBNYXAgdGhlIG9yaWdpbmFsIGltcG9ydCBuYW1lICh3aGljaCBtaWdodCBiZSBhIHRzY29uZmlnIHBhdGggYWxpYXMpIHRvIHRoZSByZXNvbHZlZCBtb2R1bGVcbiAgICBpZiAoaW1wb3J0TmFtZSAhPT0gcmVzb2x2ZWRMb2NhbEltcG9ydFBhdGgpIHtcbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSA9XG4gICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZExvY2FsSW1wb3J0UGF0aF1cbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGlzIG1hdGNoZXMgYSB0c2NvbmZpZyBwYXRoIHBhdHRlcm4gYnV0IGZhaWxlZCB0byByZXNvbHZlXG4gIC8vIElmIHNvLCB0aHJvdyBhbiBlcnJvciBpbnN0ZWFkIG9mIGZhbGxpbmcgYmFjayB0byBucG1cbiAgY29uc3QgdHNDb25maWcgPSBjdHgudHNDb25maWcgPz8gZ2V0VHNDb25maWcoY3R4LmZzTWFwKVxuICBpZiAoIWN0eC50c0NvbmZpZyAmJiB0c0NvbmZpZykge1xuICAgIGN0eC50c0NvbmZpZyA9IHRzQ29uZmlnXG4gIH1cbiAgaWYgKG1hdGNoZXNUc2NvbmZpZ1BhdGhQYXR0ZXJuKGltcG9ydE5hbWUsIHRzQ29uZmlnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbXBvcnQgXCIke2ltcG9ydE5hbWV9XCIgbWF0Y2hlcyBhIHRzY29uZmlnIHBhdGggYWxpYXMgYnV0IGNvdWxkIG5vdCBiZSByZXNvbHZlZCB0byBhbiBleGlzdGluZyBmaWxlJHtvcHRzLmN3ZCA/IGAgZnJvbSBkaXJlY3RvcnkgXCIke29wdHMuY3dkfVwiYCA6IFwiXCJ9XFxuXFxuJHtjdHgubG9nZ2VyLnN0cmluZ2lmeUxvZ3MoKX1gLFxuICAgIClcbiAgfVxuXG4gIC8vIFRyeSB0byByZXNvbHZlIGZyb20gbm9kZV9tb2R1bGVzXG4gIGNvbnN0IHJlc29sdmVkTm9kZU1vZHVsZVBhdGggPSByZXNvbHZlTm9kZU1vZHVsZShcbiAgICBpbXBvcnROYW1lLFxuICAgIGN0eC5mc01hcCxcbiAgICBvcHRzLmN3ZCB8fCBcIlwiLFxuICApXG4gIGlmIChyZXNvbHZlZE5vZGVNb2R1bGVQYXRoKSB7XG4gICAgY3R4LmxvZ2dlci5pbmZvKGByZXNvbHZlZE5vZGVNb2R1bGVQYXRoPVwiJHtyZXNvbHZlZE5vZGVNb2R1bGVQYXRofVwiYClcbiAgICBjdHgubG9nZ2VyLmluZm8oYGltcG9ydE5vZGVNb2R1bGUoXCIke2ltcG9ydE5hbWV9XCIpYClcbiAgICByZXR1cm4gaW1wb3J0Tm9kZU1vZHVsZShpbXBvcnROYW1lLCBjdHgsIGRlcHRoKVxuICB9XG5cbiAgLy8gSWYgbm90IGZvdW5kIGluIGZzTWFwIGJ1dCBtaWdodCBiZSBhIG5vZGUgbW9kdWxlLCB0cnkgaW1wb3J0Tm9kZU1vZHVsZVxuICAvLyB3aGljaCB3aWxsIGF0dGVtcHQgdG8gdXNlIG5vZGVNb2R1bGVzUmVzb2x2ZXIgaWYgY29uZmlndXJlZFxuICBpZiAoXG4gICAgIWltcG9ydE5hbWUuc3RhcnRzV2l0aChcIi5cIikgJiZcbiAgICAhaW1wb3J0TmFtZS5zdGFydHNXaXRoKFwiL1wiKSAmJlxuICAgICFpbXBvcnROYW1lLnN0YXJ0c1dpdGgoXCJAdHNjaS9cIilcbiAgKSB7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBjdHguY2lyY3VpdD8ucGxhdGZvcm1cbiAgICBpZiAocGxhdGZvcm0/Lm5vZGVNb2R1bGVzUmVzb2x2ZXIpIHtcbiAgICAgIGN0eC5sb2dnZXIuaW5mbyhcbiAgICAgICAgYGltcG9ydE5vZGVNb2R1bGUoXCIke2ltcG9ydE5hbWV9XCIpIHZpYSBub2RlTW9kdWxlc1Jlc29sdmVyYCxcbiAgICAgIClcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGltcG9ydE5vZGVNb2R1bGUoaW1wb3J0TmFtZSwgY3R4LCBkZXB0aClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjdHgubG9nZ2VyLmluZm8oXG4gICAgICAgICAgYG5vZGVNb2R1bGVzUmVzb2x2ZXIgZmFpbGVkIGZvciBcIiR7aW1wb3J0TmFtZX1cIiwgZmFsbGluZyBiYWNrIHRvIG5wbSBDRE5gLFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGltcG9ydE5hbWUuc3RhcnRzV2l0aChcIkB0c2NpL1wiKSkge1xuICAgIGN0eC5sb2dnZXIuaW5mbyhgaW1wb3J0U25pcHBldChcIiR7aW1wb3J0TmFtZX1cIilgKVxuICAgIHJldHVybiBpbXBvcnRTbmlwcGV0KGltcG9ydE5hbWUsIGN0eCwgZGVwdGgpXG4gIH1cblxuICBpZiAoIWltcG9ydE5hbWUuc3RhcnRzV2l0aChcIi5cIikgJiYgIWltcG9ydE5hbWUuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICBjdHgubG9nZ2VyLmluZm8oYGltcG9ydE5wbVBhY2thZ2UoXCIke2ltcG9ydE5hbWV9XCIpYClcbiAgICByZXR1cm4gaW1wb3J0TnBtUGFja2FnZShpbXBvcnROYW1lLCBjdHgsIGRlcHRoKVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBVbnJlc29sdmVkIGltcG9ydCBcIiR7aW1wb3J0TmFtZX1cIiAke29wdHMuY3dkID8gYGZyb20gZGlyZWN0b3J5IFwiJHtvcHRzLmN3ZH1cImAgOiBcIlwifVxcblxcbiR7Y3R4LmxvZ2dlci5zdHJpbmdpZnlMb2dzKCl9YCxcbiAgKVxufVxuIiwgImltcG9ydCB7IHJlc29sdmVGaWxlUGF0aE9yVGhyb3cgfSBmcm9tIFwiLi9yZXNvbHZlRmlsZVBhdGhcIlxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJ0c2NpOmV2YWw6c2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkXCIpXG5cbmV4cG9ydCBjb25zdCBzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQgPSAob3B0czoge1xuICBlbnRyeXBvaW50Pzogc3RyaW5nXG4gIGZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIG1haW5Db21wb25lbnRQYXRoPzogc3RyaW5nXG4gIG1haW5Db21wb25lbnROYW1lPzogc3RyaW5nXG4gIG5hbWU/OiBzdHJpbmdcbiAgbWFpbkNvbXBvbmVudFByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxufSkgPT4ge1xuICBpZiAoIW9wdHMuZW50cnlwb2ludCAmJiAhb3B0cy5tYWluQ29tcG9uZW50UGF0aCkge1xuICAgIGlmIChcImluZGV4LnRzeFwiIGluIG9wdHMuZnNNYXApIHtcbiAgICAgIG9wdHMubWFpbkNvbXBvbmVudFBhdGggPSBcImluZGV4LnRzeFwiXG4gICAgfSBlbHNlIGlmIChcImluZGV4LnRzXCIgaW4gb3B0cy5mc01hcCkge1xuICAgICAgb3B0cy5tYWluQ29tcG9uZW50UGF0aCA9IFwiaW5kZXgudHNcIlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKS5maWx0ZXIoKGspID0+IGsuZW5kc1dpdGgoXCIudHN4XCIpKS5sZW5ndGggPT09IDFcbiAgICApIHtcbiAgICAgIG9wdHMubWFpbkNvbXBvbmVudFBhdGggPSBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKVswXVxuICAgIH0gZWxzZSBpZiAoXCJ0c2NpcmN1aXQuY29uZmlnLmpzb25cIiBpbiBvcHRzLmZzTWFwKSB7XG4gICAgICBjb25zdCBjb25maWdDb250ZW50ID0gb3B0cy5mc01hcFtcInRzY2lyY3VpdC5jb25maWcuanNvblwiXVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gSlNPTi5wYXJzZShjb25maWdDb250ZW50KVxuICAgICAgICBpZiAoY29uZmlnLm1haW5FbnRyeXBvaW50KSB7XG4gICAgICAgICAgb3B0cy5lbnRyeXBvaW50ID0gY29uZmlnLm1haW5FbnRyeXBvaW50XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIHRzY2lyY3VpdC5jb25maWcuanNvbjpcIiwgZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkVpdGhlciBlbnRyeXBvaW50IG9yIG1haW5Db21wb25lbnRQYXRoIG11c3QgYmUgcHJvdmlkZWQgKG5vIGluZGV4IGZpbGUsIGNvdWxkIG5vdCBpbmZlciBlbnRyeXBvaW50KVwiLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGlmICghb3B0cy5lbnRyeXBvaW50ICYmIG9wdHMubWFpbkNvbXBvbmVudFBhdGgpIHtcbiAgICBvcHRzLmVudHJ5cG9pbnQgPSBcImVudHJ5cG9pbnQudHN4XCJcbiAgICBjb25zdCBtYWluQ29tcG9uZW50Q29kZSA9XG4gICAgICBvcHRzLmZzTWFwW3Jlc29sdmVGaWxlUGF0aE9yVGhyb3cob3B0cy5tYWluQ29tcG9uZW50UGF0aCwgb3B0cy5mc01hcCldXG4gICAgaWYgKCFtYWluQ29tcG9uZW50Q29kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTWFpbiBjb21wb25lbnQgcGF0aCBcIiR7b3B0cy5tYWluQ29tcG9uZW50UGF0aH1cIiBub3QgZm91bmQgaW4gZnNNYXAuIEF2YWlsYWJsZSBwYXRoczogJHtPYmplY3Qua2V5cyhvcHRzLmZzTWFwKS5qb2luKFwiLCBcIil9YCxcbiAgICAgIClcbiAgICB9XG4gICAgb3B0cy5mc01hcFtvcHRzLmVudHJ5cG9pbnRdID0gYFxuICAgICBpbXBvcnQgKiBhcyBVc2VyQ29tcG9uZW50cyBmcm9tIFwiLi8ke29wdHMubWFpbkNvbXBvbmVudFBhdGh9XCI7XG4gICAgICAgICAgXG4gICAgICAke1xuICAgICAgICBvcHRzLm1haW5Db21wb25lbnROYW1lXG4gICAgICAgICAgPyBgXG4gICAgICAgIGNvbnN0IENvbXBvbmVudFRvUmVuZGVyID0gVXNlckNvbXBvbmVudHNbXCIke29wdHMubWFpbkNvbXBvbmVudE5hbWV9XCJdXG4gICAgICAgIGBcbiAgICAgICAgICA6IGBjb25zdCBDb21wb25lbnRUb1JlbmRlciA9IFVzZXJDb21wb25lbnRzLmRlZmF1bHQgfHwgXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoVXNlckNvbXBvbmVudHMpXG4gICAgICAgICAgLmZpbHRlcigoW25hbWVdKSA9PiAhbmFtZS5zdGFydHNXaXRoKFwidXNlXCIpKVxuICAgICAgICAgIC5tYXAoKFtfLCBjb21wb25lbnRdKSA9PiBjb21wb25lbnQpWzBdIHx8ICgoKSA9PiBudWxsKTtgXG4gICAgICB9XG5cbiAgICAgICAgICAgJHtcbiAgICAgICAgICAgICBkZWJ1Zy5lbmFibGVkXG4gICAgICAgICAgICAgICA/IGBcbiAgICAgY29uc29sZS5sb2coeyBVc2VyQ29tcG9uZW50cyB9KVxuICAgICBjb25zb2xlLmxvZyhcIkNvbXBvbmVudFRvUmVuZGVyIFwiICsgQ29tcG9uZW50VG9SZW5kZXIudG9TdHJpbmcoKSwgIHsgQ29tcG9uZW50VG9SZW5kZXIgfSlcbiAgICAgYFxuICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgIH1cblxuICAgICAgY2lyY3VpdC5hZGQoICAgICAgIFxuICAgICAgICAgIDxDb21wb25lbnRUb1JlbmRlciAke29wdHMubWFpbkNvbXBvbmVudFByb3BzID8gYHsuLi4ke0pTT04uc3RyaW5naWZ5KG9wdHMubWFpbkNvbXBvbmVudFByb3BzLCBudWxsLCAyKX19YCA6IFwiXCJ9IC8+IFxuICAgICAgKTtcbmBcbiAgfVxuXG4gIGlmICghb3B0cy5uYW1lICYmIG9wdHMubWFpbkNvbXBvbmVudE5hbWUpIHtcbiAgICBvcHRzLm5hbWUgPSBvcHRzLm1haW5Db21wb25lbnROYW1lXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgZW5oYW5jZVJvb3RDaXJjdWl0SGFzTm9DaGlsZHJlbkVycm9yID0gKFxuICBlcnJvcjogdW5rbm93bixcbiAgZW50cnlwb2ludD86IHN0cmluZyxcbikgPT4ge1xuICBpZiAoXG4gICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgIGVudHJ5cG9pbnQgJiZcbiAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiUm9vdENpcmN1aXQgaGFzIG5vIGNoaWxkcmVuXCIpICYmXG4gICAgIWVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1wiZW50cnlwb2ludFwiOicpXG4gICkge1xuICAgIGNvbnN0IGVudHJ5cG9pbnRNZXNzYWdlID0gZW50cnlwb2ludC5zdGFydHNXaXRoKFwiLi9cIilcbiAgICAgID8gZW50cnlwb2ludC5zbGljZSgyKVxuICAgICAgOiBlbnRyeXBvaW50XG4gICAgZXJyb3IubWVzc2FnZSA9IGAke2Vycm9yLm1lc3NhZ2V9LiBcImVudHJ5cG9pbnRcIjogXCIke2VudHJ5cG9pbnRNZXNzYWdlfVwiIGlzIHNldCBpbiB0aGUgcnVubmVyIGNvbmZpZ3VyYXRpb24sIGVudHJ5cG9pbnRzIG11c3QgY29udGFpbiBcImNpcmN1aXQuYWRkKC4uLilcIiwgeW91IG1pZ2h0IGJlIGxvb2tpbmcgdG8gdXNlIG1haW5Db21wb25lbnRQYXRoIGluc3RlYWQgaWYgeW91ciBmaWxlIGV4cG9ydHMgYSBjb21wb25lbnQuYFxuICB9XG5cbiAgcmV0dXJuIGVycm9yXG59XG4iLCAiLyoqXG4gKiBHZXQgYWxsIHBhdGhzIG9mIGFuIG9iamVjdFxuICpcbiAqIGdldE9iamVjdFBhdGhzKHsgYTogeyBiOiAyLCBjOiB7IGQ6IDMgfSB9LCBlOiA1IH0pXG4gKlxuICogLy8gT3V0cHV0OiBbJ2EuYicsICdhLmMuZCcsICdlJ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9iamVjdFBhdGhzKFxuICBvYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIHByZWZpeCA9IFwiXCIsXG4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHBhdGhzOiBzdHJpbmdbXSA9IFtdXG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV1cbiAgICBjb25zdCBwYXRoID0gcHJlZml4ID8gYCR7cHJlZml4fS4ke2tleX1gIDoga2V5XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY29uc3Qgc3ViUGF0aHMgPSBnZXRPYmplY3RQYXRocyh2YWx1ZSwgcGF0aClcbiAgICAgIHBhdGhzLnB1c2goLi4uc3ViUGF0aHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzLnB1c2gocGF0aClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0aHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlQXRQYXRoKG9iajogUmVjb3JkPHN0cmluZywgYW55PiwgcGF0aDogc3RyaW5nKTogYW55IHtcbiAgY29uc3Qga2V5cyA9IHBhdGguc3BsaXQoXCIuXCIpXG4gIGxldCBjdXJyZW50ID0gb2JqXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjdXJyZW50ID0gY3VycmVudFtrZXldXG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRcbn1cbi8qKlxuICogU2V0IGEgdmFsdWUgYXQgYSBwYXRoIGluIGFuIG9iamVjdFxuICpcbiAqIHNldFZhbHVlQXRQYXRoKHsgYTogeyBiOiAyIH0gfSwgXCJhLmMuZFwiLCA1KVxuICpcbiAqIC8vIE91dHB1dDogeyBhOiB7IGI6IDIsIGM6IHsgZDogNSB9IH0gfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VmFsdWVBdFBhdGgoXG4gIG9iajogUmVjb3JkPHN0cmluZywgYW55PixcbiAgcGF0aDogc3RyaW5nLFxuICB2YWx1ZTogYW55LFxuKSB7XG4gIGNvbnN0IGtleXMgPSBwYXRoLnNwbGl0KFwiLlwiKVxuICBsZXQgY3VycmVudCA9IG9ialxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG5cbiAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgbGFzdCBrZXksIHNldCB0aGUgdmFsdWUuXG4gICAgaWYgKGkgPT09IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgY3VycmVudFtrZXldID0gdmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0IG9yIGlzIG5vdCBhbiBvYmplY3QgKGF2b2lkIG92ZXJ3cml0aW5nIGFycmF5cyksIGNyZWF0ZSBhIG5ldyBvYmplY3RcbiAgICAgIGlmIChcbiAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJyZW50LCBrZXkpIHx8XG4gICAgICAgIHR5cGVvZiBjdXJyZW50W2tleV0gIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgY3VycmVudFtrZXldID09PSBudWxsIHx8XG4gICAgICAgIEFycmF5LmlzQXJyYXkoY3VycmVudFtrZXldKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRba2V5XSA9IHt9XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudFtrZXldXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgQ2lyY3VpdFJ1bm5lciB9IGZyb20gXCIuL0NpcmN1aXRSdW5uZXJcIlxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuVHNjaXJjdWl0Q29kZShcbiAgZmlsZXN5c3RlbU9yQ29kZVN0cmluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZyxcbiAgb3B0cz86IE9taXQ8UGFyYW1ldGVyczxDaXJjdWl0UnVubmVyW1wiZXhlY3V0ZVdpdGhGc01hcFwiXT5bMF0sIFwiZnNNYXBcIj4sXG4pIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nID09PSBcInN0cmluZ1wiICYmXG4gICAgIWZpbGVzeXN0ZW1PckNvZGVTdHJpbmcuaW5jbHVkZXMoXCJleHBvcnRcIilcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBcImV4cG9ydFwiIGtleXdvcmQgd2Fzbid0IGZvdW5kIGluIHlvdXIgcHJvdmlkZWQgY29kZS4gWW91IG5lZWQgdG8gZXhwb3J0IGEgY29tcG9uZW50IGluIHlvdXIgY29kZSwgZS5nLlxcblxcbmV4cG9ydCBkZWZhdWx0ICgpID0+IChcXG4gIDxyZXNpc3RvciBuYW1lPVwiUjFcIiByZXNpc3RhbmNlPVwiMWtcIiAvPlxcbilgLFxuICAgIClcbiAgfVxuICBjb25zdCBmaWxlc3lzdGVtID1cbiAgICB0eXBlb2YgZmlsZXN5c3RlbU9yQ29kZVN0cmluZyA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyB7IFwidXNlci1jb2RlLnRzeFwiOiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nIH1cbiAgICAgIDogZmlsZXN5c3RlbU9yQ29kZVN0cmluZ1xuXG4gIGNvbnN0IGNpcmN1aXRSdW5uZXIgPSBuZXcgQ2lyY3VpdFJ1bm5lcigpXG5cbiAgYXdhaXQgY2lyY3VpdFJ1bm5lci5leGVjdXRlV2l0aEZzTWFwKHtcbiAgICBmc01hcDogZmlsZXN5c3RlbSxcbiAgICAuLi5vcHRzLFxuICB9KVxuXG4gIGF3YWl0IGNpcmN1aXRSdW5uZXIucmVuZGVyVW50aWxTZXR0bGVkKClcblxuICByZXR1cm4gYXdhaXQgY2lyY3VpdFJ1bm5lci5nZXRDaXJjdWl0SnNvbigpXG59XG4iLCAiaW1wb3J0IHsgcnVuVHNjaXJjdWl0Q29kZSB9IGZyb20gXCIuL3J1blRzY2lyY3VpdENvZGVcIlxuXG5leHBvcnQgY29uc3QgcnVuVHNjaXJjdWl0TW9kdWxlID0gYXN5bmMgKFxuICBtb2R1bGU6IHN0cmluZyxcbiAgb3B0czogeyBwcm9wcz86IFJlY29yZDxzdHJpbmcsIGFueT47IGV4cG9ydE5hbWU/OiBzdHJpbmcgfSA9IHt9LFxuKSA9PiB7XG4gIGlmICghbW9kdWxlLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgbW9kdWxlID0gYEB0c2NpLyR7bW9kdWxlLnJlcGxhY2UoL1xcLy8sIFwiLlwiKX1gXG4gIH1cbiAgY29uc3QgY2lyY3VpdEpzb24gPSBhd2FpdCBydW5Uc2NpcmN1aXRDb2RlKFxuICAgIHtcbiAgICAgIC8vIFRPRE8gaGFuZGxlIGV4cG9ydHMgdGhhdCBhcmUgbm90IHRoZSBkZWZhdWx0IGV4cG9ydCBieSBzY2FubmluZ1xuICAgICAgLy8gb3RoZXJFeHBvcnRzIGZvciBjb21wb25lbnRzXG4gICAgICBcInVzZXItY29kZS50c3hcIjogYFxuICAgIGltcG9ydCBNb2R1bGUsICogYXMgb3RoZXJFeHBvcnRzIGZyb20gXCIke21vZHVsZX1cIjtcblxuICAgIGxldCBleHBvcnROYW1lID0gXCIke29wdHMuZXhwb3J0TmFtZSA/PyBcIlwifVwiXG5cbiAgICBpZiAoKCFNb2R1bGUgfHwgdHlwZW9mIE1vZHVsZSAhPT0gXCJmdW5jdGlvblwiKSAmJiAhQm9vbGVhbihleHBvcnROYW1lKSkge1xuICAgICAgZXhwb3J0TmFtZSA9IE9iamVjdC5rZXlzKG90aGVyRXhwb3J0cykuZmlsdGVyKGtleSA9PiBrZXlbMF0gPT09IGtleVswXS50b1VwcGVyQ2FzZSgpICYmIHR5cGVvZiBvdGhlckV4cG9ydHNba2V5XSA9PT0gXCJmdW5jdGlvblwiKVswXVxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRFeHBvcnQgPSBleHBvcnROYW1lID8gb3RoZXJFeHBvcnRzW2V4cG9ydE5hbWVdIDogTW9kdWxlXG5cbiAgICBpZiAoIWRlZmF1bHRFeHBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXGBObyBleHBvcnQgZm91bmQgZm9yIG1vZHVsZSBcIlxcJHttb2R1bGV9XCIgKHRyaWVkIFwiXFwke2V4cG9ydE5hbWUgPz8gXCJkZWZhdWx0XCJ9XCIpXFxgKVxuICAgIH1cblxuICAgIGV4cG9ydCBkZWZhdWx0IGRlZmF1bHRFeHBvcnQ7XG4gICAgYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIG1haW5Db21wb25lbnRQcm9wczogb3B0cy5wcm9wcyxcbiAgICB9LFxuICApXG4gIHJldHVybiBjaXJjdWl0SnNvblxufVxuIiwgImltcG9ydCAqIGFzIENvbWxpbmsgZnJvbSBcImNvbWxpbmtcIlxuZXhwb3J0ICogZnJvbSBcIi4vdXRpbHMvaW5kZXhcIlxuaW1wb3J0IHR5cGUge1xuICBJbnRlcm5hbFdlYldvcmtlckFwaSxcbiAgV2ViV29ya2VyQ29uZmlndXJhdGlvbixcbiAgQ2lyY3VpdFdlYldvcmtlcixcbn0gZnJvbSBcIi4vc2hhcmVkL3R5cGVzXCJcbmltcG9ydCB0eXBlIHsgUm9vdENpcmN1aXRFdmVudE5hbWUgfSBmcm9tIFwiLi9zaGFyZWQvdHlwZXNcIlxuaW1wb3J0IHsgZ2V0T2JqZWN0UGF0aHMsIGdldFZhbHVlQXRQYXRoIH0gZnJvbSBcIi4vc2hhcmVkL29iai1wYXRoXCJcblxuZXhwb3J0IHR5cGUgeyBDaXJjdWl0V2ViV29ya2VyLCBXZWJXb3JrZXJDb25maWd1cmF0aW9uIH1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBUU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSOiBDaXJjdWl0V2ViV29ya2VyIHwgdW5kZWZpbmVkXG4gIH1cbiAgdmFyIFRTQ0lSQ1VJVF9HTE9CQUxfQ0lSQ1VJVF9XT1JLRVI6IENpcmN1aXRXZWJXb3JrZXIgfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNpcmN1aXRXZWJXb3JrZXIgPSBhc3luYyAoXG4gIGNvbmZpZ3VyYXRpb246IFBhcnRpYWw8V2ViV29ya2VyQ29uZmlndXJhdGlvbj4sXG4pOiBQcm9taXNlPENpcmN1aXRXZWJXb3JrZXI+ID0+IHtcbiAgLy8gS2lsbCBleGlzdGluZyBnbG9iYWwgd29ya2VyIGluc3RhbmNlIGlmIHByZXNlbnRcbiAgY29uc3QgZXhpc3RpbmdXb3JrZXIgPSBnbG9iYWxUaGlzLlRTQ0lSQ1VJVF9HTE9CQUxfQ0lSQ1VJVF9XT1JLRVJcbiAgaWYgKGV4aXN0aW5nV29ya2VyICYmIHR5cGVvZiBleGlzdGluZ1dvcmtlci5raWxsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltXb3JrZXJdIEtpbGxpbmcgcHJldmlvdXMgZ2xvYmFsIHdvcmtlciBpbnN0YW5jZS4uLlwiKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhpc3RpbmdXb3JrZXIua2lsbCgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24udmVyYm9zZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJbV29ya2VyXSBFcnJvciBraWxsaW5nIHByZXZpb3VzIGdsb2JhbCB3b3JrZXIgaW5zdGFuY2U6XCIsXG4gICAgICAgICAgZSxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIHRoZSBrZXkgaXMgY2xlYXJlZCBldmVuIGlmIGtpbGwgdGhyb3dzIGFuIGVycm9yXG4gICAgICBpZiAoZ2xvYmFsVGhpcy5UU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSID09PSBleGlzdGluZ1dvcmtlcikge1xuICAgICAgICBnbG9iYWxUaGlzLlRTQ0lSQ1VJVF9HTE9CQUxfQ0lSQ1VJVF9XT1JLRVIgPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIltXb3JrZXJdIENyZWF0aW5nIGNpcmN1aXQgd2ViIHdvcmtlciB3aXRoIGNvbmZpZzpcIixcbiAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgKVxuICB9XG5cbiAgbGV0IHdvcmtlckJsb2JVcmwgPVxuICAgIGNvbmZpZ3VyYXRpb24ud2ViV29ya2VyQmxvYlVybCA/PyBjb25maWd1cmF0aW9uLndlYldvcmtlclVybFxuXG4gIGlmICghd29ya2VyQmxvYlVybCkge1xuICAgIGNvbnN0IGNkblVybCA9IGBodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B0c2NpcmN1aXQvZXZhbEAke2NvbmZpZ3VyYXRpb24uZXZhbFZlcnNpb24gPz8gXCJsYXRlc3RcIn0vZGlzdC93ZWJ3b3JrZXIvZW50cnlwb2ludC5qc2BcblxuICAgIGNvbnN0IHdvcmtlckJsb2IgPSBhd2FpdCBnbG9iYWxUaGlzLmZldGNoKGNkblVybCkudGhlbigocmVzKSA9PiByZXMuYmxvYigpKVxuICAgIHdvcmtlckJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHdvcmtlckJsb2IpXG4gIH1cblxuICBjb25zdCByYXdXb3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlckJsb2JVcmwsIHsgdHlwZTogXCJtb2R1bGVcIiB9KVxuICBsZXQgd29ya2VySW5pdEVycm9yOiBhbnlcbiAgcmF3V29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKFwiW1dvcmtlcl0gRXJyb3IgaW4gd29ya2VyXCIsIGV2ZW50KVxuICAgIHdvcmtlckluaXRFcnJvciA9IGV2ZW50XG4gIH0pXG4gIHJhd1dvcmtlci5hZGRFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsIChldmVudCkgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbV29ya2VyXSBVbmhhbmRsZWQgcmVqZWN0aW9uIGluIHdvcmtlclwiLCBldmVudClcbiAgfSlcbiAgcmF3V29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlZXJyb3JcIiwgKGV2ZW50KSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihcIltXb3JrZXJdIE1lc3NhZ2UgZXJyb3IgaW4gd29ya2VyXCIsIGV2ZW50KVxuICB9KVxuICBjb25zdCBlYXJseU1lc3NhZ2VIYW5kbGVyID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIltXb3JrZXJdIE1lc3NhZ2UgaW4gd29ya2VyXCIsIGV2ZW50KVxuICB9XG4gIHJhd1dvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBlYXJseU1lc3NhZ2VIYW5kbGVyKVxuXG4gIC8vIEhhbmRsZSBmZXRjaCByZXF1ZXN0cyBmcm9tIHRoZSB3b3JrZXJcbiAgcmF3V29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGFzeW5jIChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGFcbiAgICBpZiAoZGF0YT8udHlwZSAhPT0gXCJ3b3JrZXJfZmV0Y2hcIikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnbG9iYWxUaGlzLmZldGNoKGRhdGEuaW5wdXQsIGRhdGEuaW5pdClcbiAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgIHJhd1dvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwid29ya2VyX2ZldGNoX3Jlc3VsdFwiLFxuICAgICAgICByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLFxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JqOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgIH0pKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICByYXdXb3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcIndvcmtlcl9mZXRjaF9yZXN1bHRcIixcbiAgICAgICAgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCxcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgbmFtZTogZXJyLm5hbWUsXG4gICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgc3RhY2s6IGVyci5zdGFjayxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIGlmICh3b3JrZXJJbml0RXJyb3IpIHtcbiAgICB0aHJvdyB3b3JrZXJJbml0RXJyb3JcbiAgfVxuXG4gIGNvbnN0IGNvbWxpbmtXb3JrZXIgPSBDb21saW5rLndyYXA8SW50ZXJuYWxXZWJXb3JrZXJBcGk+KHJhd1dvcmtlcilcblxuICByYXdXb3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZWFybHlNZXNzYWdlSGFuZGxlcilcblxuICAvLyBIZWxwZXIgdG8gc2VyaWFsaXplIFJlYWN0IGVsZW1lbnRzIGZvciBjcm9zcy13b3JrZXIgY29tbXVuaWNhdGlvblxuICBmdW5jdGlvbiBzZXJpYWxpemVSZWFjdEVsZW1lbnQoZWxlbWVudDogYW55KTogYW55IHtcbiAgICBpZiAoIWVsZW1lbnQgfHwgdHlwZW9mIGVsZW1lbnQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBlbGVtZW50XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBSZWFjdCBlbGVtZW50XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfX2lzU2VyaWFsaXplZFJlYWN0RWxlbWVudDogdHJ1ZSxcbiAgICAgICAgdHlwZTogZWxlbWVudC50eXBlLFxuICAgICAgICBwcm9wczogc2VyaWFsaXplUHJvcHMoZWxlbWVudC5wcm9wcyksXG4gICAgICAgIGtleTogZWxlbWVudC5rZXksXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVByb3BzKHByb3BzOiBhbnkpOiBhbnkge1xuICAgIGlmICghcHJvcHMgfHwgdHlwZW9mIHByb3BzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gcHJvcHNcbiAgICB9XG5cbiAgICBjb25zdCBzZXJpYWxpemVkOiBhbnkgPSB7fVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuICAgICAgaWYgKGtleSA9PT0gXCJjaGlsZHJlblwiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWQuY2hpbGRyZW4gPSB2YWx1ZS5tYXAoc2VyaWFsaXplUmVhY3RFbGVtZW50KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlcmlhbGl6ZWQuY2hpbGRyZW4gPSBzZXJpYWxpemVSZWFjdEVsZW1lbnQodmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkXG4gIH1cblxuICAvLyBDb25kaXRpb25hbGx5IG92ZXJyaWRlIGdsb2JhbCBmZXRjaCBpbnNpZGUgdGhlIHdvcmtlciB0byByb3V0ZSB0aHJvdWdoIHRoZSBwYXJlbnRcbiAgLy8gT25seSBlbmFibGUgd2hlbiBleHBsaWNpdGx5IHJlcXVlc3RlZCB2aWEgY29uZmlndXJhdGlvblxuICBpZiAoY29uZmlndXJhdGlvbi5lbmFibGVGZXRjaFByb3h5KSB7XG4gICAgcmF3V29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJvdmVycmlkZV9nbG9iYWxfZmV0Y2hcIiB9KVxuICB9XG5cbiAgaWYgKGNvbmZpZ3VyYXRpb24uc25pcHBldHNBcGlCYXNlVXJsKSB7XG4gICAgYXdhaXQgY29tbGlua1dvcmtlci5zZXRTbmlwcGV0c0FwaUJhc2VVcmwoY29uZmlndXJhdGlvbi5zbmlwcGV0c0FwaUJhc2VVcmwpXG4gIH1cblxuICBjb25zdCBtYXliZVByb3h5ID0gKHZhbHVlOiBhbnkpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBDb21saW5rLnByb3h5KHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBpZiAoY29uZmlndXJhdGlvbi5wbGF0Zm9ybSkge1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBnZXRPYmplY3RQYXRocyhjb25maWd1cmF0aW9uLnBsYXRmb3JtKSkge1xuICAgICAgYXdhaXQgY29tbGlua1dvcmtlclxuICAgICAgICAuc2V0UGxhdGZvcm1Db25maWdQcm9wZXJ0eShcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG1heWJlUHJveHkoZ2V0VmFsdWVBdFBhdGgoY29uZmlndXJhdGlvbi5wbGF0Zm9ybSwgcGF0aCkpLFxuICAgICAgICApXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBFcnJvciBzZXR0aW5nIHBsYXRmb3JtIGNvbmZpZyBwcm9wZXJ0eSAke3BhdGh9OiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKX1gLFxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cbiAgaWYgKGNvbmZpZ3VyYXRpb24ucHJvamVjdENvbmZpZykge1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBnZXRPYmplY3RQYXRocyhjb25maWd1cmF0aW9uLnByb2plY3RDb25maWcpKSB7XG4gICAgICBhd2FpdCBjb21saW5rV29ya2VyXG4gICAgICAgIC5zZXRQcm9qZWN0Q29uZmlnUHJvcGVydHkoXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBtYXliZVByb3h5KGdldFZhbHVlQXRQYXRoKGNvbmZpZ3VyYXRpb24ucHJvamVjdENvbmZpZywgcGF0aCkpLFxuICAgICAgICApXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBFcnJvciBzZXR0aW5nIHByb2plY3QgY29uZmlnIHByb3BlcnR5ICR7cGF0aH06ICR7ZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpfWAsXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGxldCBpc1Rlcm1pbmF0ZWQgPSBmYWxzZVxuXG4gIC8vIENyZWF0ZSBhIHdyYXBwZXIgdGhhdCBoYW5kbGVzIGV2ZW50cyBkaXJlY3RseSB0aHJvdWdoIGNpcmN1aXQgaW5zdGFuY2VcbiAgY29uc3Qgd3JhcHBlcjogQ2lyY3VpdFdlYldvcmtlciA9IHtcbiAgICBjbGVhckV2ZW50TGlzdGVuZXJzOiBjb21saW5rV29ya2VyLmNsZWFyRXZlbnRMaXN0ZW5lcnMuYmluZChjb21saW5rV29ya2VyKSxcbiAgICBlbmFibGVEZWJ1ZzogYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmIChpc1Rlcm1pbmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VpdFdlYldvcmtlciB3YXMgdGVybWluYXRlZCwgY2FuJ3QgZW5hYmxlRGVidWdcIilcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21saW5rV29ya2VyLmVuYWJsZURlYnVnLmJpbmQoY29tbGlua1dvcmtlcikoLi4uYXJncylcbiAgICB9LFxuICAgIHZlcnNpb246IGNvbWxpbmtXb3JrZXIudmVyc2lvbi5iaW5kKGNvbWxpbmtXb3JrZXIpLFxuICAgIGV4ZWN1dGU6IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAoaXNUZXJtaW5hdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNpcmN1aXRXZWJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQsIGNhbid0IGV4ZWN1dGVcIilcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21saW5rV29ya2VyLmV4ZWN1dGUuYmluZChjb21saW5rV29ya2VyKSguLi5hcmdzKVxuICAgIH0sXG4gICAgZXhlY3V0ZUNvbXBvbmVudDogYXN5bmMgKGNvbXBvbmVudDogYW55KSA9PiB7XG4gICAgICBpZiAoaXNUZXJtaW5hdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNpcmN1aXRXZWJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQsIGNhbid0IGV4ZWN1dGVDb21wb25lbnRcIixcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCdzIGEgZnVuY3Rpb24sIHBhc3MgaXQgYXMtaXMgKHdpbGwgYmUgcHJveGllZCBieSBDb21saW5rKVxuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gY29tbGlua1dvcmtlci5leGVjdXRlQ29tcG9uZW50LmJpbmQoY29tbGlua1dvcmtlcikoY29tcG9uZW50KVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCdzIGEgUmVhY3QgZWxlbWVudCwgc2VyaWFsaXplIGl0IHRvIGEgcmVjb25zdHJ1Y3RhYmxlIGZvcm1hdFxuICAgICAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSBcIm9iamVjdFwiICYmIGNvbXBvbmVudC50eXBlKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRFbGVtZW50ID0gc2VyaWFsaXplUmVhY3RFbGVtZW50KGNvbXBvbmVudClcbiAgICAgICAgcmV0dXJuIGNvbWxpbmtXb3JrZXIuZXhlY3V0ZUNvbXBvbmVudC5iaW5kKGNvbWxpbmtXb3JrZXIpKFxuICAgICAgICAgIHNlcmlhbGl6ZWRFbGVtZW50LFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21saW5rV29ya2VyLmV4ZWN1dGVDb21wb25lbnQuYmluZChjb21saW5rV29ya2VyKShjb21wb25lbnQpXG4gICAgfSxcbiAgICBleGVjdXRlV2l0aEZzTWFwOiBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKGlzVGVybWluYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDaXJjdWl0V2ViV29ya2VyIHdhcyB0ZXJtaW5hdGVkLCBjYW4ndCBleGVjdXRlV2l0aEZzTWFwXCIsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21saW5rV29ya2VyLmV4ZWN1dGVXaXRoRnNNYXAuYmluZChjb21saW5rV29ya2VyKSguLi5hcmdzKVxuICAgIH0sXG4gICAgcmVuZGVyVW50aWxTZXR0bGVkOiBjb21saW5rV29ya2VyLnJlbmRlclVudGlsU2V0dGxlZC5iaW5kKGNvbWxpbmtXb3JrZXIpLFxuICAgIGdldENpcmN1aXRKc29uOiBjb21saW5rV29ya2VyLmdldENpcmN1aXRKc29uLmJpbmQoY29tbGlua1dvcmtlciksXG4gICAgb246IChldmVudDogc3RyaW5nLCBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKSA9PiB7XG4gICAgICBjb25zdCBwcm94aWVkQ2FsbGJhY2sgPSBDb21saW5rLnByb3h5KGNhbGxiYWNrKVxuICAgICAgY29tbGlua1dvcmtlci5vbihldmVudCBhcyBSb290Q2lyY3VpdEV2ZW50TmFtZSwgcHJveGllZENhbGxiYWNrKVxuICAgIH0sXG4gICAga2lsbDogYXN5bmMgKCkgPT4ge1xuICAgICAgY29tbGlua1dvcmtlcltDb21saW5rLnJlbGVhc2VQcm94eV0oKVxuICAgICAgcmF3V29ya2VyLnRlcm1pbmF0ZSgpXG4gICAgICBpc1Rlcm1pbmF0ZWQgPSB0cnVlXG4gICAgICBpZiAoZ2xvYmFsVGhpcy5UU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSID09PSB3cmFwcGVyKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuVFNDSVJDVUlUX0dMT0JBTF9DSVJDVUlUX1dPUktFUiA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0sXG4gIH1cbiAgOyh3cmFwcGVyIGFzIGFueSkuX19yYXdXb3JrZXIgPSByYXdXb3JrZXJcbiAgZ2xvYmFsVGhpcy5UU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSID0gd3JhcHBlclxuICByZXR1cm4gd3JhcHBlclxufVxuIiwgImltcG9ydCB7IG5vcm1hbGl6ZUZpbGVQYXRoIH0gZnJvbSBcIi4vcnVubmVyL25vcm1hbGl6ZUZzTWFwXCJcblxuZXhwb3J0IGNvbnN0IGdldFBvc3NpYmxlRW50cnlwb2ludENvbXBvbmVudFBhdGhzID0gKFxuICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbik6IHN0cmluZ1tdID0+IHtcbiAgY29uc3Qgbm9ybWFsaXplZEZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgZm9yIChjb25zdCBbcGF0aCwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoZnNNYXApKSB7XG4gICAgbm9ybWFsaXplZEZzTWFwW25vcm1hbGl6ZUZpbGVQYXRoKHBhdGgpXSA9IGNvbnRlbnRcbiAgfVxuXG4gIGNvbnN0IHBvc3NpYmxlID0gbmV3IFNldDxzdHJpbmc+KClcblxuICBpZiAoXCJ0c2NpcmN1aXQuY29uZmlnLmpzb25cIiBpbiBub3JtYWxpemVkRnNNYXApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29uZmlnID0gSlNPTi5wYXJzZShub3JtYWxpemVkRnNNYXBbXCJ0c2NpcmN1aXQuY29uZmlnLmpzb25cIl0pXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5tYWluRW50cnlwb2ludCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwb3NzaWJsZS5hZGQobm9ybWFsaXplRmlsZVBhdGgoY29uZmlnLm1haW5FbnRyeXBvaW50KSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8qIGlnbm9yZSAqL1xuICAgIH1cbiAgfVxuXG4gIGlmIChub3JtYWxpemVkRnNNYXBbXCJpbmRleC50c3hcIl0pIHBvc3NpYmxlLmFkZChcImluZGV4LnRzeFwiKVxuICBpZiAobm9ybWFsaXplZEZzTWFwW1wiaW5kZXgudHNcIl0pIHBvc3NpYmxlLmFkZChcImluZGV4LnRzXCIpXG5cbiAgY29uc3QgY2lyY3VpdEZpbGVzID0gT2JqZWN0LmtleXMobm9ybWFsaXplZEZzTWFwKS5maWx0ZXIoKGspID0+XG4gICAgay5lbmRzV2l0aChcIi5jaXJjdWl0LnRzeFwiKSxcbiAgKVxuICBmb3IgKGNvbnN0IGZpbGUgb2YgY2lyY3VpdEZpbGVzKSB7XG4gICAgcG9zc2libGUuYWRkKGZpbGUpXG4gIH1cblxuICBjb25zdCB0c3hGaWxlcyA9IE9iamVjdC5rZXlzKG5vcm1hbGl6ZWRGc01hcCkuZmlsdGVyKChrKSA9PlxuICAgIGsuZW5kc1dpdGgoXCIudHN4XCIpLFxuICApXG4gIGlmICh0c3hGaWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICBwb3NzaWJsZS5hZGQodHN4RmlsZXNbMF0pXG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShwb3NzaWJsZSlcbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7QUFBQSxTQUFTLG1CQUFtQjtBQUU1QixZQUFZLG1CQUFtQjtBQUMvQixZQUFZLFdBQVc7QUFDdkIsWUFBWSx3QkFBd0I7OztBQ0M3QixJQUFNLGdDQUFnQyxDQUMzQyxtQkFDdUI7QUFFdkIsTUFBSSxRQUFRLGVBQWUsTUFBTSxnQkFBZ0I7QUFDakQsTUFBSSxNQUFPLFFBQU8sTUFBTSxDQUFDO0FBSXpCLFVBQVEsZUFBZTtBQUFBLElBQ3JCO0FBQUEsRUFDRjtBQUNB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QVk7QUFFakMsTUFBSSwyQkFBMkIsaUJBQWlCO0FBQzlDLFFBQUk7QUFDRixZQUFNLFNBQVMsS0FBSyxNQUFNLGdCQUFnQix1QkFBdUIsQ0FBQztBQUNsRSxVQUFJLE9BQU8sT0FBTyxtQkFBbUIsVUFBVTtBQUM3QyxpQkFBUyxJQUFJLGtCQUFrQixPQUFPLGNBQWMsQ0FBQztBQUFBLE1BQ3ZEO0FBQUEsSUFDRixRQUFRO0FBQUEsSUFFUjtBQUFBLEVBQ0Y7QUFFQSxNQUFJLGdCQUFnQixXQUFXLEVBQUcsVUFBUyxJQUFJLFdBQVc7QUFDMUQsTUFBSSxnQkFBZ0IsVUFBVSxFQUFHLFVBQVMsSUFBSSxVQUFVO0FBRXhELFFBQU0sZUFBZSxPQUFPLEtBQUssZUFBZSxFQUFFO0FBQUEsSUFBTyxDQUFDLE1BQ3hELEVBQUUsU0FBUyxjQUFjO0FBQUEsRUFDM0I7QUFDQSxhQUFXLFFBQVEsY0FBYztBQUMvQixhQUFTLElBQUksSUFBSTtBQUFBLEVBQ25CO0FBRUEsUUFBTSxXQUFXLE9BQU8sS0FBSyxlQUFlLEVBQUU7QUFBQSxJQUFPLENBQUMsTUFDcEQsRUFBRSxTQUFTLE1BQU07QUFBQSxFQUNuQjtBQUNBLE1BQUksU0FBUyxXQUFXLEdBQUc7QUFDekIsYUFBUyxJQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsRUFDMUI7QUFFQSxTQUFPLE1BQU0sS0FBSyxRQUFRO0FBQzVCOyIsCiAgIm5hbWVzIjogWyJEZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJpbXBvcnROYW1lIiwgIkRlYnVnIiwgImRlYnVnIiwgInVucHJlZml4ZWRQYXRoIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIl0KfQo=