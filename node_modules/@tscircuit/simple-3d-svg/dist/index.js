// lib/vec3.ts
function add(a, b) {
  return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
}
function sub(a, b) {
  return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
}
function dot(a, b) {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
function cross(a, b) {
  return {
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x
  };
}
function scale(v, k) {
  return { x: v.x * k, y: v.y * k, z: v.z * k };
}
function len(v) {
  return Math.sqrt(dot(v, v));
}
function norm(v) {
  const l = len(v) || 1;
  return scale(v, 1 / l);
}
function rotLocal(p, r = { x: 0, y: 0, z: 0 }) {
  let { x, y, z } = p;
  if (r.x) {
    const c = Math.cos(r.x);
    const s = Math.sin(r.x);
    const y2 = y * c - z * s;
    z = y * s + z * c;
    y = y2;
  }
  if (r.y) {
    const c = Math.cos(r.y);
    const s = Math.sin(r.y);
    const x2 = x * c + z * s;
    z = -x * s + z * c;
    x = x2;
  }
  if (r.z) {
    const c = Math.cos(r.z);
    const s = Math.sin(r.z);
    const x2 = x * c - y * s;
    y = x * s + y * c;
    x = x2;
  }
  return { x, y, z };
}

// lib/color.ts
var NAMED_COLORS = {
  black: [0, 0, 0],
  silver: [192, 192, 192],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  white: [255, 255, 255],
  maroon: [128, 0, 0],
  red: [255, 0, 0],
  purple: [128, 0, 128],
  fuchsia: [255, 0, 255],
  green: [0, 128, 0],
  lime: [0, 255, 0],
  olive: [128, 128, 0],
  yellow: [255, 255, 0],
  navy: [0, 0, 128],
  blue: [0, 0, 255],
  teal: [0, 128, 128],
  aqua: [0, 255, 255],
  orange: [255, 165, 0]
};
function colorToCss(c) {
  if (typeof c === "string") return c;
  const [r, g, b, a] = c;
  return `rgba(${Math.round(r)},${Math.round(g)},${Math.round(b)},${a})`;
}
function colorToRGBA(c) {
  if (Array.isArray(c)) return c;
  const s = c.trim().toLowerCase();
  if (s.startsWith("#")) {
    const hex = s.slice(1);
    if (hex.length === 3) {
      const r = parseInt(hex.charAt(0) + hex.charAt(0), 16);
      const g = parseInt(hex.charAt(1) + hex.charAt(1), 16);
      const b = parseInt(hex.charAt(2) + hex.charAt(2), 16);
      return [r, g, b, 1];
    }
    if (hex.length === 6) {
      const r = parseInt(hex.slice(0, 2), 16);
      const g = parseInt(hex.slice(2, 4), 16);
      const b = parseInt(hex.slice(4, 6), 16);
      return [r, g, b, 1];
    }
  }
  const rgbm = s.match(/^rgba?\(([^)]+)\)$/);
  if (rgbm) {
    const content = rgbm[1];
    const parts = content.split(/\s*,\s*/).map(Number);
    const [r = 0, g = 0, b = 0, a = 1] = parts;
    return [r, g, b, a];
  }
  const named = NAMED_COLORS[s];
  if (named) return [named[0], named[1], named[2], 1];
  return [0, 0, 0, 1];
}
function lightenColor(c, f) {
  const [r, g, b, a] = colorToRGBA(c);
  return [r + (255 - r) * f, g + (255 - g) * f, b + (255 - b) * f, a];
}
function darkenColor(c, f) {
  const [r, g, b, a] = colorToRGBA(c);
  return [r * (1 - f), g * (1 - f), b * (1 - f), a];
}
function shadeByNormal(base, normal) {
  const n = norm(normal);
  if (n.z >= 0) {
    return colorToCss(lightenColor(base, n.z * 0.4));
  } else {
    return colorToCss(darkenColor(base, -n.z * 0.4));
  }
}

// lib/loaders/stl.ts
var stlCache = /* @__PURE__ */ new Map();
async function loadSTL(url) {
  if (stlCache.has(url)) {
    return stlCache.get(url);
  }
  const response = await fetch(url);
  const buffer = await response.arrayBuffer();
  const mesh = parseSTL(buffer);
  stlCache.set(url, mesh);
  return mesh;
}
function parseSTL(buffer) {
  const view = new DataView(buffer);
  const header = new TextDecoder().decode(buffer.slice(0, 5));
  if (header.toLowerCase() === "solid") {
    return parseASCIISTL(buffer);
  } else {
    return parseBinarySTL(view);
  }
}
function parseASCIISTL(buffer) {
  const text = new TextDecoder().decode(buffer);
  const lines = text.split("\n").map((line) => line.trim());
  const triangles = [];
  let i = 0;
  while (i < lines.length) {
    const line = lines[i];
    if (line && line.startsWith("facet normal")) {
      const normalMatch = line.match(
        /facet normal\s+([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)\s+([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)\s+([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/
      );
      const normal = normalMatch ? {
        x: parseFloat(normalMatch[1]),
        y: parseFloat(normalMatch[2]),
        z: parseFloat(normalMatch[3])
      } : { x: 0, y: 0, z: 1 };
      i++;
      const vertices = [];
      while (i < lines.length && lines[i] && !lines[i].startsWith("endfacet")) {
        const vertexLine = lines[i];
        if (vertexLine.startsWith("vertex")) {
          const vertexMatch = vertexLine.match(
            /vertex\s+([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)\s+([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)\s+([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/
          );
          if (vertexMatch) {
            vertices.push({
              x: parseFloat(vertexMatch[1]),
              y: parseFloat(vertexMatch[2]),
              z: parseFloat(vertexMatch[3])
            });
          }
        }
        i++;
      }
      if (vertices.length === 3) {
        triangles.push({
          vertices: [vertices[0], vertices[1], vertices[2]],
          normal
        });
      }
    }
    i++;
  }
  const rotatedTriangles = triangles.map((triangle) => ({
    ...triangle,
    vertices: triangle.vertices.map((v) => ({
      x: v.x,
      y: -v.z,
      z: v.y
    })),
    normal: {
      x: triangle.normal.x,
      y: -triangle.normal.z,
      z: triangle.normal.y
    }
  }));
  return {
    triangles: rotatedTriangles,
    boundingBox: calculateBoundingBox(rotatedTriangles)
  };
}
function parseBinarySTL(view) {
  let offset = 80;
  const numTriangles = view.getUint32(offset, true);
  offset += 4;
  const triangles = [];
  for (let i = 0; i < numTriangles; i++) {
    const normal = {
      x: view.getFloat32(offset, true),
      y: view.getFloat32(offset + 4, true),
      z: view.getFloat32(offset + 8, true)
    };
    offset += 12;
    const vertices = [
      {
        x: view.getFloat32(offset, true),
        y: view.getFloat32(offset + 4, true),
        z: view.getFloat32(offset + 8, true)
      },
      {
        x: view.getFloat32(offset + 12, true),
        y: view.getFloat32(offset + 16, true),
        z: view.getFloat32(offset + 20, true)
      },
      {
        x: view.getFloat32(offset + 24, true),
        y: view.getFloat32(offset + 28, true),
        z: view.getFloat32(offset + 32, true)
      }
    ];
    offset += 36;
    offset += 2;
    triangles.push({ vertices, normal });
  }
  const rotatedTriangles = triangles.map((triangle) => ({
    ...triangle,
    vertices: triangle.vertices.map((v) => ({
      x: v.x,
      y: -v.z,
      z: v.y
    })),
    normal: {
      x: triangle.normal.x,
      y: -triangle.normal.z,
      z: triangle.normal.y
    }
  }));
  return {
    triangles: rotatedTriangles,
    boundingBox: calculateBoundingBox(rotatedTriangles)
  };
}
function calculateBoundingBox(triangles) {
  if (triangles.length === 0) {
    return {
      min: { x: 0, y: 0, z: 0 },
      max: { x: 0, y: 0, z: 0 }
    };
  }
  let minX = Infinity, minY = Infinity, minZ = Infinity;
  let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
  for (const triangle of triangles) {
    for (const vertex of triangle.vertices) {
      minX = Math.min(minX, vertex.x);
      minY = Math.min(minY, vertex.y);
      minZ = Math.min(minZ, vertex.z);
      maxX = Math.max(maxX, vertex.x);
      maxY = Math.max(maxY, vertex.y);
      maxZ = Math.max(maxZ, vertex.z);
    }
  }
  return {
    min: { x: minX, y: minY, z: minZ },
    max: { x: maxX, y: maxY, z: maxZ }
  };
}

// lib/loaders/obj.ts
var objCache = /* @__PURE__ */ new Map();
async function loadOBJ(url) {
  if (objCache.has(url)) {
    return objCache.get(url);
  }
  const response = await fetch(url);
  const text = await response.text();
  const mesh = parseOBJ(text);
  objCache.set(url, mesh);
  return mesh;
}
function parseOBJ(text) {
  const lines = text.split(/\r?\n/);
  const vertices = [];
  const vertexColors = [];
  const normals = [];
  const triangles = [];
  const materialColors = {};
  let activeMaterial;
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith("v ")) {
      const parts = trimmed.split(/\s+/);
      const x = parts[1];
      const y = parts[2];
      const z = parts[3];
      vertices.push({ x: parseFloat(x), y: parseFloat(y), z: -parseFloat(z) });
      if (parts.length >= 7) {
        const [rStr, gStr, bStr] = parts.slice(4, 7);
        let r = Number(rStr);
        let g = Number(gStr);
        let b = Number(bStr);
        if (r <= 1 && g <= 1 && b <= 1) {
          r *= 255;
          g *= 255;
          b *= 255;
        }
        vertexColors.push([r, g, b, 1]);
      } else {
        vertexColors.push(void 0);
      }
    } else if (trimmed.startsWith("vn ")) {
      const parts = trimmed.split(/\s+/);
      const x = parts[1];
      const y = parts[2];
      const z = parts[3];
      normals.push({ x: parseFloat(x), y: parseFloat(y), z: -parseFloat(z) });
    } else if (trimmed.startsWith("newmtl ")) {
      activeMaterial = trimmed.split(/\s+/)[1];
    } else if (trimmed.startsWith("Kd ") && activeMaterial) {
      const parts = trimmed.split(/\s+/);
      const rStr = parts[1];
      const gStr = parts[2];
      const bStr = parts[3];
      let r = parseFloat(rStr);
      let g = parseFloat(gStr);
      let b = parseFloat(bStr);
      if (r <= 1 && g <= 1 && b <= 1) {
        r *= 255;
        g *= 255;
        b *= 255;
      }
      materialColors[activeMaterial] = [r, g, b, 1];
    } else if (trimmed.startsWith("usemtl ")) {
      activeMaterial = trimmed.split(/\s+/)[1];
    } else if (trimmed.startsWith("f ")) {
      const parts = trimmed.slice(2).trim().split(/\s+/);
      const idxs = parts.map((p) => {
        const [vi, , ni] = p.split("/");
        return {
          v: parseInt(vi) - 1,
          n: ni ? parseInt(ni) - 1 : void 0
        };
      });
      for (let i = 1; i < idxs.length - 1; i++) {
        const a = idxs[0];
        const b = idxs[i];
        const c = idxs[i + 1];
        const v0 = vertices[a.v];
        const v1 = vertices[b.v];
        const v2 = vertices[c.v];
        let normal;
        if (a.n !== void 0 && normals[a.n]) {
          normal = normals[a.n];
        } else if (b.n !== void 0 && normals[b.n]) {
          normal = normals[b.n];
        } else if (c.n !== void 0 && normals[c.n]) {
          normal = normals[c.n];
        } else {
          const edge1 = {
            x: v1.x - v0.x,
            y: v1.y - v0.y,
            z: v1.z - v0.z
          };
          const edge2 = {
            x: v2.x - v0.x,
            y: v2.y - v0.y,
            z: v2.z - v0.z
          };
          normal = {
            x: edge1.y * edge2.z - edge1.z * edge2.y,
            y: edge1.z * edge2.x - edge1.x * edge2.z,
            z: -(edge1.x * edge2.y - edge1.y * edge2.x)
          };
        }
        let color;
        if (activeMaterial && materialColors[activeMaterial]) {
          color = materialColors[activeMaterial];
        } else {
          color = vertexColors[a.v] ?? vertexColors[b.v] ?? vertexColors[c.v];
        }
        triangles.push({ vertices: [v0, v1, v2], normal, color });
      }
    }
  }
  return {
    triangles,
    boundingBox: calculateBoundingBox2(triangles)
  };
}
function calculateBoundingBox2(triangles) {
  if (triangles.length === 0) {
    return { min: { x: 0, y: 0, z: 0 }, max: { x: 0, y: 0, z: 0 } };
  }
  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  for (const tri of triangles) {
    for (const v of tri.vertices) {
      if (v.x < minX) minX = v.x;
      if (v.y < minY) minY = v.y;
      if (v.z < minZ) minZ = v.z;
      if (v.x > maxX) maxX = v.x;
      if (v.y > maxY) maxY = v.y;
      if (v.z > maxZ) maxZ = v.z;
    }
  }
  return {
    min: { x: minX, y: minY, z: minZ },
    max: { x: maxX, y: maxY, z: maxZ }
  };
}

// lib/loaders/threemf.ts
import { unzipSync } from "fflate";
import { XMLParser } from "fast-xml-parser";
var threeMfCache = /* @__PURE__ */ new Map();
async function load3MF(url) {
  if (threeMfCache.has(url)) {
    return threeMfCache.get(url);
  }
  const response = await fetch(url);
  const buffer = await response.arrayBuffer();
  const files = unzipSync(new Uint8Array(buffer));
  const modelFile = files["3D/3dmodel.model"];
  if (!modelFile) throw new Error("3MF model file not found");
  const modelXml = new TextDecoder().decode(modelFile);
  const mesh = parse3MF(modelXml);
  threeMfCache.set(url, mesh);
  return mesh;
}
function parse3MF(xml) {
  const parser = new XMLParser({ ignoreAttributes: false });
  const json = parser.parse(xml);
  const vertexData = json?.model?.resources?.object?.mesh?.vertices?.vertex ?? [];
  const verticesArr = Array.isArray(vertexData) ? vertexData : [vertexData];
  const vertices = verticesArr.map((v) => ({
    x: parseFloat(v["@_x"]),
    y: parseFloat(v["@_y"]),
    z: parseFloat(v["@_z"])
  }));
  const baseMaterials = json?.model?.resources?.basematerials;
  const materialColors = {};
  if (baseMaterials) {
    const mats = Array.isArray(baseMaterials) ? baseMaterials : [baseMaterials];
    for (const mat of mats) {
      const id = mat["@_id"];
      const bases = mat.base ?? [];
      const basesArr = Array.isArray(bases) ? bases : [bases];
      materialColors[id] = basesArr.map(
        (b) => parseDisplayColor(b["@_displaycolor"])
      );
    }
  }
  const triangleData = json?.model?.resources?.object?.mesh?.triangles?.triangle ?? [];
  const trianglesArr = Array.isArray(triangleData) ? triangleData : [triangleData];
  const triangles = trianglesArr.map((t) => {
    const v1 = vertices[parseInt(t["@_v1"])];
    const v2 = vertices[parseInt(t["@_v2"])];
    const v3 = vertices[parseInt(t["@_v3"])];
    const edge1 = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
    const edge2 = { x: v3.x - v1.x, y: v3.y - v1.y, z: v3.z - v1.z };
    const normal = {
      x: edge1.y * edge2.z - edge1.z * edge2.y,
      y: edge1.z * edge2.x - edge1.x * edge2.z,
      z: -(edge1.x * edge2.y - edge1.y * edge2.x)
    };
    let color;
    const pid = t["@_pid"];
    if (pid && materialColors[pid]) {
      const idx = parseInt(t["@_p1"] ?? t["@_p2"] ?? t["@_p3"] ?? "0");
      color = materialColors[pid][idx];
    }
    return color ? { vertices: [v1, v2, v3], normal, color } : { vertices: [v1, v2, v3], normal };
  });
  const rotatedTriangles = triangles.map((tri) => ({
    ...tri,
    vertices: tri.vertices.map((v) => ({
      x: v.x,
      y: -v.z,
      z: v.y
    })),
    normal: {
      x: tri.normal.x,
      y: -tri.normal.z,
      z: tri.normal.y
    }
  }));
  return {
    triangles: rotatedTriangles,
    boundingBox: calculateBoundingBox3(rotatedTriangles)
  };
}
function parseDisplayColor(str) {
  if (str?.startsWith("#")) {
    const hex = str.slice(1);
    if (hex.length === 8) {
      const r = parseInt(hex.slice(0, 2), 16);
      const g = parseInt(hex.slice(2, 4), 16);
      const b = parseInt(hex.slice(4, 6), 16);
      const a = parseInt(hex.slice(6, 8), 16) / 255;
      return [r, g, b, a];
    }
    if (hex.length === 6) {
      const r = parseInt(hex.slice(0, 2), 16);
      const g = parseInt(hex.slice(2, 4), 16);
      const b = parseInt(hex.slice(4, 6), 16);
      return [r, g, b, 1];
    }
  }
  return [0, 0, 0, 1];
}
function calculateBoundingBox3(triangles) {
  if (triangles.length === 0) {
    return { min: { x: 0, y: 0, z: 0 }, max: { x: 0, y: 0, z: 0 } };
  }
  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  for (const tri of triangles) {
    for (const v of tri.vertices) {
      if (v.x < minX) minX = v.x;
      if (v.y < minY) minY = v.y;
      if (v.z < minZ) minZ = v.z;
      if (v.x > maxX) maxX = v.x;
      if (v.y > maxY) maxY = v.y;
      if (v.z > maxZ) maxZ = v.z;
    }
  }
  return {
    min: { x: minX, y: minY, z: minZ },
    max: { x: maxX, y: maxY, z: maxZ }
  };
}

// lib/mesh.ts
function scaleAndPositionMesh(mesh, box, scaleToBox, modelType) {
  const { boundingBox } = mesh;
  const meshCenter = scale(add(boundingBox.min, boundingBox.max), 0.5);
  const centerModel = box.centerModel !== false;
  const rotatedVerts = [];
  for (const tri of mesh.triangles) {
    for (const v of tri.vertices) {
      let p = sub(v, meshCenter);
      if (modelType === "stl" && box.stlRotation)
        p = rotLocal(p, box.stlRotation);
      if (modelType === "obj" && box.objRotation)
        p = rotLocal(p, box.objRotation);
      if (modelType === "3mf" && box.threeMfRotation)
        p = rotLocal(p, box.threeMfRotation);
      if (!centerModel) p = add(p, meshCenter);
      rotatedVerts.push(p);
    }
  }
  let uniformScale = 1;
  let rotatedCenter = { x: 0, y: 0, z: 0 };
  if (scaleToBox) {
    let min = { x: Infinity, y: Infinity, z: Infinity };
    let max = { x: -Infinity, y: -Infinity, z: -Infinity };
    for (const v of rotatedVerts) {
      if (v.x < min.x) min.x = v.x;
      if (v.y < min.y) min.y = v.y;
      if (v.z < min.z) min.z = v.z;
      if (v.x > max.x) max.x = v.x;
      if (v.y > max.y) max.y = v.y;
      if (v.z > max.z) max.z = v.z;
    }
    const rotatedSize = sub(max, min);
    const boxSize = box.size;
    const scaleX = boxSize.x / rotatedSize.x;
    const scaleY = boxSize.y / rotatedSize.y;
    const scaleZ = boxSize.z / rotatedSize.z;
    uniformScale = Math.min(scaleX, scaleY, scaleZ);
    rotatedCenter = scale(add(min, max), 0.5);
  }
  const transformedVertices = [];
  for (const p of rotatedVerts) {
    let t = p;
    if (scaleToBox) {
      t = sub(t, rotatedCenter);
      t = scale(t, uniformScale);
      if (!centerModel) t = add(t, rotatedCenter);
    }
    if (box.stlPosition) t = add(t, box.stlPosition);
    if (box.objPosition) t = add(t, box.objPosition);
    if (box.threeMfPosition) t = add(t, box.threeMfPosition);
    if (box.rotation) t = rotLocal(t, box.rotation);
    t = add(t, box.center);
    transformedVertices.push(t);
  }
  return transformedVertices;
}

// lib/geometry.ts
var FACES = [
  [0, 1, 2, 3],
  [4, 7, 6, 5],
  [0, 1, 5, 4],
  [3, 2, 6, 7],
  [1, 2, 6, 5],
  [0, 3, 7, 4]
];
var EDGES = [
  [0, 1],
  [1, 2],
  [2, 3],
  [3, 0],
  [4, 5],
  [5, 6],
  [6, 7],
  [7, 4],
  [0, 4],
  [1, 5],
  [2, 6],
  [3, 7]
];
var TOP = [3, 2, 6, 7];
function verts(b) {
  const {
    size: { x: sx, y: sy, z: sz },
    center,
    rotation
  } = b;
  const offs = [
    { x: -sx / 2, y: -sy / 2, z: -sz / 2 },
    { x: sx / 2, y: -sy / 2, z: -sz / 2 },
    { x: sx / 2, y: sy / 2, z: -sz / 2 },
    { x: -sx / 2, y: sy / 2, z: -sz / 2 },
    { x: -sx / 2, y: -sy / 2, z: sz / 2 },
    { x: sx / 2, y: -sy / 2, z: sz / 2 },
    { x: sx / 2, y: sy / 2, z: sz / 2 },
    { x: -sx / 2, y: sy / 2, z: sz / 2 }
  ];
  return offs.map((o) => add(center, rotLocal(o, rotation)));
}

// lib/affine.ts
function inv3(m) {
  const a = m[0][0], d = m[0][1], g = m[0][2];
  const b = m[1][0], e = m[1][1], h = m[1][2];
  const c = m[2][0], f = m[2][1], i = m[2][2];
  const A = e * i - f * h;
  const B = -(d * i - f * g);
  const C = d * h - e * g;
  const D = -(b * i - c * h);
  const E = a * i - c * g;
  const F = -(a * h - b * g);
  const G = b * f - c * e;
  const H = -(a * f - c * d);
  const I = a * e - b * d;
  const det = a * A + d * D + g * G;
  const invDet = det ? 1 / det : 0;
  return [
    [A * invDet, B * invDet, C * invDet],
    [D * invDet, E * invDet, F * invDet],
    [G * invDet, H * invDet, I * invDet]
  ];
}
function mul3(a, b) {
  const r = [
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0]
  ];
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      r[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];
    }
  }
  return r;
}
function affineMatrix(src, dst) {
  const S = [
    [src[0].x, src[1].x, src[2].x],
    [src[0].y, src[1].y, src[2].y],
    [1, 1, 1]
  ];
  const D = [
    [dst[0].x, dst[1].x, dst[2].x],
    [dst[0].y, dst[1].y, dst[2].y],
    [1, 1, 1]
  ];
  const M = mul3(D, inv3(S));
  return `matrix(${M[0][0]} ${M[1][0]} ${M[0][1]} ${M[1][1]} ${M[0][2]} ${M[1][2]})`;
}

// lib/render-elements.ts
function fmtPrecise(n) {
  return (Math.round(n * 100) / 100).toString();
}
var W_DEF = 400;
var H_DEF = 400;
var FOCAL = 2;
function axes(cam) {
  const f = norm(sub(cam.lookAt, cam.position));
  const wUp = { x: 0, y: 1, z: 0 };
  let r = norm(cross(f, wUp));
  if (!len(r)) r = { x: 1, y: 0, z: 0 };
  const u = cross(r, f);
  return { r, u, f };
}
function toCam(p, cam) {
  const { r, u, f } = axes(cam);
  const d = sub(p, cam.position);
  return { x: dot(d, r), y: dot(d, u), z: dot(d, f) };
}
function proj(p, w, h, focal) {
  if (p.z <= 0) return null;
  const s = focal / p.z;
  return { x: p.x * s * w / 2, y: -p.y * s * h / 2, z: p.z };
}
async function buildRenderElements(scene, opt = {}) {
  const W = opt.width ?? W_DEF;
  const H = opt.height ?? H_DEF;
  const focal = scene.camera.focalLength ?? FOCAL;
  const faces = [];
  const images = [];
  const faceToImg = /* @__PURE__ */ new Map();
  const labels = [];
  const edges = [];
  let clipSeq = 0;
  const texId = /* @__PURE__ */ new Map();
  const stlMeshes = /* @__PURE__ */ new Map();
  const objMeshes = /* @__PURE__ */ new Map();
  const threeMfMeshes = /* @__PURE__ */ new Map();
  for (const box of scene.boxes) {
    if (box.stlUrl && !stlMeshes.has(box.stlUrl)) {
      try {
        const mesh = await loadSTL(box.stlUrl);
        stlMeshes.set(box.stlUrl, mesh);
      } catch (error) {
        console.warn(`Failed to load STL from ${box.stlUrl}:`, error);
      }
    }
    if (box.objUrl && !objMeshes.has(box.objUrl)) {
      try {
        const mesh = await loadOBJ(box.objUrl);
        objMeshes.set(box.objUrl, mesh);
      } catch (error) {
        console.warn(`Failed to load OBJ from ${box.objUrl}:`, error);
      }
    }
    if (box.threeMfUrl && !threeMfMeshes.has(box.threeMfUrl)) {
      try {
        const mesh = await load3MF(box.threeMfUrl);
        threeMfMeshes.set(box.threeMfUrl, mesh);
      } catch (error) {
        console.warn(`Failed to load 3MF from ${box.threeMfUrl}:`, error);
      }
    }
  }
  for (const box of scene.boxes) {
    const bw = verts(box);
    const bc = bw.map((v) => toCam(v, scene.camera));
    const bp = bc.map((v) => proj(v, W, H, focal));
    if (box.drawBoundingBox) {
      for (const [a, b] of EDGES) {
        const pa = bp[a];
        const pb = bp[b];
        if (pa && pb) {
          const depth = Math.max(bc[a].z, bc[b].z);
          edges.push({ pts: [pa, pb], depth, color: "rgba(0,0,0,0.5)" });
        }
      }
    }
    if (box.stlUrl && stlMeshes.has(box.stlUrl)) {
      const mesh = stlMeshes.get(box.stlUrl);
      const transformedVertices = scaleAndPositionMesh(
        mesh,
        box,
        box.scaleStlToBox ?? false,
        "stl"
      );
      for (let i = 0; i < mesh.triangles.length; i++) {
        const triangle = mesh.triangles[i];
        const vertexStart = i * 3;
        const v0w = transformedVertices[vertexStart];
        const v1w = transformedVertices[vertexStart + 1];
        const v2w = transformedVertices[vertexStart + 2];
        const v0c = toCam(v0w, scene.camera);
        const v1c = toCam(v1w, scene.camera);
        const v2c = toCam(v2w, scene.camera);
        const v0p = proj(v0c, W, H, focal);
        const v1p = proj(v1c, W, H, focal);
        const v2p = proj(v2c, W, H, focal);
        if (v0p && v1p && v2p) {
          const edge1 = sub(v1c, v0c);
          const edge2 = sub(v2c, v0c);
          const normal = cross(edge1, edge2);
          const baseColor = box.color ?? "gray";
          faces.push({
            pts: [v0p, v1p, v2p],
            cam: [v0c, v1c, v2c],
            fill: shadeByNormal(baseColor, normal),
            stroke: false
          });
        }
      }
    } else if (box.objUrl && objMeshes.has(box.objUrl)) {
      const mesh = objMeshes.get(box.objUrl);
      const transformedVertices = scaleAndPositionMesh(
        mesh,
        box,
        box.scaleObjToBox ?? false,
        "obj"
      );
      for (let i = 0; i < mesh.triangles.length; i++) {
        const vertexStart = i * 3;
        const triangle = mesh.triangles[i];
        const v0w = transformedVertices[vertexStart];
        const v1w = transformedVertices[vertexStart + 1];
        const v2w = transformedVertices[vertexStart + 2];
        const v0c = toCam(v0w, scene.camera);
        const v1c = toCam(v1w, scene.camera);
        const v2c = toCam(v2w, scene.camera);
        const v0p = proj(v0c, W, H, focal);
        const v1p = proj(v1c, W, H, focal);
        const v2p = proj(v2c, W, H, focal);
        if (v0p && v1p && v2p) {
          const edge1 = sub(v1c, v0c);
          const edge2 = sub(v2c, v0c);
          const faceNormal = cross(edge1, edge2);
          faces.push({
            pts: [v0p, v1p, v2p],
            cam: [v0c, v1c, v2c],
            fill: shadeByNormal(
              box.color ?? triangle.color ?? "gray",
              faceNormal
            ),
            stroke: false
          });
        }
      }
    } else if (box.threeMfUrl && threeMfMeshes.has(box.threeMfUrl)) {
      const mesh = threeMfMeshes.get(box.threeMfUrl);
      const transformedVertices = scaleAndPositionMesh(
        mesh,
        box,
        box.scaleThreeMfToBox ?? false,
        "3mf"
      );
      for (let i = 0; i < mesh.triangles.length; i++) {
        const vertexStart = i * 3;
        const triangle = mesh.triangles[i];
        const v0w = transformedVertices[vertexStart];
        const v1w = transformedVertices[vertexStart + 1];
        const v2w = transformedVertices[vertexStart + 2];
        const v0c = toCam(v0w, scene.camera);
        const v1c = toCam(v1w, scene.camera);
        const v2c = toCam(v2w, scene.camera);
        const v0p = proj(v0c, W, H, focal);
        const v1p = proj(v1c, W, H, focal);
        const v2p = proj(v2c, W, H, focal);
        if (v0p && v1p && v2p) {
          const edge1 = sub(v1c, v0c);
          const edge2 = sub(v2c, v0c);
          const faceNormal = cross(edge1, edge2);
          faces.push({
            pts: [v0p, v1p, v2p],
            cam: [v0c, v1c, v2c],
            fill: shadeByNormal(
              box.color ?? triangle.color ?? "gray",
              faceNormal
            ),
            stroke: false
          });
        }
      }
    } else {
      const vw = verts(box);
      const vc = vw.map((v) => toCam(v, scene.camera));
      const vp = vc.map((v) => proj(v, W, H, focal));
      for (const idx of FACES) {
        const p4 = [];
        let behind = false;
        for (const i of idx) {
          const p = vp[i];
          if (!p) {
            behind = true;
            break;
          }
          p4.push(p);
        }
        if (behind) continue;
        const cam4 = idx.map((i) => vc[i]);
        faces.push({
          pts: p4,
          cam: cam4,
          fill: colorToCss(box.color ?? "gray"),
          stroke: true
        });
      }
      if (box.faceImages?.top) {
        const pts = TOP.map((i) => vw[i]);
        if (pts.every(Boolean)) {
          const dst = pts;
          const cz = Math.max(...TOP.map((i) => vc[i].z));
          const href = box.faceImages.top;
          if (!texId.has(href)) {
            texId.set(href, `tex${texId.size}`);
          }
          const sym = texId.get(href);
          const subdivisions = box.projectionSubdivision ?? 2;
          const quadsPerSide = subdivisions;
          for (let row = 0; row < quadsPerSide; row++) {
            for (let col = 0; col < quadsPerSide; col++) {
              const u0 = col / quadsPerSide;
              const u1 = (col + 1) / quadsPerSide;
              const v0 = row / quadsPerSide;
              const v1 = (row + 1) / quadsPerSide;
              const lerp = (a, b, t) => ({
                x: a.x * (1 - t) + b.x * t,
                y: a.y * (1 - t) + b.y * t,
                z: a.z * (1 - t) + b.z * t
              });
              const c00 = toCam(
                lerp(lerp(dst[0], dst[1], u0), lerp(dst[3], dst[2], u0), v0),
                scene.camera
              );
              const c10 = toCam(
                lerp(lerp(dst[0], dst[1], u1), lerp(dst[3], dst[2], u1), v0),
                scene.camera
              );
              const c01 = toCam(
                lerp(lerp(dst[0], dst[1], u0), lerp(dst[3], dst[2], u0), v1),
                scene.camera
              );
              const c11 = toCam(
                lerp(lerp(dst[0], dst[1], u1), lerp(dst[3], dst[2], u1), v1),
                scene.camera
              );
              const p00 = proj(c00, W, H, focal);
              const p10 = proj(c10, W, H, focal);
              const p01 = proj(c01, W, H, focal);
              const p11 = proj(c11, W, H, focal);
              const tri0Mat = affineMatrix(
                [
                  { x: u0, y: v0 },
                  { x: u1, y: v0 },
                  { x: u1, y: v1 }
                ],
                [p00, p10, p11]
              );
              const id0 = `clip${clipSeq++}`;
              images.push({
                matrix: tri0Mat,
                depth: cz,
                href,
                clip: id0,
                points: `${fmtPrecise(u0)},${fmtPrecise(v0)} ${fmtPrecise(u1)},${fmtPrecise(v0)} ${fmtPrecise(u1)},${fmtPrecise(v1)}`,
                sym
              });
              const triFace0 = {
                pts: [p00, p10, p11],
                cam: [c00, c10, c11],
                fill: "none",
                stroke: false
              };
              faces.push(triFace0);
              faceToImg.set(triFace0, images[images.length - 1]);
              const tri1Mat = affineMatrix(
                [
                  { x: u0, y: v0 },
                  { x: u1, y: v1 },
                  { x: u0, y: v1 }
                ],
                [p00, p11, p01]
              );
              const id1 = `clip${clipSeq++}`;
              images.push({
                matrix: tri1Mat,
                depth: cz,
                href,
                clip: id1,
                points: `${fmtPrecise(u0)},${fmtPrecise(v0)} ${fmtPrecise(u1)},${fmtPrecise(v1)} ${fmtPrecise(u0)},${fmtPrecise(v1)}`,
                sym
              });
              const triFace1 = {
                pts: [p00, p11, p01],
                cam: [c00, c11, c01],
                fill: "none",
                stroke: false
              };
              faces.push(triFace1);
              faceToImg.set(triFace1, images[images.length - 1]);
            }
          }
        }
      }
      if (box.topLabel) {
        const pts = TOP.map((i) => vp[i]);
        if (pts.every(Boolean)) {
          const p0 = pts[0];
          const p1 = pts[1];
          const p3 = pts[3];
          const u = sub(p1, p0);
          const v = sub(p3, p0);
          const lu = len(u);
          const lv = len(v);
          if (lu && lv) {
            const uN = scale(u, 1 / lu);
            const vN = scale(v, 1 / lv);
            const cx = pts.reduce((s, p) => s + p.x, 0) / 4;
            const cy = pts.reduce((s, p) => s + p.y, 0) / 4;
            const cz = Math.max(...TOP.map((i) => vc[i].z));
            const m = `matrix(${uN.x} ${uN.y} ${vN.x} ${vN.y} ${cx} ${cy})`;
            const fillCol = box.topLabelColor ?? [0, 0, 0, 1];
            labels.push({
              matrix: m,
              depth: cz,
              text: box.topLabel,
              fill: colorToCss(fillCol)
            });
          }
        }
      }
    }
  }
  function sortFacesBSP(polys, W2, H2, focal2) {
    const EPS = 1e-6;
    function build(list) {
      if (!list.length) return null;
      const face = list[0];
      const p0 = face.cam[0];
      const p1 = face.cam[1];
      const p2 = face.cam[2];
      const normal = cross(sub(p1, p0), sub(p2, p0));
      const front = [];
      const back = [];
      for (let k = 1; k < list.length; k++) {
        const f = list[k];
        let pos = 0, neg = 0;
        const d = [];
        for (const v of f.cam) {
          const dist = dot(normal, sub(v, p0));
          d.push(dist);
          if (dist > EPS) pos++;
          else if (dist < -EPS) neg++;
        }
        if (!pos && !neg) {
          front.push(f);
        } else if (!pos) back.push(f);
        else if (!neg) front.push(f);
        else {
          const fFrontCam = [];
          const fBackCam = [];
          const fFront2D = [];
          const fBack2D = [];
          for (let i = 0; i < f.cam.length; i++) {
            const j = (i + 1) % f.cam.length;
            const aCam = f.cam[i];
            const bCam = f.cam[j];
            const a2D = f.pts[i];
            const b2D = f.pts[j];
            const da = d[i];
            const db = d[j];
            const push = (arrCam, arr2D, cCam, c2D) => {
              arrCam.push(cCam);
              arr2D.push(c2D);
            };
            if (da >= -EPS) push(fFrontCam, fFront2D, aCam, a2D);
            if (da <= EPS) push(fBackCam, fBack2D, aCam, a2D);
            if (da > 0 && db < 0 || da < 0 && db > 0) {
              const t = da / (da - db);
              const interCam = {
                x: aCam.x + (bCam.x - aCam.x) * t,
                y: aCam.y + (bCam.y - aCam.y) * t,
                z: aCam.z + (bCam.z - aCam.z) * t
              };
              const inter2D = proj(interCam, W2, H2, focal2);
              push(fFrontCam, fFront2D, interCam, inter2D);
              push(fBackCam, fBack2D, interCam, inter2D);
            }
          }
          const mk = (cam, pts) => {
            if (cam.length < 3) return null;
            const nf = { cam, pts, fill: f.fill, stroke: false };
            const img = faceToImg.get(f);
            if (img) faceToImg.set(nf, img);
            return nf;
          };
          const f1 = mk(fFrontCam, fFront2D);
          const f2 = mk(fBackCam, fBack2D);
          if (f1) front.push(f1);
          if (f2) back.push(f2);
        }
      }
      return {
        face,
        normal,
        point: p0,
        front: build(front),
        back: build(back)
      };
    }
    function traverse(node, out) {
      if (!node) return;
      const cameraSide = dot(node.normal, scale(node.point, -1));
      if (cameraSide >= 0) {
        traverse(node.back, out);
        out.push(node.face);
        traverse(node.front, out);
      } else {
        traverse(node.front, out);
        out.push(node.face);
        traverse(node.back, out);
      }
    }
    const root = build(polys);
    const ordered = [];
    traverse(root, ordered);
    return ordered;
  }
  const orderedFaces = sortFacesBSP(faces, W, H, focal);
  const elements = [];
  for (const f of orderedFaces) {
    const img = faceToImg.get(f);
    if (img) {
      elements.push({ type: "image", data: img });
    } else {
      elements.push({ type: "face", data: f });
    }
  }
  elements.push(
    ...labels.map((l) => ({ type: "label", data: l })),
    ...edges.sort((a, b) => a.depth - b.depth).map((e) => ({ type: "edge", data: e }))
  );
  return {
    width: W,
    height: H,
    backgroundColor: opt.backgroundColor,
    elements,
    images,
    texId
  };
}

// lib/render-svg.ts
function fmt(n) {
  return Math.round(n) + "";
}
async function renderScene(scene, opt = {}) {
  const {
    width: W,
    height: H,
    backgroundColor,
    elements,
    images,
    texId
  } = await buildRenderElements(scene, {
    width: opt.width,
    height: opt.height,
    backgroundColor: opt.backgroundColor
  });
  const out = [];
  out.push(
    `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="${-W / 2} ${-H / 2} ${W} ${H}">`
  );
  if (backgroundColor) {
    out.push(
      `  <rect x="${-W / 2}" y="${-H / 2}" width="${W}" height="${H}" fill="${colorToCss(backgroundColor)}" />
`
    );
  }
  if (images.length) {
    out.push("  <defs>\n");
    for (const [href, id] of texId) {
      out.push(
        `    <image id="${id}" href="${href}" width="1" height="1" preserveAspectRatio="none" style="image-rendering:pixelated"/>
`
      );
    }
    for (const img of images) {
      out.push(
        `    <clipPath id="${img.clip}" clipPathUnits="objectBoundingBox"><polygon points="${img.points}" /></clipPath>
`
      );
    }
    out.push("  </defs>\n");
  }
  if (opt.showGrid) {
    out.push(
      renderGrid(scene, W, H, opt.grid?.cellSize ?? 1, opt.grid?.plane ?? "xz")
    );
  }
  let inStrokeGroup = false;
  for (const element of elements) {
    if (element.type === "face" || element.type === "image") {
      if (!inStrokeGroup) {
        out.push(
          '  <g stroke="#000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">\n'
        );
        inStrokeGroup = true;
      }
      if (element.type === "face") {
        const f = element.data;
        const strokeAttr = f.stroke ? "" : ' stroke="none"';
        out.push(
          `    <polygon fill="${f.fill}"${strokeAttr} points="${f.pts.map((p) => `${fmt(p.x)},${fmt(p.y)}`).join(" ")}" />
`
        );
      } else {
        const img = element.data;
        out.push(
          `    <g transform="${img.matrix}" clip-path="url(#${img.clip})"><use href="#${img.sym}"/></g>
`
        );
      }
    } else if (element.type === "label") {
      if (inStrokeGroup) {
        out.push("  </g>\n");
        inStrokeGroup = false;
      }
      const l = element.data;
      out.push(
        `  <g font-family="sans-serif" font-size="14" text-anchor="middle" dominant-baseline="central" transform="${l.matrix}"><text x="0" y="0" fill="${l.fill}">${l.text}</text></g>
`
      );
    } else if (element.type === "edge") {
      if (inStrokeGroup) {
        out.push("  </g>\n");
        inStrokeGroup = false;
      }
      const e = element.data;
      out.push(
        `  <polyline fill="none" stroke="${e.color}" points="${e.pts.map((p) => `${p.x},${p.y}`).join(" ")}" />
`
      );
    }
  }
  if (inStrokeGroup) {
    out.push("  </g>\n");
  }
  if (opt.showOrigin) {
    out.push(renderOrigin(scene.camera, W, H));
  }
  if (opt.showAxes) {
    out.push(renderAxes(scene.camera, W, H));
  }
  out.push("</svg>");
  return out.join("");
}
function renderAxes(cam, W, H) {
  const focal = cam.focalLength ?? 2;
  const baseDist = 3;
  const margin = Math.min(W, H) * 0.08;
  const arrowDist = baseDist * 0.16 / focal;
  const baseProj = proj2({ x: 0, y: 0, z: baseDist }, W, H, focal);
  if (!baseProj) return "";
  const offsetX = -W / 2 + margin - baseProj.x;
  const offsetY = H / 2 - margin - baseProj.y;
  function t(p) {
    const pp = proj2(p, W, H, focal);
    return pp ? { x: pp.x + offsetX, y: pp.y + offsetY } : { x: 0, y: 0 };
  }
  const { r, u, f } = axes2(cam);
  const start = t({ x: 0, y: 0, z: baseDist });
  const axesData = [
    { w: { x: 1, y: 0, z: 0 }, color: "red", label: "X" },
    { w: { x: 0, y: 1, z: 0 }, color: "green", label: "Y" },
    { w: { x: 0, y: 0, z: 1 }, color: "blue", label: "Z" }
  ].map(({ w, color, label }) => ({
    dir: {
      x: w.x * r.x + w.y * r.y + w.z * r.z,
      y: w.x * u.x + w.y * u.y + w.z * u.z,
      z: w.x * f.x + w.y * f.y + w.z * f.z
    },
    color,
    label
  }));
  const parts = [];
  for (const { dir, color, label } of axesData) {
    const end = t({
      x: dir.x * arrowDist,
      y: dir.y * arrowDist,
      z: baseDist + dir.z * arrowDist
    });
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const l = Math.sqrt(dx * dx + dy * dy) || 1;
    const nx = dx / l;
    const ny = dy / l;
    const hx = end.x - nx * 8;
    const hy = end.y - ny * 8;
    const b1x = hx + -ny * 4;
    const b1y = hy + nx * 4;
    const b2x = hx - -ny * 4;
    const b2y = hy - nx * 4;
    const tx = end.x + nx * 10;
    const ty = end.y + ny * 10;
    parts.push(
      `    <line x1="${fmt(start.x)}" y1="${fmt(start.y)}" x2="${fmt(hx)}" y2="${fmt(hy)}" stroke="${color}" />`
    );
    parts.push(
      `    <polygon fill="${color}" points="${fmt(end.x)},${fmt(end.y)} ${fmt(b1x)},${fmt(b1y)} ${fmt(b2x)},${fmt(b2y)}" />`
    );
    parts.push(
      `    <text x="${fmt(tx)}" y="${fmt(ty)}" fill="${color}" font-size="12" font-family="sans-serif" text-anchor="middle" dominant-baseline="central">${label}</text>`
    );
  }
  return `  <g stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
${parts.join(
    "\n"
  )}
  </g>
`;
}
function renderGrid(scene, W, H, cellSize, plane) {
  const cam = scene.camera;
  const focal = cam.focalLength ?? 2;
  const { r, u, f } = axes2(cam);
  const toCam2 = (p) => {
    const d = sub(p, cam.position);
    return { x: dot(d, r), y: dot(d, u), z: dot(d, f) };
  };
  const project = (p) => proj2(toCam2(p), W, H, focal);
  const R = cellSize * 10;
  const lines = [];
  for (let t = -R; t <= R; t += cellSize) {
    const pushLine = (a, b) => {
      const p0 = project(a);
      const p1 = project(b);
      if (p0 && p1) {
        lines.push(
          `    <line x1="${fmt(p0.x)}" y1="${fmt(p0.y)}" x2="${fmt(p1.x)}" y2="${fmt(p1.y)}" />`
        );
      }
    };
    switch (plane) {
      case "xz":
        pushLine({ x: t, y: 0, z: -R }, { x: t, y: 0, z: R });
        pushLine({ x: -R, y: 0, z: t }, { x: R, y: 0, z: t });
        break;
      case "xy":
        pushLine({ x: t, y: -R, z: 0 }, { x: t, y: R, z: 0 });
        pushLine({ x: -R, y: t, z: 0 }, { x: R, y: t, z: 0 });
        break;
      case "yz":
        pushLine({ x: 0, y: t, z: -R }, { x: 0, y: t, z: R });
        pushLine({ x: 0, y: -R, z: t }, { x: 0, y: R, z: t });
        break;
    }
  }
  return lines.length ? `  <g stroke="#ccc" stroke-width="0.5">
${lines.join("\n")}
  </g>
` : "";
}
function renderOrigin(cam, W, H) {
  const focal = cam.focalLength ?? 2;
  const { r, u, f } = axes2(cam);
  const toCam2 = (p) => {
    const d = sub(p, cam.position);
    return { x: dot(d, r), y: dot(d, u), z: dot(d, f) };
  };
  const project = (p) => proj2(p, W, H, focal);
  const axesData = [
    { dir: { x: 1, y: 0, z: 0 }, color: "red" },
    { dir: { x: 0, y: 1, z: 0 }, color: "green" },
    { dir: { x: 0, y: 0, z: 1 }, color: "blue" }
  ];
  const minLineLengthPx = Math.max(W, H) * Math.SQRT2;
  const parts = [];
  const origin = { x: 0, y: 0, z: 0 };
  const gradientDefs = [];
  axesData.forEach(({ dir, color }, i) => {
    const L = 1;
    const end = add(origin, scale(dir, L));
    const startCam = toCam2(origin);
    const endCam = toCam2(end);
    const start2d = project(startCam);
    const end2d1 = project(endCam);
    const dx = end2d1.x - start2d.x;
    const dy = end2d1.y - start2d.y;
    const len2 = Math.sqrt(dx * dx + dy * dy);
    const end2d2 = {
      x: start2d.x + dx * minLineLengthPx / len2,
      y: start2d.y + dy * minLineLengthPx / len2
    };
    if (start2d && end2d1) {
      const gradId = `axis-grad-${i}`;
      const x1 = fmt(start2d.x);
      const y1 = fmt(start2d.y);
      const x2 = fmt(end2d2.x);
      const y2 = fmt(end2d2.y);
      gradientDefs.push(
        `    <linearGradient id="${gradId}" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" gradientUnits="userSpaceOnUse">      <stop offset="0%" stop-color="${color}"/>      <stop offset="${Math.min(len2 / minLineLengthPx * 1e3, 100)}%" stop-color="rgba(255,255,255,0)"/>      <stop offset="100%" stop-color="rgba(255,255,255,0)"/>    </linearGradient>`
      );
      parts.push(
        `    <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="url(#${gradId})" />`
      );
    }
  });
  if (gradientDefs.length) {
    parts.unshift(`  <defs>
${gradientDefs.join("\n")}
  </defs>`);
  }
  return parts.length ? `  <g stroke-width="1">
${parts.join("\n")}
  </g>
` : "";
}
function axes2(cam) {
  const f = norm(sub(cam.lookAt, cam.position));
  const wUp = { x: 0, y: 1, z: 0 };
  let r = norm(cross(f, wUp));
  if (!len(r)) r = { x: 1, y: 0, z: 0 };
  const u = cross(r, f);
  return { r, u, f };
}
function proj2(p, w, h, focal) {
  if (p.z <= 0) return null;
  const s = focal / p.z;
  return { x: p.x * s * w / 2, y: -p.y * s * h / 2 };
}
export {
  load3MF,
  loadOBJ,
  loadSTL,
  renderScene
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbGliL3ZlYzMudHMiLCAiLi4vbGliL2NvbG9yLnRzIiwgIi4uL2xpYi9sb2FkZXJzL3N0bC50cyIsICIuLi9saWIvbG9hZGVycy9vYmoudHMiLCAiLi4vbGliL2xvYWRlcnMvdGhyZWVtZi50cyIsICIuLi9saWIvbWVzaC50cyIsICIuLi9saWIvZ2VvbWV0cnkudHMiLCAiLi4vbGliL2FmZmluZS50cyIsICIuLi9saWIvcmVuZGVyLWVsZW1lbnRzLnRzIiwgIi4uL2xpYi9yZW5kZXItc3ZnLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IFBvaW50MyB9IGZyb20gXCIuL3R5cGVzXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChhOiBQb2ludDMsIGI6IFBvaW50Myk6IFBvaW50MyB7XG4gIHJldHVybiB7IHg6IGEueCArIGIueCwgeTogYS55ICsgYi55LCB6OiBhLnogKyBiLnogfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHN1YihhOiBQb2ludDMsIGI6IFBvaW50Myk6IFBvaW50MyB7XG4gIHJldHVybiB7IHg6IGEueCAtIGIueCwgeTogYS55IC0gYi55LCB6OiBhLnogLSBiLnogfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhOiBQb2ludDMsIGI6IFBvaW50Myk6IG51bWJlciB7XG4gIHJldHVybiBhLnggKiBiLnggKyBhLnkgKiBiLnkgKyBhLnogKiBiLnpcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhhOiBQb2ludDMsIGI6IFBvaW50Myk6IFBvaW50MyB7XG4gIHJldHVybiB7XG4gICAgeDogYS55ICogYi56IC0gYS56ICogYi55LFxuICAgIHk6IGEueiAqIGIueCAtIGEueCAqIGIueixcbiAgICB6OiBhLnggKiBiLnkgLSBhLnkgKiBiLngsXG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZSh2OiBQb2ludDMsIGs6IG51bWJlcik6IFBvaW50MyB7XG4gIHJldHVybiB7IHg6IHYueCAqIGssIHk6IHYueSAqIGssIHo6IHYueiAqIGsgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGxlbih2OiBQb2ludDMpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5zcXJ0KGRvdCh2LCB2KSlcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtKHY6IFBvaW50Myk6IFBvaW50MyB7XG4gIGNvbnN0IGwgPSBsZW4odikgfHwgMVxuICByZXR1cm4gc2NhbGUodiwgMSAvIGwpXG59XG5leHBvcnQgZnVuY3Rpb24gcm90TG9jYWwocDogUG9pbnQzLCByOiBQb2ludDMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfSk6IFBvaW50MyB7XG4gIGxldCB7IHgsIHksIHogfSA9IHBcbiAgaWYgKHIueCkge1xuICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhyLngpXG4gICAgY29uc3QgcyA9IE1hdGguc2luKHIueClcbiAgICBjb25zdCB5MiA9IHkgKiBjIC0geiAqIHNcbiAgICB6ID0geSAqIHMgKyB6ICogY1xuICAgIHkgPSB5MlxuICB9XG4gIGlmIChyLnkpIHtcbiAgICBjb25zdCBjID0gTWF0aC5jb3Moci55KVxuICAgIGNvbnN0IHMgPSBNYXRoLnNpbihyLnkpXG4gICAgY29uc3QgeDIgPSB4ICogYyArIHogKiBzXG4gICAgeiA9IC14ICogcyArIHogKiBjXG4gICAgeCA9IHgyXG4gIH1cbiAgaWYgKHIueikge1xuICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhyLnopXG4gICAgY29uc3QgcyA9IE1hdGguc2luKHIueilcbiAgICBjb25zdCB4MiA9IHggKiBjIC0geSAqIHNcbiAgICB5ID0geCAqIHMgKyB5ICogY1xuICAgIHggPSB4MlxuICB9XG4gIHJldHVybiB7IHgsIHksIHogfVxufVxuIiwgImltcG9ydCB0eXBlIHsgQ29sb3IsIFJHQkEsIFBvaW50MyB9IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCB7IG5vcm0gfSBmcm9tIFwiLi92ZWMzXCJcblxuZXhwb3J0IGNvbnN0IE5BTUVEX0NPTE9SUzogUmVjb3JkPHN0cmluZywgW251bWJlciwgbnVtYmVyLCBudW1iZXJdPiA9IHtcbiAgYmxhY2s6IFswLCAwLCAwXSxcbiAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxuICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICByZWQ6IFsyNTUsIDAsIDBdLFxuICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgbGltZTogWzAsIDI1NSwgMF0sXG4gIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgYXF1YTogWzAsIDI1NSwgMjU1XSxcbiAgb3JhbmdlOiBbMjU1LCAxNjUsIDBdLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sb3JUb0NzcyhjOiBDb2xvcik6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgYyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGNcbiAgY29uc3QgW3IsIGcsIGIsIGFdID0gY1xuICByZXR1cm4gYHJnYmEoJHtNYXRoLnJvdW5kKHIpfSwke01hdGgucm91bmQoZyl9LCR7TWF0aC5yb3VuZChiKX0sJHthfSlgXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2xvclRvUkdCQShjOiBDb2xvcik6IFJHQkEge1xuICBpZiAoQXJyYXkuaXNBcnJheShjKSkgcmV0dXJuIGNcbiAgY29uc3QgcyA9IGMudHJpbSgpLnRvTG93ZXJDYXNlKClcbiAgaWYgKHMuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBjb25zdCBoZXggPSBzLnNsaWNlKDEpXG4gICAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguY2hhckF0KDApICsgaGV4LmNoYXJBdCgwKSwgMTYpXG4gICAgICBjb25zdCBnID0gcGFyc2VJbnQoaGV4LmNoYXJBdCgxKSArIGhleC5jaGFyQXQoMSksIDE2KVxuICAgICAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5jaGFyQXQoMikgKyBoZXguY2hhckF0KDIpLCAxNilcbiAgICAgIHJldHVybiBbciwgZywgYiwgMV1cbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggPT09IDYpIHtcbiAgICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguc2xpY2UoMCwgMiksIDE2KVxuICAgICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zbGljZSgyLCA0KSwgMTYpXG4gICAgICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnNsaWNlKDQsIDYpLCAxNilcbiAgICAgIHJldHVybiBbciwgZywgYiwgMV1cbiAgICB9XG4gIH1cbiAgY29uc3QgcmdibSA9IHMubWF0Y2goL15yZ2JhP1xcKChbXildKylcXCkkLylcbiAgaWYgKHJnYm0pIHtcbiAgICBjb25zdCBjb250ZW50ID0gcmdibVsxXSFcbiAgICBjb25zdCBwYXJ0cyA9IGNvbnRlbnQuc3BsaXQoL1xccyosXFxzKi8pLm1hcChOdW1iZXIpXG4gICAgY29uc3QgW3IgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAxXSA9IHBhcnRzXG4gICAgcmV0dXJuIFtyLCBnLCBiLCBhXVxuICB9XG4gIGNvbnN0IG5hbWVkID0gTkFNRURfQ09MT1JTW3NdXG4gIGlmIChuYW1lZCkgcmV0dXJuIFtuYW1lZFswXSwgbmFtZWRbMV0sIG5hbWVkWzJdLCAxXVxuICByZXR1cm4gWzAsIDAsIDAsIDFdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaWdodGVuQ29sb3IoYzogQ29sb3IsIGY6IG51bWJlcik6IFJHQkEge1xuICBjb25zdCBbciwgZywgYiwgYV0gPSBjb2xvclRvUkdCQShjKVxuICByZXR1cm4gW3IgKyAoMjU1IC0gcikgKiBmLCBnICsgKDI1NSAtIGcpICogZiwgYiArICgyNTUgLSBiKSAqIGYsIGFdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXJrZW5Db2xvcihjOiBDb2xvciwgZjogbnVtYmVyKTogUkdCQSB7XG4gIGNvbnN0IFtyLCBnLCBiLCBhXSA9IGNvbG9yVG9SR0JBKGMpXG4gIHJldHVybiBbciAqICgxIC0gZiksIGcgKiAoMSAtIGYpLCBiICogKDEgLSBmKSwgYV1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoYWRlQnlOb3JtYWwoYmFzZTogQ29sb3IsIG5vcm1hbDogUG9pbnQzKTogc3RyaW5nIHtcbiAgY29uc3QgbiA9IG5vcm0obm9ybWFsKVxuICBpZiAobi56ID49IDApIHtcbiAgICByZXR1cm4gY29sb3JUb0NzcyhsaWdodGVuQ29sb3IoYmFzZSwgbi56ICogMC40KSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29sb3JUb0NzcyhkYXJrZW5Db2xvcihiYXNlLCAtbi56ICogMC40KSlcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgUG9pbnQzLCBTVExNZXNoLCBUcmlhbmdsZSB9IGZyb20gXCIuLi90eXBlc1wiXG5cbi8vIENhY2hlIGZvciBsb2FkZWQgU1RMIGZpbGVzXG5jb25zdCBzdGxDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBTVExNZXNoPigpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkU1RMKHVybDogc3RyaW5nKTogUHJvbWlzZTxTVExNZXNoPiB7XG4gIGlmIChzdGxDYWNoZS5oYXModXJsKSkge1xuICAgIHJldHVybiBzdGxDYWNoZS5nZXQodXJsKSFcbiAgfVxuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKVxuICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpXG4gIGNvbnN0IG1lc2ggPSBwYXJzZVNUTChidWZmZXIpXG4gIHN0bENhY2hlLnNldCh1cmwsIG1lc2gpXG4gIHJldHVybiBtZXNoXG59XG5cbmZ1bmN0aW9uIHBhcnNlU1RMKGJ1ZmZlcjogQXJyYXlCdWZmZXIpOiBTVExNZXNoIHtcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXG5cbiAgLy8gQ2hlY2sgaWYgaXQncyBiaW5hcnkgU1RMIChmaXJzdCA1IGJ5dGVzIHNob3VsZCBub3QgYmUgXCJzb2xpZFwiKVxuICBjb25zdCBoZWFkZXIgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZmVyLnNsaWNlKDAsIDUpKVxuXG4gIGlmIChoZWFkZXIudG9Mb3dlckNhc2UoKSA9PT0gXCJzb2xpZFwiKSB7XG4gICAgcmV0dXJuIHBhcnNlQVNDSUlTVEwoYnVmZmVyKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUJpbmFyeVNUTCh2aWV3KVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlQVNDSUlTVEwoYnVmZmVyOiBBcnJheUJ1ZmZlcik6IFNUTE1lc2gge1xuICBjb25zdCB0ZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlcilcbiAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpLm1hcCgobGluZSkgPT4gbGluZS50cmltKCkpXG5cbiAgY29uc3QgdHJpYW5nbGVzOiBUcmlhbmdsZVtdID0gW11cbiAgbGV0IGkgPSAwXG5cbiAgd2hpbGUgKGkgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbaV1cblxuICAgIGlmIChsaW5lICYmIGxpbmUuc3RhcnRzV2l0aChcImZhY2V0IG5vcm1hbFwiKSkge1xuICAgICAgY29uc3Qgbm9ybWFsTWF0Y2ggPSBsaW5lLm1hdGNoKFxuICAgICAgICAvZmFjZXQgbm9ybWFsXFxzKyhbLStdP1xcZCpcXC4/XFxkKyg/OltlRV1bLStdP1xcZCspPylcXHMrKFstK10/XFxkKlxcLj9cXGQrKD86W2VFXVstK10/XFxkKyk/KVxccysoWy0rXT9cXGQqXFwuP1xcZCsoPzpbZUVdWy0rXT9cXGQrKT8pLyxcbiAgICAgIClcbiAgICAgIGNvbnN0IG5vcm1hbDogUG9pbnQzID0gbm9ybWFsTWF0Y2hcbiAgICAgICAgPyB7XG4gICAgICAgICAgICB4OiBwYXJzZUZsb2F0KG5vcm1hbE1hdGNoWzFdISksXG4gICAgICAgICAgICB5OiBwYXJzZUZsb2F0KG5vcm1hbE1hdGNoWzJdISksXG4gICAgICAgICAgICB6OiBwYXJzZUZsb2F0KG5vcm1hbE1hdGNoWzNdISksXG4gICAgICAgICAgfVxuICAgICAgICA6IHsgeDogMCwgeTogMCwgejogMSB9XG5cbiAgICAgIGkrKyAvLyBza2lwIHRvIG91dGVyIGxvb3BcbiAgICAgIGNvbnN0IHZlcnRpY2VzOiBQb2ludDNbXSA9IFtdXG5cbiAgICAgIHdoaWxlIChcbiAgICAgICAgaSA8IGxpbmVzLmxlbmd0aCAmJlxuICAgICAgICBsaW5lc1tpXSAmJlxuICAgICAgICAhbGluZXNbaV0hLnN0YXJ0c1dpdGgoXCJlbmRmYWNldFwiKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHZlcnRleExpbmUgPSBsaW5lc1tpXSFcbiAgICAgICAgaWYgKHZlcnRleExpbmUuc3RhcnRzV2l0aChcInZlcnRleFwiKSkge1xuICAgICAgICAgIGNvbnN0IHZlcnRleE1hdGNoID0gdmVydGV4TGluZS5tYXRjaChcbiAgICAgICAgICAgIC92ZXJ0ZXhcXHMrKFstK10/XFxkKlxcLj9cXGQrKD86W2VFXVstK10/XFxkKyk/KVxccysoWy0rXT9cXGQqXFwuP1xcZCsoPzpbZUVdWy0rXT9cXGQrKT8pXFxzKyhbLStdP1xcZCpcXC4/XFxkKyg/OltlRV1bLStdP1xcZCspPykvLFxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAodmVydGV4TWF0Y2gpIHtcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goe1xuICAgICAgICAgICAgICB4OiBwYXJzZUZsb2F0KHZlcnRleE1hdGNoWzFdISksXG4gICAgICAgICAgICAgIHk6IHBhcnNlRmxvYXQodmVydGV4TWF0Y2hbMl0hKSxcbiAgICAgICAgICAgICAgejogcGFyc2VGbG9hdCh2ZXJ0ZXhNYXRjaFszXSEpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSsrXG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgdHJpYW5nbGVzLnB1c2goe1xuICAgICAgICAgIHZlcnRpY2VzOiBbdmVydGljZXNbMF0hLCB2ZXJ0aWNlc1sxXSEsIHZlcnRpY2VzWzJdIV0sXG4gICAgICAgICAgbm9ybWFsLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBpKytcbiAgfVxuXG4gIC8vIEFwcGx5IFotdXAgdG8gWS11cCByb3RhdGlvbiAocm90YXRlIC05MCBkZWdyZWVzIGFyb3VuZCBYLWF4aXMpXG4gIGNvbnN0IHJvdGF0ZWRUcmlhbmdsZXMgPSB0cmlhbmdsZXMubWFwKCh0cmlhbmdsZSkgPT4gKHtcbiAgICAuLi50cmlhbmdsZSxcbiAgICB2ZXJ0aWNlczogdHJpYW5nbGUudmVydGljZXMubWFwKCh2KSA9PiAoe1xuICAgICAgeDogdi54LFxuICAgICAgeTogLXYueixcbiAgICAgIHo6IHYueSxcbiAgICB9KSkgYXMgW1BvaW50MywgUG9pbnQzLCBQb2ludDNdLFxuICAgIG5vcm1hbDoge1xuICAgICAgeDogdHJpYW5nbGUubm9ybWFsLngsXG4gICAgICB5OiAtdHJpYW5nbGUubm9ybWFsLnosXG4gICAgICB6OiB0cmlhbmdsZS5ub3JtYWwueSxcbiAgICB9LFxuICB9KSlcblxuICByZXR1cm4ge1xuICAgIHRyaWFuZ2xlczogcm90YXRlZFRyaWFuZ2xlcyxcbiAgICBib3VuZGluZ0JveDogY2FsY3VsYXRlQm91bmRpbmdCb3gocm90YXRlZFRyaWFuZ2xlcyksXG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VCaW5hcnlTVEwodmlldzogRGF0YVZpZXcpOiBTVExNZXNoIHtcbiAgLy8gU2tpcCA4MC1ieXRlIGhlYWRlclxuICBsZXQgb2Zmc2V0ID0gODBcblxuICAvLyBSZWFkIG51bWJlciBvZiB0cmlhbmdsZXMgKDQgYnl0ZXMsIGxpdHRsZSBlbmRpYW4pXG4gIGNvbnN0IG51bVRyaWFuZ2xlcyA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSlcbiAgb2Zmc2V0ICs9IDRcblxuICBjb25zdCB0cmlhbmdsZXM6IFRyaWFuZ2xlW10gPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVHJpYW5nbGVzOyBpKyspIHtcbiAgICAvLyBSZWFkIG5vcm1hbCB2ZWN0b3IgKDMgZmxvYXRzLCAxMiBieXRlcylcbiAgICBjb25zdCBub3JtYWw6IFBvaW50MyA9IHtcbiAgICAgIHg6IHZpZXcuZ2V0RmxvYXQzMihvZmZzZXQsIHRydWUpLFxuICAgICAgeTogdmlldy5nZXRGbG9hdDMyKG9mZnNldCArIDQsIHRydWUpLFxuICAgICAgejogdmlldy5nZXRGbG9hdDMyKG9mZnNldCArIDgsIHRydWUpLFxuICAgIH1cbiAgICBvZmZzZXQgKz0gMTJcblxuICAgIC8vIFJlYWQgdmVydGljZXMgKDMgdmVydGljZXMgXHUwMEQ3IDMgZmxvYXRzIFx1MDBENyA0IGJ5dGVzID0gMzYgYnl0ZXMpXG4gICAgY29uc3QgdmVydGljZXM6IFtQb2ludDMsIFBvaW50MywgUG9pbnQzXSA9IFtcbiAgICAgIHtcbiAgICAgICAgeDogdmlldy5nZXRGbG9hdDMyKG9mZnNldCwgdHJ1ZSksXG4gICAgICAgIHk6IHZpZXcuZ2V0RmxvYXQzMihvZmZzZXQgKyA0LCB0cnVlKSxcbiAgICAgICAgejogdmlldy5nZXRGbG9hdDMyKG9mZnNldCArIDgsIHRydWUpLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgeDogdmlldy5nZXRGbG9hdDMyKG9mZnNldCArIDEyLCB0cnVlKSxcbiAgICAgICAgeTogdmlldy5nZXRGbG9hdDMyKG9mZnNldCArIDE2LCB0cnVlKSxcbiAgICAgICAgejogdmlldy5nZXRGbG9hdDMyKG9mZnNldCArIDIwLCB0cnVlKSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHg6IHZpZXcuZ2V0RmxvYXQzMihvZmZzZXQgKyAyNCwgdHJ1ZSksXG4gICAgICAgIHk6IHZpZXcuZ2V0RmxvYXQzMihvZmZzZXQgKyAyOCwgdHJ1ZSksXG4gICAgICAgIHo6IHZpZXcuZ2V0RmxvYXQzMihvZmZzZXQgKyAzMiwgdHJ1ZSksXG4gICAgICB9LFxuICAgIF1cbiAgICBvZmZzZXQgKz0gMzZcblxuICAgIC8vIFNraXAgYXR0cmlidXRlIGJ5dGUgY291bnQgKDIgYnl0ZXMpXG4gICAgb2Zmc2V0ICs9IDJcblxuICAgIHRyaWFuZ2xlcy5wdXNoKHsgdmVydGljZXMsIG5vcm1hbCB9KVxuICB9XG5cbiAgLy8gQXBwbHkgWi11cCB0byBZLXVwIHJvdGF0aW9uIChyb3RhdGUgLTkwIGRlZ3JlZXMgYXJvdW5kIFgtYXhpcylcbiAgY29uc3Qgcm90YXRlZFRyaWFuZ2xlcyA9IHRyaWFuZ2xlcy5tYXAoKHRyaWFuZ2xlKSA9PiAoe1xuICAgIC4uLnRyaWFuZ2xlLFxuICAgIHZlcnRpY2VzOiB0cmlhbmdsZS52ZXJ0aWNlcy5tYXAoKHYpID0+ICh7XG4gICAgICB4OiB2LngsXG4gICAgICB5OiAtdi56LFxuICAgICAgejogdi55LFxuICAgIH0pKSBhcyBbUG9pbnQzLCBQb2ludDMsIFBvaW50M10sXG4gICAgbm9ybWFsOiB7XG4gICAgICB4OiB0cmlhbmdsZS5ub3JtYWwueCxcbiAgICAgIHk6IC10cmlhbmdsZS5ub3JtYWwueixcbiAgICAgIHo6IHRyaWFuZ2xlLm5vcm1hbC55LFxuICAgIH0sXG4gIH0pKVxuXG4gIHJldHVybiB7XG4gICAgdHJpYW5nbGVzOiByb3RhdGVkVHJpYW5nbGVzLFxuICAgIGJvdW5kaW5nQm94OiBjYWxjdWxhdGVCb3VuZGluZ0JveChyb3RhdGVkVHJpYW5nbGVzKSxcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVCb3VuZGluZ0JveCh0cmlhbmdsZXM6IFRyaWFuZ2xlW10pOiB7XG4gIG1pbjogUG9pbnQzXG4gIG1heDogUG9pbnQzXG59IHtcbiAgaWYgKHRyaWFuZ2xlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiB7IHg6IDAsIHk6IDAsIHo6IDAgfSxcbiAgICAgIG1heDogeyB4OiAwLCB5OiAwLCB6OiAwIH0sXG4gICAgfVxuICB9XG5cbiAgbGV0IG1pblggPSBJbmZpbml0eSxcbiAgICBtaW5ZID0gSW5maW5pdHksXG4gICAgbWluWiA9IEluZmluaXR5XG4gIGxldCBtYXhYID0gLUluZmluaXR5LFxuICAgIG1heFkgPSAtSW5maW5pdHksXG4gICAgbWF4WiA9IC1JbmZpbml0eVxuXG4gIGZvciAoY29uc3QgdHJpYW5nbGUgb2YgdHJpYW5nbGVzKSB7XG4gICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgdHJpYW5nbGUudmVydGljZXMpIHtcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB2ZXJ0ZXgueClcbiAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB2ZXJ0ZXgueSlcbiAgICAgIG1pblogPSBNYXRoLm1pbihtaW5aLCB2ZXJ0ZXgueilcbiAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB2ZXJ0ZXgueClcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB2ZXJ0ZXgueSlcbiAgICAgIG1heFogPSBNYXRoLm1heChtYXhaLCB2ZXJ0ZXgueilcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1pbjogeyB4OiBtaW5YLCB5OiBtaW5ZLCB6OiBtaW5aIH0sXG4gICAgbWF4OiB7IHg6IG1heFgsIHk6IG1heFksIHo6IG1heFogfSxcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgUG9pbnQzLCBTVExNZXNoLCBUcmlhbmdsZSwgQ29sb3IgfSBmcm9tIFwiLi4vdHlwZXNcIlxuXG5jb25zdCBvYmpDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBTVExNZXNoPigpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkT0JKKHVybDogc3RyaW5nKTogUHJvbWlzZTxTVExNZXNoPiB7XG4gIGlmIChvYmpDYWNoZS5oYXModXJsKSkge1xuICAgIHJldHVybiBvYmpDYWNoZS5nZXQodXJsKSFcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybClcbiAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICBjb25zdCBtZXNoID0gcGFyc2VPQkoodGV4dClcbiAgb2JqQ2FjaGUuc2V0KHVybCwgbWVzaClcbiAgcmV0dXJuIG1lc2hcbn1cblxuZnVuY3Rpb24gcGFyc2VPQkoodGV4dDogc3RyaW5nKTogU1RMTWVzaCB7XG4gIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgvXFxyP1xcbi8pXG4gIGNvbnN0IHZlcnRpY2VzOiBQb2ludDNbXSA9IFtdXG4gIGNvbnN0IHZlcnRleENvbG9yczogKENvbG9yIHwgdW5kZWZpbmVkKVtdID0gW11cbiAgY29uc3Qgbm9ybWFsczogUG9pbnQzW10gPSBbXVxuICBjb25zdCB0cmlhbmdsZXM6IFRyaWFuZ2xlW10gPSBbXVxuICBjb25zdCBtYXRlcmlhbENvbG9yczogUmVjb3JkPHN0cmluZywgQ29sb3I+ID0ge31cbiAgbGV0IGFjdGl2ZU1hdGVyaWFsOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBjb25zdCB0cmltbWVkID0gbGluZS50cmltKClcbiAgICBpZiAodHJpbW1lZC5zdGFydHNXaXRoKFwidiBcIikpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdHJpbW1lZC5zcGxpdCgvXFxzKy8pXG4gICAgICBjb25zdCB4ID0gcGFydHNbMV0hXG4gICAgICBjb25zdCB5ID0gcGFydHNbMl0hXG4gICAgICBjb25zdCB6ID0gcGFydHNbM10hXG4gICAgICB2ZXJ0aWNlcy5wdXNoKHsgeDogcGFyc2VGbG9hdCh4KSwgeTogcGFyc2VGbG9hdCh5KSwgejogLXBhcnNlRmxvYXQoeikgfSlcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gNykge1xuICAgICAgICBjb25zdCBbclN0ciwgZ1N0ciwgYlN0cl0gPSBwYXJ0cy5zbGljZSg0LCA3KSBhcyBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ11cbiAgICAgICAgbGV0IHIgPSBOdW1iZXIoclN0cilcbiAgICAgICAgbGV0IGcgPSBOdW1iZXIoZ1N0cilcbiAgICAgICAgbGV0IGIgPSBOdW1iZXIoYlN0cilcbiAgICAgICAgaWYgKHIgPD0gMSAmJiBnIDw9IDEgJiYgYiA8PSAxKSB7XG4gICAgICAgICAgciAqPSAyNTVcbiAgICAgICAgICBnICo9IDI1NVxuICAgICAgICAgIGIgKj0gMjU1XG4gICAgICAgIH1cbiAgICAgICAgdmVydGV4Q29sb3JzLnB1c2goW3IsIGcsIGIsIDFdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVydGV4Q29sb3JzLnB1c2godW5kZWZpbmVkKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHJpbW1lZC5zdGFydHNXaXRoKFwidm4gXCIpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHRyaW1tZWQuc3BsaXQoL1xccysvKVxuICAgICAgY29uc3QgeCA9IHBhcnRzWzFdIVxuICAgICAgY29uc3QgeSA9IHBhcnRzWzJdIVxuICAgICAgY29uc3QgeiA9IHBhcnRzWzNdIVxuICAgICAgbm9ybWFscy5wdXNoKHsgeDogcGFyc2VGbG9hdCh4KSwgeTogcGFyc2VGbG9hdCh5KSwgejogLXBhcnNlRmxvYXQoeikgfSlcbiAgICB9IGVsc2UgaWYgKHRyaW1tZWQuc3RhcnRzV2l0aChcIm5ld210bCBcIikpIHtcbiAgICAgIGFjdGl2ZU1hdGVyaWFsID0gdHJpbW1lZC5zcGxpdCgvXFxzKy8pWzFdIVxuICAgIH0gZWxzZSBpZiAodHJpbW1lZC5zdGFydHNXaXRoKFwiS2QgXCIpICYmIGFjdGl2ZU1hdGVyaWFsKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHRyaW1tZWQuc3BsaXQoL1xccysvKVxuICAgICAgY29uc3QgclN0ciA9IHBhcnRzWzFdIVxuICAgICAgY29uc3QgZ1N0ciA9IHBhcnRzWzJdIVxuICAgICAgY29uc3QgYlN0ciA9IHBhcnRzWzNdIVxuICAgICAgbGV0IHIgPSBwYXJzZUZsb2F0KHJTdHIpXG4gICAgICBsZXQgZyA9IHBhcnNlRmxvYXQoZ1N0cilcbiAgICAgIGxldCBiID0gcGFyc2VGbG9hdChiU3RyKVxuICAgICAgaWYgKHIgPD0gMSAmJiBnIDw9IDEgJiYgYiA8PSAxKSB7XG4gICAgICAgIHIgKj0gMjU1XG4gICAgICAgIGcgKj0gMjU1XG4gICAgICAgIGIgKj0gMjU1XG4gICAgICB9XG4gICAgICBtYXRlcmlhbENvbG9yc1thY3RpdmVNYXRlcmlhbF0gPSBbciwgZywgYiwgMV1cbiAgICB9IGVsc2UgaWYgKHRyaW1tZWQuc3RhcnRzV2l0aChcInVzZW10bCBcIikpIHtcbiAgICAgIGFjdGl2ZU1hdGVyaWFsID0gdHJpbW1lZC5zcGxpdCgvXFxzKy8pWzFdIVxuICAgIH0gZWxzZSBpZiAodHJpbW1lZC5zdGFydHNXaXRoKFwiZiBcIikpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdHJpbW1lZC5zbGljZSgyKS50cmltKCkuc3BsaXQoL1xccysvKVxuICAgICAgY29uc3QgaWR4cyA9IHBhcnRzLm1hcCgocCkgPT4ge1xuICAgICAgICBjb25zdCBbdmksICwgbmldID0gcC5zcGxpdChcIi9cIikgYXMgW3N0cmluZywgc3RyaW5nLCBzdHJpbmddXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdjogcGFyc2VJbnQodmkpIC0gMSxcbiAgICAgICAgICBuOiBuaSA/IHBhcnNlSW50KG5pKSAtIDEgOiB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlkeHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBpZHhzWzBdIVxuICAgICAgICBjb25zdCBiID0gaWR4c1tpXSFcbiAgICAgICAgY29uc3QgYyA9IGlkeHNbaSArIDFdIVxuICAgICAgICBjb25zdCB2MCA9IHZlcnRpY2VzW2Eudl0hXG4gICAgICAgIGNvbnN0IHYxID0gdmVydGljZXNbYi52XSFcbiAgICAgICAgY29uc3QgdjIgPSB2ZXJ0aWNlc1tjLnZdIVxuICAgICAgICBsZXQgbm9ybWFsOiBQb2ludDNcbiAgICAgICAgaWYgKGEubiAhPT0gdW5kZWZpbmVkICYmIG5vcm1hbHNbYS5uXSkge1xuICAgICAgICAgIG5vcm1hbCA9IG5vcm1hbHNbYS5uXSFcbiAgICAgICAgfSBlbHNlIGlmIChiLm4gIT09IHVuZGVmaW5lZCAmJiBub3JtYWxzW2Iubl0pIHtcbiAgICAgICAgICBub3JtYWwgPSBub3JtYWxzW2Iubl0hXG4gICAgICAgIH0gZWxzZSBpZiAoYy5uICE9PSB1bmRlZmluZWQgJiYgbm9ybWFsc1tjLm5dKSB7XG4gICAgICAgICAgbm9ybWFsID0gbm9ybWFsc1tjLm5dIVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGVkZ2UxID0ge1xuICAgICAgICAgICAgeDogdjEueCAtIHYwLngsXG4gICAgICAgICAgICB5OiB2MS55IC0gdjAueSxcbiAgICAgICAgICAgIHo6IHYxLnogLSB2MC56LFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlZGdlMiA9IHtcbiAgICAgICAgICAgIHg6IHYyLnggLSB2MC54LFxuICAgICAgICAgICAgeTogdjIueSAtIHYwLnksXG4gICAgICAgICAgICB6OiB2Mi56IC0gdjAueixcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9ybWFsID0ge1xuICAgICAgICAgICAgeDogZWRnZTEueSAqIGVkZ2UyLnogLSBlZGdlMS56ICogZWRnZTIueSxcbiAgICAgICAgICAgIHk6IGVkZ2UxLnogKiBlZGdlMi54IC0gZWRnZTEueCAqIGVkZ2UyLnosXG4gICAgICAgICAgICB6OiAtKGVkZ2UxLnggKiBlZGdlMi55IC0gZWRnZTEueSAqIGVkZ2UyLngpLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29sb3I6IENvbG9yIHwgdW5kZWZpbmVkXG4gICAgICAgIGlmIChhY3RpdmVNYXRlcmlhbCAmJiBtYXRlcmlhbENvbG9yc1thY3RpdmVNYXRlcmlhbF0pIHtcbiAgICAgICAgICBjb2xvciA9IG1hdGVyaWFsQ29sb3JzW2FjdGl2ZU1hdGVyaWFsXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbG9yID0gdmVydGV4Q29sb3JzW2Eudl0gPz8gdmVydGV4Q29sb3JzW2Iudl0gPz8gdmVydGV4Q29sb3JzW2Mudl1cbiAgICAgICAgfVxuICAgICAgICB0cmlhbmdsZXMucHVzaCh7IHZlcnRpY2VzOiBbdjAsIHYxLCB2Ml0sIG5vcm1hbCwgY29sb3IgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRyaWFuZ2xlcyxcbiAgICBib3VuZGluZ0JveDogY2FsY3VsYXRlQm91bmRpbmdCb3godHJpYW5nbGVzKSxcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVCb3VuZGluZ0JveCh0cmlhbmdsZXM6IFRyaWFuZ2xlW10pOiB7XG4gIG1pbjogUG9pbnQzXG4gIG1heDogUG9pbnQzXG59IHtcbiAgaWYgKHRyaWFuZ2xlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyBtaW46IHsgeDogMCwgeTogMCwgejogMCB9LCBtYXg6IHsgeDogMCwgeTogMCwgejogMCB9IH1cbiAgfVxuXG4gIGxldCBtaW5YID0gSW5maW5pdHlcbiAgbGV0IG1pblkgPSBJbmZpbml0eVxuICBsZXQgbWluWiA9IEluZmluaXR5XG4gIGxldCBtYXhYID0gLUluZmluaXR5XG4gIGxldCBtYXhZID0gLUluZmluaXR5XG4gIGxldCBtYXhaID0gLUluZmluaXR5XG5cbiAgZm9yIChjb25zdCB0cmkgb2YgdHJpYW5nbGVzKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIHRyaS52ZXJ0aWNlcykge1xuICAgICAgaWYgKHYueCA8IG1pblgpIG1pblggPSB2LnhcbiAgICAgIGlmICh2LnkgPCBtaW5ZKSBtaW5ZID0gdi55XG4gICAgICBpZiAodi56IDwgbWluWikgbWluWiA9IHYuelxuICAgICAgaWYgKHYueCA+IG1heFgpIG1heFggPSB2LnhcbiAgICAgIGlmICh2LnkgPiBtYXhZKSBtYXhZID0gdi55XG4gICAgICBpZiAodi56ID4gbWF4WikgbWF4WiA9IHYuelxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiB7IHg6IG1pblgsIHk6IG1pblksIHo6IG1pblogfSxcbiAgICBtYXg6IHsgeDogbWF4WCwgeTogbWF4WSwgejogbWF4WiB9LFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBQb2ludDMsIFNUTE1lc2gsIFRyaWFuZ2xlIH0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCB7IHVuemlwU3luYyB9IGZyb20gXCJmZmxhdGVcIlxuaW1wb3J0IHsgWE1MUGFyc2VyIH0gZnJvbSBcImZhc3QteG1sLXBhcnNlclwiXG5cbmNvbnN0IHRocmVlTWZDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBTVExNZXNoPigpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkM01GKHVybDogc3RyaW5nKTogUHJvbWlzZTxTVExNZXNoPiB7XG4gIGlmICh0aHJlZU1mQ2FjaGUuaGFzKHVybCkpIHtcbiAgICByZXR1cm4gdGhyZWVNZkNhY2hlLmdldCh1cmwpIVxuICB9XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpXG4gIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKClcbiAgY29uc3QgZmlsZXMgPSB1bnppcFN5bmMobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSlcbiAgY29uc3QgbW9kZWxGaWxlID0gZmlsZXNbXCIzRC8zZG1vZGVsLm1vZGVsXCJdXG4gIGlmICghbW9kZWxGaWxlKSB0aHJvdyBuZXcgRXJyb3IoXCIzTUYgbW9kZWwgZmlsZSBub3QgZm91bmRcIilcbiAgY29uc3QgbW9kZWxYbWwgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobW9kZWxGaWxlKVxuICBjb25zdCBtZXNoID0gcGFyc2UzTUYobW9kZWxYbWwpXG4gIHRocmVlTWZDYWNoZS5zZXQodXJsLCBtZXNoKVxuICByZXR1cm4gbWVzaFxufVxuXG5mdW5jdGlvbiBwYXJzZTNNRih4bWw6IHN0cmluZyk6IFNUTE1lc2gge1xuICBjb25zdCBwYXJzZXIgPSBuZXcgWE1MUGFyc2VyKHsgaWdub3JlQXR0cmlidXRlczogZmFsc2UgfSlcbiAgY29uc3QganNvbiA9IHBhcnNlci5wYXJzZSh4bWwpXG4gIGNvbnN0IHZlcnRleERhdGEgPVxuICAgIGpzb24/Lm1vZGVsPy5yZXNvdXJjZXM/Lm9iamVjdD8ubWVzaD8udmVydGljZXM/LnZlcnRleCA/PyBbXVxuICBjb25zdCB2ZXJ0aWNlc0FyciA9IEFycmF5LmlzQXJyYXkodmVydGV4RGF0YSkgPyB2ZXJ0ZXhEYXRhIDogW3ZlcnRleERhdGFdXG4gIGNvbnN0IHZlcnRpY2VzOiBQb2ludDNbXSA9IHZlcnRpY2VzQXJyLm1hcCgodjogYW55KSA9PiAoe1xuICAgIHg6IHBhcnNlRmxvYXQodltcIkBfeFwiXSksXG4gICAgeTogcGFyc2VGbG9hdCh2W1wiQF95XCJdKSxcbiAgICB6OiBwYXJzZUZsb2F0KHZbXCJAX3pcIl0pLFxuICB9KSlcblxuICBjb25zdCBiYXNlTWF0ZXJpYWxzID0ganNvbj8ubW9kZWw/LnJlc291cmNlcz8uYmFzZW1hdGVyaWFsc1xuICBjb25zdCBtYXRlcmlhbENvbG9yczogUmVjb3JkPHN0cmluZywgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1bXT4gPSB7fVxuICBpZiAoYmFzZU1hdGVyaWFscykge1xuICAgIGNvbnN0IG1hdHMgPSBBcnJheS5pc0FycmF5KGJhc2VNYXRlcmlhbHMpID8gYmFzZU1hdGVyaWFscyA6IFtiYXNlTWF0ZXJpYWxzXVxuICAgIGZvciAoY29uc3QgbWF0IG9mIG1hdHMpIHtcbiAgICAgIGNvbnN0IGlkID0gbWF0W1wiQF9pZFwiXVxuICAgICAgY29uc3QgYmFzZXMgPSBtYXQuYmFzZSA/PyBbXVxuICAgICAgY29uc3QgYmFzZXNBcnIgPSBBcnJheS5pc0FycmF5KGJhc2VzKSA/IGJhc2VzIDogW2Jhc2VzXVxuICAgICAgbWF0ZXJpYWxDb2xvcnNbaWRdID0gYmFzZXNBcnIubWFwKChiOiBhbnkpID0+XG4gICAgICAgIHBhcnNlRGlzcGxheUNvbG9yKGJbXCJAX2Rpc3BsYXljb2xvclwiXSksXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdHJpYW5nbGVEYXRhID1cbiAgICBqc29uPy5tb2RlbD8ucmVzb3VyY2VzPy5vYmplY3Q/Lm1lc2g/LnRyaWFuZ2xlcz8udHJpYW5nbGUgPz8gW11cbiAgY29uc3QgdHJpYW5nbGVzQXJyID0gQXJyYXkuaXNBcnJheSh0cmlhbmdsZURhdGEpXG4gICAgPyB0cmlhbmdsZURhdGFcbiAgICA6IFt0cmlhbmdsZURhdGFdXG4gIGNvbnN0IHRyaWFuZ2xlczogVHJpYW5nbGVbXSA9IHRyaWFuZ2xlc0Fyci5tYXAoKHQ6IGFueSkgPT4ge1xuICAgIGNvbnN0IHYxID0gdmVydGljZXNbcGFyc2VJbnQodFtcIkBfdjFcIl0pXSFcbiAgICBjb25zdCB2MiA9IHZlcnRpY2VzW3BhcnNlSW50KHRbXCJAX3YyXCJdKV0hXG4gICAgY29uc3QgdjMgPSB2ZXJ0aWNlc1twYXJzZUludCh0W1wiQF92M1wiXSldIVxuICAgIGNvbnN0IGVkZ2UxID0geyB4OiB2Mi54IC0gdjEueCwgeTogdjIueSAtIHYxLnksIHo6IHYyLnogLSB2MS56IH1cbiAgICBjb25zdCBlZGdlMiA9IHsgeDogdjMueCAtIHYxLngsIHk6IHYzLnkgLSB2MS55LCB6OiB2My56IC0gdjEueiB9XG4gICAgY29uc3Qgbm9ybWFsID0ge1xuICAgICAgeDogZWRnZTEueSAqIGVkZ2UyLnogLSBlZGdlMS56ICogZWRnZTIueSxcbiAgICAgIHk6IGVkZ2UxLnogKiBlZGdlMi54IC0gZWRnZTEueCAqIGVkZ2UyLnosXG4gICAgICB6OiAtKGVkZ2UxLnggKiBlZGdlMi55IC0gZWRnZTEueSAqIGVkZ2UyLngpLFxuICAgIH1cbiAgICBsZXQgY29sb3JcbiAgICBjb25zdCBwaWQgPSB0W1wiQF9waWRcIl1cbiAgICBpZiAocGlkICYmIG1hdGVyaWFsQ29sb3JzW3BpZF0pIHtcbiAgICAgIGNvbnN0IGlkeCA9IHBhcnNlSW50KHRbXCJAX3AxXCJdID8/IHRbXCJAX3AyXCJdID8/IHRbXCJAX3AzXCJdID8/IFwiMFwiKVxuICAgICAgY29sb3IgPSBtYXRlcmlhbENvbG9yc1twaWRdW2lkeF1cbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yXG4gICAgICA/IHsgdmVydGljZXM6IFt2MSwgdjIsIHYzXSwgbm9ybWFsLCBjb2xvciB9XG4gICAgICA6IHsgdmVydGljZXM6IFt2MSwgdjIsIHYzXSwgbm9ybWFsIH1cbiAgfSlcblxuICBjb25zdCByb3RhdGVkVHJpYW5nbGVzID0gdHJpYW5nbGVzLm1hcCgodHJpKSA9PiAoe1xuICAgIC4uLnRyaSxcbiAgICB2ZXJ0aWNlczogdHJpLnZlcnRpY2VzLm1hcCgodikgPT4gKHtcbiAgICAgIHg6IHYueCxcbiAgICAgIHk6IC12LnosXG4gICAgICB6OiB2LnksXG4gICAgfSkpIGFzIFtQb2ludDMsIFBvaW50MywgUG9pbnQzXSxcbiAgICBub3JtYWw6IHtcbiAgICAgIHg6IHRyaS5ub3JtYWwueCxcbiAgICAgIHk6IC10cmkubm9ybWFsLnosXG4gICAgICB6OiB0cmkubm9ybWFsLnksXG4gICAgfSxcbiAgfSkpXG5cbiAgcmV0dXJuIHtcbiAgICB0cmlhbmdsZXM6IHJvdGF0ZWRUcmlhbmdsZXMsXG4gICAgYm91bmRpbmdCb3g6IGNhbGN1bGF0ZUJvdW5kaW5nQm94KHJvdGF0ZWRUcmlhbmdsZXMpLFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGlzcGxheUNvbG9yKHN0cjogc3RyaW5nKTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICBpZiAoc3RyPy5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgIGNvbnN0IGhleCA9IHN0ci5zbGljZSgxKVxuICAgIGlmIChoZXgubGVuZ3RoID09PSA4KSB7XG4gICAgICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnNsaWNlKDAsIDIpLCAxNilcbiAgICAgIGNvbnN0IGcgPSBwYXJzZUludChoZXguc2xpY2UoMiwgNCksIDE2KVxuICAgICAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zbGljZSg0LCA2KSwgMTYpXG4gICAgICBjb25zdCBhID0gcGFyc2VJbnQoaGV4LnNsaWNlKDYsIDgpLCAxNikgLyAyNTVcbiAgICAgIHJldHVybiBbciwgZywgYiwgYV1cbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggPT09IDYpIHtcbiAgICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguc2xpY2UoMCwgMiksIDE2KVxuICAgICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zbGljZSgyLCA0KSwgMTYpXG4gICAgICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnNsaWNlKDQsIDYpLCAxNilcbiAgICAgIHJldHVybiBbciwgZywgYiwgMV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFswLCAwLCAwLCAxXVxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVCb3VuZGluZ0JveCh0cmlhbmdsZXM6IFRyaWFuZ2xlW10pOiB7XG4gIG1pbjogUG9pbnQzXG4gIG1heDogUG9pbnQzXG59IHtcbiAgaWYgKHRyaWFuZ2xlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyBtaW46IHsgeDogMCwgeTogMCwgejogMCB9LCBtYXg6IHsgeDogMCwgeTogMCwgejogMCB9IH1cbiAgfVxuXG4gIGxldCBtaW5YID0gSW5maW5pdHlcbiAgbGV0IG1pblkgPSBJbmZpbml0eVxuICBsZXQgbWluWiA9IEluZmluaXR5XG4gIGxldCBtYXhYID0gLUluZmluaXR5XG4gIGxldCBtYXhZID0gLUluZmluaXR5XG4gIGxldCBtYXhaID0gLUluZmluaXR5XG5cbiAgZm9yIChjb25zdCB0cmkgb2YgdHJpYW5nbGVzKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIHRyaS52ZXJ0aWNlcykge1xuICAgICAgaWYgKHYueCA8IG1pblgpIG1pblggPSB2LnhcbiAgICAgIGlmICh2LnkgPCBtaW5ZKSBtaW5ZID0gdi55XG4gICAgICBpZiAodi56IDwgbWluWikgbWluWiA9IHYuelxuICAgICAgaWYgKHYueCA+IG1heFgpIG1heFggPSB2LnhcbiAgICAgIGlmICh2LnkgPiBtYXhZKSBtYXhZID0gdi55XG4gICAgICBpZiAodi56ID4gbWF4WikgbWF4WiA9IHYuelxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiB7IHg6IG1pblgsIHk6IG1pblksIHo6IG1pblogfSxcbiAgICBtYXg6IHsgeDogbWF4WCwgeTogbWF4WSwgejogbWF4WiB9LFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBQb2ludDMsIFNUTE1lc2gsIEJveCB9IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCB7IGFkZCwgc3ViLCBzY2FsZSwgcm90TG9jYWwgfSBmcm9tIFwiLi92ZWMzXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kUG9zaXRpb25NZXNoKFxuICBtZXNoOiBTVExNZXNoLFxuICBib3g6IEJveCxcbiAgc2NhbGVUb0JveDogYm9vbGVhbixcbiAgbW9kZWxUeXBlOiBcInN0bFwiIHwgXCJvYmpcIiB8IFwiM21mXCIsXG4pOiBQb2ludDNbXSB7XG4gIGNvbnN0IHsgYm91bmRpbmdCb3ggfSA9IG1lc2hcbiAgY29uc3QgbWVzaENlbnRlciA9IHNjYWxlKGFkZChib3VuZGluZ0JveC5taW4sIGJvdW5kaW5nQm94Lm1heCksIDAuNSlcbiAgY29uc3QgY2VudGVyTW9kZWwgPSBib3guY2VudGVyTW9kZWwgIT09IGZhbHNlXG5cbiAgLy8gUm90YXRlIHZlcnRpY2VzIGFyb3VuZCB0aGUgbWVzaCBjZW50ZXJcbiAgY29uc3Qgcm90YXRlZFZlcnRzOiBQb2ludDNbXSA9IFtdXG4gIGZvciAoY29uc3QgdHJpIG9mIG1lc2gudHJpYW5nbGVzKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIHRyaS52ZXJ0aWNlcykge1xuICAgICAgbGV0IHAgPSBzdWIodiwgbWVzaENlbnRlcilcbiAgICAgIGlmIChtb2RlbFR5cGUgPT09IFwic3RsXCIgJiYgYm94LnN0bFJvdGF0aW9uKVxuICAgICAgICBwID0gcm90TG9jYWwocCwgYm94LnN0bFJvdGF0aW9uKVxuICAgICAgaWYgKG1vZGVsVHlwZSA9PT0gXCJvYmpcIiAmJiBib3gub2JqUm90YXRpb24pXG4gICAgICAgIHAgPSByb3RMb2NhbChwLCBib3gub2JqUm90YXRpb24pXG4gICAgICBpZiAobW9kZWxUeXBlID09PSBcIjNtZlwiICYmIGJveC50aHJlZU1mUm90YXRpb24pXG4gICAgICAgIHAgPSByb3RMb2NhbChwLCBib3gudGhyZWVNZlJvdGF0aW9uKVxuICAgICAgaWYgKCFjZW50ZXJNb2RlbCkgcCA9IGFkZChwLCBtZXNoQ2VudGVyKVxuICAgICAgcm90YXRlZFZlcnRzLnB1c2gocClcbiAgICB9XG4gIH1cblxuICBsZXQgdW5pZm9ybVNjYWxlID0gMVxuICBsZXQgcm90YXRlZENlbnRlciA9IHsgeDogMCwgeTogMCwgejogMCB9XG5cbiAgaWYgKHNjYWxlVG9Cb3gpIHtcbiAgICAvLyBDb21wdXRlIGJvdW5kaW5nIGJveCBhZnRlciByb3RhdGlvblxuICAgIGxldCBtaW4gPSB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSwgejogSW5maW5pdHkgfVxuICAgIGxldCBtYXggPSB7IHg6IC1JbmZpbml0eSwgeTogLUluZmluaXR5LCB6OiAtSW5maW5pdHkgfVxuICAgIGZvciAoY29uc3QgdiBvZiByb3RhdGVkVmVydHMpIHtcbiAgICAgIGlmICh2LnggPCBtaW4ueCkgbWluLnggPSB2LnhcbiAgICAgIGlmICh2LnkgPCBtaW4ueSkgbWluLnkgPSB2LnlcbiAgICAgIGlmICh2LnogPCBtaW4ueikgbWluLnogPSB2LnpcbiAgICAgIGlmICh2LnggPiBtYXgueCkgbWF4LnggPSB2LnhcbiAgICAgIGlmICh2LnkgPiBtYXgueSkgbWF4LnkgPSB2LnlcbiAgICAgIGlmICh2LnogPiBtYXgueikgbWF4LnogPSB2LnpcbiAgICB9XG4gICAgY29uc3Qgcm90YXRlZFNpemUgPSBzdWIobWF4LCBtaW4pXG4gICAgY29uc3QgYm94U2l6ZSA9IGJveC5zaXplXG4gICAgY29uc3Qgc2NhbGVYID0gYm94U2l6ZS54IC8gcm90YXRlZFNpemUueFxuICAgIGNvbnN0IHNjYWxlWSA9IGJveFNpemUueSAvIHJvdGF0ZWRTaXplLnlcbiAgICBjb25zdCBzY2FsZVogPSBib3hTaXplLnogLyByb3RhdGVkU2l6ZS56XG4gICAgdW5pZm9ybVNjYWxlID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVksIHNjYWxlWilcbiAgICByb3RhdGVkQ2VudGVyID0gc2NhbGUoYWRkKG1pbiwgbWF4KSwgMC41KVxuICB9XG5cbiAgY29uc3QgdHJhbnNmb3JtZWRWZXJ0aWNlczogUG9pbnQzW10gPSBbXVxuICBmb3IgKGNvbnN0IHAgb2Ygcm90YXRlZFZlcnRzKSB7XG4gICAgbGV0IHQgPSBwXG4gICAgaWYgKHNjYWxlVG9Cb3gpIHtcbiAgICAgIHQgPSBzdWIodCwgcm90YXRlZENlbnRlcilcbiAgICAgIHQgPSBzY2FsZSh0LCB1bmlmb3JtU2NhbGUpXG4gICAgICBpZiAoIWNlbnRlck1vZGVsKSB0ID0gYWRkKHQsIHJvdGF0ZWRDZW50ZXIpXG4gICAgfVxuICAgIGlmIChib3guc3RsUG9zaXRpb24pIHQgPSBhZGQodCwgYm94LnN0bFBvc2l0aW9uKVxuICAgIGlmIChib3gub2JqUG9zaXRpb24pIHQgPSBhZGQodCwgYm94Lm9ialBvc2l0aW9uKVxuICAgIGlmIChib3gudGhyZWVNZlBvc2l0aW9uKSB0ID0gYWRkKHQsIGJveC50aHJlZU1mUG9zaXRpb24pXG4gICAgaWYgKGJveC5yb3RhdGlvbikgdCA9IHJvdExvY2FsKHQsIGJveC5yb3RhdGlvbilcbiAgICB0ID0gYWRkKHQsIGJveC5jZW50ZXIpXG4gICAgdHJhbnNmb3JtZWRWZXJ0aWNlcy5wdXNoKHQpXG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtZWRWZXJ0aWNlc1xufVxuIiwgImltcG9ydCB0eXBlIHsgUG9pbnQzLCBCb3ggfSBmcm9tIFwiLi90eXBlc1wiXG5pbXBvcnQgeyBhZGQsIHJvdExvY2FsIH0gZnJvbSBcIi4vdmVjM1wiXG5cbi8vIGZhY2VzOiBmcm9udCwgYmFjaywgYm90dG9tLCB0b3AsIHJpZ2h0LCBsZWZ0XG5leHBvcnQgY29uc3QgRkFDRVM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdW10gPSBbXG4gIFswLCAxLCAyLCAzXSxcbiAgWzQsIDcsIDYsIDVdLFxuICBbMCwgMSwgNSwgNF0sXG4gIFszLCAyLCA2LCA3XSxcbiAgWzEsIDIsIDYsIDVdLFxuICBbMCwgMywgNywgNF0sXG5dXG5leHBvcnQgY29uc3QgRURHRVM6IFtudW1iZXIsIG51bWJlcl1bXSA9IFtcbiAgWzAsIDFdLFxuICBbMSwgMl0sXG4gIFsyLCAzXSxcbiAgWzMsIDBdLFxuICBbNCwgNV0sXG4gIFs1LCA2XSxcbiAgWzYsIDddLFxuICBbNywgNF0sXG4gIFswLCA0XSxcbiAgWzEsIDVdLFxuICBbMiwgNl0sXG4gIFszLCA3XSxcbl1cbmV4cG9ydCBjb25zdCBUT1AgPSBbMywgMiwgNiwgN10gYXMgY29uc3RcblxuZXhwb3J0IGZ1bmN0aW9uIHZlcnRzKGI6IEJveCk6IFBvaW50M1tdIHtcbiAgY29uc3Qge1xuICAgIHNpemU6IHsgeDogc3gsIHk6IHN5LCB6OiBzeiB9LFxuICAgIGNlbnRlcixcbiAgICByb3RhdGlvbixcbiAgfSA9IGJcbiAgY29uc3Qgb2ZmcyA9IFtcbiAgICB7IHg6IC1zeCAvIDIsIHk6IC1zeSAvIDIsIHo6IC1zeiAvIDIgfSxcbiAgICB7IHg6IHN4IC8gMiwgeTogLXN5IC8gMiwgejogLXN6IC8gMiB9LFxuICAgIHsgeDogc3ggLyAyLCB5OiBzeSAvIDIsIHo6IC1zeiAvIDIgfSxcbiAgICB7IHg6IC1zeCAvIDIsIHk6IHN5IC8gMiwgejogLXN6IC8gMiB9LFxuICAgIHsgeDogLXN4IC8gMiwgeTogLXN5IC8gMiwgejogc3ogLyAyIH0sXG4gICAgeyB4OiBzeCAvIDIsIHk6IC1zeSAvIDIsIHo6IHN6IC8gMiB9LFxuICAgIHsgeDogc3ggLyAyLCB5OiBzeSAvIDIsIHo6IHN6IC8gMiB9LFxuICAgIHsgeDogLXN4IC8gMiwgeTogc3kgLyAyLCB6OiBzeiAvIDIgfSxcbiAgXVxuICByZXR1cm4gb2Zmcy5tYXAoKG8pID0+IGFkZChjZW50ZXIsIHJvdExvY2FsKG8sIHJvdGF0aW9uKSkpXG59XG4iLCAiZXhwb3J0IGludGVyZmFjZSBQb2ludDIge1xuICB4OiBudW1iZXJcbiAgeTogbnVtYmVyXG59XG5cbi8qKlxuICogSW52ZXJ0IGEgM3gzIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52MyhcbiAgbTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdW10sXG4pOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl1bXSB7XG4gIGNvbnN0IGEgPSBtWzBdIVswXSxcbiAgICBkID0gbVswXSFbMV0sXG4gICAgZyA9IG1bMF0hWzJdXG4gIGNvbnN0IGIgPSBtWzFdIVswXSxcbiAgICBlID0gbVsxXSFbMV0sXG4gICAgaCA9IG1bMV0hWzJdXG4gIGNvbnN0IGMgPSBtWzJdIVswXSxcbiAgICBmID0gbVsyXSFbMV0sXG4gICAgaSA9IG1bMl0hWzJdXG4gIGNvbnN0IEEgPSBlICogaSAtIGYgKiBoXG4gIGNvbnN0IEIgPSAtKGQgKiBpIC0gZiAqIGcpXG4gIGNvbnN0IEMgPSBkICogaCAtIGUgKiBnXG4gIGNvbnN0IEQgPSAtKGIgKiBpIC0gYyAqIGgpXG4gIGNvbnN0IEUgPSBhICogaSAtIGMgKiBnXG4gIGNvbnN0IEYgPSAtKGEgKiBoIC0gYiAqIGcpXG4gIGNvbnN0IEcgPSBiICogZiAtIGMgKiBlXG4gIGNvbnN0IEggPSAtKGEgKiBmIC0gYyAqIGQpXG4gIGNvbnN0IEkgPSBhICogZSAtIGIgKiBkXG4gIGNvbnN0IGRldCA9IGEgKiBBICsgZCAqIEQgKyBnICogR1xuICBjb25zdCBpbnZEZXQgPSBkZXQgPyAxIC8gZGV0IDogMFxuICByZXR1cm4gW1xuICAgIFtBICogaW52RGV0LCBCICogaW52RGV0LCBDICogaW52RGV0XSxcbiAgICBbRCAqIGludkRldCwgRSAqIGludkRldCwgRiAqIGludkRldF0sXG4gICAgW0cgKiBpbnZEZXQsIEggKiBpbnZEZXQsIEkgKiBpbnZEZXRdLFxuICBdXG59XG5cbi8qKlxuICogTXVsdGlwbHkgdHdvIDN4MyBtYXRyaWNlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsMyhcbiAgYTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdW10sXG4gIGI6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVtdLFxuKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdW10ge1xuICBjb25zdCByOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl1bXSA9IFtcbiAgICBbMCwgMCwgMF0sXG4gICAgWzAsIDAsIDBdLFxuICAgIFswLCAwLCAwXSxcbiAgXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICByW2ldIVtqXSA9XG4gICAgICAgIGFbaV0hWzBdISAqIGJbMF0hW2pdISArIGFbaV0hWzFdISAqIGJbMV0hW2pdISArIGFbaV0hWzJdISAqIGJbMl0hW2pdIVxuICAgIH1cbiAgfVxuICByZXR1cm4gclxufVxuXG4vKiBQdWJsaWMgaGVscGVyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gYWZmaW5lTWF0cml4KFxuICBzcmM6IFtQb2ludDIsIFBvaW50MiwgUG9pbnQyXSxcbiAgZHN0OiBbUG9pbnQyLCBQb2ludDIsIFBvaW50Ml0sXG4pOiBzdHJpbmcge1xuICBjb25zdCBTOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl1bXSA9IFtcbiAgICBbc3JjWzBdLngsIHNyY1sxXS54LCBzcmNbMl0ueF0sXG4gICAgW3NyY1swXS55LCBzcmNbMV0ueSwgc3JjWzJdLnldLFxuICAgIFsxLCAxLCAxXSxcbiAgXVxuICBjb25zdCBEOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl1bXSA9IFtcbiAgICBbZHN0WzBdLngsIGRzdFsxXS54LCBkc3RbMl0ueF0sXG4gICAgW2RzdFswXS55LCBkc3RbMV0ueSwgZHN0WzJdLnldLFxuICAgIFsxLCAxLCAxXSxcbiAgXVxuICBjb25zdCBNID0gbXVsMyhELCBpbnYzKFMpKVxuICByZXR1cm4gYG1hdHJpeCgke01bMF0hWzBdfSAke01bMV0hWzBdfSAke01bMF0hWzFdfSAke01bMV0hWzFdfSAke01bMF0hWzJdfSAke01bMV0hWzJdfSlgXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBQb2ludDMsIENvbG9yLCBCb3gsIENhbWVyYSwgU2NlbmUsIFNUTE1lc2ggfSBmcm9tIFwiLi90eXBlc1wiXG5pbXBvcnQgeyBsb2FkU1RMIH0gZnJvbSBcIi4vbG9hZGVycy9zdGxcIlxuaW1wb3J0IHsgbG9hZE9CSiB9IGZyb20gXCIuL2xvYWRlcnMvb2JqXCJcbmltcG9ydCB7IGxvYWQzTUYgfSBmcm9tIFwiLi9sb2FkZXJzL3RocmVlbWZcIlxuaW1wb3J0IHsgYWRkLCBzdWIsIGRvdCwgY3Jvc3MsIHNjYWxlLCBsZW4sIG5vcm0sIHJvdExvY2FsIH0gZnJvbSBcIi4vdmVjM1wiXG5pbXBvcnQgeyBjb2xvclRvQ3NzLCBzaGFkZUJ5Tm9ybWFsIH0gZnJvbSBcIi4vY29sb3JcIlxuaW1wb3J0IHsgc2NhbGVBbmRQb3NpdGlvbk1lc2ggfSBmcm9tIFwiLi9tZXNoXCJcbmltcG9ydCB7IEZBQ0VTLCBFREdFUywgVE9QLCB2ZXJ0cyB9IGZyb20gXCIuL2dlb21ldHJ5XCJcbmltcG9ydCB7IGFmZmluZU1hdHJpeCB9IGZyb20gXCIuL2FmZmluZVwiXG5cbmZ1bmN0aW9uIGZtdChuOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gTWF0aC5yb3VuZChuKS50b1N0cmluZygpXG59XG5mdW5jdGlvbiBmbXRQcmVjaXNlKG46IG51bWJlcik6IHN0cmluZyB7XG4gIHJldHVybiAoTWF0aC5yb3VuZChuICogMTAwKSAvIDEwMCkudG9TdHJpbmcoKVxufVxuXG4vKlx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMCBDYW1lcmEgJiBQcm9qZWN0aW9uIFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMFx1MjUwMCovXG5jb25zdCBXX0RFRiA9IDQwMFxuY29uc3QgSF9ERUYgPSA0MDBcbmNvbnN0IEZPQ0FMID0gMlxuaW50ZXJmYWNlIFByb2oge1xuICB4OiBudW1iZXJcbiAgeTogbnVtYmVyXG4gIHo6IG51bWJlclxufVxuZnVuY3Rpb24gYXhlcyhjYW06IENhbWVyYSkge1xuICBjb25zdCBmID0gbm9ybShzdWIoY2FtLmxvb2tBdCwgY2FtLnBvc2l0aW9uKSlcbiAgY29uc3Qgd1VwID0geyB4OiAwLCB5OiAxLCB6OiAwIH1cbiAgbGV0IHIgPSBub3JtKGNyb3NzKGYsIHdVcCkpXG4gIGlmICghbGVuKHIpKSByID0geyB4OiAxLCB5OiAwLCB6OiAwIH1cbiAgY29uc3QgdSA9IGNyb3NzKHIsIGYpXG4gIHJldHVybiB7IHIsIHUsIGYgfVxufVxuZnVuY3Rpb24gdG9DYW0ocDogUG9pbnQzLCBjYW06IENhbWVyYSkge1xuICBjb25zdCB7IHIsIHUsIGYgfSA9IGF4ZXMoY2FtKVxuICBjb25zdCBkID0gc3ViKHAsIGNhbS5wb3NpdGlvbilcbiAgcmV0dXJuIHsgeDogZG90KGQsIHIpLCB5OiBkb3QoZCwgdSksIHo6IGRvdChkLCBmKSB9XG59XG5mdW5jdGlvbiBwcm9qKHA6IFBvaW50MywgdzogbnVtYmVyLCBoOiBudW1iZXIsIGZvY2FsOiBudW1iZXIpOiBQcm9qIHwgbnVsbCB7XG4gIGlmIChwLnogPD0gMCkgcmV0dXJuIG51bGxcbiAgY29uc3QgcyA9IGZvY2FsIC8gcC56XG4gIHJldHVybiB7IHg6IChwLnggKiBzICogdykgLyAyLCB5OiAoLXAueSAqIHMgKiBoKSAvIDIsIHo6IHAueiB9XG59XG5cbnR5cGUgRmFjZSA9IHtcbiAgcHRzOiBQcm9qW10gLy8gMi1EIHByb2plY3RlZCBwb2ludHMgKFNWRyBzcGFjZSlcbiAgY2FtOiBQb2ludDNbXSAvLyB0aGUgc2FtZSB2ZXJ0aWNlcyBpbiBDQU1FUkEgc3BhY2UgKHo+MClcbiAgZmlsbDogc3RyaW5nXG4gIHN0cm9rZTogYm9vbGVhblxufVxudHlwZSBMYWJlbCA9IHsgbWF0cml4OiBzdHJpbmc7IGRlcHRoOiBudW1iZXI7IHRleHQ6IHN0cmluZzsgZmlsbDogc3RyaW5nIH1cbnR5cGUgSW1nID0ge1xuICBtYXRyaXg6IHN0cmluZ1xuICBkZXB0aDogbnVtYmVyXG4gIGhyZWY6IHN0cmluZ1xuICBjbGlwOiBzdHJpbmdcbiAgcG9pbnRzOiBzdHJpbmdcbiAgc3ltPzogc3RyaW5nXG59XG50eXBlIEVkZ2UgPSB7IHB0czogW1Byb2osIFByb2pdOyBkZXB0aDogbnVtYmVyOyBjb2xvcjogc3RyaW5nIH1cbnR5cGUgUmVuZGVyRWxlbWVudCA9XG4gIHwgeyB0eXBlOiBcImZhY2VcIjsgZGF0YTogRmFjZSB9XG4gIHwgeyB0eXBlOiBcImltYWdlXCI7IGRhdGE6IEltZyB9XG4gIHwgeyB0eXBlOiBcImxhYmVsXCI7IGRhdGE6IExhYmVsIH1cbiAgfCB7IHR5cGU6IFwiZWRnZVwiOyBkYXRhOiBFZGdlIH1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkUmVuZGVyRWxlbWVudHMoXG4gIHNjZW5lOiBTY2VuZSxcbiAgb3B0OiB7IHdpZHRoPzogbnVtYmVyOyBoZWlnaHQ/OiBudW1iZXI7IGJhY2tncm91bmRDb2xvcj86IENvbG9yIH0gPSB7fSxcbik6IFByb21pc2U8e1xuICB3aWR0aDogbnVtYmVyXG4gIGhlaWdodDogbnVtYmVyXG4gIGJhY2tncm91bmRDb2xvcj86IENvbG9yXG4gIGVsZW1lbnRzOiBSZW5kZXJFbGVtZW50W11cbiAgaW1hZ2VzOiBJbWdbXVxuICB0ZXhJZDogTWFwPHN0cmluZywgc3RyaW5nPlxufT4ge1xuICBjb25zdCBXID0gb3B0LndpZHRoID8/IFdfREVGXG4gIGNvbnN0IEggPSBvcHQuaGVpZ2h0ID8/IEhfREVGXG4gIGNvbnN0IGZvY2FsID0gc2NlbmUuY2FtZXJhLmZvY2FsTGVuZ3RoID8/IEZPQ0FMXG4gIGNvbnN0IGZhY2VzOiBGYWNlW10gPSBbXVxuICBjb25zdCBpbWFnZXM6IEltZ1tdID0gW11cbiAgLy8gTWFwIGVhY2ggQlNQLXNvcnRlZCBGYWNlIGlmIGl0IGFjdHVhbGx5IHJlcHJlc2VudHMgYW4gPGltYWdlPiB0cmlhbmdsZVxuICBjb25zdCBmYWNlVG9JbWcgPSBuZXcgTWFwPEZhY2UsIEltZz4oKVxuICBjb25zdCBsYWJlbHM6IExhYmVsW10gPSBbXVxuICBjb25zdCBlZGdlczogRWRnZVtdID0gW11cbiAgbGV0IGNsaXBTZXEgPSAwXG4gIGNvbnN0IHRleElkID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKVxuXG4gIC8vIExvYWQgU1RMIG1lc2hlcyBmb3IgYm94ZXMgdGhhdCBoYXZlIHN0bFVybFxuICBjb25zdCBzdGxNZXNoZXMgPSBuZXcgTWFwPHN0cmluZywgU1RMTWVzaD4oKVxuICBjb25zdCBvYmpNZXNoZXMgPSBuZXcgTWFwPHN0cmluZywgU1RMTWVzaD4oKVxuICBjb25zdCB0aHJlZU1mTWVzaGVzID0gbmV3IE1hcDxzdHJpbmcsIFNUTE1lc2g+KClcbiAgZm9yIChjb25zdCBib3ggb2Ygc2NlbmUuYm94ZXMpIHtcbiAgICBpZiAoYm94LnN0bFVybCAmJiAhc3RsTWVzaGVzLmhhcyhib3guc3RsVXJsKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWVzaCA9IGF3YWl0IGxvYWRTVEwoYm94LnN0bFVybClcbiAgICAgICAgc3RsTWVzaGVzLnNldChib3guc3RsVXJsLCBtZXNoKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gbG9hZCBTVEwgZnJvbSAke2JveC5zdGxVcmx9OmAsIGVycm9yKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYm94Lm9ialVybCAmJiAhb2JqTWVzaGVzLmhhcyhib3gub2JqVXJsKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWVzaCA9IGF3YWl0IGxvYWRPQkooYm94Lm9ialVybClcbiAgICAgICAgb2JqTWVzaGVzLnNldChib3gub2JqVXJsLCBtZXNoKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gbG9hZCBPQkogZnJvbSAke2JveC5vYmpVcmx9OmAsIGVycm9yKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYm94LnRocmVlTWZVcmwgJiYgIXRocmVlTWZNZXNoZXMuaGFzKGJveC50aHJlZU1mVXJsKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWVzaCA9IGF3YWl0IGxvYWQzTUYoYm94LnRocmVlTWZVcmwpXG4gICAgICAgIHRocmVlTWZNZXNoZXMuc2V0KGJveC50aHJlZU1mVXJsLCBtZXNoKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gbG9hZCAzTUYgZnJvbSAke2JveC50aHJlZU1mVXJsfTpgLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGJveCBvZiBzY2VuZS5ib3hlcykge1xuICAgIGNvbnN0IGJ3ID0gdmVydHMoYm94KVxuICAgIGNvbnN0IGJjID0gYncubWFwKCh2KSA9PiB0b0NhbSh2LCBzY2VuZS5jYW1lcmEpKVxuICAgIGNvbnN0IGJwID0gYmMubWFwKCh2KSA9PiBwcm9qKHYsIFcsIEgsIGZvY2FsKSlcblxuICAgIGlmIChib3guZHJhd0JvdW5kaW5nQm94KSB7XG4gICAgICBmb3IgKGNvbnN0IFthLCBiXSBvZiBFREdFUykge1xuICAgICAgICBjb25zdCBwYSA9IGJwW2FdXG4gICAgICAgIGNvbnN0IHBiID0gYnBbYl1cbiAgICAgICAgaWYgKHBhICYmIHBiKSB7XG4gICAgICAgICAgY29uc3QgZGVwdGggPSBNYXRoLm1heChiY1thXSEueiwgYmNbYl0hLnopXG4gICAgICAgICAgZWRnZXMucHVzaCh7IHB0czogW3BhLCBwYl0sIGRlcHRoLCBjb2xvcjogXCJyZ2JhKDAsMCwwLDAuNSlcIiB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIFNUTCByZW5kZXJpbmdcbiAgICBpZiAoYm94LnN0bFVybCAmJiBzdGxNZXNoZXMuaGFzKGJveC5zdGxVcmwpKSB7XG4gICAgICBjb25zdCBtZXNoID0gc3RsTWVzaGVzLmdldChib3guc3RsVXJsKSFcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVmVydGljZXMgPSBzY2FsZUFuZFBvc2l0aW9uTWVzaChcbiAgICAgICAgbWVzaCxcbiAgICAgICAgYm94LFxuICAgICAgICBib3guc2NhbGVTdGxUb0JveCA/PyBmYWxzZSxcbiAgICAgICAgXCJzdGxcIixcbiAgICAgIClcblxuICAgICAgLy8gUmVuZGVyIFNUTCB0cmlhbmdsZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzaC50cmlhbmdsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJpYW5nbGUgPSBtZXNoLnRyaWFuZ2xlc1tpXVxuICAgICAgICBjb25zdCB2ZXJ0ZXhTdGFydCA9IGkgKiAzXG5cbiAgICAgICAgY29uc3QgdjB3ID0gdHJhbnNmb3JtZWRWZXJ0aWNlc1t2ZXJ0ZXhTdGFydF0hXG4gICAgICAgIGNvbnN0IHYxdyA9IHRyYW5zZm9ybWVkVmVydGljZXNbdmVydGV4U3RhcnQgKyAxXSFcbiAgICAgICAgY29uc3QgdjJ3ID0gdHJhbnNmb3JtZWRWZXJ0aWNlc1t2ZXJ0ZXhTdGFydCArIDJdIVxuXG4gICAgICAgIGNvbnN0IHYwYyA9IHRvQ2FtKHYwdywgc2NlbmUuY2FtZXJhKVxuICAgICAgICBjb25zdCB2MWMgPSB0b0NhbSh2MXcsIHNjZW5lLmNhbWVyYSlcbiAgICAgICAgY29uc3QgdjJjID0gdG9DYW0odjJ3LCBzY2VuZS5jYW1lcmEpXG5cbiAgICAgICAgY29uc3QgdjBwID0gcHJvaih2MGMsIFcsIEgsIGZvY2FsKVxuICAgICAgICBjb25zdCB2MXAgPSBwcm9qKHYxYywgVywgSCwgZm9jYWwpXG4gICAgICAgIGNvbnN0IHYycCA9IHByb2oodjJjLCBXLCBILCBmb2NhbClcblxuICAgICAgICBpZiAodjBwICYmIHYxcCAmJiB2MnApIHtcbiAgICAgICAgICBjb25zdCBlZGdlMSA9IHN1Yih2MWMsIHYwYylcbiAgICAgICAgICBjb25zdCBlZGdlMiA9IHN1Yih2MmMsIHYwYylcbiAgICAgICAgICBjb25zdCBub3JtYWwgPSBjcm9zcyhlZGdlMSwgZWRnZTIpXG4gICAgICAgICAgY29uc3QgYmFzZUNvbG9yID0gYm94LmNvbG9yID8/IFwiZ3JheVwiXG4gICAgICAgICAgZmFjZXMucHVzaCh7XG4gICAgICAgICAgICBwdHM6IFt2MHAsIHYxcCwgdjJwXSxcbiAgICAgICAgICAgIGNhbTogW3YwYywgdjFjLCB2MmNdLFxuICAgICAgICAgICAgZmlsbDogc2hhZGVCeU5vcm1hbChiYXNlQ29sb3IsIG5vcm1hbCksXG4gICAgICAgICAgICBzdHJva2U6IGZhbHNlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJveC5vYmpVcmwgJiYgb2JqTWVzaGVzLmhhcyhib3gub2JqVXJsKSkge1xuICAgICAgY29uc3QgbWVzaCA9IG9iak1lc2hlcy5nZXQoYm94Lm9ialVybCkhXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFZlcnRpY2VzID0gc2NhbGVBbmRQb3NpdGlvbk1lc2goXG4gICAgICAgIG1lc2gsXG4gICAgICAgIGJveCxcbiAgICAgICAgYm94LnNjYWxlT2JqVG9Cb3ggPz8gZmFsc2UsXG4gICAgICAgIFwib2JqXCIsXG4gICAgICApXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzaC50cmlhbmdsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmVydGV4U3RhcnQgPSBpICogM1xuICAgICAgICBjb25zdCB0cmlhbmdsZSA9IG1lc2gudHJpYW5nbGVzW2ldIVxuXG4gICAgICAgIGNvbnN0IHYwdyA9IHRyYW5zZm9ybWVkVmVydGljZXNbdmVydGV4U3RhcnRdIVxuICAgICAgICBjb25zdCB2MXcgPSB0cmFuc2Zvcm1lZFZlcnRpY2VzW3ZlcnRleFN0YXJ0ICsgMV0hXG4gICAgICAgIGNvbnN0IHYydyA9IHRyYW5zZm9ybWVkVmVydGljZXNbdmVydGV4U3RhcnQgKyAyXSFcblxuICAgICAgICBjb25zdCB2MGMgPSB0b0NhbSh2MHcsIHNjZW5lLmNhbWVyYSlcbiAgICAgICAgY29uc3QgdjFjID0gdG9DYW0odjF3LCBzY2VuZS5jYW1lcmEpXG4gICAgICAgIGNvbnN0IHYyYyA9IHRvQ2FtKHYydywgc2NlbmUuY2FtZXJhKVxuXG4gICAgICAgIGNvbnN0IHYwcCA9IHByb2oodjBjLCBXLCBILCBmb2NhbClcbiAgICAgICAgY29uc3QgdjFwID0gcHJvaih2MWMsIFcsIEgsIGZvY2FsKVxuICAgICAgICBjb25zdCB2MnAgPSBwcm9qKHYyYywgVywgSCwgZm9jYWwpXG5cbiAgICAgICAgaWYgKHYwcCAmJiB2MXAgJiYgdjJwKSB7XG4gICAgICAgICAgY29uc3QgZWRnZTEgPSBzdWIodjFjLCB2MGMpXG4gICAgICAgICAgY29uc3QgZWRnZTIgPSBzdWIodjJjLCB2MGMpXG4gICAgICAgICAgY29uc3QgZmFjZU5vcm1hbCA9IGNyb3NzKGVkZ2UxLCBlZGdlMilcblxuICAgICAgICAgIGZhY2VzLnB1c2goe1xuICAgICAgICAgICAgcHRzOiBbdjBwLCB2MXAsIHYycF0sXG4gICAgICAgICAgICBjYW06IFt2MGMsIHYxYywgdjJjXSxcbiAgICAgICAgICAgIGZpbGw6IHNoYWRlQnlOb3JtYWwoXG4gICAgICAgICAgICAgIGJveC5jb2xvciA/PyB0cmlhbmdsZS5jb2xvciA/PyBcImdyYXlcIixcbiAgICAgICAgICAgICAgZmFjZU5vcm1hbCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzdHJva2U6IGZhbHNlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJveC50aHJlZU1mVXJsICYmIHRocmVlTWZNZXNoZXMuaGFzKGJveC50aHJlZU1mVXJsKSkge1xuICAgICAgY29uc3QgbWVzaCA9IHRocmVlTWZNZXNoZXMuZ2V0KGJveC50aHJlZU1mVXJsKSFcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVmVydGljZXMgPSBzY2FsZUFuZFBvc2l0aW9uTWVzaChcbiAgICAgICAgbWVzaCxcbiAgICAgICAgYm94LFxuICAgICAgICBib3guc2NhbGVUaHJlZU1mVG9Cb3ggPz8gZmFsc2UsXG4gICAgICAgIFwiM21mXCIsXG4gICAgICApXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzaC50cmlhbmdsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmVydGV4U3RhcnQgPSBpICogM1xuICAgICAgICBjb25zdCB0cmlhbmdsZSA9IG1lc2gudHJpYW5nbGVzW2ldIVxuXG4gICAgICAgIGNvbnN0IHYwdyA9IHRyYW5zZm9ybWVkVmVydGljZXNbdmVydGV4U3RhcnRdIVxuICAgICAgICBjb25zdCB2MXcgPSB0cmFuc2Zvcm1lZFZlcnRpY2VzW3ZlcnRleFN0YXJ0ICsgMV0hXG4gICAgICAgIGNvbnN0IHYydyA9IHRyYW5zZm9ybWVkVmVydGljZXNbdmVydGV4U3RhcnQgKyAyXSFcblxuICAgICAgICBjb25zdCB2MGMgPSB0b0NhbSh2MHcsIHNjZW5lLmNhbWVyYSlcbiAgICAgICAgY29uc3QgdjFjID0gdG9DYW0odjF3LCBzY2VuZS5jYW1lcmEpXG4gICAgICAgIGNvbnN0IHYyYyA9IHRvQ2FtKHYydywgc2NlbmUuY2FtZXJhKVxuXG4gICAgICAgIGNvbnN0IHYwcCA9IHByb2oodjBjLCBXLCBILCBmb2NhbClcbiAgICAgICAgY29uc3QgdjFwID0gcHJvaih2MWMsIFcsIEgsIGZvY2FsKVxuICAgICAgICBjb25zdCB2MnAgPSBwcm9qKHYyYywgVywgSCwgZm9jYWwpXG5cbiAgICAgICAgaWYgKHYwcCAmJiB2MXAgJiYgdjJwKSB7XG4gICAgICAgICAgY29uc3QgZWRnZTEgPSBzdWIodjFjLCB2MGMpXG4gICAgICAgICAgY29uc3QgZWRnZTIgPSBzdWIodjJjLCB2MGMpXG4gICAgICAgICAgY29uc3QgZmFjZU5vcm1hbCA9IGNyb3NzKGVkZ2UxLCBlZGdlMilcblxuICAgICAgICAgIGZhY2VzLnB1c2goe1xuICAgICAgICAgICAgcHRzOiBbdjBwLCB2MXAsIHYycF0sXG4gICAgICAgICAgICBjYW06IFt2MGMsIHYxYywgdjJjXSxcbiAgICAgICAgICAgIGZpbGw6IHNoYWRlQnlOb3JtYWwoXG4gICAgICAgICAgICAgIGJveC5jb2xvciA/PyB0cmlhbmdsZS5jb2xvciA/PyBcImdyYXlcIixcbiAgICAgICAgICAgICAgZmFjZU5vcm1hbCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzdHJva2U6IGZhbHNlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGFuZGxlIHJlZ3VsYXIgYm94IHJlbmRlcmluZ1xuICAgICAgY29uc3QgdncgPSB2ZXJ0cyhib3gpXG4gICAgICBjb25zdCB2YyA9IHZ3Lm1hcCgodikgPT4gdG9DYW0odiwgc2NlbmUuY2FtZXJhKSlcbiAgICAgIGNvbnN0IHZwID0gdmMubWFwKCh2KSA9PiBwcm9qKHYsIFcsIEgsIGZvY2FsKSlcblxuICAgICAgLy8gZmFjZXNcbiAgICAgIGZvciAoY29uc3QgaWR4IG9mIEZBQ0VTKSB7XG4gICAgICAgIGNvbnN0IHA0OiBQcm9qW10gPSBbXVxuICAgICAgICBsZXQgYmVoaW5kID0gZmFsc2VcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGlkeCkge1xuICAgICAgICAgIGNvbnN0IHAgPSB2cFtpXVxuICAgICAgICAgIGlmICghcCkge1xuICAgICAgICAgICAgYmVoaW5kID0gdHJ1ZVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgcDQucHVzaChwKVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZWhpbmQpIGNvbnRpbnVlXG4gICAgICAgIGNvbnN0IGNhbTQgPSBpZHgubWFwKChpKSA9PiB2Y1tpXSBhcyBQb2ludDMpXG4gICAgICAgIGZhY2VzLnB1c2goe1xuICAgICAgICAgIHB0czogcDQsXG4gICAgICAgICAgY2FtOiBjYW00LFxuICAgICAgICAgIGZpbGw6IGNvbG9yVG9Dc3MoYm94LmNvbG9yID8/IFwiZ3JheVwiKSxcbiAgICAgICAgICBzdHJva2U6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIHRvcCBmYWNlIGltYWdlXG4gICAgICBpZiAoYm94LmZhY2VJbWFnZXM/LnRvcCkge1xuICAgICAgICBjb25zdCBwdHMgPSBUT1AubWFwKChpKSA9PiB2d1tpXSlcbiAgICAgICAgaWYgKHB0cy5ldmVyeShCb29sZWFuKSkge1xuICAgICAgICAgIGNvbnN0IGRzdCA9IHB0cyBhcyBbUG9pbnQzLCBQb2ludDMsIFBvaW50MywgUG9pbnQzXVxuICAgICAgICAgIGNvbnN0IGN6ID0gTWF0aC5tYXgoLi4uVE9QLm1hcCgoaSkgPT4gdmNbaV0hLnopKVxuICAgICAgICAgIGNvbnN0IGhyZWYgPSBib3guZmFjZUltYWdlcy50b3BcblxuICAgICAgICAgIC8vIEFzc2lnbiB1bmlxdWUgdGV4dHVyZSBJRFxuICAgICAgICAgIGlmICghdGV4SWQuaGFzKGhyZWYpKSB7XG4gICAgICAgICAgICB0ZXhJZC5zZXQoaHJlZiwgYHRleCR7dGV4SWQuc2l6ZX1gKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzeW0gPSB0ZXhJZC5nZXQoaHJlZikhXG5cbiAgICAgICAgICAvLyBTdWJkaXZpZGUgdGhlIGZhY2UgaW50byBwcm9qZWN0aW9uU3ViZGl2aXNpb24geCBwcm9qZWN0aW9uU3ViZGl2aXNpb24gZ3JpZFxuICAgICAgICAgIGNvbnN0IHN1YmRpdmlzaW9ucyA9IGJveC5wcm9qZWN0aW9uU3ViZGl2aXNpb24gPz8gMlxuICAgICAgICAgIGNvbnN0IHF1YWRzUGVyU2lkZSA9IHN1YmRpdmlzaW9uc1xuICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHF1YWRzUGVyU2lkZTsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHF1YWRzUGVyU2lkZTsgY29sKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgdTAgPSBjb2wgLyBxdWFkc1BlclNpZGVcbiAgICAgICAgICAgICAgY29uc3QgdTEgPSAoY29sICsgMSkgLyBxdWFkc1BlclNpZGVcbiAgICAgICAgICAgICAgY29uc3QgdjAgPSByb3cgLyBxdWFkc1BlclNpZGVcbiAgICAgICAgICAgICAgY29uc3QgdjEgPSAocm93ICsgMSkgLyBxdWFkc1BlclNpZGVcblxuICAgICAgICAgICAgICAvLyBCaWxpbmVhciBpbnRlcnBvbGF0aW9uIGZvciBxdWFkIGNvcm5lcnMgaW4gM0Qgc3BhY2VcbiAgICAgICAgICAgICAgY29uc3QgbGVycCA9IChhOiBQb2ludDMsIGI6IFBvaW50MywgdDogbnVtYmVyKTogUG9pbnQzID0+ICh7XG4gICAgICAgICAgICAgICAgeDogYS54ICogKDEgLSB0KSArIGIueCAqIHQsXG4gICAgICAgICAgICAgICAgeTogYS55ICogKDEgLSB0KSArIGIueSAqIHQsXG4gICAgICAgICAgICAgICAgejogYS56ICogKDEgLSB0KSArIGIueiAqIHQsXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgLy8gLS0tIGNvbXB1dGUgY2FtZXJhLXNwYWNlIHZlcnRpY2VzIG9uY2UgLS0tXG4gICAgICAgICAgICAgIGNvbnN0IGMwMCA9IHRvQ2FtKFxuICAgICAgICAgICAgICAgIGxlcnAobGVycChkc3RbMF0sIGRzdFsxXSwgdTApLCBsZXJwKGRzdFszXSwgZHN0WzJdLCB1MCksIHYwKSxcbiAgICAgICAgICAgICAgICBzY2VuZS5jYW1lcmEsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgY29uc3QgYzEwID0gdG9DYW0oXG4gICAgICAgICAgICAgICAgbGVycChsZXJwKGRzdFswXSwgZHN0WzFdLCB1MSksIGxlcnAoZHN0WzNdLCBkc3RbMl0sIHUxKSwgdjApLFxuICAgICAgICAgICAgICAgIHNjZW5lLmNhbWVyYSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBjb25zdCBjMDEgPSB0b0NhbShcbiAgICAgICAgICAgICAgICBsZXJwKGxlcnAoZHN0WzBdLCBkc3RbMV0sIHUwKSwgbGVycChkc3RbM10sIGRzdFsyXSwgdTApLCB2MSksXG4gICAgICAgICAgICAgICAgc2NlbmUuY2FtZXJhLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIGNvbnN0IGMxMSA9IHRvQ2FtKFxuICAgICAgICAgICAgICAgIGxlcnAobGVycChkc3RbMF0sIGRzdFsxXSwgdTEpLCBsZXJwKGRzdFszXSwgZHN0WzJdLCB1MSksIHYxKSxcbiAgICAgICAgICAgICAgICBzY2VuZS5jYW1lcmEsXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICBjb25zdCBwMDAgPSBwcm9qKGMwMCwgVywgSCwgZm9jYWwpIVxuICAgICAgICAgICAgICBjb25zdCBwMTAgPSBwcm9qKGMxMCwgVywgSCwgZm9jYWwpIVxuICAgICAgICAgICAgICBjb25zdCBwMDEgPSBwcm9qKGMwMSwgVywgSCwgZm9jYWwpIVxuICAgICAgICAgICAgICBjb25zdCBwMTEgPSBwcm9qKGMxMSwgVywgSCwgZm9jYWwpIVxuXG4gICAgICAgICAgICAgIC8vIEZpcnN0IHRyaWFuZ2xlOiBwMDAsIHAxMCwgcDExXG4gICAgICAgICAgICAgIGNvbnN0IHRyaTBNYXQgPSBhZmZpbmVNYXRyaXgoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgeyB4OiB1MCwgeTogdjAgfSxcbiAgICAgICAgICAgICAgICAgIHsgeDogdTEsIHk6IHYwIH0sXG4gICAgICAgICAgICAgICAgICB7IHg6IHUxLCB5OiB2MSB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgW3AwMCwgcDEwLCBwMTFdLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIGNvbnN0IGlkMCA9IGBjbGlwJHtjbGlwU2VxKyt9YFxuICAgICAgICAgICAgICBpbWFnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWF0cml4OiB0cmkwTWF0LFxuICAgICAgICAgICAgICAgIGRlcHRoOiBjeixcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIGNsaXA6IGlkMCxcbiAgICAgICAgICAgICAgICBwb2ludHM6IGAke2ZtdFByZWNpc2UodTApfSwke2ZtdFByZWNpc2UodjApfSAke2ZtdFByZWNpc2UodTEpfSwke2ZtdFByZWNpc2UodjApfSAke2ZtdFByZWNpc2UodTEpfSwke2ZtdFByZWNpc2UodjEpfWAsXG4gICAgICAgICAgICAgICAgc3ltLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAvLyBBZnRlciBwdXNoaW5nIGltZyBmb3IgZmlyc3QgdHJpYW5nbGUgKHAwMCxwMTAscDExKVxuICAgICAgICAgICAgICBjb25zdCB0cmlGYWNlMDogRmFjZSA9IHtcbiAgICAgICAgICAgICAgICBwdHM6IFtwMDAsIHAxMCwgcDExXSxcbiAgICAgICAgICAgICAgICBjYW06IFtjMDAsIGMxMCwgYzExXSxcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBzdHJva2U6IGZhbHNlLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZhY2VzLnB1c2godHJpRmFjZTApXG4gICAgICAgICAgICAgIGZhY2VUb0ltZy5zZXQodHJpRmFjZTAsIGltYWdlc1tpbWFnZXMubGVuZ3RoIC0gMV0hKVxuXG4gICAgICAgICAgICAgIC8vIFNlY29uZCB0cmlhbmdsZTogcDAwLCBwMTEsIHAwMVxuICAgICAgICAgICAgICBjb25zdCB0cmkxTWF0ID0gYWZmaW5lTWF0cml4KFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIHsgeDogdTAsIHk6IHYwIH0sXG4gICAgICAgICAgICAgICAgICB7IHg6IHUxLCB5OiB2MSB9LFxuICAgICAgICAgICAgICAgICAgeyB4OiB1MCwgeTogdjEgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFtwMDAsIHAxMSwgcDAxXSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBjb25zdCBpZDEgPSBgY2xpcCR7Y2xpcFNlcSsrfWBcbiAgICAgICAgICAgICAgaW1hZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1hdHJpeDogdHJpMU1hdCxcbiAgICAgICAgICAgICAgICBkZXB0aDogY3osXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICBjbGlwOiBpZDEsXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBgJHtmbXRQcmVjaXNlKHUwKX0sJHtmbXRQcmVjaXNlKHYwKX0gJHtmbXRQcmVjaXNlKHUxKX0sJHtmbXRQcmVjaXNlKHYxKX0gJHtmbXRQcmVjaXNlKHUwKX0sJHtmbXRQcmVjaXNlKHYxKX1gLFxuICAgICAgICAgICAgICAgIHN5bSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLy8gQWZ0ZXIgcHVzaGluZyBpbWcgZm9yIHNlY29uZCB0cmlhbmdsZSAocDAwLHAxMSxwMDEpXG4gICAgICAgICAgICAgIGNvbnN0IHRyaUZhY2UxOiBGYWNlID0ge1xuICAgICAgICAgICAgICAgIHB0czogW3AwMCwgcDExLCBwMDFdLFxuICAgICAgICAgICAgICAgIGNhbTogW2MwMCwgYzExLCBjMDFdLFxuICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogZmFsc2UsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmFjZXMucHVzaCh0cmlGYWNlMSlcbiAgICAgICAgICAgICAgZmFjZVRvSW1nLnNldCh0cmlGYWNlMSwgaW1hZ2VzW2ltYWdlcy5sZW5ndGggLSAxXSEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRvcCBsYWJlbFxuICAgICAgaWYgKGJveC50b3BMYWJlbCkge1xuICAgICAgICBjb25zdCBwdHMgPSBUT1AubWFwKChpKSA9PiB2cFtpXSlcbiAgICAgICAgaWYgKHB0cy5ldmVyeShCb29sZWFuKSkge1xuICAgICAgICAgIGNvbnN0IHAwID0gcHRzWzBdIGFzIFByb2pcbiAgICAgICAgICBjb25zdCBwMSA9IHB0c1sxXSBhcyBQcm9qXG4gICAgICAgICAgY29uc3QgcDMgPSBwdHNbM10gYXMgUHJvalxuICAgICAgICAgIGNvbnN0IHUgPSBzdWIocDEsIHAwKVxuICAgICAgICAgIGNvbnN0IHYgPSBzdWIocDMsIHAwKVxuICAgICAgICAgIGNvbnN0IGx1ID0gbGVuKHUpXG4gICAgICAgICAgY29uc3QgbHYgPSBsZW4odilcbiAgICAgICAgICBpZiAobHUgJiYgbHYpIHtcbiAgICAgICAgICAgIGNvbnN0IHVOID0gc2NhbGUodSwgMSAvIGx1KVxuICAgICAgICAgICAgY29uc3Qgdk4gPSBzY2FsZSh2LCAxIC8gbHYpXG4gICAgICAgICAgICBjb25zdCBjeCA9IHB0cy5yZWR1Y2UoKHMsIHApID0+IHMgKyAocCBhcyBQcm9qKS54LCAwKSAvIDRcbiAgICAgICAgICAgIGNvbnN0IGN5ID0gcHRzLnJlZHVjZSgocywgcCkgPT4gcyArIChwIGFzIFByb2opLnksIDApIC8gNFxuICAgICAgICAgICAgLy8gdXNlIGZ1cnRoZXN0IHRvcC1mYWNlIHZlcnRleCBzbyB0aGUgbGFiZWwgZm9sbG93cyB0aGUgZmFjZSBvcmRlclxuICAgICAgICAgICAgY29uc3QgY3ogPSBNYXRoLm1heCguLi5UT1AubWFwKChpKSA9PiB2Y1tpXSEueikpXG4gICAgICAgICAgICAvLyBTVkcgdHJhbnNmb3JtIG1hdHJpeDogW2EgYiBjIGQgZSBmXSB3aGVyZVxuICAgICAgICAgICAgLy8geCcgPSBhKnggKyBjKnkgKyBlIDsgeScgPSBiKnggKyBkKnkgKyBmXG4gICAgICAgICAgICBjb25zdCBtID0gYG1hdHJpeCgke3VOLnh9ICR7dU4ueX0gJHt2Ti54fSAke3ZOLnl9ICR7Y3h9ICR7Y3l9KWBcbiAgICAgICAgICAgIGNvbnN0IGZpbGxDb2wgPSBib3gudG9wTGFiZWxDb2xvciA/PyBbMCwgMCwgMCwgMV1cbiAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcbiAgICAgICAgICAgICAgbWF0cml4OiBtLFxuICAgICAgICAgICAgICBkZXB0aDogY3osXG4gICAgICAgICAgICAgIHRleHQ6IGJveC50b3BMYWJlbCxcbiAgICAgICAgICAgICAgZmlsbDogY29sb3JUb0NzcyhmaWxsQ29sKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQlNQIHNvcnQgZmFjZXMgYmVmb3JlIG1lcmdpbmcgd2l0aCBvdGhlciBlbGVtZW50c1xuICBmdW5jdGlvbiBzb3J0RmFjZXNCU1AoXG4gICAgcG9seXM6IEZhY2VbXSxcbiAgICBXOiBudW1iZXIsXG4gICAgSDogbnVtYmVyLFxuICAgIGZvY2FsOiBudW1iZXIsXG4gICk6IEZhY2VbXSB7XG4gICAgY29uc3QgRVBTID0gMWUtNlxuICAgIHR5cGUgTm9kZSA9IHtcbiAgICAgIGZhY2U6IEZhY2VcbiAgICAgIG5vcm1hbDogUG9pbnQzXG4gICAgICBwb2ludDogUG9pbnQzXG4gICAgICBmcm9udDogTm9kZSB8IG51bGxcbiAgICAgIGJhY2s6IE5vZGUgfCBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGQobGlzdDogRmFjZVtdKTogTm9kZSB8IG51bGwge1xuICAgICAgaWYgKCFsaXN0Lmxlbmd0aCkgcmV0dXJuIG51bGxcbiAgICAgIGNvbnN0IGZhY2UgPSBsaXN0WzBdIVxuICAgICAgY29uc3QgcDAgPSBmYWNlLmNhbVswXSFcbiAgICAgIGNvbnN0IHAxID0gZmFjZS5jYW1bMV0hXG4gICAgICBjb25zdCBwMiA9IGZhY2UuY2FtWzJdIVxuICAgICAgY29uc3Qgbm9ybWFsID0gY3Jvc3Moc3ViKHAxLCBwMCksIHN1YihwMiwgcDApKVxuICAgICAgY29uc3QgZnJvbnQ6IEZhY2VbXSA9IFtdXG4gICAgICBjb25zdCBiYWNrOiBGYWNlW10gPSBbXVxuXG4gICAgICBmb3IgKGxldCBrID0gMTsgayA8IGxpc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgY29uc3QgZiA9IGxpc3Rba10hXG4gICAgICAgIC8vIGNsYXNzaWZ5IGVhY2ggdmVydGV4XG4gICAgICAgIGxldCBwb3MgPSAwLFxuICAgICAgICAgIG5lZyA9IDBcbiAgICAgICAgY29uc3QgZDogbnVtYmVyW10gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgZi5jYW0pIHtcbiAgICAgICAgICBjb25zdCBkaXN0ID0gZG90KG5vcm1hbCwgc3ViKHYhLCBwMCkpXG4gICAgICAgICAgZC5wdXNoKGRpc3QpXG4gICAgICAgICAgaWYgKGRpc3QgPiBFUFMpIHBvcysrXG4gICAgICAgICAgZWxzZSBpZiAoZGlzdCA8IC1FUFMpIG5lZysrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwb3MgJiYgIW5lZykge1xuICAgICAgICAgIGZyb250LnB1c2goZikgLy8gY29wbGFuYXIgXHUyMDEzIGRyYXcgYWZ0ZXIgc3BsaXR0ZXJcbiAgICAgICAgfSBlbHNlIGlmICghcG9zKSBiYWNrLnB1c2goZilcbiAgICAgICAgZWxzZSBpZiAoIW5lZykgZnJvbnQucHVzaChmKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBzcGxpdCBwb2x5Z29uIGJ5IHBsYW5lXG4gICAgICAgICAgY29uc3QgZkZyb250Q2FtOiBQb2ludDNbXSA9IFtdXG4gICAgICAgICAgY29uc3QgZkJhY2tDYW06IFBvaW50M1tdID0gW11cbiAgICAgICAgICBjb25zdCBmRnJvbnQyRDogUHJvaltdID0gW11cbiAgICAgICAgICBjb25zdCBmQmFjazJEOiBQcm9qW10gPSBbXVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmLmNhbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaiA9IChpICsgMSkgJSBmLmNhbS5sZW5ndGhcbiAgICAgICAgICAgIGNvbnN0IGFDYW0gPSBmLmNhbVtpXSFcbiAgICAgICAgICAgIGNvbnN0IGJDYW0gPSBmLmNhbVtqXSFcbiAgICAgICAgICAgIGNvbnN0IGEyRCA9IGYucHRzW2ldIVxuICAgICAgICAgICAgY29uc3QgYjJEID0gZi5wdHNbal0hXG4gICAgICAgICAgICBjb25zdCBkYSA9IGRbaV0hXG4gICAgICAgICAgICBjb25zdCBkYiA9IGRbal0hXG5cbiAgICAgICAgICAgIGNvbnN0IHB1c2ggPSAoXG4gICAgICAgICAgICAgIGFyckNhbTogUG9pbnQzW10sXG4gICAgICAgICAgICAgIGFycjJEOiBQcm9qW10sXG4gICAgICAgICAgICAgIGNDYW06IFBvaW50MyxcbiAgICAgICAgICAgICAgYzJEOiBQcm9qLFxuICAgICAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICAgIGFyckNhbS5wdXNoKGNDYW0pXG4gICAgICAgICAgICAgIGFycjJELnB1c2goYzJEKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGEgPj0gLUVQUykgcHVzaChmRnJvbnRDYW0sIGZGcm9udDJELCBhQ2FtISwgYTJEISlcbiAgICAgICAgICAgIGlmIChkYSA8PSBFUFMpIHB1c2goZkJhY2tDYW0sIGZCYWNrMkQsIGFDYW0hLCBhMkQhKVxuXG4gICAgICAgICAgICBpZiAoKGRhID4gMCAmJiBkYiA8IDApIHx8IChkYSA8IDAgJiYgZGIgPiAwKSkge1xuICAgICAgICAgICAgICBjb25zdCB0ID0gZGEgLyAoZGEgLSBkYilcbiAgICAgICAgICAgICAgY29uc3QgaW50ZXJDYW0gPSB7XG4gICAgICAgICAgICAgICAgeDogYUNhbS54ICsgKGJDYW0ueCAtIGFDYW0ueCkgKiB0LFxuICAgICAgICAgICAgICAgIHk6IGFDYW0ueSArIChiQ2FtLnkgLSBhQ2FtLnkpICogdCxcbiAgICAgICAgICAgICAgICB6OiBhQ2FtLnogKyAoYkNhbS56IC0gYUNhbS56KSAqIHQsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgaW50ZXIyRCA9IHByb2ooaW50ZXJDYW0sIFcsIEgsIGZvY2FsKSFcbiAgICAgICAgICAgICAgcHVzaChmRnJvbnRDYW0sIGZGcm9udDJELCBpbnRlckNhbSwgaW50ZXIyRClcbiAgICAgICAgICAgICAgcHVzaChmQmFja0NhbSwgZkJhY2syRCwgaW50ZXJDYW0sIGludGVyMkQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbWsgPSAoY2FtOiBQb2ludDNbXSwgcHRzOiBQcm9qW10pOiBGYWNlIHwgbnVsbCA9PiB7XG4gICAgICAgICAgICBpZiAoY2FtLmxlbmd0aCA8IDMpIHJldHVybiBudWxsXG4gICAgICAgICAgICBjb25zdCBuZjogRmFjZSA9IHsgY2FtLCBwdHMsIGZpbGw6IGYhLmZpbGwsIHN0cm9rZTogZmFsc2UgfVxuICAgICAgICAgICAgY29uc3QgaW1nID0gZmFjZVRvSW1nLmdldChmKVxuICAgICAgICAgICAgaWYgKGltZykgZmFjZVRvSW1nLnNldChuZiwgaW1nKVxuICAgICAgICAgICAgcmV0dXJuIG5mXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGYxID0gbWsoZkZyb250Q2FtLCBmRnJvbnQyRClcbiAgICAgICAgICBjb25zdCBmMiA9IG1rKGZCYWNrQ2FtLCBmQmFjazJEKVxuICAgICAgICAgIGlmIChmMSkgZnJvbnQucHVzaChmMSlcbiAgICAgICAgICBpZiAoZjIpIGJhY2sucHVzaChmMilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmYWNlLFxuICAgICAgICBub3JtYWwsXG4gICAgICAgIHBvaW50OiBwMCxcbiAgICAgICAgZnJvbnQ6IGJ1aWxkKGZyb250KSxcbiAgICAgICAgYmFjazogYnVpbGQoYmFjayksXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhdmVyc2Uobm9kZTogTm9kZSB8IG51bGwsIG91dDogRmFjZVtdKSB7XG4gICAgICBpZiAoIW5vZGUpIHJldHVyblxuICAgICAgY29uc3QgY2FtZXJhU2lkZSA9IGRvdChub2RlLm5vcm1hbCwgc2NhbGUobm9kZS5wb2ludCwgLTEpKVxuICAgICAgaWYgKGNhbWVyYVNpZGUgPj0gMCkge1xuICAgICAgICB0cmF2ZXJzZShub2RlLmJhY2ssIG91dClcbiAgICAgICAgb3V0LnB1c2gobm9kZS5mYWNlKVxuICAgICAgICB0cmF2ZXJzZShub2RlLmZyb250LCBvdXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmF2ZXJzZShub2RlLmZyb250LCBvdXQpXG4gICAgICAgIG91dC5wdXNoKG5vZGUuZmFjZSlcbiAgICAgICAgdHJhdmVyc2Uobm9kZS5iYWNrLCBvdXQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdCA9IGJ1aWxkKHBvbHlzKVxuICAgIGNvbnN0IG9yZGVyZWQ6IEZhY2VbXSA9IFtdXG4gICAgdHJhdmVyc2Uocm9vdCwgb3JkZXJlZClcbiAgICByZXR1cm4gb3JkZXJlZFxuICB9XG5cbiAgY29uc3Qgb3JkZXJlZEZhY2VzID0gc29ydEZhY2VzQlNQKGZhY2VzLCBXLCBILCBmb2NhbClcblxuICBjb25zdCBlbGVtZW50czogUmVuZGVyRWxlbWVudFtdID0gW11cbiAgZm9yIChjb25zdCBmIG9mIG9yZGVyZWRGYWNlcykge1xuICAgIGNvbnN0IGltZyA9IGZhY2VUb0ltZy5nZXQoZilcbiAgICBpZiAoaW1nKSB7XG4gICAgICBlbGVtZW50cy5wdXNoKHsgdHlwZTogXCJpbWFnZVwiLCBkYXRhOiBpbWcgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudHMucHVzaCh7IHR5cGU6IFwiZmFjZVwiLCBkYXRhOiBmIH0pXG4gICAgfVxuICB9XG4gIGVsZW1lbnRzLnB1c2goXG4gICAgLi4ubGFiZWxzLm1hcCgobCkgPT4gKHsgdHlwZTogXCJsYWJlbFwiIGFzIGNvbnN0LCBkYXRhOiBsIH0pKSxcbiAgICAuLi5lZGdlc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZGVwdGggLSBiLmRlcHRoKVxuICAgICAgLm1hcCgoZSkgPT4gKHsgdHlwZTogXCJlZGdlXCIgYXMgY29uc3QsIGRhdGE6IGUgfSkpLFxuICApXG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogVyxcbiAgICBoZWlnaHQ6IEgsXG4gICAgYmFja2dyb3VuZENvbG9yOiBvcHQuYmFja2dyb3VuZENvbG9yLFxuICAgIGVsZW1lbnRzLFxuICAgIGltYWdlcyxcbiAgICB0ZXhJZCxcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgU2NlbmUsIENvbG9yLCBDYW1lcmEsIFBvaW50MyB9IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCB7IGNvbG9yVG9Dc3MgfSBmcm9tIFwiLi9jb2xvclwiXG5pbXBvcnQgeyBidWlsZFJlbmRlckVsZW1lbnRzIH0gZnJvbSBcIi4vcmVuZGVyLWVsZW1lbnRzXCJcbmltcG9ydCB7IHN1YiwgY3Jvc3MsIGRvdCwgbGVuLCBub3JtLCBhZGQsIHNjYWxlIH0gZnJvbSBcIi4vdmVjM1wiXG5cbmZ1bmN0aW9uIGZtdChuOiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobikgKyBcIlwiXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW5kZXJTY2VuZShcbiAgc2NlbmU6IFNjZW5lLFxuICBvcHQ6IHtcbiAgICB3aWR0aD86IG51bWJlclxuICAgIGhlaWdodD86IG51bWJlclxuICAgIGJhY2tncm91bmRDb2xvcj86IENvbG9yXG4gICAgc2hvd0F4ZXM/OiBib29sZWFuXG4gICAgc2hvd09yaWdpbj86IGJvb2xlYW5cbiAgICBzaG93R3JpZD86IGJvb2xlYW5cbiAgICBncmlkPzoge1xuICAgICAgLyoqIHdvcmxkLXNwYWNlIGdyaWQgY2VsbCBzaXplIChkZWZhdWx0ID0gMSkgICAgICAgICAgICAqLyBjZWxsU2l6ZT86IG51bWJlclxuICAgICAgLyoqIHBsYW5lIG9uIHdoaWNoIHRvIGRyYXcgdGhlIGdyaWQgKGRlZmF1bHQgPSBcInh6XCIpICAgKi8gcGxhbmU/OlxuICAgICAgICB8IFwieHlcIlxuICAgICAgICB8IFwieXpcIlxuICAgICAgICB8IFwieHpcIlxuICAgIH1cbiAgfSA9IHt9LFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3Qge1xuICAgIHdpZHRoOiBXLFxuICAgIGhlaWdodDogSCxcbiAgICBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgZWxlbWVudHMsXG4gICAgaW1hZ2VzLFxuICAgIHRleElkLFxuICB9ID0gYXdhaXQgYnVpbGRSZW5kZXJFbGVtZW50cyhzY2VuZSwge1xuICAgIHdpZHRoOiBvcHQud2lkdGgsXG4gICAgaGVpZ2h0OiBvcHQuaGVpZ2h0LFxuICAgIGJhY2tncm91bmRDb2xvcjogb3B0LmJhY2tncm91bmRDb2xvcixcbiAgfSlcblxuICBjb25zdCBvdXQ6IHN0cmluZ1tdID0gW11cbiAgb3V0LnB1c2goXG4gICAgYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiJHtXfVwiIGhlaWdodD1cIiR7SH1cIiB2aWV3Qm94PVwiJHstVyAvIDJ9ICR7LUggLyAyfSAke1d9ICR7SH1cIj5gLFxuICApXG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBvdXQucHVzaChcbiAgICAgIGAgIDxyZWN0IHg9XCIkey1XIC8gMn1cIiB5PVwiJHstSCAvIDJ9XCIgd2lkdGg9XCIke1d9XCIgaGVpZ2h0PVwiJHtIfVwiIGZpbGw9XCIke2NvbG9yVG9Dc3MoYmFja2dyb3VuZENvbG9yKX1cIiAvPlxcbmAsXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLSBkZWZzIHNlY3Rpb24gKGlkZW50aWNhbCB0byBvbGQgY29kZSkgLS0tLVxuICBpZiAoaW1hZ2VzLmxlbmd0aCkge1xuICAgIG91dC5wdXNoKFwiICA8ZGVmcz5cXG5cIilcblxuICAgIC8vIFdyaXRlIG9uZSA8aW1hZ2U+IHBlciB1bmlxdWUgdGV4dHVyZVxuICAgIGZvciAoY29uc3QgW2hyZWYsIGlkXSBvZiB0ZXhJZCkge1xuICAgICAgb3V0LnB1c2goXG4gICAgICAgIGAgICAgPGltYWdlIGlkPVwiJHtpZH1cIiBocmVmPVwiJHtocmVmfVwiIHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiIHN0eWxlPVwiaW1hZ2UtcmVuZGVyaW5nOnBpeGVsYXRlZFwiLz5cXG5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFdyaXRlIGNsaXAgcGF0aHNcbiAgICBmb3IgKGNvbnN0IGltZyBvZiBpbWFnZXMpIHtcbiAgICAgIG91dC5wdXNoKFxuICAgICAgICBgICAgIDxjbGlwUGF0aCBpZD1cIiR7aW1nLmNsaXB9XCIgY2xpcFBhdGhVbml0cz1cIm9iamVjdEJvdW5kaW5nQm94XCI+PHBvbHlnb24gcG9pbnRzPVwiJHtpbWcucG9pbnRzfVwiIC8+PC9jbGlwUGF0aD5cXG5gLFxuICAgICAgKVxuICAgIH1cbiAgICBvdXQucHVzaChcIiAgPC9kZWZzPlxcblwiKVxuICB9XG5cbiAgLy8gXHUyNTAwXHUyNTAwIGdyaWQgcGxhbmUgXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXHUyNTAwXG4gIGlmIChvcHQuc2hvd0dyaWQpIHtcbiAgICBvdXQucHVzaChcbiAgICAgIHJlbmRlckdyaWQoc2NlbmUsIFcsIEgsIG9wdC5ncmlkPy5jZWxsU2l6ZSA/PyAxLCBvcHQuZ3JpZD8ucGxhbmUgPz8gXCJ4elwiKSxcbiAgICApXG4gIH1cblxuICAvLyAtLS0tIGVsZW1lbnQgcmVuZGVyaW5nIGxvb3AgLS0tLVxuICBsZXQgaW5TdHJva2VHcm91cCA9IGZhbHNlXG5cbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJmYWNlXCIgfHwgZWxlbWVudC50eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgIC8vIFN0YXJ0IHN0cm9rZSBncm91cCBpZiBub3QgYWxyZWFkeSBpbiBvbmVcbiAgICAgIGlmICghaW5TdHJva2VHcm91cCkge1xuICAgICAgICBvdXQucHVzaChcbiAgICAgICAgICAnICA8ZyBzdHJva2U9XCIjMDAwXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxcbicsXG4gICAgICAgIClcbiAgICAgICAgaW5TdHJva2VHcm91cCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJmYWNlXCIpIHtcbiAgICAgICAgY29uc3QgZiA9IGVsZW1lbnQuZGF0YVxuICAgICAgICBjb25zdCBzdHJva2VBdHRyID0gZi5zdHJva2UgPyBcIlwiIDogJyBzdHJva2U9XCJub25lXCInXG4gICAgICAgIG91dC5wdXNoKFxuICAgICAgICAgIGAgICAgPHBvbHlnb24gZmlsbD1cIiR7Zi5maWxsfVwiJHtzdHJva2VBdHRyfSBwb2ludHM9XCIke2YucHRzXG4gICAgICAgICAgICAubWFwKChwKSA9PiBgJHtmbXQocC54KX0sJHtmbXQocC55KX1gKVxuICAgICAgICAgICAgLmpvaW4oXCIgXCIpfVwiIC8+XFxuYCxcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW1nID0gZWxlbWVudC5kYXRhXG4gICAgICAgIG91dC5wdXNoKFxuICAgICAgICAgIGAgICAgPGcgdHJhbnNmb3JtPVwiJHtpbWcubWF0cml4fVwiIGNsaXAtcGF0aD1cInVybCgjJHtpbWcuY2xpcH0pXCI+PHVzZSBocmVmPVwiIyR7aW1nLnN5bX1cIi8+PC9nPlxcbmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJsYWJlbFwiKSB7XG4gICAgICAvLyBDbG9zZSBzdHJva2UgZ3JvdXAgaWYgd2UncmUgaW4gb25lXG4gICAgICBpZiAoaW5TdHJva2VHcm91cCkge1xuICAgICAgICBvdXQucHVzaChcIiAgPC9nPlxcblwiKVxuICAgICAgICBpblN0cm9rZUdyb3VwID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgbCA9IGVsZW1lbnQuZGF0YVxuICAgICAgb3V0LnB1c2goXG4gICAgICAgIGAgIDxnIGZvbnQtZmFtaWx5PVwic2Fucy1zZXJpZlwiIGZvbnQtc2l6ZT1cIjE0XCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIiBkb21pbmFudC1iYXNlbGluZT1cImNlbnRyYWxcIiB0cmFuc2Zvcm09XCIke2wubWF0cml4fVwiPjx0ZXh0IHg9XCIwXCIgeT1cIjBcIiBmaWxsPVwiJHtsLmZpbGx9XCI+JHtsLnRleHR9PC90ZXh0PjwvZz5cXG5gLFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBcImVkZ2VcIikge1xuICAgICAgaWYgKGluU3Ryb2tlR3JvdXApIHtcbiAgICAgICAgb3V0LnB1c2goXCIgIDwvZz5cXG5cIilcbiAgICAgICAgaW5TdHJva2VHcm91cCA9IGZhbHNlXG4gICAgICB9XG4gICAgICBjb25zdCBlID0gZWxlbWVudC5kYXRhXG4gICAgICBvdXQucHVzaChcbiAgICAgICAgYCAgPHBvbHlsaW5lIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiJHtlLmNvbG9yfVwiIHBvaW50cz1cIiR7ZS5wdHNcbiAgICAgICAgICAubWFwKChwKSA9PiBgJHtwLnh9LCR7cC55fWApXG4gICAgICAgICAgLmpvaW4oXCIgXCIpfVwiIC8+XFxuYCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBDbG9zZSBzdHJva2UgZ3JvdXAgaWYgc3RpbGwgb3BlblxuICBpZiAoaW5TdHJva2VHcm91cCkge1xuICAgIG91dC5wdXNoKFwiICA8L2c+XFxuXCIpXG4gIH1cblxuICBpZiAob3B0LnNob3dPcmlnaW4pIHtcbiAgICBvdXQucHVzaChyZW5kZXJPcmlnaW4oc2NlbmUuY2FtZXJhLCBXLCBIKSlcbiAgfVxuXG4gIGlmIChvcHQuc2hvd0F4ZXMpIHtcbiAgICBvdXQucHVzaChyZW5kZXJBeGVzKHNjZW5lLmNhbWVyYSwgVywgSCkpXG4gIH1cblxuICBvdXQucHVzaChcIjwvc3ZnPlwiKVxuICByZXR1cm4gb3V0LmpvaW4oXCJcIilcbn1cblxuZnVuY3Rpb24gcmVuZGVyQXhlcyhjYW06IENhbWVyYSwgVzogbnVtYmVyLCBIOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBmb2NhbCA9IGNhbS5mb2NhbExlbmd0aCA/PyAyXG4gIGNvbnN0IGJhc2VEaXN0ID0gM1xuICBjb25zdCBtYXJnaW4gPSBNYXRoLm1pbihXLCBIKSAqIDAuMDhcbiAgY29uc3QgYXJyb3dEaXN0ID0gKGJhc2VEaXN0ICogMC4xNikgLyBmb2NhbFxuXG4gIGNvbnN0IGJhc2VQcm9qID0gcHJvaih7IHg6IDAsIHk6IDAsIHo6IGJhc2VEaXN0IH0sIFcsIEgsIGZvY2FsKVxuICBpZiAoIWJhc2VQcm9qKSByZXR1cm4gXCJcIlxuICBjb25zdCBvZmZzZXRYID0gLVcgLyAyICsgbWFyZ2luIC0gYmFzZVByb2oueFxuICBjb25zdCBvZmZzZXRZID0gSCAvIDIgLSBtYXJnaW4gLSBiYXNlUHJvai55XG5cbiAgZnVuY3Rpb24gdChwOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB6OiBudW1iZXIgfSkge1xuICAgIGNvbnN0IHBwID0gcHJvaihwLCBXLCBILCBmb2NhbClcbiAgICByZXR1cm4gcHAgPyB7IHg6IHBwLnggKyBvZmZzZXRYLCB5OiBwcC55ICsgb2Zmc2V0WSB9IDogeyB4OiAwLCB5OiAwIH1cbiAgfVxuXG4gIGNvbnN0IHsgciwgdSwgZiB9ID0gYXhlcyhjYW0pXG4gIGNvbnN0IHN0YXJ0ID0gdCh7IHg6IDAsIHk6IDAsIHo6IGJhc2VEaXN0IH0pXG4gIGNvbnN0IGF4ZXNEYXRhID0gW1xuICAgIHsgdzogeyB4OiAxLCB5OiAwLCB6OiAwIH0sIGNvbG9yOiBcInJlZFwiLCBsYWJlbDogXCJYXCIgfSxcbiAgICB7IHc6IHsgeDogMCwgeTogMSwgejogMCB9LCBjb2xvcjogXCJncmVlblwiLCBsYWJlbDogXCJZXCIgfSxcbiAgICB7IHc6IHsgeDogMCwgeTogMCwgejogMSB9LCBjb2xvcjogXCJibHVlXCIsIGxhYmVsOiBcIlpcIiB9LFxuICBdLm1hcCgoeyB3LCBjb2xvciwgbGFiZWwgfSkgPT4gKHtcbiAgICBkaXI6IHtcbiAgICAgIHg6IHcueCAqIHIueCArIHcueSAqIHIueSArIHcueiAqIHIueixcbiAgICAgIHk6IHcueCAqIHUueCArIHcueSAqIHUueSArIHcueiAqIHUueixcbiAgICAgIHo6IHcueCAqIGYueCArIHcueSAqIGYueSArIHcueiAqIGYueixcbiAgICB9LFxuICAgIGNvbG9yLFxuICAgIGxhYmVsLFxuICB9KSlcblxuICBjb25zdCBwYXJ0czogc3RyaW5nW10gPSBbXVxuICBmb3IgKGNvbnN0IHsgZGlyLCBjb2xvciwgbGFiZWwgfSBvZiBheGVzRGF0YSkge1xuICAgIGNvbnN0IGVuZCA9IHQoe1xuICAgICAgeDogZGlyLnggKiBhcnJvd0Rpc3QsXG4gICAgICB5OiBkaXIueSAqIGFycm93RGlzdCxcbiAgICAgIHo6IGJhc2VEaXN0ICsgZGlyLnogKiBhcnJvd0Rpc3QsXG4gICAgfSlcbiAgICBjb25zdCBkeCA9IGVuZC54IC0gc3RhcnQueFxuICAgIGNvbnN0IGR5ID0gZW5kLnkgLSBzdGFydC55XG4gICAgY29uc3QgbCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgfHwgMVxuICAgIGNvbnN0IG54ID0gZHggLyBsXG4gICAgY29uc3QgbnkgPSBkeSAvIGxcbiAgICBjb25zdCBoeCA9IGVuZC54IC0gbnggKiA4XG4gICAgY29uc3QgaHkgPSBlbmQueSAtIG55ICogOFxuICAgIGNvbnN0IGIxeCA9IGh4ICsgLW55ICogNFxuICAgIGNvbnN0IGIxeSA9IGh5ICsgbnggKiA0XG4gICAgY29uc3QgYjJ4ID0gaHggLSAtbnkgKiA0XG4gICAgY29uc3QgYjJ5ID0gaHkgLSBueCAqIDRcbiAgICBjb25zdCB0eCA9IGVuZC54ICsgbnggKiAxMFxuICAgIGNvbnN0IHR5ID0gZW5kLnkgKyBueSAqIDEwXG4gICAgcGFydHMucHVzaChcbiAgICAgIGAgICAgPGxpbmUgeDE9XCIke2ZtdChzdGFydC54KX1cIiB5MT1cIiR7Zm10KHN0YXJ0LnkpfVwiIHgyPVwiJHtmbXQoaHgpfVwiIHkyPVwiJHtmbXQoaHkpfVwiIHN0cm9rZT1cIiR7Y29sb3J9XCIgLz5gLFxuICAgIClcbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgYCAgICA8cG9seWdvbiBmaWxsPVwiJHtjb2xvcn1cIiBwb2ludHM9XCIke2ZtdChlbmQueCl9LCR7Zm10KGVuZC55KX0gJHtmbXQoYjF4KX0sJHtmbXQoYjF5KX0gJHtmbXQoYjJ4KX0sJHtmbXQoYjJ5KX1cIiAvPmAsXG4gICAgKVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBgICAgIDx0ZXh0IHg9XCIke2ZtdCh0eCl9XCIgeT1cIiR7Zm10KHR5KX1cIiBmaWxsPVwiJHtjb2xvcn1cIiBmb250LXNpemU9XCIxMlwiIGZvbnQtZmFtaWx5PVwic2Fucy1zZXJpZlwiIHRleHQtYW5jaG9yPVwibWlkZGxlXCIgZG9taW5hbnQtYmFzZWxpbmU9XCJjZW50cmFsXCI+JHtsYWJlbH08L3RleHQ+YCxcbiAgICApXG4gIH1cblxuICByZXR1cm4gYCAgPGcgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPlxcbiR7cGFydHMuam9pbihcbiAgICBcIlxcblwiLFxuICApfVxcbiAgPC9nPlxcbmBcbn1cblxuZnVuY3Rpb24gcmVuZGVyR3JpZChcbiAgc2NlbmU6IFNjZW5lLFxuICBXOiBudW1iZXIsXG4gIEg6IG51bWJlcixcbiAgY2VsbFNpemU6IG51bWJlcixcbiAgcGxhbmU6IFwieHlcIiB8IFwieXpcIiB8IFwieHpcIixcbik6IHN0cmluZyB7XG4gIGNvbnN0IGNhbSA9IHNjZW5lLmNhbWVyYVxuICBjb25zdCBmb2NhbCA9IGNhbS5mb2NhbExlbmd0aCA/PyAyXG4gIGNvbnN0IHsgciwgdSwgZiB9ID0gYXhlcyhjYW0pXG5cbiAgLy8gaGVscGVyOiB3b3JsZC0+Y2FtZXJhLT4yRCBwcm9qZWN0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25zdCB0b0NhbSA9IChwOiBQb2ludDMpID0+IHtcbiAgICBjb25zdCBkID0gc3ViKHAsIGNhbS5wb3NpdGlvbilcbiAgICByZXR1cm4geyB4OiBkb3QoZCwgciksIHk6IGRvdChkLCB1KSwgejogZG90KGQsIGYpIH1cbiAgfVxuICBjb25zdCBwcm9qZWN0ID0gKHA6IFBvaW50MykgPT4gcHJvaih0b0NhbShwKSwgVywgSCwgZm9jYWwpXG5cbiAgLy8gZ3JpZCBleHRlbnQgKFx1MDBCMVIgaW4gYm90aCBkaXJlY3Rpb25zKVxuICBjb25zdCBSID0gY2VsbFNpemUgKiAxMCAvLyAyMVx1MDBENzIxIGxpbmVzIGJ5IGRlZmF1bHRcblxuICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXVxuICBmb3IgKGxldCB0ID0gLVI7IHQgPD0gUjsgdCArPSBjZWxsU2l6ZSkge1xuICAgIGNvbnN0IHB1c2hMaW5lID0gKGE6IFBvaW50MywgYjogUG9pbnQzKSA9PiB7XG4gICAgICBjb25zdCBwMCA9IHByb2plY3QoYSlcbiAgICAgIGNvbnN0IHAxID0gcHJvamVjdChiKVxuICAgICAgaWYgKHAwICYmIHAxKSB7XG4gICAgICAgIGxpbmVzLnB1c2goXG4gICAgICAgICAgYCAgICA8bGluZSB4MT1cIiR7Zm10KHAwLngpfVwiIHkxPVwiJHtmbXQocDAueSl9XCIgYCArXG4gICAgICAgICAgICBgeDI9XCIke2ZtdChwMS54KX1cIiB5Mj1cIiR7Zm10KHAxLnkpfVwiIC8+YCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAocGxhbmUpIHtcbiAgICAgIGNhc2UgXCJ4elwiOlxuICAgICAgICBwdXNoTGluZSh7IHg6IHQsIHk6IDAsIHo6IC1SIH0sIHsgeDogdCwgeTogMCwgejogUiB9KSAvLyBsaW5lcyBcdTIwMTYgWlxuICAgICAgICBwdXNoTGluZSh7IHg6IC1SLCB5OiAwLCB6OiB0IH0sIHsgeDogUiwgeTogMCwgejogdCB9KSAvLyBsaW5lcyBcdTIwMTYgWFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInh5XCI6XG4gICAgICAgIHB1c2hMaW5lKHsgeDogdCwgeTogLVIsIHo6IDAgfSwgeyB4OiB0LCB5OiBSLCB6OiAwIH0pIC8vIGxpbmVzIFx1MjAxNiBZXG4gICAgICAgIHB1c2hMaW5lKHsgeDogLVIsIHk6IHQsIHo6IDAgfSwgeyB4OiBSLCB5OiB0LCB6OiAwIH0pIC8vIGxpbmVzIFx1MjAxNiBYXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwieXpcIjpcbiAgICAgICAgcHVzaExpbmUoeyB4OiAwLCB5OiB0LCB6OiAtUiB9LCB7IHg6IDAsIHk6IHQsIHo6IFIgfSkgLy8gbGluZXMgXHUyMDE2IFpcbiAgICAgICAgcHVzaExpbmUoeyB4OiAwLCB5OiAtUiwgejogdCB9LCB7IHg6IDAsIHk6IFIsIHo6IHQgfSkgLy8gbGluZXMgXHUyMDE2IFlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGluZXMubGVuZ3RoXG4gICAgPyBgICA8ZyBzdHJva2U9XCIjY2NjXCIgc3Ryb2tlLXdpZHRoPVwiMC41XCI+XFxuJHtsaW5lcy5qb2luKFwiXFxuXCIpfVxcbiAgPC9nPlxcbmBcbiAgICA6IFwiXCJcbn1cblxuZnVuY3Rpb24gcmVuZGVyT3JpZ2luKGNhbTogQ2FtZXJhLCBXOiBudW1iZXIsIEg6IG51bWJlcik6IHN0cmluZyB7XG4gIC8vIFByb2plY3QgdGhlIHdvcmxkIG9yaWdpbiBhbmQgYXhlcyBkaXJlY3Rpb25zIGludG8gY2FtZXJhIHNwYWNlLCB0aGVuIHRvIDJEXG4gIGNvbnN0IGZvY2FsID0gY2FtLmZvY2FsTGVuZ3RoID8/IDJcbiAgY29uc3QgeyByLCB1LCBmIH0gPSBheGVzKGNhbSlcblxuICAvLyBIZWxwZXI6IHdvcmxkIC0+IGNhbWVyYSBzcGFjZVxuICBjb25zdCB0b0NhbSA9IChwOiBQb2ludDMpID0+IHtcbiAgICBjb25zdCBkID0gc3ViKHAsIGNhbS5wb3NpdGlvbilcbiAgICByZXR1cm4geyB4OiBkb3QoZCwgciksIHk6IGRvdChkLCB1KSwgejogZG90KGQsIGYpIH1cbiAgfVxuICAvLyBIZWxwZXI6IGNhbWVyYSAtPiAyRCBwcm9qZWN0aW9uXG4gIGNvbnN0IHByb2plY3QgPSAocDogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgejogbnVtYmVyIH0pID0+XG4gICAgcHJvaihwLCBXLCBILCBmb2NhbClcblxuICAvLyBEZWZpbmUgYXhlcyBhbmQgdGhlaXIgYmFzZSBjb2xvcnNcbiAgY29uc3QgYXhlc0RhdGEgPSBbXG4gICAgeyBkaXI6IHsgeDogMSwgeTogMCwgejogMCB9LCBjb2xvcjogXCJyZWRcIiB9LFxuICAgIHsgZGlyOiB7IHg6IDAsIHk6IDEsIHo6IDAgfSwgY29sb3I6IFwiZ3JlZW5cIiB9LFxuICAgIHsgZGlyOiB7IHg6IDAsIHk6IDAsIHo6IDEgfSwgY29sb3I6IFwiYmx1ZVwiIH0sXG4gIF1cblxuICBjb25zdCBtaW5MaW5lTGVuZ3RoUHggPSBNYXRoLm1heChXLCBIKSAqIE1hdGguU1FSVDJcblxuICBjb25zdCBwYXJ0czogc3RyaW5nW10gPSBbXVxuICBjb25zdCBvcmlnaW4gPSB7IHg6IDAsIHk6IDAsIHo6IDAgfVxuXG4gIC8vIFNWRyBkZWZzIGZvciBncmFkaWVudHNcbiAgY29uc3QgZ3JhZGllbnREZWZzOiBzdHJpbmdbXSA9IFtdXG5cbiAgYXhlc0RhdGEuZm9yRWFjaCgoeyBkaXIsIGNvbG9yIH0sIGkpID0+IHtcbiAgICBjb25zdCBMID0gMVxuICAgIGNvbnN0IGVuZCA9IGFkZChvcmlnaW4sIHNjYWxlKGRpciwgTCkpXG4gICAgY29uc3Qgc3RhcnRDYW0gPSB0b0NhbShvcmlnaW4pXG4gICAgY29uc3QgZW5kQ2FtID0gdG9DYW0oZW5kKVxuICAgIGNvbnN0IHN0YXJ0MmQgPSBwcm9qZWN0KHN0YXJ0Q2FtKSFcbiAgICBjb25zdCBlbmQyZDEgPSBwcm9qZWN0KGVuZENhbSkhXG4gICAgY29uc3QgZHggPSBlbmQyZDEueCAtIHN0YXJ0MmQueFxuICAgIGNvbnN0IGR5ID0gZW5kMmQxLnkgLSBzdGFydDJkLnlcbiAgICBjb25zdCBsZW4gPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXG4gICAgY29uc3QgZW5kMmQyID0ge1xuICAgICAgeDogc3RhcnQyZC54ICsgKGR4ICogbWluTGluZUxlbmd0aFB4KSAvIGxlbixcbiAgICAgIHk6IHN0YXJ0MmQueSArIChkeSAqIG1pbkxpbmVMZW5ndGhQeCkgLyBsZW4sXG4gICAgfVxuICAgIGlmIChzdGFydDJkICYmIGVuZDJkMSkge1xuICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIGdyYWRpZW50IGlkIGZvciBlYWNoIGF4aXNcbiAgICAgIGNvbnN0IGdyYWRJZCA9IGBheGlzLWdyYWQtJHtpfWBcblxuICAgICAgLy8gQ2FsY3VsYXRlIGdyYWRpZW50IHZlY3RvciBpbiBTVkcgdXNlciBzcGFjZVxuICAgICAgY29uc3QgeDEgPSBmbXQoc3RhcnQyZC54KVxuICAgICAgY29uc3QgeTEgPSBmbXQoc3RhcnQyZC55KVxuICAgICAgY29uc3QgeDIgPSBmbXQoZW5kMmQyLngpXG4gICAgICBjb25zdCB5MiA9IGZtdChlbmQyZDIueSlcblxuICAgICAgLy8gRGVmaW5lIHRoZSBncmFkaWVudDogY29sb3IgYXQgMCUsIHdoaXRlIGF0IDUwJSBhbmQgMTAwJVxuICAgICAgZ3JhZGllbnREZWZzLnB1c2goXG4gICAgICAgIGAgICAgPGxpbmVhckdyYWRpZW50IGlkPVwiJHtncmFkSWR9XCIgeDE9XCIke3gxfVwiIHkxPVwiJHt5MX1cIiB4Mj1cIiR7eDJ9XCIgeTI9XCIke3kyfVwiIGdyYWRpZW50VW5pdHM9XCJ1c2VyU3BhY2VPblVzZVwiPmAgK1xuICAgICAgICAgIGAgICAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCIke2NvbG9yfVwiLz5gICtcbiAgICAgICAgICBgICAgICAgPHN0b3Agb2Zmc2V0PVwiJHtNYXRoLm1pbigobGVuIC8gbWluTGluZUxlbmd0aFB4KSAqIDEwMDAsIDEwMCl9JVwiIHN0b3AtY29sb3I9XCJyZ2JhKDI1NSwyNTUsMjU1LDApXCIvPmAgK1xuICAgICAgICAgIGAgICAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgc3RvcC1jb2xvcj1cInJnYmEoMjU1LDI1NSwyNTUsMClcIi8+YCArXG4gICAgICAgICAgYCAgICA8L2xpbmVhckdyYWRpZW50PmAsXG4gICAgICApXG5cbiAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgIGAgICAgPGxpbmUgeDE9XCIke3gxfVwiIHkxPVwiJHt5MX1cIiB4Mj1cIiR7eDJ9XCIgeTI9XCIke3kyfVwiIHN0cm9rZT1cInVybCgjJHtncmFkSWR9KVwiIC8+YCxcbiAgICAgIClcbiAgICB9XG4gIH0pXG5cbiAgLy8gSW5zZXJ0IGdyYWRpZW50cyBpbnRvIFNWRyA8ZGVmcz4gaWYgYW55XG4gIGlmIChncmFkaWVudERlZnMubGVuZ3RoKSB7XG4gICAgcGFydHMudW5zaGlmdChgICA8ZGVmcz5cXG4ke2dyYWRpZW50RGVmcy5qb2luKFwiXFxuXCIpfVxcbiAgPC9kZWZzPmApXG4gIH1cblxuICByZXR1cm4gcGFydHMubGVuZ3RoXG4gICAgPyBgICA8ZyBzdHJva2Utd2lkdGg9XCIxXCI+XFxuJHtwYXJ0cy5qb2luKFwiXFxuXCIpfVxcbiAgPC9nPlxcbmBcbiAgICA6IFwiXCJcbn1cblxuZnVuY3Rpb24gYXhlcyhjYW06IENhbWVyYSkge1xuICBjb25zdCBmID0gbm9ybShzdWIoY2FtLmxvb2tBdCwgY2FtLnBvc2l0aW9uKSlcbiAgY29uc3Qgd1VwID0geyB4OiAwLCB5OiAxLCB6OiAwIH1cbiAgbGV0IHIgPSBub3JtKGNyb3NzKGYsIHdVcCkpXG4gIGlmICghbGVuKHIpKSByID0geyB4OiAxLCB5OiAwLCB6OiAwIH1cbiAgY29uc3QgdSA9IGNyb3NzKHIsIGYpXG4gIHJldHVybiB7IHIsIHUsIGYgfVxufVxuXG5mdW5jdGlvbiBwcm9qKFxuICBwOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB6OiBudW1iZXIgfSxcbiAgdzogbnVtYmVyLFxuICBoOiBudW1iZXIsXG4gIGZvY2FsOiBudW1iZXIsXG4pOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsIHtcbiAgaWYgKHAueiA8PSAwKSByZXR1cm4gbnVsbFxuICBjb25zdCBzID0gZm9jYWwgLyBwLnpcbiAgcmV0dXJuIHsgeDogKHAueCAqIHMgKiB3KSAvIDIsIHk6ICgtcC55ICogcyAqIGgpIC8gMiB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiO0FBRU8sU0FBUyxJQUFJLEdBQVcsR0FBbUI7QUFDaEQsU0FBTyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFO0FBQ3BEO0FBQ08sU0FBUyxJQUFJLEdBQVcsR0FBbUI7QUFDaEQsU0FBTyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFO0FBQ3BEO0FBQ08sU0FBUyxJQUFJLEdBQVcsR0FBbUI7QUFDaEQsU0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDekM7QUFDTyxTQUFTLE1BQU0sR0FBVyxHQUFtQjtBQUNsRCxTQUFPO0FBQUEsSUFDTCxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFBQSxJQUN2QixHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFBQSxJQUN2QixHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFBQSxFQUN6QjtBQUNGO0FBQ08sU0FBUyxNQUFNLEdBQVcsR0FBbUI7QUFDbEQsU0FBTyxFQUFFLEdBQUcsRUFBRSxJQUFJLEdBQUcsR0FBRyxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzlDO0FBQ08sU0FBUyxJQUFJLEdBQW1CO0FBQ3JDLFNBQU8sS0FBSyxLQUFLLElBQUksR0FBRyxDQUFDLENBQUM7QUFDNUI7QUFDTyxTQUFTLEtBQUssR0FBbUI7QUFDdEMsUUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLO0FBQ3BCLFNBQU8sTUFBTSxHQUFHLElBQUksQ0FBQztBQUN2QjtBQUNPLFNBQVMsU0FBUyxHQUFXLElBQVksRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFXO0FBQzVFLE1BQUksRUFBRSxHQUFHLEdBQUcsRUFBRSxJQUFJO0FBQ2xCLE1BQUksRUFBRSxHQUFHO0FBQ1AsVUFBTSxJQUFJLEtBQUssSUFBSSxFQUFFLENBQUM7QUFDdEIsVUFBTSxJQUFJLEtBQUssSUFBSSxFQUFFLENBQUM7QUFDdEIsVUFBTSxLQUFLLElBQUksSUFBSSxJQUFJO0FBQ3ZCLFFBQUksSUFBSSxJQUFJLElBQUk7QUFDaEIsUUFBSTtBQUFBLEVBQ047QUFDQSxNQUFJLEVBQUUsR0FBRztBQUNQLFVBQU0sSUFBSSxLQUFLLElBQUksRUFBRSxDQUFDO0FBQ3RCLFVBQU0sSUFBSSxLQUFLLElBQUksRUFBRSxDQUFDO0FBQ3RCLFVBQU0sS0FBSyxJQUFJLElBQUksSUFBSTtBQUN2QixRQUFJLENBQUMsSUFBSSxJQUFJLElBQUk7QUFDakIsUUFBSTtBQUFBLEVBQ047QUFDQSxNQUFJLEVBQUUsR0FBRztBQUNQLFVBQU0sSUFBSSxLQUFLLElBQUksRUFBRSxDQUFDO0FBQ3RCLFVBQU0sSUFBSSxLQUFLLElBQUksRUFBRSxDQUFDO0FBQ3RCLFVBQU0sS0FBSyxJQUFJLElBQUksSUFBSTtBQUN2QixRQUFJLElBQUksSUFBSSxJQUFJO0FBQ2hCLFFBQUk7QUFBQSxFQUNOO0FBQ0EsU0FBTyxFQUFFLEdBQUcsR0FBRyxFQUFFO0FBQ25COzs7QUNqRE8sSUFBTSxlQUF5RDtBQUFBLEVBQ3BFLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUFBLEVBQ2YsUUFBUSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDdEIsTUFBTSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDcEIsTUFBTSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDcEIsT0FBTyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDckIsUUFBUSxDQUFDLEtBQUssR0FBRyxDQUFDO0FBQUEsRUFDbEIsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDO0FBQUEsRUFDZixRQUFRLENBQUMsS0FBSyxHQUFHLEdBQUc7QUFBQSxFQUNwQixTQUFTLENBQUMsS0FBSyxHQUFHLEdBQUc7QUFBQSxFQUNyQixPQUFPLENBQUMsR0FBRyxLQUFLLENBQUM7QUFBQSxFQUNqQixNQUFNLENBQUMsR0FBRyxLQUFLLENBQUM7QUFBQSxFQUNoQixPQUFPLENBQUMsS0FBSyxLQUFLLENBQUM7QUFBQSxFQUNuQixRQUFRLENBQUMsS0FBSyxLQUFLLENBQUM7QUFBQSxFQUNwQixNQUFNLENBQUMsR0FBRyxHQUFHLEdBQUc7QUFBQSxFQUNoQixNQUFNLENBQUMsR0FBRyxHQUFHLEdBQUc7QUFBQSxFQUNoQixNQUFNLENBQUMsR0FBRyxLQUFLLEdBQUc7QUFBQSxFQUNsQixNQUFNLENBQUMsR0FBRyxLQUFLLEdBQUc7QUFBQSxFQUNsQixRQUFRLENBQUMsS0FBSyxLQUFLLENBQUM7QUFDdEI7QUFFTyxTQUFTLFdBQVcsR0FBa0I7QUFDM0MsTUFBSSxPQUFPLE1BQU0sU0FBVSxRQUFPO0FBQ2xDLFFBQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLElBQUk7QUFDckIsU0FBTyxRQUFRLEtBQUssTUFBTSxDQUFDLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDckU7QUFFTyxTQUFTLFlBQVksR0FBZ0I7QUFDMUMsTUFBSSxNQUFNLFFBQVEsQ0FBQyxFQUFHLFFBQU87QUFDN0IsUUFBTSxJQUFJLEVBQUUsS0FBSyxFQUFFLFlBQVk7QUFDL0IsTUFBSSxFQUFFLFdBQVcsR0FBRyxHQUFHO0FBQ3JCLFVBQU0sTUFBTSxFQUFFLE1BQU0sQ0FBQztBQUNyQixRQUFJLElBQUksV0FBVyxHQUFHO0FBQ3BCLFlBQU0sSUFBSSxTQUFTLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQ3BELFlBQU0sSUFBSSxTQUFTLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQ3BELFlBQU0sSUFBSSxTQUFTLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQ3BELGFBQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQUEsSUFDcEI7QUFDQSxRQUFJLElBQUksV0FBVyxHQUFHO0FBQ3BCLFlBQU0sSUFBSSxTQUFTLElBQUksTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3RDLFlBQU0sSUFBSSxTQUFTLElBQUksTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3RDLFlBQU0sSUFBSSxTQUFTLElBQUksTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3RDLGFBQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQUEsSUFDcEI7QUFBQSxFQUNGO0FBQ0EsUUFBTSxPQUFPLEVBQUUsTUFBTSxvQkFBb0I7QUFDekMsTUFBSSxNQUFNO0FBQ1IsVUFBTSxVQUFVLEtBQUssQ0FBQztBQUN0QixVQUFNLFFBQVEsUUFBUSxNQUFNLFNBQVMsRUFBRSxJQUFJLE1BQU07QUFDakQsVUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJO0FBQ3JDLFdBQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQUEsRUFDcEI7QUFDQSxRQUFNLFFBQVEsYUFBYSxDQUFDO0FBQzVCLE1BQUksTUFBTyxRQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQztBQUNsRCxTQUFPLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUNwQjtBQUVPLFNBQVMsYUFBYSxHQUFVLEdBQWlCO0FBQ3RELFFBQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLElBQUksWUFBWSxDQUFDO0FBQ2xDLFNBQU8sQ0FBQyxLQUFLLE1BQU0sS0FBSyxHQUFHLEtBQUssTUFBTSxLQUFLLEdBQUcsS0FBSyxNQUFNLEtBQUssR0FBRyxDQUFDO0FBQ3BFO0FBRU8sU0FBUyxZQUFZLEdBQVUsR0FBaUI7QUFDckQsUUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxZQUFZLENBQUM7QUFDbEMsU0FBTyxDQUFDLEtBQUssSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUM7QUFDbEQ7QUFFTyxTQUFTLGNBQWMsTUFBYSxRQUF3QjtBQUNqRSxRQUFNLElBQUksS0FBSyxNQUFNO0FBQ3JCLE1BQUksRUFBRSxLQUFLLEdBQUc7QUFDWixXQUFPLFdBQVcsYUFBYSxNQUFNLEVBQUUsSUFBSSxHQUFHLENBQUM7QUFBQSxFQUNqRCxPQUFPO0FBQ0wsV0FBTyxXQUFXLFlBQVksTUFBTSxDQUFDLEVBQUUsSUFBSSxHQUFHLENBQUM7QUFBQSxFQUNqRDtBQUNGOzs7QUMxRUEsSUFBTSxXQUFXLG9CQUFJLElBQXFCO0FBRTFDLGVBQXNCLFFBQVEsS0FBK0I7QUFDM0QsTUFBSSxTQUFTLElBQUksR0FBRyxHQUFHO0FBQ3JCLFdBQU8sU0FBUyxJQUFJLEdBQUc7QUFBQSxFQUN6QjtBQUVBLFFBQU0sV0FBVyxNQUFNLE1BQU0sR0FBRztBQUNoQyxRQUFNLFNBQVMsTUFBTSxTQUFTLFlBQVk7QUFDMUMsUUFBTSxPQUFPLFNBQVMsTUFBTTtBQUM1QixXQUFTLElBQUksS0FBSyxJQUFJO0FBQ3RCLFNBQU87QUFDVDtBQUVBLFNBQVMsU0FBUyxRQUE4QjtBQUM5QyxRQUFNLE9BQU8sSUFBSSxTQUFTLE1BQU07QUFHaEMsUUFBTSxTQUFTLElBQUksWUFBWSxFQUFFLE9BQU8sT0FBTyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBRTFELE1BQUksT0FBTyxZQUFZLE1BQU0sU0FBUztBQUNwQyxXQUFPLGNBQWMsTUFBTTtBQUFBLEVBQzdCLE9BQU87QUFDTCxXQUFPLGVBQWUsSUFBSTtBQUFBLEVBQzVCO0FBQ0Y7QUFFQSxTQUFTLGNBQWMsUUFBOEI7QUFDbkQsUUFBTSxPQUFPLElBQUksWUFBWSxFQUFFLE9BQU8sTUFBTTtBQUM1QyxRQUFNLFFBQVEsS0FBSyxNQUFNLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxLQUFLLEtBQUssQ0FBQztBQUV4RCxRQUFNLFlBQXdCLENBQUM7QUFDL0IsTUFBSSxJQUFJO0FBRVIsU0FBTyxJQUFJLE1BQU0sUUFBUTtBQUN2QixVQUFNLE9BQU8sTUFBTSxDQUFDO0FBRXBCLFFBQUksUUFBUSxLQUFLLFdBQVcsY0FBYyxHQUFHO0FBQzNDLFlBQU0sY0FBYyxLQUFLO0FBQUEsUUFDdkI7QUFBQSxNQUNGO0FBQ0EsWUFBTSxTQUFpQixjQUNuQjtBQUFBLFFBQ0UsR0FBRyxXQUFXLFlBQVksQ0FBQyxDQUFFO0FBQUEsUUFDN0IsR0FBRyxXQUFXLFlBQVksQ0FBQyxDQUFFO0FBQUEsUUFDN0IsR0FBRyxXQUFXLFlBQVksQ0FBQyxDQUFFO0FBQUEsTUFDL0IsSUFDQSxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFO0FBRXZCO0FBQ0EsWUFBTSxXQUFxQixDQUFDO0FBRTVCLGFBQ0UsSUFBSSxNQUFNLFVBQ1YsTUFBTSxDQUFDLEtBQ1AsQ0FBQyxNQUFNLENBQUMsRUFBRyxXQUFXLFVBQVUsR0FDaEM7QUFDQSxjQUFNLGFBQWEsTUFBTSxDQUFDO0FBQzFCLFlBQUksV0FBVyxXQUFXLFFBQVEsR0FBRztBQUNuQyxnQkFBTSxjQUFjLFdBQVc7QUFBQSxZQUM3QjtBQUFBLFVBQ0Y7QUFDQSxjQUFJLGFBQWE7QUFDZixxQkFBUyxLQUFLO0FBQUEsY0FDWixHQUFHLFdBQVcsWUFBWSxDQUFDLENBQUU7QUFBQSxjQUM3QixHQUFHLFdBQVcsWUFBWSxDQUFDLENBQUU7QUFBQSxjQUM3QixHQUFHLFdBQVcsWUFBWSxDQUFDLENBQUU7QUFBQSxZQUMvQixDQUFDO0FBQUEsVUFDSDtBQUFBLFFBQ0Y7QUFDQTtBQUFBLE1BQ0Y7QUFFQSxVQUFJLFNBQVMsV0FBVyxHQUFHO0FBQ3pCLGtCQUFVLEtBQUs7QUFBQSxVQUNiLFVBQVUsQ0FBQyxTQUFTLENBQUMsR0FBSSxTQUFTLENBQUMsR0FBSSxTQUFTLENBQUMsQ0FBRTtBQUFBLFVBQ25EO0FBQUEsUUFDRixDQUFDO0FBQUEsTUFDSDtBQUFBLElBQ0Y7QUFDQTtBQUFBLEVBQ0Y7QUFHQSxRQUFNLG1CQUFtQixVQUFVLElBQUksQ0FBQyxjQUFjO0FBQUEsSUFDcEQsR0FBRztBQUFBLElBQ0gsVUFBVSxTQUFTLFNBQVMsSUFBSSxDQUFDLE9BQU87QUFBQSxNQUN0QyxHQUFHLEVBQUU7QUFBQSxNQUNMLEdBQUcsQ0FBQyxFQUFFO0FBQUEsTUFDTixHQUFHLEVBQUU7QUFBQSxJQUNQLEVBQUU7QUFBQSxJQUNGLFFBQVE7QUFBQSxNQUNOLEdBQUcsU0FBUyxPQUFPO0FBQUEsTUFDbkIsR0FBRyxDQUFDLFNBQVMsT0FBTztBQUFBLE1BQ3BCLEdBQUcsU0FBUyxPQUFPO0FBQUEsSUFDckI7QUFBQSxFQUNGLEVBQUU7QUFFRixTQUFPO0FBQUEsSUFDTCxXQUFXO0FBQUEsSUFDWCxhQUFhLHFCQUFxQixnQkFBZ0I7QUFBQSxFQUNwRDtBQUNGO0FBRUEsU0FBUyxlQUFlLE1BQXlCO0FBRS9DLE1BQUksU0FBUztBQUdiLFFBQU0sZUFBZSxLQUFLLFVBQVUsUUFBUSxJQUFJO0FBQ2hELFlBQVU7QUFFVixRQUFNLFlBQXdCLENBQUM7QUFFL0IsV0FBUyxJQUFJLEdBQUcsSUFBSSxjQUFjLEtBQUs7QUFFckMsVUFBTSxTQUFpQjtBQUFBLE1BQ3JCLEdBQUcsS0FBSyxXQUFXLFFBQVEsSUFBSTtBQUFBLE1BQy9CLEdBQUcsS0FBSyxXQUFXLFNBQVMsR0FBRyxJQUFJO0FBQUEsTUFDbkMsR0FBRyxLQUFLLFdBQVcsU0FBUyxHQUFHLElBQUk7QUFBQSxJQUNyQztBQUNBLGNBQVU7QUFHVixVQUFNLFdBQXFDO0FBQUEsTUFDekM7QUFBQSxRQUNFLEdBQUcsS0FBSyxXQUFXLFFBQVEsSUFBSTtBQUFBLFFBQy9CLEdBQUcsS0FBSyxXQUFXLFNBQVMsR0FBRyxJQUFJO0FBQUEsUUFDbkMsR0FBRyxLQUFLLFdBQVcsU0FBUyxHQUFHLElBQUk7QUFBQSxNQUNyQztBQUFBLE1BQ0E7QUFBQSxRQUNFLEdBQUcsS0FBSyxXQUFXLFNBQVMsSUFBSSxJQUFJO0FBQUEsUUFDcEMsR0FBRyxLQUFLLFdBQVcsU0FBUyxJQUFJLElBQUk7QUFBQSxRQUNwQyxHQUFHLEtBQUssV0FBVyxTQUFTLElBQUksSUFBSTtBQUFBLE1BQ3RDO0FBQUEsTUFDQTtBQUFBLFFBQ0UsR0FBRyxLQUFLLFdBQVcsU0FBUyxJQUFJLElBQUk7QUFBQSxRQUNwQyxHQUFHLEtBQUssV0FBVyxTQUFTLElBQUksSUFBSTtBQUFBLFFBQ3BDLEdBQUcsS0FBSyxXQUFXLFNBQVMsSUFBSSxJQUFJO0FBQUEsTUFDdEM7QUFBQSxJQUNGO0FBQ0EsY0FBVTtBQUdWLGNBQVU7QUFFVixjQUFVLEtBQUssRUFBRSxVQUFVLE9BQU8sQ0FBQztBQUFBLEVBQ3JDO0FBR0EsUUFBTSxtQkFBbUIsVUFBVSxJQUFJLENBQUMsY0FBYztBQUFBLElBQ3BELEdBQUc7QUFBQSxJQUNILFVBQVUsU0FBUyxTQUFTLElBQUksQ0FBQyxPQUFPO0FBQUEsTUFDdEMsR0FBRyxFQUFFO0FBQUEsTUFDTCxHQUFHLENBQUMsRUFBRTtBQUFBLE1BQ04sR0FBRyxFQUFFO0FBQUEsSUFDUCxFQUFFO0FBQUEsSUFDRixRQUFRO0FBQUEsTUFDTixHQUFHLFNBQVMsT0FBTztBQUFBLE1BQ25CLEdBQUcsQ0FBQyxTQUFTLE9BQU87QUFBQSxNQUNwQixHQUFHLFNBQVMsT0FBTztBQUFBLElBQ3JCO0FBQUEsRUFDRixFQUFFO0FBRUYsU0FBTztBQUFBLElBQ0wsV0FBVztBQUFBLElBQ1gsYUFBYSxxQkFBcUIsZ0JBQWdCO0FBQUEsRUFDcEQ7QUFDRjtBQUVBLFNBQVMscUJBQXFCLFdBRzVCO0FBQ0EsTUFBSSxVQUFVLFdBQVcsR0FBRztBQUMxQixXQUFPO0FBQUEsTUFDTCxLQUFLLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFBQSxNQUN4QixLQUFLLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFBQSxJQUMxQjtBQUFBLEVBQ0Y7QUFFQSxNQUFJLE9BQU8sVUFDVCxPQUFPLFVBQ1AsT0FBTztBQUNULE1BQUksT0FBTyxXQUNULE9BQU8sV0FDUCxPQUFPO0FBRVQsYUFBVyxZQUFZLFdBQVc7QUFDaEMsZUFBVyxVQUFVLFNBQVMsVUFBVTtBQUN0QyxhQUFPLEtBQUssSUFBSSxNQUFNLE9BQU8sQ0FBQztBQUM5QixhQUFPLEtBQUssSUFBSSxNQUFNLE9BQU8sQ0FBQztBQUM5QixhQUFPLEtBQUssSUFBSSxNQUFNLE9BQU8sQ0FBQztBQUM5QixhQUFPLEtBQUssSUFBSSxNQUFNLE9BQU8sQ0FBQztBQUM5QixhQUFPLEtBQUssSUFBSSxNQUFNLE9BQU8sQ0FBQztBQUM5QixhQUFPLEtBQUssSUFBSSxNQUFNLE9BQU8sQ0FBQztBQUFBLElBQ2hDO0FBQUEsRUFDRjtBQUVBLFNBQU87QUFBQSxJQUNMLEtBQUssRUFBRSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsS0FBSztBQUFBLElBQ2pDLEtBQUssRUFBRSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsS0FBSztBQUFBLEVBQ25DO0FBQ0Y7OztBQzVNQSxJQUFNLFdBQVcsb0JBQUksSUFBcUI7QUFFMUMsZUFBc0IsUUFBUSxLQUErQjtBQUMzRCxNQUFJLFNBQVMsSUFBSSxHQUFHLEdBQUc7QUFDckIsV0FBTyxTQUFTLElBQUksR0FBRztBQUFBLEVBQ3pCO0FBQ0EsUUFBTSxXQUFXLE1BQU0sTUFBTSxHQUFHO0FBQ2hDLFFBQU0sT0FBTyxNQUFNLFNBQVMsS0FBSztBQUNqQyxRQUFNLE9BQU8sU0FBUyxJQUFJO0FBQzFCLFdBQVMsSUFBSSxLQUFLLElBQUk7QUFDdEIsU0FBTztBQUNUO0FBRUEsU0FBUyxTQUFTLE1BQXVCO0FBQ3ZDLFFBQU0sUUFBUSxLQUFLLE1BQU0sT0FBTztBQUNoQyxRQUFNLFdBQXFCLENBQUM7QUFDNUIsUUFBTSxlQUFzQyxDQUFDO0FBQzdDLFFBQU0sVUFBb0IsQ0FBQztBQUMzQixRQUFNLFlBQXdCLENBQUM7QUFDL0IsUUFBTSxpQkFBd0MsQ0FBQztBQUMvQyxNQUFJO0FBRUosYUFBVyxRQUFRLE9BQU87QUFDeEIsVUFBTSxVQUFVLEtBQUssS0FBSztBQUMxQixRQUFJLFFBQVEsV0FBVyxJQUFJLEdBQUc7QUFDNUIsWUFBTSxRQUFRLFFBQVEsTUFBTSxLQUFLO0FBQ2pDLFlBQU0sSUFBSSxNQUFNLENBQUM7QUFDakIsWUFBTSxJQUFJLE1BQU0sQ0FBQztBQUNqQixZQUFNLElBQUksTUFBTSxDQUFDO0FBQ2pCLGVBQVMsS0FBSyxFQUFFLEdBQUcsV0FBVyxDQUFDLEdBQUcsR0FBRyxXQUFXLENBQUMsR0FBRyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQztBQUN2RSxVQUFJLE1BQU0sVUFBVSxHQUFHO0FBQ3JCLGNBQU0sQ0FBQyxNQUFNLE1BQU0sSUFBSSxJQUFJLE1BQU0sTUFBTSxHQUFHLENBQUM7QUFDM0MsWUFBSSxJQUFJLE9BQU8sSUFBSTtBQUNuQixZQUFJLElBQUksT0FBTyxJQUFJO0FBQ25CLFlBQUksSUFBSSxPQUFPLElBQUk7QUFDbkIsWUFBSSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRztBQUM5QixlQUFLO0FBQ0wsZUFBSztBQUNMLGVBQUs7QUFBQSxRQUNQO0FBQ0EscUJBQWEsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUFBLE1BQ2hDLE9BQU87QUFDTCxxQkFBYSxLQUFLLE1BQVM7QUFBQSxNQUM3QjtBQUFBLElBQ0YsV0FBVyxRQUFRLFdBQVcsS0FBSyxHQUFHO0FBQ3BDLFlBQU0sUUFBUSxRQUFRLE1BQU0sS0FBSztBQUNqQyxZQUFNLElBQUksTUFBTSxDQUFDO0FBQ2pCLFlBQU0sSUFBSSxNQUFNLENBQUM7QUFDakIsWUFBTSxJQUFJLE1BQU0sQ0FBQztBQUNqQixjQUFRLEtBQUssRUFBRSxHQUFHLFdBQVcsQ0FBQyxHQUFHLEdBQUcsV0FBVyxDQUFDLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUM7QUFBQSxJQUN4RSxXQUFXLFFBQVEsV0FBVyxTQUFTLEdBQUc7QUFDeEMsdUJBQWlCLFFBQVEsTUFBTSxLQUFLLEVBQUUsQ0FBQztBQUFBLElBQ3pDLFdBQVcsUUFBUSxXQUFXLEtBQUssS0FBSyxnQkFBZ0I7QUFDdEQsWUFBTSxRQUFRLFFBQVEsTUFBTSxLQUFLO0FBQ2pDLFlBQU0sT0FBTyxNQUFNLENBQUM7QUFDcEIsWUFBTSxPQUFPLE1BQU0sQ0FBQztBQUNwQixZQUFNLE9BQU8sTUFBTSxDQUFDO0FBQ3BCLFVBQUksSUFBSSxXQUFXLElBQUk7QUFDdkIsVUFBSSxJQUFJLFdBQVcsSUFBSTtBQUN2QixVQUFJLElBQUksV0FBVyxJQUFJO0FBQ3ZCLFVBQUksS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUc7QUFDOUIsYUFBSztBQUNMLGFBQUs7QUFDTCxhQUFLO0FBQUEsTUFDUDtBQUNBLHFCQUFlLGNBQWMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFBQSxJQUM5QyxXQUFXLFFBQVEsV0FBVyxTQUFTLEdBQUc7QUFDeEMsdUJBQWlCLFFBQVEsTUFBTSxLQUFLLEVBQUUsQ0FBQztBQUFBLElBQ3pDLFdBQVcsUUFBUSxXQUFXLElBQUksR0FBRztBQUNuQyxZQUFNLFFBQVEsUUFBUSxNQUFNLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxLQUFLO0FBQ2pELFlBQU0sT0FBTyxNQUFNLElBQUksQ0FBQyxNQUFNO0FBQzVCLGNBQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxHQUFHO0FBQzlCLGVBQU87QUFBQSxVQUNMLEdBQUcsU0FBUyxFQUFFLElBQUk7QUFBQSxVQUNsQixHQUFHLEtBQUssU0FBUyxFQUFFLElBQUksSUFBSTtBQUFBLFFBQzdCO0FBQUEsTUFDRixDQUFDO0FBQ0QsZUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFNBQVMsR0FBRyxLQUFLO0FBQ3hDLGNBQU0sSUFBSSxLQUFLLENBQUM7QUFDaEIsY0FBTSxJQUFJLEtBQUssQ0FBQztBQUNoQixjQUFNLElBQUksS0FBSyxJQUFJLENBQUM7QUFDcEIsY0FBTSxLQUFLLFNBQVMsRUFBRSxDQUFDO0FBQ3ZCLGNBQU0sS0FBSyxTQUFTLEVBQUUsQ0FBQztBQUN2QixjQUFNLEtBQUssU0FBUyxFQUFFLENBQUM7QUFDdkIsWUFBSTtBQUNKLFlBQUksRUFBRSxNQUFNLFVBQWEsUUFBUSxFQUFFLENBQUMsR0FBRztBQUNyQyxtQkFBUyxRQUFRLEVBQUUsQ0FBQztBQUFBLFFBQ3RCLFdBQVcsRUFBRSxNQUFNLFVBQWEsUUFBUSxFQUFFLENBQUMsR0FBRztBQUM1QyxtQkFBUyxRQUFRLEVBQUUsQ0FBQztBQUFBLFFBQ3RCLFdBQVcsRUFBRSxNQUFNLFVBQWEsUUFBUSxFQUFFLENBQUMsR0FBRztBQUM1QyxtQkFBUyxRQUFRLEVBQUUsQ0FBQztBQUFBLFFBQ3RCLE9BQU87QUFDTCxnQkFBTSxRQUFRO0FBQUEsWUFDWixHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQUEsWUFDYixHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQUEsWUFDYixHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQUEsVUFDZjtBQUNBLGdCQUFNLFFBQVE7QUFBQSxZQUNaLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFBQSxZQUNiLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFBQSxZQUNiLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFBQSxVQUNmO0FBQ0EsbUJBQVM7QUFBQSxZQUNQLEdBQUcsTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTTtBQUFBLFlBQ3ZDLEdBQUcsTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTTtBQUFBLFlBQ3ZDLEdBQUcsRUFBRSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNO0FBQUEsVUFDM0M7QUFBQSxRQUNGO0FBQ0EsWUFBSTtBQUNKLFlBQUksa0JBQWtCLGVBQWUsY0FBYyxHQUFHO0FBQ3BELGtCQUFRLGVBQWUsY0FBYztBQUFBLFFBQ3ZDLE9BQU87QUFDTCxrQkFBUSxhQUFhLEVBQUUsQ0FBQyxLQUFLLGFBQWEsRUFBRSxDQUFDLEtBQUssYUFBYSxFQUFFLENBQUM7QUFBQSxRQUNwRTtBQUNBLGtCQUFVLEtBQUssRUFBRSxVQUFVLENBQUMsSUFBSSxJQUFJLEVBQUUsR0FBRyxRQUFRLE1BQU0sQ0FBQztBQUFBLE1BQzFEO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFQSxTQUFPO0FBQUEsSUFDTDtBQUFBLElBQ0EsYUFBYUEsc0JBQXFCLFNBQVM7QUFBQSxFQUM3QztBQUNGO0FBRUEsU0FBU0Esc0JBQXFCLFdBRzVCO0FBQ0EsTUFBSSxVQUFVLFdBQVcsR0FBRztBQUMxQixXQUFPLEVBQUUsS0FBSyxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsS0FBSyxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLEVBQUU7QUFBQSxFQUNoRTtBQUVBLE1BQUksT0FBTztBQUNYLE1BQUksT0FBTztBQUNYLE1BQUksT0FBTztBQUNYLE1BQUksT0FBTztBQUNYLE1BQUksT0FBTztBQUNYLE1BQUksT0FBTztBQUVYLGFBQVcsT0FBTyxXQUFXO0FBQzNCLGVBQVcsS0FBSyxJQUFJLFVBQVU7QUFDNUIsVUFBSSxFQUFFLElBQUksS0FBTSxRQUFPLEVBQUU7QUFDekIsVUFBSSxFQUFFLElBQUksS0FBTSxRQUFPLEVBQUU7QUFDekIsVUFBSSxFQUFFLElBQUksS0FBTSxRQUFPLEVBQUU7QUFDekIsVUFBSSxFQUFFLElBQUksS0FBTSxRQUFPLEVBQUU7QUFDekIsVUFBSSxFQUFFLElBQUksS0FBTSxRQUFPLEVBQUU7QUFDekIsVUFBSSxFQUFFLElBQUksS0FBTSxRQUFPLEVBQUU7QUFBQSxJQUMzQjtBQUFBLEVBQ0Y7QUFFQSxTQUFPO0FBQUEsSUFDTCxLQUFLLEVBQUUsR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLEtBQUs7QUFBQSxJQUNqQyxLQUFLLEVBQUUsR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLEtBQUs7QUFBQSxFQUNuQztBQUNGOzs7QUM1SkEsU0FBUyxpQkFBaUI7QUFDMUIsU0FBUyxpQkFBaUI7QUFFMUIsSUFBTSxlQUFlLG9CQUFJLElBQXFCO0FBRTlDLGVBQXNCLFFBQVEsS0FBK0I7QUFDM0QsTUFBSSxhQUFhLElBQUksR0FBRyxHQUFHO0FBQ3pCLFdBQU8sYUFBYSxJQUFJLEdBQUc7QUFBQSxFQUM3QjtBQUVBLFFBQU0sV0FBVyxNQUFNLE1BQU0sR0FBRztBQUNoQyxRQUFNLFNBQVMsTUFBTSxTQUFTLFlBQVk7QUFDMUMsUUFBTSxRQUFRLFVBQVUsSUFBSSxXQUFXLE1BQU0sQ0FBQztBQUM5QyxRQUFNLFlBQVksTUFBTSxrQkFBa0I7QUFDMUMsTUFBSSxDQUFDLFVBQVcsT0FBTSxJQUFJLE1BQU0sMEJBQTBCO0FBQzFELFFBQU0sV0FBVyxJQUFJLFlBQVksRUFBRSxPQUFPLFNBQVM7QUFDbkQsUUFBTSxPQUFPLFNBQVMsUUFBUTtBQUM5QixlQUFhLElBQUksS0FBSyxJQUFJO0FBQzFCLFNBQU87QUFDVDtBQUVBLFNBQVMsU0FBUyxLQUFzQjtBQUN0QyxRQUFNLFNBQVMsSUFBSSxVQUFVLEVBQUUsa0JBQWtCLE1BQU0sQ0FBQztBQUN4RCxRQUFNLE9BQU8sT0FBTyxNQUFNLEdBQUc7QUFDN0IsUUFBTSxhQUNKLE1BQU0sT0FBTyxXQUFXLFFBQVEsTUFBTSxVQUFVLFVBQVUsQ0FBQztBQUM3RCxRQUFNLGNBQWMsTUFBTSxRQUFRLFVBQVUsSUFBSSxhQUFhLENBQUMsVUFBVTtBQUN4RSxRQUFNLFdBQXFCLFlBQVksSUFBSSxDQUFDLE9BQVk7QUFBQSxJQUN0RCxHQUFHLFdBQVcsRUFBRSxLQUFLLENBQUM7QUFBQSxJQUN0QixHQUFHLFdBQVcsRUFBRSxLQUFLLENBQUM7QUFBQSxJQUN0QixHQUFHLFdBQVcsRUFBRSxLQUFLLENBQUM7QUFBQSxFQUN4QixFQUFFO0FBRUYsUUFBTSxnQkFBZ0IsTUFBTSxPQUFPLFdBQVc7QUFDOUMsUUFBTSxpQkFBcUUsQ0FBQztBQUM1RSxNQUFJLGVBQWU7QUFDakIsVUFBTSxPQUFPLE1BQU0sUUFBUSxhQUFhLElBQUksZ0JBQWdCLENBQUMsYUFBYTtBQUMxRSxlQUFXLE9BQU8sTUFBTTtBQUN0QixZQUFNLEtBQUssSUFBSSxNQUFNO0FBQ3JCLFlBQU0sUUFBUSxJQUFJLFFBQVEsQ0FBQztBQUMzQixZQUFNLFdBQVcsTUFBTSxRQUFRLEtBQUssSUFBSSxRQUFRLENBQUMsS0FBSztBQUN0RCxxQkFBZSxFQUFFLElBQUksU0FBUztBQUFBLFFBQUksQ0FBQyxNQUNqQyxrQkFBa0IsRUFBRSxnQkFBZ0IsQ0FBQztBQUFBLE1BQ3ZDO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFQSxRQUFNLGVBQ0osTUFBTSxPQUFPLFdBQVcsUUFBUSxNQUFNLFdBQVcsWUFBWSxDQUFDO0FBQ2hFLFFBQU0sZUFBZSxNQUFNLFFBQVEsWUFBWSxJQUMzQyxlQUNBLENBQUMsWUFBWTtBQUNqQixRQUFNLFlBQXdCLGFBQWEsSUFBSSxDQUFDLE1BQVc7QUFDekQsVUFBTSxLQUFLLFNBQVMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3ZDLFVBQU0sS0FBSyxTQUFTLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUN2QyxVQUFNLEtBQUssU0FBUyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDdkMsVUFBTSxRQUFRLEVBQUUsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEVBQUU7QUFDL0QsVUFBTSxRQUFRLEVBQUUsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEVBQUU7QUFDL0QsVUFBTSxTQUFTO0FBQUEsTUFDYixHQUFHLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU07QUFBQSxNQUN2QyxHQUFHLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU07QUFBQSxNQUN2QyxHQUFHLEVBQUUsTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTTtBQUFBLElBQzNDO0FBQ0EsUUFBSTtBQUNKLFVBQU0sTUFBTSxFQUFFLE9BQU87QUFDckIsUUFBSSxPQUFPLGVBQWUsR0FBRyxHQUFHO0FBQzlCLFlBQU0sTUFBTSxTQUFTLEVBQUUsTUFBTSxLQUFLLEVBQUUsTUFBTSxLQUFLLEVBQUUsTUFBTSxLQUFLLEdBQUc7QUFDL0QsY0FBUSxlQUFlLEdBQUcsRUFBRSxHQUFHO0FBQUEsSUFDakM7QUFDQSxXQUFPLFFBQ0gsRUFBRSxVQUFVLENBQUMsSUFBSSxJQUFJLEVBQUUsR0FBRyxRQUFRLE1BQU0sSUFDeEMsRUFBRSxVQUFVLENBQUMsSUFBSSxJQUFJLEVBQUUsR0FBRyxPQUFPO0FBQUEsRUFDdkMsQ0FBQztBQUVELFFBQU0sbUJBQW1CLFVBQVUsSUFBSSxDQUFDLFNBQVM7QUFBQSxJQUMvQyxHQUFHO0FBQUEsSUFDSCxVQUFVLElBQUksU0FBUyxJQUFJLENBQUMsT0FBTztBQUFBLE1BQ2pDLEdBQUcsRUFBRTtBQUFBLE1BQ0wsR0FBRyxDQUFDLEVBQUU7QUFBQSxNQUNOLEdBQUcsRUFBRTtBQUFBLElBQ1AsRUFBRTtBQUFBLElBQ0YsUUFBUTtBQUFBLE1BQ04sR0FBRyxJQUFJLE9BQU87QUFBQSxNQUNkLEdBQUcsQ0FBQyxJQUFJLE9BQU87QUFBQSxNQUNmLEdBQUcsSUFBSSxPQUFPO0FBQUEsSUFDaEI7QUFBQSxFQUNGLEVBQUU7QUFFRixTQUFPO0FBQUEsSUFDTCxXQUFXO0FBQUEsSUFDWCxhQUFhQyxzQkFBcUIsZ0JBQWdCO0FBQUEsRUFDcEQ7QUFDRjtBQUVBLFNBQVMsa0JBQWtCLEtBQStDO0FBQ3hFLE1BQUksS0FBSyxXQUFXLEdBQUcsR0FBRztBQUN4QixVQUFNLE1BQU0sSUFBSSxNQUFNLENBQUM7QUFDdkIsUUFBSSxJQUFJLFdBQVcsR0FBRztBQUNwQixZQUFNLElBQUksU0FBUyxJQUFJLE1BQU0sR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUN0QyxZQUFNLElBQUksU0FBUyxJQUFJLE1BQU0sR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUN0QyxZQUFNLElBQUksU0FBUyxJQUFJLE1BQU0sR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUN0QyxZQUFNLElBQUksU0FBUyxJQUFJLE1BQU0sR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJO0FBQzFDLGFBQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQUEsSUFDcEI7QUFDQSxRQUFJLElBQUksV0FBVyxHQUFHO0FBQ3BCLFlBQU0sSUFBSSxTQUFTLElBQUksTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3RDLFlBQU0sSUFBSSxTQUFTLElBQUksTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3RDLFlBQU0sSUFBSSxTQUFTLElBQUksTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3RDLGFBQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQUEsSUFDcEI7QUFBQSxFQUNGO0FBQ0EsU0FBTyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDcEI7QUFFQSxTQUFTQSxzQkFBcUIsV0FHNUI7QUFDQSxNQUFJLFVBQVUsV0FBVyxHQUFHO0FBQzFCLFdBQU8sRUFBRSxLQUFLLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxLQUFLLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsRUFBRTtBQUFBLEVBQ2hFO0FBRUEsTUFBSSxPQUFPO0FBQ1gsTUFBSSxPQUFPO0FBQ1gsTUFBSSxPQUFPO0FBQ1gsTUFBSSxPQUFPO0FBQ1gsTUFBSSxPQUFPO0FBQ1gsTUFBSSxPQUFPO0FBRVgsYUFBVyxPQUFPLFdBQVc7QUFDM0IsZUFBVyxLQUFLLElBQUksVUFBVTtBQUM1QixVQUFJLEVBQUUsSUFBSSxLQUFNLFFBQU8sRUFBRTtBQUN6QixVQUFJLEVBQUUsSUFBSSxLQUFNLFFBQU8sRUFBRTtBQUN6QixVQUFJLEVBQUUsSUFBSSxLQUFNLFFBQU8sRUFBRTtBQUN6QixVQUFJLEVBQUUsSUFBSSxLQUFNLFFBQU8sRUFBRTtBQUN6QixVQUFJLEVBQUUsSUFBSSxLQUFNLFFBQU8sRUFBRTtBQUN6QixVQUFJLEVBQUUsSUFBSSxLQUFNLFFBQU8sRUFBRTtBQUFBLElBQzNCO0FBQUEsRUFDRjtBQUVBLFNBQU87QUFBQSxJQUNMLEtBQUssRUFBRSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsS0FBSztBQUFBLElBQ2pDLEtBQUssRUFBRSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsS0FBSztBQUFBLEVBQ25DO0FBQ0Y7OztBQzlJTyxTQUFTLHFCQUNkLE1BQ0EsS0FDQSxZQUNBLFdBQ1U7QUFDVixRQUFNLEVBQUUsWUFBWSxJQUFJO0FBQ3hCLFFBQU0sYUFBYSxNQUFNLElBQUksWUFBWSxLQUFLLFlBQVksR0FBRyxHQUFHLEdBQUc7QUFDbkUsUUFBTSxjQUFjLElBQUksZ0JBQWdCO0FBR3hDLFFBQU0sZUFBeUIsQ0FBQztBQUNoQyxhQUFXLE9BQU8sS0FBSyxXQUFXO0FBQ2hDLGVBQVcsS0FBSyxJQUFJLFVBQVU7QUFDNUIsVUFBSSxJQUFJLElBQUksR0FBRyxVQUFVO0FBQ3pCLFVBQUksY0FBYyxTQUFTLElBQUk7QUFDN0IsWUFBSSxTQUFTLEdBQUcsSUFBSSxXQUFXO0FBQ2pDLFVBQUksY0FBYyxTQUFTLElBQUk7QUFDN0IsWUFBSSxTQUFTLEdBQUcsSUFBSSxXQUFXO0FBQ2pDLFVBQUksY0FBYyxTQUFTLElBQUk7QUFDN0IsWUFBSSxTQUFTLEdBQUcsSUFBSSxlQUFlO0FBQ3JDLFVBQUksQ0FBQyxZQUFhLEtBQUksSUFBSSxHQUFHLFVBQVU7QUFDdkMsbUJBQWEsS0FBSyxDQUFDO0FBQUEsSUFDckI7QUFBQSxFQUNGO0FBRUEsTUFBSSxlQUFlO0FBQ25CLE1BQUksZ0JBQWdCLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFFdkMsTUFBSSxZQUFZO0FBRWQsUUFBSSxNQUFNLEVBQUUsR0FBRyxVQUFVLEdBQUcsVUFBVSxHQUFHLFNBQVM7QUFDbEQsUUFBSSxNQUFNLEVBQUUsR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLFVBQVU7QUFDckQsZUFBVyxLQUFLLGNBQWM7QUFDNUIsVUFBSSxFQUFFLElBQUksSUFBSSxFQUFHLEtBQUksSUFBSSxFQUFFO0FBQzNCLFVBQUksRUFBRSxJQUFJLElBQUksRUFBRyxLQUFJLElBQUksRUFBRTtBQUMzQixVQUFJLEVBQUUsSUFBSSxJQUFJLEVBQUcsS0FBSSxJQUFJLEVBQUU7QUFDM0IsVUFBSSxFQUFFLElBQUksSUFBSSxFQUFHLEtBQUksSUFBSSxFQUFFO0FBQzNCLFVBQUksRUFBRSxJQUFJLElBQUksRUFBRyxLQUFJLElBQUksRUFBRTtBQUMzQixVQUFJLEVBQUUsSUFBSSxJQUFJLEVBQUcsS0FBSSxJQUFJLEVBQUU7QUFBQSxJQUM3QjtBQUNBLFVBQU0sY0FBYyxJQUFJLEtBQUssR0FBRztBQUNoQyxVQUFNLFVBQVUsSUFBSTtBQUNwQixVQUFNLFNBQVMsUUFBUSxJQUFJLFlBQVk7QUFDdkMsVUFBTSxTQUFTLFFBQVEsSUFBSSxZQUFZO0FBQ3ZDLFVBQU0sU0FBUyxRQUFRLElBQUksWUFBWTtBQUN2QyxtQkFBZSxLQUFLLElBQUksUUFBUSxRQUFRLE1BQU07QUFDOUMsb0JBQWdCLE1BQU0sSUFBSSxLQUFLLEdBQUcsR0FBRyxHQUFHO0FBQUEsRUFDMUM7QUFFQSxRQUFNLHNCQUFnQyxDQUFDO0FBQ3ZDLGFBQVcsS0FBSyxjQUFjO0FBQzVCLFFBQUksSUFBSTtBQUNSLFFBQUksWUFBWTtBQUNkLFVBQUksSUFBSSxHQUFHLGFBQWE7QUFDeEIsVUFBSSxNQUFNLEdBQUcsWUFBWTtBQUN6QixVQUFJLENBQUMsWUFBYSxLQUFJLElBQUksR0FBRyxhQUFhO0FBQUEsSUFDNUM7QUFDQSxRQUFJLElBQUksWUFBYSxLQUFJLElBQUksR0FBRyxJQUFJLFdBQVc7QUFDL0MsUUFBSSxJQUFJLFlBQWEsS0FBSSxJQUFJLEdBQUcsSUFBSSxXQUFXO0FBQy9DLFFBQUksSUFBSSxnQkFBaUIsS0FBSSxJQUFJLEdBQUcsSUFBSSxlQUFlO0FBQ3ZELFFBQUksSUFBSSxTQUFVLEtBQUksU0FBUyxHQUFHLElBQUksUUFBUTtBQUM5QyxRQUFJLElBQUksR0FBRyxJQUFJLE1BQU07QUFDckIsd0JBQW9CLEtBQUssQ0FBQztBQUFBLEVBQzVCO0FBRUEsU0FBTztBQUNUOzs7QUNsRU8sSUFBTSxRQUE0QztBQUFBLEVBQ3ZELENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUFBLEVBQ1gsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQUEsRUFDWCxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFBQSxFQUNYLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUFBLEVBQ1gsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQUEsRUFDWCxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDYjtBQUNPLElBQU0sUUFBNEI7QUFBQSxFQUN2QyxDQUFDLEdBQUcsQ0FBQztBQUFBLEVBQ0wsQ0FBQyxHQUFHLENBQUM7QUFBQSxFQUNMLENBQUMsR0FBRyxDQUFDO0FBQUEsRUFDTCxDQUFDLEdBQUcsQ0FBQztBQUFBLEVBQ0wsQ0FBQyxHQUFHLENBQUM7QUFBQSxFQUNMLENBQUMsR0FBRyxDQUFDO0FBQUEsRUFDTCxDQUFDLEdBQUcsQ0FBQztBQUFBLEVBQ0wsQ0FBQyxHQUFHLENBQUM7QUFBQSxFQUNMLENBQUMsR0FBRyxDQUFDO0FBQUEsRUFDTCxDQUFDLEdBQUcsQ0FBQztBQUFBLEVBQ0wsQ0FBQyxHQUFHLENBQUM7QUFBQSxFQUNMLENBQUMsR0FBRyxDQUFDO0FBQ1A7QUFDTyxJQUFNLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBRXZCLFNBQVMsTUFBTSxHQUFrQjtBQUN0QyxRQUFNO0FBQUEsSUFDSixNQUFNLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLEdBQUc7QUFBQSxJQUM1QjtBQUFBLElBQ0E7QUFBQSxFQUNGLElBQUk7QUFDSixRQUFNLE9BQU87QUFBQSxJQUNYLEVBQUUsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEVBQUU7QUFBQSxJQUNyQyxFQUFFLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssRUFBRTtBQUFBLElBQ3BDLEVBQUUsR0FBRyxLQUFLLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssRUFBRTtBQUFBLElBQ25DLEVBQUUsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxFQUFFO0FBQUEsSUFDcEMsRUFBRSxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxLQUFLLEVBQUU7QUFBQSxJQUNwQyxFQUFFLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxLQUFLLEVBQUU7QUFBQSxJQUNuQyxFQUFFLEdBQUcsS0FBSyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsS0FBSyxFQUFFO0FBQUEsSUFDbEMsRUFBRSxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsS0FBSyxFQUFFO0FBQUEsRUFDckM7QUFDQSxTQUFPLEtBQUssSUFBSSxDQUFDLE1BQU0sSUFBSSxRQUFRLFNBQVMsR0FBRyxRQUFRLENBQUMsQ0FBQztBQUMzRDs7O0FDckNPLFNBQVMsS0FDZCxHQUM0QjtBQUM1QixRQUFNLElBQUksRUFBRSxDQUFDLEVBQUcsQ0FBQyxHQUNmLElBQUksRUFBRSxDQUFDLEVBQUcsQ0FBQyxHQUNYLElBQUksRUFBRSxDQUFDLEVBQUcsQ0FBQztBQUNiLFFBQU0sSUFBSSxFQUFFLENBQUMsRUFBRyxDQUFDLEdBQ2YsSUFBSSxFQUFFLENBQUMsRUFBRyxDQUFDLEdBQ1gsSUFBSSxFQUFFLENBQUMsRUFBRyxDQUFDO0FBQ2IsUUFBTSxJQUFJLEVBQUUsQ0FBQyxFQUFHLENBQUMsR0FDZixJQUFJLEVBQUUsQ0FBQyxFQUFHLENBQUMsR0FDWCxJQUFJLEVBQUUsQ0FBQyxFQUFHLENBQUM7QUFDYixRQUFNLElBQUksSUFBSSxJQUFJLElBQUk7QUFDdEIsUUFBTSxJQUFJLEVBQUUsSUFBSSxJQUFJLElBQUk7QUFDeEIsUUFBTSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQ3RCLFFBQU0sSUFBSSxFQUFFLElBQUksSUFBSSxJQUFJO0FBQ3hCLFFBQU0sSUFBSSxJQUFJLElBQUksSUFBSTtBQUN0QixRQUFNLElBQUksRUFBRSxJQUFJLElBQUksSUFBSTtBQUN4QixRQUFNLElBQUksSUFBSSxJQUFJLElBQUk7QUFDdEIsUUFBTSxJQUFJLEVBQUUsSUFBSSxJQUFJLElBQUk7QUFDeEIsUUFBTSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQ3RCLFFBQU0sTUFBTSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFDaEMsUUFBTSxTQUFTLE1BQU0sSUFBSSxNQUFNO0FBQy9CLFNBQU87QUFBQSxJQUNMLENBQUMsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLE1BQU07QUFBQSxJQUNuQyxDQUFDLElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxNQUFNO0FBQUEsSUFDbkMsQ0FBQyxJQUFJLFFBQVEsSUFBSSxRQUFRLElBQUksTUFBTTtBQUFBLEVBQ3JDO0FBQ0Y7QUFLTyxTQUFTLEtBQ2QsR0FDQSxHQUM0QjtBQUM1QixRQUFNLElBQWdDO0FBQUEsSUFDcEMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUFBLElBQ1IsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUFBLElBQ1IsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUFBLEVBQ1Y7QUFDQSxXQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSztBQUMxQixhQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSztBQUMxQixRQUFFLENBQUMsRUFBRyxDQUFDLElBQ0wsRUFBRSxDQUFDLEVBQUcsQ0FBQyxJQUFLLEVBQUUsQ0FBQyxFQUFHLENBQUMsSUFBSyxFQUFFLENBQUMsRUFBRyxDQUFDLElBQUssRUFBRSxDQUFDLEVBQUcsQ0FBQyxJQUFLLEVBQUUsQ0FBQyxFQUFHLENBQUMsSUFBSyxFQUFFLENBQUMsRUFBRyxDQUFDO0FBQUEsSUFDdkU7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUNUO0FBR08sU0FBUyxhQUNkLEtBQ0EsS0FDUTtBQUNSLFFBQU0sSUFBZ0M7QUFBQSxJQUNwQyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO0FBQUEsSUFDN0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUFBLElBQzdCLENBQUMsR0FBRyxHQUFHLENBQUM7QUFBQSxFQUNWO0FBQ0EsUUFBTSxJQUFnQztBQUFBLElBQ3BDLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7QUFBQSxJQUM3QixDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO0FBQUEsSUFDN0IsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUFBLEVBQ1Y7QUFDQSxRQUFNLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQ3pCLFNBQU8sVUFBVSxFQUFFLENBQUMsRUFBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRyxDQUFDLENBQUM7QUFDdkY7OztBQy9EQSxTQUFTLFdBQVcsR0FBbUI7QUFDckMsVUFBUSxLQUFLLE1BQU0sSUFBSSxHQUFHLElBQUksS0FBSyxTQUFTO0FBQzlDO0FBR0EsSUFBTSxRQUFRO0FBQ2QsSUFBTSxRQUFRO0FBQ2QsSUFBTSxRQUFRO0FBTWQsU0FBUyxLQUFLLEtBQWE7QUFDekIsUUFBTSxJQUFJLEtBQUssSUFBSSxJQUFJLFFBQVEsSUFBSSxRQUFRLENBQUM7QUFDNUMsUUFBTSxNQUFNLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFDL0IsTUFBSSxJQUFJLEtBQUssTUFBTSxHQUFHLEdBQUcsQ0FBQztBQUMxQixNQUFJLENBQUMsSUFBSSxDQUFDLEVBQUcsS0FBSSxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFO0FBQ3BDLFFBQU0sSUFBSSxNQUFNLEdBQUcsQ0FBQztBQUNwQixTQUFPLEVBQUUsR0FBRyxHQUFHLEVBQUU7QUFDbkI7QUFDQSxTQUFTLE1BQU0sR0FBVyxLQUFhO0FBQ3JDLFFBQU0sRUFBRSxHQUFHLEdBQUcsRUFBRSxJQUFJLEtBQUssR0FBRztBQUM1QixRQUFNLElBQUksSUFBSSxHQUFHLElBQUksUUFBUTtBQUM3QixTQUFPLEVBQUUsR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLEVBQUU7QUFDcEQ7QUFDQSxTQUFTLEtBQUssR0FBVyxHQUFXLEdBQVcsT0FBNEI7QUFDekUsTUFBSSxFQUFFLEtBQUssRUFBRyxRQUFPO0FBQ3JCLFFBQU0sSUFBSSxRQUFRLEVBQUU7QUFDcEIsU0FBTyxFQUFFLEdBQUksRUFBRSxJQUFJLElBQUksSUFBSyxHQUFHLEdBQUksQ0FBQyxFQUFFLElBQUksSUFBSSxJQUFLLEdBQUcsR0FBRyxFQUFFLEVBQUU7QUFDL0Q7QUF3QkEsZUFBc0Isb0JBQ3BCLE9BQ0EsTUFBb0UsQ0FBQyxHQVFwRTtBQUNELFFBQU0sSUFBSSxJQUFJLFNBQVM7QUFDdkIsUUFBTSxJQUFJLElBQUksVUFBVTtBQUN4QixRQUFNLFFBQVEsTUFBTSxPQUFPLGVBQWU7QUFDMUMsUUFBTSxRQUFnQixDQUFDO0FBQ3ZCLFFBQU0sU0FBZ0IsQ0FBQztBQUV2QixRQUFNLFlBQVksb0JBQUksSUFBZTtBQUNyQyxRQUFNLFNBQWtCLENBQUM7QUFDekIsUUFBTSxRQUFnQixDQUFDO0FBQ3ZCLE1BQUksVUFBVTtBQUNkLFFBQU0sUUFBUSxvQkFBSSxJQUFvQjtBQUd0QyxRQUFNLFlBQVksb0JBQUksSUFBcUI7QUFDM0MsUUFBTSxZQUFZLG9CQUFJLElBQXFCO0FBQzNDLFFBQU0sZ0JBQWdCLG9CQUFJLElBQXFCO0FBQy9DLGFBQVcsT0FBTyxNQUFNLE9BQU87QUFDN0IsUUFBSSxJQUFJLFVBQVUsQ0FBQyxVQUFVLElBQUksSUFBSSxNQUFNLEdBQUc7QUFDNUMsVUFBSTtBQUNGLGNBQU0sT0FBTyxNQUFNLFFBQVEsSUFBSSxNQUFNO0FBQ3JDLGtCQUFVLElBQUksSUFBSSxRQUFRLElBQUk7QUFBQSxNQUNoQyxTQUFTLE9BQU87QUFDZCxnQkFBUSxLQUFLLDJCQUEyQixJQUFJLE1BQU0sS0FBSyxLQUFLO0FBQUEsTUFDOUQ7QUFBQSxJQUNGO0FBQ0EsUUFBSSxJQUFJLFVBQVUsQ0FBQyxVQUFVLElBQUksSUFBSSxNQUFNLEdBQUc7QUFDNUMsVUFBSTtBQUNGLGNBQU0sT0FBTyxNQUFNLFFBQVEsSUFBSSxNQUFNO0FBQ3JDLGtCQUFVLElBQUksSUFBSSxRQUFRLElBQUk7QUFBQSxNQUNoQyxTQUFTLE9BQU87QUFDZCxnQkFBUSxLQUFLLDJCQUEyQixJQUFJLE1BQU0sS0FBSyxLQUFLO0FBQUEsTUFDOUQ7QUFBQSxJQUNGO0FBQ0EsUUFBSSxJQUFJLGNBQWMsQ0FBQyxjQUFjLElBQUksSUFBSSxVQUFVLEdBQUc7QUFDeEQsVUFBSTtBQUNGLGNBQU0sT0FBTyxNQUFNLFFBQVEsSUFBSSxVQUFVO0FBQ3pDLHNCQUFjLElBQUksSUFBSSxZQUFZLElBQUk7QUFBQSxNQUN4QyxTQUFTLE9BQU87QUFDZCxnQkFBUSxLQUFLLDJCQUEyQixJQUFJLFVBQVUsS0FBSyxLQUFLO0FBQUEsTUFDbEU7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVBLGFBQVcsT0FBTyxNQUFNLE9BQU87QUFDN0IsVUFBTSxLQUFLLE1BQU0sR0FBRztBQUNwQixVQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxNQUFNLEdBQUcsTUFBTSxNQUFNLENBQUM7QUFDL0MsVUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUM7QUFFN0MsUUFBSSxJQUFJLGlCQUFpQjtBQUN2QixpQkFBVyxDQUFDLEdBQUcsQ0FBQyxLQUFLLE9BQU87QUFDMUIsY0FBTSxLQUFLLEdBQUcsQ0FBQztBQUNmLGNBQU0sS0FBSyxHQUFHLENBQUM7QUFDZixZQUFJLE1BQU0sSUFBSTtBQUNaLGdCQUFNLFFBQVEsS0FBSyxJQUFJLEdBQUcsQ0FBQyxFQUFHLEdBQUcsR0FBRyxDQUFDLEVBQUcsQ0FBQztBQUN6QyxnQkFBTSxLQUFLLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxHQUFHLE9BQU8sT0FBTyxrQkFBa0IsQ0FBQztBQUFBLFFBQy9EO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFHQSxRQUFJLElBQUksVUFBVSxVQUFVLElBQUksSUFBSSxNQUFNLEdBQUc7QUFDM0MsWUFBTSxPQUFPLFVBQVUsSUFBSSxJQUFJLE1BQU07QUFDckMsWUFBTSxzQkFBc0I7QUFBQSxRQUMxQjtBQUFBLFFBQ0E7QUFBQSxRQUNBLElBQUksaUJBQWlCO0FBQUEsUUFDckI7QUFBQSxNQUNGO0FBR0EsZUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFVBQVUsUUFBUSxLQUFLO0FBQzlDLGNBQU0sV0FBVyxLQUFLLFVBQVUsQ0FBQztBQUNqQyxjQUFNLGNBQWMsSUFBSTtBQUV4QixjQUFNLE1BQU0sb0JBQW9CLFdBQVc7QUFDM0MsY0FBTSxNQUFNLG9CQUFvQixjQUFjLENBQUM7QUFDL0MsY0FBTSxNQUFNLG9CQUFvQixjQUFjLENBQUM7QUFFL0MsY0FBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU07QUFDbkMsY0FBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU07QUFDbkMsY0FBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU07QUFFbkMsY0FBTSxNQUFNLEtBQUssS0FBSyxHQUFHLEdBQUcsS0FBSztBQUNqQyxjQUFNLE1BQU0sS0FBSyxLQUFLLEdBQUcsR0FBRyxLQUFLO0FBQ2pDLGNBQU0sTUFBTSxLQUFLLEtBQUssR0FBRyxHQUFHLEtBQUs7QUFFakMsWUFBSSxPQUFPLE9BQU8sS0FBSztBQUNyQixnQkFBTSxRQUFRLElBQUksS0FBSyxHQUFHO0FBQzFCLGdCQUFNLFFBQVEsSUFBSSxLQUFLLEdBQUc7QUFDMUIsZ0JBQU0sU0FBUyxNQUFNLE9BQU8sS0FBSztBQUNqQyxnQkFBTSxZQUFZLElBQUksU0FBUztBQUMvQixnQkFBTSxLQUFLO0FBQUEsWUFDVCxLQUFLLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxZQUNuQixLQUFLLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxZQUNuQixNQUFNLGNBQWMsV0FBVyxNQUFNO0FBQUEsWUFDckMsUUFBUTtBQUFBLFVBQ1YsQ0FBQztBQUFBLFFBQ0g7QUFBQSxNQUNGO0FBQUEsSUFDRixXQUFXLElBQUksVUFBVSxVQUFVLElBQUksSUFBSSxNQUFNLEdBQUc7QUFDbEQsWUFBTSxPQUFPLFVBQVUsSUFBSSxJQUFJLE1BQU07QUFDckMsWUFBTSxzQkFBc0I7QUFBQSxRQUMxQjtBQUFBLFFBQ0E7QUFBQSxRQUNBLElBQUksaUJBQWlCO0FBQUEsUUFDckI7QUFBQSxNQUNGO0FBRUEsZUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFVBQVUsUUFBUSxLQUFLO0FBQzlDLGNBQU0sY0FBYyxJQUFJO0FBQ3hCLGNBQU0sV0FBVyxLQUFLLFVBQVUsQ0FBQztBQUVqQyxjQUFNLE1BQU0sb0JBQW9CLFdBQVc7QUFDM0MsY0FBTSxNQUFNLG9CQUFvQixjQUFjLENBQUM7QUFDL0MsY0FBTSxNQUFNLG9CQUFvQixjQUFjLENBQUM7QUFFL0MsY0FBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU07QUFDbkMsY0FBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU07QUFDbkMsY0FBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU07QUFFbkMsY0FBTSxNQUFNLEtBQUssS0FBSyxHQUFHLEdBQUcsS0FBSztBQUNqQyxjQUFNLE1BQU0sS0FBSyxLQUFLLEdBQUcsR0FBRyxLQUFLO0FBQ2pDLGNBQU0sTUFBTSxLQUFLLEtBQUssR0FBRyxHQUFHLEtBQUs7QUFFakMsWUFBSSxPQUFPLE9BQU8sS0FBSztBQUNyQixnQkFBTSxRQUFRLElBQUksS0FBSyxHQUFHO0FBQzFCLGdCQUFNLFFBQVEsSUFBSSxLQUFLLEdBQUc7QUFDMUIsZ0JBQU0sYUFBYSxNQUFNLE9BQU8sS0FBSztBQUVyQyxnQkFBTSxLQUFLO0FBQUEsWUFDVCxLQUFLLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxZQUNuQixLQUFLLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxZQUNuQixNQUFNO0FBQUEsY0FDSixJQUFJLFNBQVMsU0FBUyxTQUFTO0FBQUEsY0FDL0I7QUFBQSxZQUNGO0FBQUEsWUFDQSxRQUFRO0FBQUEsVUFDVixDQUFDO0FBQUEsUUFDSDtBQUFBLE1BQ0Y7QUFBQSxJQUNGLFdBQVcsSUFBSSxjQUFjLGNBQWMsSUFBSSxJQUFJLFVBQVUsR0FBRztBQUM5RCxZQUFNLE9BQU8sY0FBYyxJQUFJLElBQUksVUFBVTtBQUM3QyxZQUFNLHNCQUFzQjtBQUFBLFFBQzFCO0FBQUEsUUFDQTtBQUFBLFFBQ0EsSUFBSSxxQkFBcUI7QUFBQSxRQUN6QjtBQUFBLE1BQ0Y7QUFFQSxlQUFTLElBQUksR0FBRyxJQUFJLEtBQUssVUFBVSxRQUFRLEtBQUs7QUFDOUMsY0FBTSxjQUFjLElBQUk7QUFDeEIsY0FBTSxXQUFXLEtBQUssVUFBVSxDQUFDO0FBRWpDLGNBQU0sTUFBTSxvQkFBb0IsV0FBVztBQUMzQyxjQUFNLE1BQU0sb0JBQW9CLGNBQWMsQ0FBQztBQUMvQyxjQUFNLE1BQU0sb0JBQW9CLGNBQWMsQ0FBQztBQUUvQyxjQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTTtBQUNuQyxjQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTTtBQUNuQyxjQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTTtBQUVuQyxjQUFNLE1BQU0sS0FBSyxLQUFLLEdBQUcsR0FBRyxLQUFLO0FBQ2pDLGNBQU0sTUFBTSxLQUFLLEtBQUssR0FBRyxHQUFHLEtBQUs7QUFDakMsY0FBTSxNQUFNLEtBQUssS0FBSyxHQUFHLEdBQUcsS0FBSztBQUVqQyxZQUFJLE9BQU8sT0FBTyxLQUFLO0FBQ3JCLGdCQUFNLFFBQVEsSUFBSSxLQUFLLEdBQUc7QUFDMUIsZ0JBQU0sUUFBUSxJQUFJLEtBQUssR0FBRztBQUMxQixnQkFBTSxhQUFhLE1BQU0sT0FBTyxLQUFLO0FBRXJDLGdCQUFNLEtBQUs7QUFBQSxZQUNULEtBQUssQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFlBQ25CLEtBQUssQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFlBQ25CLE1BQU07QUFBQSxjQUNKLElBQUksU0FBUyxTQUFTLFNBQVM7QUFBQSxjQUMvQjtBQUFBLFlBQ0Y7QUFBQSxZQUNBLFFBQVE7QUFBQSxVQUNWLENBQUM7QUFBQSxRQUNIO0FBQUEsTUFDRjtBQUFBLElBQ0YsT0FBTztBQUVMLFlBQU0sS0FBSyxNQUFNLEdBQUc7QUFDcEIsWUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sTUFBTSxHQUFHLE1BQU0sTUFBTSxDQUFDO0FBQy9DLFlBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxDQUFDO0FBRzdDLGlCQUFXLE9BQU8sT0FBTztBQUN2QixjQUFNLEtBQWEsQ0FBQztBQUNwQixZQUFJLFNBQVM7QUFDYixtQkFBVyxLQUFLLEtBQUs7QUFDbkIsZ0JBQU0sSUFBSSxHQUFHLENBQUM7QUFDZCxjQUFJLENBQUMsR0FBRztBQUNOLHFCQUFTO0FBQ1Q7QUFBQSxVQUNGO0FBQ0EsYUFBRyxLQUFLLENBQUM7QUFBQSxRQUNYO0FBQ0EsWUFBSSxPQUFRO0FBQ1osY0FBTSxPQUFPLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQVc7QUFDM0MsY0FBTSxLQUFLO0FBQUEsVUFDVCxLQUFLO0FBQUEsVUFDTCxLQUFLO0FBQUEsVUFDTCxNQUFNLFdBQVcsSUFBSSxTQUFTLE1BQU07QUFBQSxVQUNwQyxRQUFRO0FBQUEsUUFDVixDQUFDO0FBQUEsTUFDSDtBQUdBLFVBQUksSUFBSSxZQUFZLEtBQUs7QUFDdkIsY0FBTSxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDaEMsWUFBSSxJQUFJLE1BQU0sT0FBTyxHQUFHO0FBQ3RCLGdCQUFNLE1BQU07QUFDWixnQkFBTSxLQUFLLEtBQUssSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUcsQ0FBQyxDQUFDO0FBQy9DLGdCQUFNLE9BQU8sSUFBSSxXQUFXO0FBRzVCLGNBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxHQUFHO0FBQ3BCLGtCQUFNLElBQUksTUFBTSxNQUFNLE1BQU0sSUFBSSxFQUFFO0FBQUEsVUFDcEM7QUFDQSxnQkFBTSxNQUFNLE1BQU0sSUFBSSxJQUFJO0FBRzFCLGdCQUFNLGVBQWUsSUFBSSx5QkFBeUI7QUFDbEQsZ0JBQU0sZUFBZTtBQUNyQixtQkFBUyxNQUFNLEdBQUcsTUFBTSxjQUFjLE9BQU87QUFDM0MscUJBQVMsTUFBTSxHQUFHLE1BQU0sY0FBYyxPQUFPO0FBQzNDLG9CQUFNLEtBQUssTUFBTTtBQUNqQixvQkFBTSxNQUFNLE1BQU0sS0FBSztBQUN2QixvQkFBTSxLQUFLLE1BQU07QUFDakIsb0JBQU0sTUFBTSxNQUFNLEtBQUs7QUFHdkIsb0JBQU0sT0FBTyxDQUFDLEdBQVcsR0FBVyxPQUF1QjtBQUFBLGdCQUN6RCxHQUFHLEVBQUUsS0FBSyxJQUFJLEtBQUssRUFBRSxJQUFJO0FBQUEsZ0JBQ3pCLEdBQUcsRUFBRSxLQUFLLElBQUksS0FBSyxFQUFFLElBQUk7QUFBQSxnQkFDekIsR0FBRyxFQUFFLEtBQUssSUFBSSxLQUFLLEVBQUUsSUFBSTtBQUFBLGNBQzNCO0FBR0Esb0JBQU0sTUFBTTtBQUFBLGdCQUNWLEtBQUssS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRTtBQUFBLGdCQUMzRCxNQUFNO0FBQUEsY0FDUjtBQUNBLG9CQUFNLE1BQU07QUFBQSxnQkFDVixLQUFLLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFBQSxnQkFDM0QsTUFBTTtBQUFBLGNBQ1I7QUFDQSxvQkFBTSxNQUFNO0FBQUEsZ0JBQ1YsS0FBSyxLQUFLLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxLQUFLLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQUEsZ0JBQzNELE1BQU07QUFBQSxjQUNSO0FBQ0Esb0JBQU0sTUFBTTtBQUFBLGdCQUNWLEtBQUssS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRTtBQUFBLGdCQUMzRCxNQUFNO0FBQUEsY0FDUjtBQUVBLG9CQUFNLE1BQU0sS0FBSyxLQUFLLEdBQUcsR0FBRyxLQUFLO0FBQ2pDLG9CQUFNLE1BQU0sS0FBSyxLQUFLLEdBQUcsR0FBRyxLQUFLO0FBQ2pDLG9CQUFNLE1BQU0sS0FBSyxLQUFLLEdBQUcsR0FBRyxLQUFLO0FBQ2pDLG9CQUFNLE1BQU0sS0FBSyxLQUFLLEdBQUcsR0FBRyxLQUFLO0FBR2pDLG9CQUFNLFVBQVU7QUFBQSxnQkFDZDtBQUFBLGtCQUNFLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRztBQUFBLGtCQUNmLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRztBQUFBLGtCQUNmLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRztBQUFBLGdCQUNqQjtBQUFBLGdCQUNBLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxjQUNoQjtBQUNBLG9CQUFNLE1BQU0sT0FBTyxTQUFTO0FBQzVCLHFCQUFPLEtBQUs7QUFBQSxnQkFDVixRQUFRO0FBQUEsZ0JBQ1IsT0FBTztBQUFBLGdCQUNQO0FBQUEsZ0JBQ0EsTUFBTTtBQUFBLGdCQUNOLFFBQVEsR0FBRyxXQUFXLEVBQUUsQ0FBQyxJQUFJLFdBQVcsRUFBRSxDQUFDLElBQUksV0FBVyxFQUFFLENBQUMsSUFBSSxXQUFXLEVBQUUsQ0FBQyxJQUFJLFdBQVcsRUFBRSxDQUFDLElBQUksV0FBVyxFQUFFLENBQUM7QUFBQSxnQkFDbkg7QUFBQSxjQUNGLENBQUM7QUFFRCxvQkFBTSxXQUFpQjtBQUFBLGdCQUNyQixLQUFLLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxnQkFDbkIsS0FBSyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsZ0JBQ25CLE1BQU07QUFBQSxnQkFDTixRQUFRO0FBQUEsY0FDVjtBQUNBLG9CQUFNLEtBQUssUUFBUTtBQUNuQix3QkFBVSxJQUFJLFVBQVUsT0FBTyxPQUFPLFNBQVMsQ0FBQyxDQUFFO0FBR2xELG9CQUFNLFVBQVU7QUFBQSxnQkFDZDtBQUFBLGtCQUNFLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRztBQUFBLGtCQUNmLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRztBQUFBLGtCQUNmLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRztBQUFBLGdCQUNqQjtBQUFBLGdCQUNBLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxjQUNoQjtBQUNBLG9CQUFNLE1BQU0sT0FBTyxTQUFTO0FBQzVCLHFCQUFPLEtBQUs7QUFBQSxnQkFDVixRQUFRO0FBQUEsZ0JBQ1IsT0FBTztBQUFBLGdCQUNQO0FBQUEsZ0JBQ0EsTUFBTTtBQUFBLGdCQUNOLFFBQVEsR0FBRyxXQUFXLEVBQUUsQ0FBQyxJQUFJLFdBQVcsRUFBRSxDQUFDLElBQUksV0FBVyxFQUFFLENBQUMsSUFBSSxXQUFXLEVBQUUsQ0FBQyxJQUFJLFdBQVcsRUFBRSxDQUFDLElBQUksV0FBVyxFQUFFLENBQUM7QUFBQSxnQkFDbkg7QUFBQSxjQUNGLENBQUM7QUFFRCxvQkFBTSxXQUFpQjtBQUFBLGdCQUNyQixLQUFLLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxnQkFDbkIsS0FBSyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsZ0JBQ25CLE1BQU07QUFBQSxnQkFDTixRQUFRO0FBQUEsY0FDVjtBQUNBLG9CQUFNLEtBQUssUUFBUTtBQUNuQix3QkFBVSxJQUFJLFVBQVUsT0FBTyxPQUFPLFNBQVMsQ0FBQyxDQUFFO0FBQUEsWUFDcEQ7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFHQSxVQUFJLElBQUksVUFBVTtBQUNoQixjQUFNLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUNoQyxZQUFJLElBQUksTUFBTSxPQUFPLEdBQUc7QUFDdEIsZ0JBQU0sS0FBSyxJQUFJLENBQUM7QUFDaEIsZ0JBQU0sS0FBSyxJQUFJLENBQUM7QUFDaEIsZ0JBQU0sS0FBSyxJQUFJLENBQUM7QUFDaEIsZ0JBQU0sSUFBSSxJQUFJLElBQUksRUFBRTtBQUNwQixnQkFBTSxJQUFJLElBQUksSUFBSSxFQUFFO0FBQ3BCLGdCQUFNLEtBQUssSUFBSSxDQUFDO0FBQ2hCLGdCQUFNLEtBQUssSUFBSSxDQUFDO0FBQ2hCLGNBQUksTUFBTSxJQUFJO0FBQ1osa0JBQU0sS0FBSyxNQUFNLEdBQUcsSUFBSSxFQUFFO0FBQzFCLGtCQUFNLEtBQUssTUFBTSxHQUFHLElBQUksRUFBRTtBQUMxQixrQkFBTSxLQUFLLElBQUksT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFLLEVBQVcsR0FBRyxDQUFDLElBQUk7QUFDeEQsa0JBQU0sS0FBSyxJQUFJLE9BQU8sQ0FBQyxHQUFHLE1BQU0sSUFBSyxFQUFXLEdBQUcsQ0FBQyxJQUFJO0FBRXhELGtCQUFNLEtBQUssS0FBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRyxDQUFDLENBQUM7QUFHL0Msa0JBQU0sSUFBSSxVQUFVLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQzVELGtCQUFNLFVBQVUsSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQ2hELG1CQUFPLEtBQUs7QUFBQSxjQUNWLFFBQVE7QUFBQSxjQUNSLE9BQU87QUFBQSxjQUNQLE1BQU0sSUFBSTtBQUFBLGNBQ1YsTUFBTSxXQUFXLE9BQU87QUFBQSxZQUMxQixDQUFDO0FBQUEsVUFDSDtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFHQSxXQUFTLGFBQ1AsT0FDQUMsSUFDQUMsSUFDQUMsUUFDUTtBQUNSLFVBQU0sTUFBTTtBQVNaLGFBQVMsTUFBTSxNQUEyQjtBQUN4QyxVQUFJLENBQUMsS0FBSyxPQUFRLFFBQU87QUFDekIsWUFBTSxPQUFPLEtBQUssQ0FBQztBQUNuQixZQUFNLEtBQUssS0FBSyxJQUFJLENBQUM7QUFDckIsWUFBTSxLQUFLLEtBQUssSUFBSSxDQUFDO0FBQ3JCLFlBQU0sS0FBSyxLQUFLLElBQUksQ0FBQztBQUNyQixZQUFNLFNBQVMsTUFBTSxJQUFJLElBQUksRUFBRSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7QUFDN0MsWUFBTSxRQUFnQixDQUFDO0FBQ3ZCLFlBQU0sT0FBZSxDQUFDO0FBRXRCLGVBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEtBQUs7QUFDcEMsY0FBTSxJQUFJLEtBQUssQ0FBQztBQUVoQixZQUFJLE1BQU0sR0FDUixNQUFNO0FBQ1IsY0FBTSxJQUFjLENBQUM7QUFDckIsbUJBQVcsS0FBSyxFQUFFLEtBQUs7QUFDckIsZ0JBQU0sT0FBTyxJQUFJLFFBQVEsSUFBSSxHQUFJLEVBQUUsQ0FBQztBQUNwQyxZQUFFLEtBQUssSUFBSTtBQUNYLGNBQUksT0FBTyxJQUFLO0FBQUEsbUJBQ1AsT0FBTyxDQUFDLElBQUs7QUFBQSxRQUN4QjtBQUNBLFlBQUksQ0FBQyxPQUFPLENBQUMsS0FBSztBQUNoQixnQkFBTSxLQUFLLENBQUM7QUFBQSxRQUNkLFdBQVcsQ0FBQyxJQUFLLE1BQUssS0FBSyxDQUFDO0FBQUEsaUJBQ25CLENBQUMsSUFBSyxPQUFNLEtBQUssQ0FBQztBQUFBLGFBQ3RCO0FBRUgsZ0JBQU0sWUFBc0IsQ0FBQztBQUM3QixnQkFBTSxXQUFxQixDQUFDO0FBQzVCLGdCQUFNLFdBQW1CLENBQUM7QUFDMUIsZ0JBQU0sVUFBa0IsQ0FBQztBQUV6QixtQkFBUyxJQUFJLEdBQUcsSUFBSSxFQUFFLElBQUksUUFBUSxLQUFLO0FBQ3JDLGtCQUFNLEtBQUssSUFBSSxLQUFLLEVBQUUsSUFBSTtBQUMxQixrQkFBTSxPQUFPLEVBQUUsSUFBSSxDQUFDO0FBQ3BCLGtCQUFNLE9BQU8sRUFBRSxJQUFJLENBQUM7QUFDcEIsa0JBQU0sTUFBTSxFQUFFLElBQUksQ0FBQztBQUNuQixrQkFBTSxNQUFNLEVBQUUsSUFBSSxDQUFDO0FBQ25CLGtCQUFNLEtBQUssRUFBRSxDQUFDO0FBQ2Qsa0JBQU0sS0FBSyxFQUFFLENBQUM7QUFFZCxrQkFBTSxPQUFPLENBQ1gsUUFDQSxPQUNBLE1BQ0EsUUFDRztBQUNILHFCQUFPLEtBQUssSUFBSTtBQUNoQixvQkFBTSxLQUFLLEdBQUc7QUFBQSxZQUNoQjtBQUVBLGdCQUFJLE1BQU0sQ0FBQyxJQUFLLE1BQUssV0FBVyxVQUFVLE1BQU8sR0FBSTtBQUNyRCxnQkFBSSxNQUFNLElBQUssTUFBSyxVQUFVLFNBQVMsTUFBTyxHQUFJO0FBRWxELGdCQUFLLEtBQUssS0FBSyxLQUFLLEtBQU8sS0FBSyxLQUFLLEtBQUssR0FBSTtBQUM1QyxvQkFBTSxJQUFJLE1BQU0sS0FBSztBQUNyQixvQkFBTSxXQUFXO0FBQUEsZ0JBQ2YsR0FBRyxLQUFLLEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSztBQUFBLGdCQUNoQyxHQUFHLEtBQUssS0FBSyxLQUFLLElBQUksS0FBSyxLQUFLO0FBQUEsZ0JBQ2hDLEdBQUcsS0FBSyxLQUFLLEtBQUssSUFBSSxLQUFLLEtBQUs7QUFBQSxjQUNsQztBQUNBLG9CQUFNLFVBQVUsS0FBSyxVQUFVRixJQUFHQyxJQUFHQyxNQUFLO0FBQzFDLG1CQUFLLFdBQVcsVUFBVSxVQUFVLE9BQU87QUFDM0MsbUJBQUssVUFBVSxTQUFTLFVBQVUsT0FBTztBQUFBLFlBQzNDO0FBQUEsVUFDRjtBQUVBLGdCQUFNLEtBQUssQ0FBQyxLQUFlLFFBQTZCO0FBQ3RELGdCQUFJLElBQUksU0FBUyxFQUFHLFFBQU87QUFDM0Isa0JBQU0sS0FBVyxFQUFFLEtBQUssS0FBSyxNQUFNLEVBQUcsTUFBTSxRQUFRLE1BQU07QUFDMUQsa0JBQU0sTUFBTSxVQUFVLElBQUksQ0FBQztBQUMzQixnQkFBSSxJQUFLLFdBQVUsSUFBSSxJQUFJLEdBQUc7QUFDOUIsbUJBQU87QUFBQSxVQUNUO0FBQ0EsZ0JBQU0sS0FBSyxHQUFHLFdBQVcsUUFBUTtBQUNqQyxnQkFBTSxLQUFLLEdBQUcsVUFBVSxPQUFPO0FBQy9CLGNBQUksR0FBSSxPQUFNLEtBQUssRUFBRTtBQUNyQixjQUFJLEdBQUksTUFBSyxLQUFLLEVBQUU7QUFBQSxRQUN0QjtBQUFBLE1BQ0Y7QUFFQSxhQUFPO0FBQUEsUUFDTDtBQUFBLFFBQ0E7QUFBQSxRQUNBLE9BQU87QUFBQSxRQUNQLE9BQU8sTUFBTSxLQUFLO0FBQUEsUUFDbEIsTUFBTSxNQUFNLElBQUk7QUFBQSxNQUNsQjtBQUFBLElBQ0Y7QUFFQSxhQUFTLFNBQVMsTUFBbUIsS0FBYTtBQUNoRCxVQUFJLENBQUMsS0FBTTtBQUNYLFlBQU0sYUFBYSxJQUFJLEtBQUssUUFBUSxNQUFNLEtBQUssT0FBTyxFQUFFLENBQUM7QUFDekQsVUFBSSxjQUFjLEdBQUc7QUFDbkIsaUJBQVMsS0FBSyxNQUFNLEdBQUc7QUFDdkIsWUFBSSxLQUFLLEtBQUssSUFBSTtBQUNsQixpQkFBUyxLQUFLLE9BQU8sR0FBRztBQUFBLE1BQzFCLE9BQU87QUFDTCxpQkFBUyxLQUFLLE9BQU8sR0FBRztBQUN4QixZQUFJLEtBQUssS0FBSyxJQUFJO0FBQ2xCLGlCQUFTLEtBQUssTUFBTSxHQUFHO0FBQUEsTUFDekI7QUFBQSxJQUNGO0FBRUEsVUFBTSxPQUFPLE1BQU0sS0FBSztBQUN4QixVQUFNLFVBQWtCLENBQUM7QUFDekIsYUFBUyxNQUFNLE9BQU87QUFDdEIsV0FBTztBQUFBLEVBQ1Q7QUFFQSxRQUFNLGVBQWUsYUFBYSxPQUFPLEdBQUcsR0FBRyxLQUFLO0FBRXBELFFBQU0sV0FBNEIsQ0FBQztBQUNuQyxhQUFXLEtBQUssY0FBYztBQUM1QixVQUFNLE1BQU0sVUFBVSxJQUFJLENBQUM7QUFDM0IsUUFBSSxLQUFLO0FBQ1AsZUFBUyxLQUFLLEVBQUUsTUFBTSxTQUFTLE1BQU0sSUFBSSxDQUFDO0FBQUEsSUFDNUMsT0FBTztBQUNMLGVBQVMsS0FBSyxFQUFFLE1BQU0sUUFBUSxNQUFNLEVBQUUsQ0FBQztBQUFBLElBQ3pDO0FBQUEsRUFDRjtBQUNBLFdBQVM7QUFBQSxJQUNQLEdBQUcsT0FBTyxJQUFJLENBQUMsT0FBTyxFQUFFLE1BQU0sU0FBa0IsTUFBTSxFQUFFLEVBQUU7QUFBQSxJQUMxRCxHQUFHLE1BQ0EsS0FBSyxDQUFDLEdBQUcsTUFBTSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQ2hDLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxRQUFpQixNQUFNLEVBQUUsRUFBRTtBQUFBLEVBQ3BEO0FBRUEsU0FBTztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsaUJBQWlCLElBQUk7QUFBQSxJQUNyQjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNGOzs7QUN2a0JBLFNBQVMsSUFBSSxHQUFXO0FBQ3RCLFNBQU8sS0FBSyxNQUFNLENBQUMsSUFBSTtBQUN6QjtBQUVBLGVBQXNCLFlBQ3BCLE9BQ0EsTUFjSSxDQUFDLEdBQ1k7QUFDakIsUUFBTTtBQUFBLElBQ0osT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1I7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGLElBQUksTUFBTSxvQkFBb0IsT0FBTztBQUFBLElBQ25DLE9BQU8sSUFBSTtBQUFBLElBQ1gsUUFBUSxJQUFJO0FBQUEsSUFDWixpQkFBaUIsSUFBSTtBQUFBLEVBQ3ZCLENBQUM7QUFFRCxRQUFNLE1BQWdCLENBQUM7QUFDdkIsTUFBSTtBQUFBLElBQ0Ysa0RBQWtELENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQUEsRUFDM0c7QUFDQSxNQUFJLGlCQUFpQjtBQUNuQixRQUFJO0FBQUEsTUFDRixjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxXQUFXLFdBQVcsZUFBZSxDQUFDO0FBQUE7QUFBQSxJQUNyRztBQUFBLEVBQ0Y7QUFHQSxNQUFJLE9BQU8sUUFBUTtBQUNqQixRQUFJLEtBQUssWUFBWTtBQUdyQixlQUFXLENBQUMsTUFBTSxFQUFFLEtBQUssT0FBTztBQUM5QixVQUFJO0FBQUEsUUFDRixrQkFBa0IsRUFBRSxXQUFXLElBQUk7QUFBQTtBQUFBLE1BQ3JDO0FBQUEsSUFDRjtBQUdBLGVBQVcsT0FBTyxRQUFRO0FBQ3hCLFVBQUk7QUFBQSxRQUNGLHFCQUFxQixJQUFJLElBQUksd0RBQXdELElBQUksTUFBTTtBQUFBO0FBQUEsTUFDakc7QUFBQSxJQUNGO0FBQ0EsUUFBSSxLQUFLLGFBQWE7QUFBQSxFQUN4QjtBQUdBLE1BQUksSUFBSSxVQUFVO0FBQ2hCLFFBQUk7QUFBQSxNQUNGLFdBQVcsT0FBTyxHQUFHLEdBQUcsSUFBSSxNQUFNLFlBQVksR0FBRyxJQUFJLE1BQU0sU0FBUyxJQUFJO0FBQUEsSUFDMUU7QUFBQSxFQUNGO0FBR0EsTUFBSSxnQkFBZ0I7QUFFcEIsYUFBVyxXQUFXLFVBQVU7QUFDOUIsUUFBSSxRQUFRLFNBQVMsVUFBVSxRQUFRLFNBQVMsU0FBUztBQUV2RCxVQUFJLENBQUMsZUFBZTtBQUNsQixZQUFJO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSx3QkFBZ0I7QUFBQSxNQUNsQjtBQUVBLFVBQUksUUFBUSxTQUFTLFFBQVE7QUFDM0IsY0FBTSxJQUFJLFFBQVE7QUFDbEIsY0FBTSxhQUFhLEVBQUUsU0FBUyxLQUFLO0FBQ25DLFlBQUk7QUFBQSxVQUNGLHNCQUFzQixFQUFFLElBQUksSUFBSSxVQUFVLFlBQVksRUFBRSxJQUNyRCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFDcEMsS0FBSyxHQUFHLENBQUM7QUFBQTtBQUFBLFFBQ2Q7QUFBQSxNQUNGLE9BQU87QUFDTCxjQUFNLE1BQU0sUUFBUTtBQUNwQixZQUFJO0FBQUEsVUFDRixxQkFBcUIsSUFBSSxNQUFNLHFCQUFxQixJQUFJLElBQUksa0JBQWtCLElBQUksR0FBRztBQUFBO0FBQUEsUUFDdkY7QUFBQSxNQUNGO0FBQUEsSUFDRixXQUFXLFFBQVEsU0FBUyxTQUFTO0FBRW5DLFVBQUksZUFBZTtBQUNqQixZQUFJLEtBQUssVUFBVTtBQUNuQix3QkFBZ0I7QUFBQSxNQUNsQjtBQUVBLFlBQU0sSUFBSSxRQUFRO0FBQ2xCLFVBQUk7QUFBQSxRQUNGLDRHQUE0RyxFQUFFLE1BQU0sNkJBQTZCLEVBQUUsSUFBSSxLQUFLLEVBQUUsSUFBSTtBQUFBO0FBQUEsTUFDcEs7QUFBQSxJQUNGLFdBQVcsUUFBUSxTQUFTLFFBQVE7QUFDbEMsVUFBSSxlQUFlO0FBQ2pCLFlBQUksS0FBSyxVQUFVO0FBQ25CLHdCQUFnQjtBQUFBLE1BQ2xCO0FBQ0EsWUFBTSxJQUFJLFFBQVE7QUFDbEIsVUFBSTtBQUFBLFFBQ0YsbUNBQW1DLEVBQUUsS0FBSyxhQUFhLEVBQUUsSUFDdEQsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUMxQixLQUFLLEdBQUcsQ0FBQztBQUFBO0FBQUEsTUFDZDtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBR0EsTUFBSSxlQUFlO0FBQ2pCLFFBQUksS0FBSyxVQUFVO0FBQUEsRUFDckI7QUFFQSxNQUFJLElBQUksWUFBWTtBQUNsQixRQUFJLEtBQUssYUFBYSxNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFBQSxFQUMzQztBQUVBLE1BQUksSUFBSSxVQUFVO0FBQ2hCLFFBQUksS0FBSyxXQUFXLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQztBQUFBLEVBQ3pDO0FBRUEsTUFBSSxLQUFLLFFBQVE7QUFDakIsU0FBTyxJQUFJLEtBQUssRUFBRTtBQUNwQjtBQUVBLFNBQVMsV0FBVyxLQUFhLEdBQVcsR0FBbUI7QUFDN0QsUUFBTSxRQUFRLElBQUksZUFBZTtBQUNqQyxRQUFNLFdBQVc7QUFDakIsUUFBTSxTQUFTLEtBQUssSUFBSSxHQUFHLENBQUMsSUFBSTtBQUNoQyxRQUFNLFlBQWEsV0FBVyxPQUFRO0FBRXRDLFFBQU0sV0FBV0MsTUFBSyxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLEtBQUs7QUFDOUQsTUFBSSxDQUFDLFNBQVUsUUFBTztBQUN0QixRQUFNLFVBQVUsQ0FBQyxJQUFJLElBQUksU0FBUyxTQUFTO0FBQzNDLFFBQU0sVUFBVSxJQUFJLElBQUksU0FBUyxTQUFTO0FBRTFDLFdBQVMsRUFBRSxHQUF3QztBQUNqRCxVQUFNLEtBQUtBLE1BQUssR0FBRyxHQUFHLEdBQUcsS0FBSztBQUM5QixXQUFPLEtBQUssRUFBRSxHQUFHLEdBQUcsSUFBSSxTQUFTLEdBQUcsR0FBRyxJQUFJLFFBQVEsSUFBSSxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFBQSxFQUN0RTtBQUVBLFFBQU0sRUFBRSxHQUFHLEdBQUcsRUFBRSxJQUFJQyxNQUFLLEdBQUc7QUFDNUIsUUFBTSxRQUFRLEVBQUUsRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDO0FBQzNDLFFBQU0sV0FBVztBQUFBLElBQ2YsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxPQUFPLE9BQU8sT0FBTyxJQUFJO0FBQUEsSUFDcEQsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxPQUFPLFNBQVMsT0FBTyxJQUFJO0FBQUEsSUFDdEQsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxPQUFPLFFBQVEsT0FBTyxJQUFJO0FBQUEsRUFDdkQsRUFBRSxJQUFJLENBQUMsRUFBRSxHQUFHLE9BQU8sTUFBTSxPQUFPO0FBQUEsSUFDOUIsS0FBSztBQUFBLE1BQ0gsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFBQSxNQUNuQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUFBLE1BQ25DLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQUEsSUFDckM7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0YsRUFBRTtBQUVGLFFBQU0sUUFBa0IsQ0FBQztBQUN6QixhQUFXLEVBQUUsS0FBSyxPQUFPLE1BQU0sS0FBSyxVQUFVO0FBQzVDLFVBQU0sTUFBTSxFQUFFO0FBQUEsTUFDWixHQUFHLElBQUksSUFBSTtBQUFBLE1BQ1gsR0FBRyxJQUFJLElBQUk7QUFBQSxNQUNYLEdBQUcsV0FBVyxJQUFJLElBQUk7QUFBQSxJQUN4QixDQUFDO0FBQ0QsVUFBTSxLQUFLLElBQUksSUFBSSxNQUFNO0FBQ3pCLFVBQU0sS0FBSyxJQUFJLElBQUksTUFBTTtBQUN6QixVQUFNLElBQUksS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEVBQUUsS0FBSztBQUMxQyxVQUFNLEtBQUssS0FBSztBQUNoQixVQUFNLEtBQUssS0FBSztBQUNoQixVQUFNLEtBQUssSUFBSSxJQUFJLEtBQUs7QUFDeEIsVUFBTSxLQUFLLElBQUksSUFBSSxLQUFLO0FBQ3hCLFVBQU0sTUFBTSxLQUFLLENBQUMsS0FBSztBQUN2QixVQUFNLE1BQU0sS0FBSyxLQUFLO0FBQ3RCLFVBQU0sTUFBTSxLQUFLLENBQUMsS0FBSztBQUN2QixVQUFNLE1BQU0sS0FBSyxLQUFLO0FBQ3RCLFVBQU0sS0FBSyxJQUFJLElBQUksS0FBSztBQUN4QixVQUFNLEtBQUssSUFBSSxJQUFJLEtBQUs7QUFDeEIsVUFBTTtBQUFBLE1BQ0osaUJBQWlCLElBQUksTUFBTSxDQUFDLENBQUMsU0FBUyxJQUFJLE1BQU0sQ0FBQyxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQyxhQUFhLEtBQUs7QUFBQSxJQUN0RztBQUNBLFVBQU07QUFBQSxNQUNKLHNCQUFzQixLQUFLLGFBQWEsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsQ0FBQztBQUFBLElBQ2xIO0FBQ0EsVUFBTTtBQUFBLE1BQ0osZ0JBQWdCLElBQUksRUFBRSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsV0FBVyxLQUFLLDhGQUE4RixLQUFLO0FBQUEsSUFDM0o7QUFBQSxFQUNGO0FBRUEsU0FBTztBQUFBLEVBQTBFLE1BQU07QUFBQSxJQUNyRjtBQUFBLEVBQ0YsQ0FBQztBQUFBO0FBQUE7QUFDSDtBQUVBLFNBQVMsV0FDUCxPQUNBLEdBQ0EsR0FDQSxVQUNBLE9BQ1E7QUFDUixRQUFNLE1BQU0sTUFBTTtBQUNsQixRQUFNLFFBQVEsSUFBSSxlQUFlO0FBQ2pDLFFBQU0sRUFBRSxHQUFHLEdBQUcsRUFBRSxJQUFJQSxNQUFLLEdBQUc7QUFHNUIsUUFBTUMsU0FBUSxDQUFDLE1BQWM7QUFDM0IsVUFBTSxJQUFJLElBQUksR0FBRyxJQUFJLFFBQVE7QUFDN0IsV0FBTyxFQUFFLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxFQUFFO0FBQUEsRUFDcEQ7QUFDQSxRQUFNLFVBQVUsQ0FBQyxNQUFjRixNQUFLRSxPQUFNLENBQUMsR0FBRyxHQUFHLEdBQUcsS0FBSztBQUd6RCxRQUFNLElBQUksV0FBVztBQUVyQixRQUFNLFFBQWtCLENBQUM7QUFDekIsV0FBUyxJQUFJLENBQUMsR0FBRyxLQUFLLEdBQUcsS0FBSyxVQUFVO0FBQ3RDLFVBQU0sV0FBVyxDQUFDLEdBQVcsTUFBYztBQUN6QyxZQUFNLEtBQUssUUFBUSxDQUFDO0FBQ3BCLFlBQU0sS0FBSyxRQUFRLENBQUM7QUFDcEIsVUFBSSxNQUFNLElBQUk7QUFDWixjQUFNO0FBQUEsVUFDSixpQkFBaUIsSUFBSSxHQUFHLENBQUMsQ0FBQyxTQUFTLElBQUksR0FBRyxDQUFDLENBQUMsU0FDbkMsSUFBSSxHQUFHLENBQUMsQ0FBQyxTQUFTLElBQUksR0FBRyxDQUFDLENBQUM7QUFBQSxRQUN0QztBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUEsWUFBUSxPQUFPO0FBQUEsTUFDYixLQUFLO0FBQ0gsaUJBQVMsRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ3BELGlCQUFTLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNwRDtBQUFBLE1BQ0YsS0FBSztBQUNILGlCQUFTLEVBQUUsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNwRCxpQkFBUyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDcEQ7QUFBQSxNQUNGLEtBQUs7QUFDSCxpQkFBUyxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDcEQsaUJBQVMsRUFBRSxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ3BEO0FBQUEsSUFDSjtBQUFBLEVBQ0Y7QUFFQSxTQUFPLE1BQU0sU0FDVDtBQUFBLEVBQTJDLE1BQU0sS0FBSyxJQUFJLENBQUM7QUFBQTtBQUFBLElBQzNEO0FBQ047QUFFQSxTQUFTLGFBQWEsS0FBYSxHQUFXLEdBQW1CO0FBRS9ELFFBQU0sUUFBUSxJQUFJLGVBQWU7QUFDakMsUUFBTSxFQUFFLEdBQUcsR0FBRyxFQUFFLElBQUlELE1BQUssR0FBRztBQUc1QixRQUFNQyxTQUFRLENBQUMsTUFBYztBQUMzQixVQUFNLElBQUksSUFBSSxHQUFHLElBQUksUUFBUTtBQUM3QixXQUFPLEVBQUUsR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLEVBQUU7QUFBQSxFQUNwRDtBQUVBLFFBQU0sVUFBVSxDQUFDLE1BQ2ZGLE1BQUssR0FBRyxHQUFHLEdBQUcsS0FBSztBQUdyQixRQUFNLFdBQVc7QUFBQSxJQUNmLEVBQUUsS0FBSyxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsT0FBTyxNQUFNO0FBQUEsSUFDMUMsRUFBRSxLQUFLLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxPQUFPLFFBQVE7QUFBQSxJQUM1QyxFQUFFLEtBQUssRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLE9BQU8sT0FBTztBQUFBLEVBQzdDO0FBRUEsUUFBTSxrQkFBa0IsS0FBSyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUs7QUFFOUMsUUFBTSxRQUFrQixDQUFDO0FBQ3pCLFFBQU0sU0FBUyxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFO0FBR2xDLFFBQU0sZUFBeUIsQ0FBQztBQUVoQyxXQUFTLFFBQVEsQ0FBQyxFQUFFLEtBQUssTUFBTSxHQUFHLE1BQU07QUFDdEMsVUFBTSxJQUFJO0FBQ1YsVUFBTSxNQUFNLElBQUksUUFBUSxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBQ3JDLFVBQU0sV0FBV0UsT0FBTSxNQUFNO0FBQzdCLFVBQU0sU0FBU0EsT0FBTSxHQUFHO0FBQ3hCLFVBQU0sVUFBVSxRQUFRLFFBQVE7QUFDaEMsVUFBTSxTQUFTLFFBQVEsTUFBTTtBQUM3QixVQUFNLEtBQUssT0FBTyxJQUFJLFFBQVE7QUFDOUIsVUFBTSxLQUFLLE9BQU8sSUFBSSxRQUFRO0FBQzlCLFVBQU1DLE9BQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEVBQUU7QUFDdkMsVUFBTSxTQUFTO0FBQUEsTUFDYixHQUFHLFFBQVEsSUFBSyxLQUFLLGtCQUFtQkE7QUFBQSxNQUN4QyxHQUFHLFFBQVEsSUFBSyxLQUFLLGtCQUFtQkE7QUFBQSxJQUMxQztBQUNBLFFBQUksV0FBVyxRQUFRO0FBRXJCLFlBQU0sU0FBUyxhQUFhLENBQUM7QUFHN0IsWUFBTSxLQUFLLElBQUksUUFBUSxDQUFDO0FBQ3hCLFlBQU0sS0FBSyxJQUFJLFFBQVEsQ0FBQztBQUN4QixZQUFNLEtBQUssSUFBSSxPQUFPLENBQUM7QUFDdkIsWUFBTSxLQUFLLElBQUksT0FBTyxDQUFDO0FBR3ZCLG1CQUFhO0FBQUEsUUFDWCwyQkFBMkIsTUFBTSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsd0VBQ3BDLEtBQUssMEJBQ3JCLEtBQUssSUFBS0EsT0FBTSxrQkFBbUIsS0FBTSxHQUFHLENBQUM7QUFBQSxNQUd4RTtBQUVBLFlBQU07QUFBQSxRQUNKLGlCQUFpQixFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLGtCQUFrQixNQUFNO0FBQUEsTUFDOUU7QUFBQSxJQUNGO0FBQUEsRUFDRixDQUFDO0FBR0QsTUFBSSxhQUFhLFFBQVE7QUFDdkIsVUFBTSxRQUFRO0FBQUEsRUFBYSxhQUFhLEtBQUssSUFBSSxDQUFDO0FBQUEsVUFBYTtBQUFBLEVBQ2pFO0FBRUEsU0FBTyxNQUFNLFNBQ1Q7QUFBQSxFQUEyQixNQUFNLEtBQUssSUFBSSxDQUFDO0FBQUE7QUFBQSxJQUMzQztBQUNOO0FBRUEsU0FBU0YsTUFBSyxLQUFhO0FBQ3pCLFFBQU0sSUFBSSxLQUFLLElBQUksSUFBSSxRQUFRLElBQUksUUFBUSxDQUFDO0FBQzVDLFFBQU0sTUFBTSxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFO0FBQy9CLE1BQUksSUFBSSxLQUFLLE1BQU0sR0FBRyxHQUFHLENBQUM7QUFDMUIsTUFBSSxDQUFDLElBQUksQ0FBQyxFQUFHLEtBQUksRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRTtBQUNwQyxRQUFNLElBQUksTUFBTSxHQUFHLENBQUM7QUFDcEIsU0FBTyxFQUFFLEdBQUcsR0FBRyxFQUFFO0FBQ25CO0FBRUEsU0FBU0QsTUFDUCxHQUNBLEdBQ0EsR0FDQSxPQUNpQztBQUNqQyxNQUFJLEVBQUUsS0FBSyxFQUFHLFFBQU87QUFDckIsUUFBTSxJQUFJLFFBQVEsRUFBRTtBQUNwQixTQUFPLEVBQUUsR0FBSSxFQUFFLElBQUksSUFBSSxJQUFLLEdBQUcsR0FBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLElBQUssRUFBRTtBQUN2RDsiLAogICJuYW1lcyI6IFsiY2FsY3VsYXRlQm91bmRpbmdCb3giLCAiY2FsY3VsYXRlQm91bmRpbmdCb3giLCAiVyIsICJIIiwgImZvY2FsIiwgInByb2oiLCAiYXhlcyIsICJ0b0NhbSIsICJsZW4iXQp9Cg==