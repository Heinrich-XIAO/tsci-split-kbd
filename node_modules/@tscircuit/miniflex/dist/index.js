// lib/minimal-flexbox.ts
var defaultStyle = {
  flexGrow: 0,
  flexShrink: 1,
  flexBasis: 0,
  alignSelf: "auto",
  width: void 0,
  height: void 0
};
var FlexNode = class {
  id;
  metadata;
  /** Computed layout values */
  size = { width: 0, height: 0 };
  position = { x: 0, y: 0 };
  /** Incoming flex style (grow / shrink / basis / alignSelf) */
  style;
  constructor(style = {}) {
    this.style = { ...defaultStyle, ...style };
    this.id = style.id;
    this.metadata = style.metadata;
  }
};
var FlexElement = class extends FlexNode {
  build() {
  }
};
var FlexBox = class _FlexBox extends FlexNode {
  children = [];
  // Containerâ€‘level layout options (with sensible defaults)
  direction = "row";
  columnGap = 0;
  rowGap = 0;
  justifyContent = "flex-start";
  alignItems = "stretch";
  constructor(width, height, opts = {}) {
    super({});
    this.size.width = width;
    this.size.height = height;
    this.id = opts.id;
    Object.assign(this, opts);
  }
  addChild(arg1, arg2) {
    if (arg1 instanceof _FlexBox) {
      const box = arg1;
      if (arg2) box.style = { ...defaultStyle, ...arg2 };
      this.children.push(box);
      return box;
    }
    const elem = new FlexElement(arg1);
    this.children.push(elem);
    return elem;
  }
  // --------------- Layout algorithm ------------------------
  build() {
    const horizontal = this.direction.startsWith("row");
    const mainProp = horizontal ? "width" : "height";
    const crossProp = horizontal ? "height" : "width";
    const mainGap = horizontal ? this.columnGap : this.rowGap;
    const crossGap = horizontal ? this.rowGap : this.columnGap;
    const gapTotal = mainGap * Math.max(0, this.children.length - 1);
    const containerMain = this.size[mainProp];
    const containerCross = this.size[crossProp];
    let totalBasis = 0;
    let totalGrow = 0;
    let totalShrink = 0;
    for (const child of this.children) {
      totalBasis += child.style.flexBasis;
      totalGrow += child.style.flexGrow;
      totalShrink += child.style.flexShrink;
    }
    const freeSpace = containerMain - totalBasis - gapTotal;
    for (const child of this.children) {
      let main = child.style.flexBasis;
      if (freeSpace > 0 && totalGrow > 0) {
        main += freeSpace * child.style.flexGrow / totalGrow;
      } else if (freeSpace < 0 && totalShrink > 0) {
        main += freeSpace * child.style.flexShrink / totalShrink;
        if (main < 0) main = 0;
      }
      child.size[mainProp] = main;
      const alignSelf = child.style.alignSelf !== "auto" ? child.style.alignSelf : this.alignItems;
      const explicitCrossSize = horizontal ? child.style.height : child.style.width;
      if (explicitCrossSize !== void 0) {
        child.size[crossProp] = explicitCrossSize;
      } else if (alignSelf === "stretch") {
        child.size[crossProp] = containerCross;
      } else {
      }
    }
    const occupied = this.children.reduce((sum, c) => sum + c.size[mainProp], 0) + gapTotal;
    const remaining = containerMain - occupied;
    let leading = 0;
    let between = mainGap;
    const n = this.children.length;
    switch (this.justifyContent) {
      case "flex-start":
        break;
      // defaults are fine
      case "flex-end":
        leading = remaining;
        break;
      case "center":
        leading = remaining / 2;
        break;
      case "space-between":
        between = n > 1 ? mainGap + remaining / (n - 1) : 0;
        break;
      case "space-around":
        between = mainGap + remaining / n;
        leading = between / 2;
        break;
      case "space-evenly":
        between = mainGap + remaining / (n + 1);
        leading = between;
        break;
    }
    const ordered = this.direction.endsWith("reverse") ? [...this.children].reverse() : this.children;
    let cursor = leading;
    for (const child of ordered) {
      if (horizontal) {
        child.position.x = this.direction === "row" ? cursor : containerMain - cursor - child.size.width;
        child.position.y = computeCross(
          child,
          crossProp,
          containerCross,
          this.alignItems
        );
      } else {
        child.position.y = this.direction === "column" ? cursor : containerMain - cursor - child.size.height;
        child.position.x = computeCross(
          child,
          crossProp,
          containerCross,
          this.alignItems
        );
      }
      cursor += child.size[mainProp] + between;
    }
    for (const child of this.children) {
      if (child instanceof _FlexBox) {
        child.build();
      }
    }
    function computeCross(child, prop, containerCross2, alignItems) {
      const alignSelf = child.style.alignSelf !== "auto" ? child.style.alignSelf : alignItems;
      switch (alignSelf) {
        case "flex-start":
          return 0;
        case "flex-end":
          return containerCross2 - child.size[prop];
        case "center":
          return (containerCross2 - child.size[prop]) / 2;
        case "stretch":
        default:
          return 0;
      }
    }
  }
};
var RootFlexBox = class extends FlexBox {
  constructor(width, height, opts = {}) {
    super(width, height, opts);
  }
  getLayout() {
    this.build();
    const layoutMap = {};
    this._collectLayout(this, layoutMap);
    return layoutMap;
  }
  _collectLayout(box, map, counterRef = { counter: 0 }) {
    for (const child of box.children) {
      const id = child.id ?? `_$$${counterRef.counter++}`;
      map[id] = { position: child.position, size: child.size };
      if (child instanceof FlexBox) {
        this._collectLayout(child, map, counterRef);
      }
    }
  }
};

// lib/flexBoxLayout.ts
function _getFlexBoxOptions(item) {
  const opts = { id: item.id };
  opts.direction = item.direction ?? "row";
  opts.columnGap = item.columnGap ?? 0;
  opts.rowGap = item.rowGap ?? 0;
  opts.justifyContent = item.justifyContent ?? "flex-start";
  opts.alignItems = item.alignItems ?? "stretch";
  return opts;
}
function _populateFlexBoxRecursive(flexContainer, items) {
  if (!items) {
    return;
  }
  for (const item of items) {
    if (item.children && item.children.length > 0) {
      const nestedBoxOptions = _getFlexBoxOptions(item);
      const initialWidth = item.width ?? 0;
      const initialHeight = item.height ?? 0;
      const nestedFlexBox = new FlexBox(
        initialWidth,
        initialHeight,
        nestedBoxOptions
      );
      flexContainer.addChild(nestedFlexBox, item);
      _populateFlexBoxRecursive(nestedFlexBox, item.children);
    } else {
      flexContainer.addChild(item);
    }
  }
}
var flexBoxLayout = (parent) => {
  const rootWidth = parent.width ?? 0;
  const rootHeight = parent.height ?? 0;
  const rootOpts = _getFlexBoxOptions(parent);
  const root = new RootFlexBox(rootWidth, rootHeight, rootOpts);
  _populateFlexBoxRecursive(root, parent.children);
  return root.getLayout();
};
export {
  FlexBox,
  FlexElement,
  RootFlexBox,
  flexBoxLayout
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbGliL21pbmltYWwtZmxleGJveC50cyIsICIuLi9saWIvZmxleEJveExheW91dC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gbWluaW1hbC1mbGV4Ym94LnRzIFx1MjAxM1x1MDBBMHNpbmdsZVx1MjAxMWZpbGUgZmxleGJveCBlbmdpbmUgd2l0aCBkaXJlY3Rpb24sIGdhcCwgbmVzdGluZyAmIGFsaWdubWVudFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljIEFQSSBzdW1tYXJ5XG4vLyAgIFx1MjAyMiBuZXcgUm9vdEZsZXhCb3god2lkdGgsIGhlaWdodCwgb3B0aW9ucz8pXG4vLyAgICAgICBvcHRpb25zID0geyBkaXJlY3Rpb24sIGNvbHVtbkdhcCwgcm93R2FwLCBqdXN0aWZ5Q29udGVudCwgYWxpZ25JdGVtcyB9XG4vLyAgIFx1MjAyMiByb290LmFkZENoaWxkKHN0eWxlPykgICAgICAgICAgICAgICAgIC8vIGFkZCBsZWFmIGVsZW1lbnRcbi8vICAgXHUyMDIyIHJvb3QuYWRkQ2hpbGQoY2hpbGRCb3gsIHN0eWxlPykgICAgICAgLy8gbmVzdCBhbm90aGVyIGZsZXggY29udGFpbmVyXG4vLyAgIFx1MjAyMiByb290LmJ1aWxkKCkgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgdGhlIGxheW91dFxuLy8gICBcdTIwMjIgRXZlcnkgZWxlbWVudCAobGVhZiBvciBjb250YWluZXIpIGV4cG9zZXMgYC5wb3NpdGlvbmAgJiBgLnNpemVgXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmltcG9ydCB0eXBlIHtcbiAgRmxleFN0eWxlLFxuICBTaXplLFxuICBQb3NpdGlvbixcbiAgRGlyZWN0aW9uLFxuICBKdXN0aWZ5LFxuICBBbGlnbixcbiAgRmxleEJveE9wdGlvbnMsXG59IGZyb20gXCIuL3R5cGVzXCJcblxuY29uc3QgZGVmYXVsdFN0eWxlOiBGbGV4U3R5bGUgPSB7XG4gIGZsZXhHcm93OiAwLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4QmFzaXM6IDAsXG4gIGFsaWduU2VsZjogXCJhdXRvXCIsXG4gIHdpZHRoOiB1bmRlZmluZWQsXG4gIGhlaWdodDogdW5kZWZpbmVkLFxufVxuXG4vLyAtLS0gQ29yZSBub2RlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmFic3RyYWN0IGNsYXNzIEZsZXhOb2RlIHtcbiAgaWQ/OiBzdHJpbmdcbiAgbWV0YWRhdGE/OiB1bmtub3duXG4gIC8qKiBDb21wdXRlZCBsYXlvdXQgdmFsdWVzICovXG4gIHB1YmxpYyByZWFkb25seSBzaXplOiBTaXplID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH1cbiAgcHVibGljIHJlYWRvbmx5IHBvc2l0aW9uOiBQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9XG4gIC8qKiBJbmNvbWluZyBmbGV4IHN0eWxlIChncm93IC8gc2hyaW5rIC8gYmFzaXMgLyBhbGlnblNlbGYpICovXG4gIHB1YmxpYyBzdHlsZTogRmxleFN0eWxlXG5cbiAgY29uc3RydWN0b3Ioc3R5bGU6IFBhcnRpYWw8RmxleFN0eWxlPiA9IHt9KSB7XG4gICAgdGhpcy5zdHlsZSA9IHsgLi4uZGVmYXVsdFN0eWxlLCAuLi5zdHlsZSB9XG4gICAgdGhpcy5pZCA9IHN0eWxlLmlkXG4gICAgdGhpcy5tZXRhZGF0YSA9IHN0eWxlLm1ldGFkYXRhXG4gIH1cblxuICAvKiogUmVjdXJzaXZlbHkgbGF5IG91dCB0aGUgc3VidHJlZS4gKi9cbiAgYWJzdHJhY3QgYnVpbGQoKTogdm9pZFxufVxuXG4vLyAtLS0gTGVhZiBlbGVtZW50IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBjbGFzcyBGbGV4RWxlbWVudCBleHRlbmRzIEZsZXhOb2RlIHtcbiAgYnVpbGQoKTogdm9pZCB7XG4gICAgLyogbm90aGluZyB0byByZWN1cnNlIGludG8gKi9cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmxleEJveCBleHRlbmRzIEZsZXhOb2RlIHtcbiAgcHVibGljIHJlYWRvbmx5IGNoaWxkcmVuOiBGbGV4Tm9kZVtdID0gW11cblxuICAvLyBDb250YWluZXJcdTIwMTFsZXZlbCBsYXlvdXQgb3B0aW9ucyAod2l0aCBzZW5zaWJsZSBkZWZhdWx0cylcbiAgcHVibGljIGRpcmVjdGlvbjogRGlyZWN0aW9uID0gXCJyb3dcIlxuICBwdWJsaWMgY29sdW1uR2FwID0gMFxuICBwdWJsaWMgcm93R2FwID0gMFxuICBwdWJsaWMganVzdGlmeUNvbnRlbnQ6IEp1c3RpZnkgPSBcImZsZXgtc3RhcnRcIlxuICBwdWJsaWMgYWxpZ25JdGVtczogQWxpZ24gPSBcInN0cmV0Y2hcIlxuXG4gIGNvbnN0cnVjdG9yKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBvcHRzOiBGbGV4Qm94T3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoe30pXG4gICAgLy8gVGhlIGNvbnRhaW5lclx1MjAxOXMgb3duIGJveCBzaXplIChyb290IHNldHMgdGhpcyBleHBsaWNpdGx5OyBuZXN0ZWQgYm94ZXNcbiAgICAvLyByZWNlaXZlIHRoZWlyIHNpemUgZnJvbSB0aGUgcGFyZW50IGR1cmluZyBsYXlvdXQpLlxuICAgIHRoaXMuc2l6ZS53aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5zaXplLmhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMuaWQgPSBvcHRzLmlkXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRzKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tIEJ1aWxkaW5nIHRoZSB0cmVlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBhZGRDaGlsZChzdHlsZT8pIFx1MjE5MiBGbGV4RWxlbWVudCAgICAgICAgKGxlYWYpXG4gICAqIGFkZENoaWxkKGNoaWxkQm94LCBzdHlsZT8pIFx1MjE5MiBGbGV4Qm94ICAobmVzdCBhbm90aGVyIGNvbnRhaW5lcilcbiAgICovXG4gIGFkZENoaWxkKHN0eWxlOiBQYXJ0aWFsPEZsZXhTdHlsZT4pOiBGbGV4RWxlbWVudFxuICBhZGRDaGlsZChib3g6IEZsZXhCb3gsIHN0eWxlPzogUGFydGlhbDxGbGV4U3R5bGU+KTogRmxleEJveFxuICBhZGRDaGlsZChhcmcxOiBhbnksIGFyZzI/OiBhbnkpOiBhbnkge1xuICAgIGlmIChhcmcxIGluc3RhbmNlb2YgRmxleEJveCkge1xuICAgICAgY29uc3QgYm94ID0gYXJnMSBhcyBGbGV4Qm94XG4gICAgICBpZiAoYXJnMikgYm94LnN0eWxlID0geyAuLi5kZWZhdWx0U3R5bGUsIC4uLmFyZzIgfVxuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGJveClcbiAgICAgIHJldHVybiBib3hcbiAgICB9XG4gICAgY29uc3QgZWxlbSA9IG5ldyBGbGV4RWxlbWVudChhcmcxIGFzIFBhcnRpYWw8RmxleFN0eWxlPilcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goZWxlbSlcbiAgICByZXR1cm4gZWxlbVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tIExheW91dCBhbGdvcml0aG0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGJ1aWxkKCk6IHZvaWQge1xuICAgIC8vIDEuIElkZW50aWZ5IGF4ZXMgJiBnYXBzXG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuZGlyZWN0aW9uLnN0YXJ0c1dpdGgoXCJyb3dcIilcbiAgICBjb25zdCBtYWluUHJvcDoga2V5b2YgU2l6ZSA9IGhvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXG4gICAgY29uc3QgY3Jvc3NQcm9wOiBrZXlvZiBTaXplID0gaG9yaXpvbnRhbCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCJcbiAgICBjb25zdCBtYWluR2FwID0gaG9yaXpvbnRhbCA/IHRoaXMuY29sdW1uR2FwIDogdGhpcy5yb3dHYXBcbiAgICBjb25zdCBjcm9zc0dhcCA9IGhvcml6b250YWwgPyB0aGlzLnJvd0dhcCA6IHRoaXMuY29sdW1uR2FwIC8vIG1heSBiZSB1bnVzZWQgKHNpbmdsZSBsaW5lKVxuXG4gICAgLy8gMi4gR2F0aGVyIGZsZXggc3RhdGlzdGljc1xuICAgIGNvbnN0IGdhcFRvdGFsID0gbWFpbkdhcCAqIE1hdGgubWF4KDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSlcbiAgICBjb25zdCBjb250YWluZXJNYWluID0gdGhpcy5zaXplW21haW5Qcm9wXVxuICAgIGNvbnN0IGNvbnRhaW5lckNyb3NzID0gdGhpcy5zaXplW2Nyb3NzUHJvcF1cblxuICAgIGxldCB0b3RhbEJhc2lzID0gMFxuICAgIGxldCB0b3RhbEdyb3cgPSAwXG4gICAgbGV0IHRvdGFsU2hyaW5rID0gMFxuXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICB0b3RhbEJhc2lzICs9IGNoaWxkLnN0eWxlLmZsZXhCYXNpc1xuICAgICAgdG90YWxHcm93ICs9IGNoaWxkLnN0eWxlLmZsZXhHcm93XG4gICAgICB0b3RhbFNocmluayArPSBjaGlsZC5zdHlsZS5mbGV4U2hyaW5rXG4gICAgfVxuXG4gICAgY29uc3QgZnJlZVNwYWNlID0gY29udGFpbmVyTWFpbiAtIHRvdGFsQmFzaXMgLSBnYXBUb3RhbFxuXG4gICAgLy8gMy4gUmVzb2x2ZSBtYWluXHUyMDExYXhpcyBzaXplcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBsZXQgbWFpbiA9IGNoaWxkLnN0eWxlLmZsZXhCYXNpc1xuXG4gICAgICBpZiAoZnJlZVNwYWNlID4gMCAmJiB0b3RhbEdyb3cgPiAwKSB7XG4gICAgICAgIG1haW4gKz0gKGZyZWVTcGFjZSAqIGNoaWxkLnN0eWxlLmZsZXhHcm93KSAvIHRvdGFsR3Jvd1xuICAgICAgfSBlbHNlIGlmIChmcmVlU3BhY2UgPCAwICYmIHRvdGFsU2hyaW5rID4gMCkge1xuICAgICAgICBtYWluICs9IChmcmVlU3BhY2UgKiBjaGlsZC5zdHlsZS5mbGV4U2hyaW5rKSAvIHRvdGFsU2hyaW5rXG4gICAgICAgIGlmIChtYWluIDwgMCkgbWFpbiA9IDBcbiAgICAgIH1cblxuICAgICAgY2hpbGQuc2l6ZVttYWluUHJvcF0gPSBtYWluXG5cbiAgICAgIC8vIENyb3NzXHUyMDExYXhpcyBzaXplIChhbGlnbkl0ZW1zIC8gYWxpZ25TZWxmKVxuICAgICAgY29uc3QgYWxpZ25TZWxmID1cbiAgICAgICAgY2hpbGQuc3R5bGUuYWxpZ25TZWxmICE9PSBcImF1dG9cIlxuICAgICAgICAgID8gKGNoaWxkLnN0eWxlLmFsaWduU2VsZiBhcyBBbGlnbilcbiAgICAgICAgICA6IHRoaXMuYWxpZ25JdGVtc1xuXG4gICAgICBjb25zdCBleHBsaWNpdENyb3NzU2l6ZSA9IGhvcml6b250YWxcbiAgICAgICAgPyBjaGlsZC5zdHlsZS5oZWlnaHRcbiAgICAgICAgOiBjaGlsZC5zdHlsZS53aWR0aFxuXG4gICAgICBpZiAoZXhwbGljaXRDcm9zc1NpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjaGlsZC5zaXplW2Nyb3NzUHJvcF0gPSBleHBsaWNpdENyb3NzU2l6ZVxuICAgICAgfSBlbHNlIGlmIChhbGlnblNlbGYgPT09IFwic3RyZXRjaFwiKSB7XG4gICAgICAgIGNoaWxkLnNpemVbY3Jvc3NQcm9wXSA9IGNvbnRhaW5lckNyb3NzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJdGVtIGlzIG5vdCBzdHJldGNoZWQgYW5kIGhhcyBubyBleHBsaWNpdCBjcm9zcyBzaXplLlxuICAgICAgICAvLyBJdHMgY3Jvc3Mgc2l6ZSBpcyBub3QgY2hhbmdlZCBieSBhbGlnbm1lbnQ7IGl0IHJlbWFpbnMgaXRzIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgLy8gKGUuZy4sIDAgZm9yIGEgRmxleEVsZW1lbnQsIG9yIHRoZSBkZWZpbmVkIHNpemUgZm9yIGEgbmVzdGVkIEZsZXhCb3gpLlxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuIEp1c3RpZnkgY29udGVudCAobWFpblx1MjAxMWF4aXMgcG9zaXRpb25pbmcpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb25zdCBvY2N1cGllZCA9XG4gICAgICB0aGlzLmNoaWxkcmVuLnJlZHVjZSgoc3VtLCBjKSA9PiBzdW0gKyBjLnNpemVbbWFpblByb3BdLCAwKSArIGdhcFRvdGFsXG4gICAgY29uc3QgcmVtYWluaW5nID0gY29udGFpbmVyTWFpbiAtIG9jY3VwaWVkXG5cbiAgICBsZXQgbGVhZGluZyA9IDBcbiAgICBsZXQgYmV0d2VlbiA9IG1haW5HYXBcbiAgICBjb25zdCBuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGhcblxuICAgIHN3aXRjaCAodGhpcy5qdXN0aWZ5Q29udGVudCkge1xuICAgICAgY2FzZSBcImZsZXgtc3RhcnRcIjpcbiAgICAgICAgYnJlYWsgLy8gZGVmYXVsdHMgYXJlIGZpbmVcbiAgICAgIGNhc2UgXCJmbGV4LWVuZFwiOlxuICAgICAgICBsZWFkaW5nID0gcmVtYWluaW5nXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgIGxlYWRpbmcgPSByZW1haW5pbmcgLyAyXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic3BhY2UtYmV0d2VlblwiOlxuICAgICAgICBiZXR3ZWVuID0gbiA+IDEgPyBtYWluR2FwICsgcmVtYWluaW5nIC8gKG4gLSAxKSA6IDBcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzcGFjZS1hcm91bmRcIjpcbiAgICAgICAgYmV0d2VlbiA9IG1haW5HYXAgKyByZW1haW5pbmcgLyBuXG4gICAgICAgIGxlYWRpbmcgPSBiZXR3ZWVuIC8gMlxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInNwYWNlLWV2ZW5seVwiOlxuICAgICAgICBiZXR3ZWVuID0gbWFpbkdhcCArIHJlbWFpbmluZyAvIChuICsgMSlcbiAgICAgICAgbGVhZGluZyA9IGJldHdlZW5cbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICAvLyA1LiBQb3NpdGlvbiBjaGlsZHJlbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb25zdCBvcmRlcmVkID0gdGhpcy5kaXJlY3Rpb24uZW5kc1dpdGgoXCJyZXZlcnNlXCIpXG4gICAgICA/IFsuLi50aGlzLmNoaWxkcmVuXS5yZXZlcnNlKClcbiAgICAgIDogdGhpcy5jaGlsZHJlblxuICAgIGxldCBjdXJzb3IgPSBsZWFkaW5nXG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG9yZGVyZWQpIHtcbiAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgIGNoaWxkLnBvc2l0aW9uLnggPVxuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID09PSBcInJvd1wiXG4gICAgICAgICAgICA/IGN1cnNvclxuICAgICAgICAgICAgOiBjb250YWluZXJNYWluIC0gY3Vyc29yIC0gY2hpbGQuc2l6ZS53aWR0aFxuICAgICAgICBjaGlsZC5wb3NpdGlvbi55ID0gY29tcHV0ZUNyb3NzKFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIGNyb3NzUHJvcCxcbiAgICAgICAgICBjb250YWluZXJDcm9zcyxcbiAgICAgICAgICB0aGlzLmFsaWduSXRlbXMsXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkLnBvc2l0aW9uLnkgPVxuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID09PSBcImNvbHVtblwiXG4gICAgICAgICAgICA/IGN1cnNvclxuICAgICAgICAgICAgOiBjb250YWluZXJNYWluIC0gY3Vyc29yIC0gY2hpbGQuc2l6ZS5oZWlnaHRcbiAgICAgICAgY2hpbGQucG9zaXRpb24ueCA9IGNvbXB1dGVDcm9zcyhcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICBjcm9zc1Byb3AsXG4gICAgICAgICAgY29udGFpbmVyQ3Jvc3MsXG4gICAgICAgICAgdGhpcy5hbGlnbkl0ZW1zLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBjdXJzb3IgKz0gY2hpbGQuc2l6ZVttYWluUHJvcF0gKyBiZXR3ZWVuXG4gICAgfVxuXG4gICAgLy8gNi4gUmVjdXJzZSBpbnRvIG5lc3RlZCBmbGV4IGNvbnRhaW5lcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEZsZXhCb3gpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBuZXN0ZWQgYm94IG1hdGNoZXMgdGhlIGNvbXB1dGVkIHNpemUgKGFscmVhZHkgb24gLnNpemUpXG4gICAgICAgIGNoaWxkLmJ1aWxkKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tIGhlbHBlcnMgLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVDcm9zcyhcbiAgICAgIGNoaWxkOiBGbGV4Tm9kZSxcbiAgICAgIHByb3A6IGtleW9mIFNpemUsXG4gICAgICBjb250YWluZXJDcm9zczogbnVtYmVyLFxuICAgICAgYWxpZ25JdGVtczogQWxpZ24sXG4gICAgKTogbnVtYmVyIHtcbiAgICAgIGNvbnN0IGFsaWduU2VsZiA9XG4gICAgICAgIGNoaWxkLnN0eWxlLmFsaWduU2VsZiAhPT0gXCJhdXRvXCJcbiAgICAgICAgICA/IChjaGlsZC5zdHlsZS5hbGlnblNlbGYgYXMgQWxpZ24pXG4gICAgICAgICAgOiBhbGlnbkl0ZW1zXG4gICAgICBzd2l0Y2ggKGFsaWduU2VsZikge1xuICAgICAgICBjYXNlIFwiZmxleC1zdGFydFwiOlxuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIGNhc2UgXCJmbGV4LWVuZFwiOlxuICAgICAgICAgIHJldHVybiBjb250YWluZXJDcm9zcyAtIGNoaWxkLnNpemVbcHJvcF1cbiAgICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgICAgIHJldHVybiAoY29udGFpbmVyQ3Jvc3MgLSBjaGlsZC5zaXplW3Byb3BdKSAvIDJcbiAgICAgICAgY2FzZSBcInN0cmV0Y2hcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnQgdHlwZXMgZm9yIGV4dGVybmFsIHVzZVxuZXhwb3J0IHR5cGUge1xuICBGbGV4U3R5bGUsXG4gIFNpemUsXG4gIFBvc2l0aW9uLFxuICBEaXJlY3Rpb24sXG4gIEp1c3RpZnksXG4gIEFsaWduLFxuICBGbGV4Qm94T3B0aW9ucyxcbn0gZnJvbSBcIi4vdHlwZXNcIlxuXG4vLyBSb290IGNvbnRhaW5lciAoc2FtZSBhcyBGbGV4Qm94IGJ1dCBzZW1hbnRpY2FsbHkgZGlzdGluY3QpXG5leHBvcnQgY2xhc3MgUm9vdEZsZXhCb3ggZXh0ZW5kcyBGbGV4Qm94IHtcbiAgY29uc3RydWN0b3Iod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIG9wdHM6IEZsZXhCb3hPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih3aWR0aCwgaGVpZ2h0LCBvcHRzKVxuICB9XG5cbiAgZ2V0TGF5b3V0KCk6IFJlY29yZDxzdHJpbmcsIHsgcG9zaXRpb246IFBvc2l0aW9uOyBzaXplOiBTaXplIH0+IHtcbiAgICB0aGlzLmJ1aWxkKClcbiAgICBjb25zdCBsYXlvdXRNYXA6IFJlY29yZDxzdHJpbmcsIHsgcG9zaXRpb246IFBvc2l0aW9uOyBzaXplOiBTaXplIH0+ID0ge31cbiAgICB0aGlzLl9jb2xsZWN0TGF5b3V0KHRoaXMsIGxheW91dE1hcClcbiAgICByZXR1cm4gbGF5b3V0TWFwXG4gIH1cblxuICBwcml2YXRlIF9jb2xsZWN0TGF5b3V0KFxuICAgIGJveDogRmxleEJveCxcbiAgICBtYXA6IFJlY29yZDxzdHJpbmcsIHsgcG9zaXRpb246IFBvc2l0aW9uOyBzaXplOiBTaXplIH0+LFxuICAgIGNvdW50ZXJSZWYgPSB7IGNvdW50ZXI6IDAgfSxcbiAgKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBib3guY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGlkID0gY2hpbGQuaWQgPz8gYF8kJCR7Y291bnRlclJlZi5jb3VudGVyKyt9YFxuICAgICAgbWFwW2lkXSA9IHsgcG9zaXRpb246IGNoaWxkLnBvc2l0aW9uLCBzaXplOiBjaGlsZC5zaXplIH1cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEZsZXhCb3gpIHtcbiAgICAgICAgdGhpcy5fY29sbGVjdExheW91dChjaGlsZCwgbWFwLCBjb3VudGVyUmVmKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IFJvb3RGbGV4Qm94LCBGbGV4Qm94IH0gZnJvbSBcIi4vbWluaW1hbC1mbGV4Ym94XCIgLy8gQWRkZWQgRmxleEJveFxuaW1wb3J0IHR5cGUge1xuICBGbGV4U3R5bGUsXG4gIFNpemUsXG4gIFBvc2l0aW9uLFxuICBEaXJlY3Rpb24sXG4gIEp1c3RpZnksXG4gIEFsaWduLFxuICBGbGV4Qm94T3B0aW9ucyxcbn0gZnJvbSBcIi4vdHlwZXNcIlxuXG5leHBvcnQgaW50ZXJmYWNlIEZsZXhCb3hJdGVtIGV4dGVuZHMgRmxleFN0eWxlIHtcbiAgY2hpbGRyZW4/OiBGbGV4Qm94SXRlbVtdXG59XG5cbi8vIEhlbHBlciB0byBleHRyYWN0IEZsZXhCb3hPcHRpb25zIGZyb20gYSBGbGV4Qm94SXRlbSwgd2l0aCBkZWZhdWx0cy5cbi8vIEFzc3VtZXMgcHJvcGVydGllcyBsaWtlICdkaXJlY3Rpb24nIG1pZ2h0IGV4aXN0IG9uIGl0ZW0gZHluYW1pY2FsbHkuXG5mdW5jdGlvbiBfZ2V0RmxleEJveE9wdGlvbnMoaXRlbTogRmxleEJveEl0ZW0pOiBGbGV4Qm94T3B0aW9ucyB7XG4gIGNvbnN0IG9wdHM6IEZsZXhCb3hPcHRpb25zID0geyBpZDogaXRlbS5pZCB9XG4gIC8vIFByb3ZpZGUgZGVmYXVsdHMgZnJvbSBGbGV4Qm94IGNsYXNzIGlmIHByb3BlcnRpZXMgYXJlIG5vdCBvbiBpdGVtXG4gIG9wdHMuZGlyZWN0aW9uID0gKGl0ZW0gYXMgYW55KS5kaXJlY3Rpb24gPz8gXCJyb3dcIlxuICBvcHRzLmNvbHVtbkdhcCA9IChpdGVtIGFzIGFueSkuY29sdW1uR2FwID8/IDBcbiAgb3B0cy5yb3dHYXAgPSAoaXRlbSBhcyBhbnkpLnJvd0dhcCA/PyAwXG4gIG9wdHMuanVzdGlmeUNvbnRlbnQgPSAoaXRlbSBhcyBhbnkpLmp1c3RpZnlDb250ZW50ID8/IFwiZmxleC1zdGFydFwiXG4gIG9wdHMuYWxpZ25JdGVtcyA9IChpdGVtIGFzIGFueSkuYWxpZ25JdGVtcyA/PyBcInN0cmV0Y2hcIlxuICByZXR1cm4gb3B0c1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gcmVjdXJzaXZlbHkgcG9wdWxhdGUgRmxleEJveCBpbnN0YW5jZXMgZnJvbSBGbGV4Qm94SXRlbSB0cmVlXG5mdW5jdGlvbiBfcG9wdWxhdGVGbGV4Qm94UmVjdXJzaXZlKFxuICBmbGV4Q29udGFpbmVyOiBGbGV4Qm94LCAvLyBUaGUgRmxleEJveCBpbnN0YW5jZSB0byBhZGQgY2hpbGRyZW4gdG9cbiAgaXRlbXM6IEZsZXhCb3hJdGVtW10gfCB1bmRlZmluZWQsIC8vIFRoZSBsaXN0IG9mIGNoaWxkIGl0ZW1zIHRvIGFkZFxuKSB7XG4gIGlmICghaXRlbXMpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgIC8vICdpdGVtJyBpcyBhIEZsZXhCb3hJdGVtLiBJdCBpbmNsdWRlcyBGbGV4U3R5bGUgcHJvcGVydGllcy5cbiAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIChmbGV4R3JvdywgZmxleFNocmluaywgZXRjLikgZGVmaW5lIGhvdyAnaXRlbScgYmVoYXZlcyBhcyBhIGNoaWxkLlxuICAgIC8vIFdlIGNhbiBwYXNzICdpdGVtJyBhcyBQYXJ0aWFsPEZsZXhTdHlsZT4gYmVjYXVzZSBGbGV4Tm9kZSBjb25zdHJ1Y3RvciBoYW5kbGVzIGRlZmF1bHRzLlxuXG4gICAgaWYgKGl0ZW0uY2hpbGRyZW4gJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBUaGlzIGl0ZW0gcmVwcmVzZW50cyBhIG5lc3RlZCBGbGV4Qm94IGNvbnRhaW5lclxuICAgICAgY29uc3QgbmVzdGVkQm94T3B0aW9ucyA9IF9nZXRGbGV4Qm94T3B0aW9ucyhpdGVtKSAvLyBFeHRyYWN0IEZsZXhCb3hPcHRpb25zIGZvciB0aGUgbmV3IGNvbnRhaW5lclxuXG4gICAgICAvLyBVc2UgaXRlbS53aWR0aC9oZWlnaHQgZnJvbSBpdHMgc3R5bGUgZm9yIHRoZSBpbml0aWFsIHNpemUgb2YgdGhlIG5lc3RlZCBGbGV4Qm94LlxuICAgICAgLy8gVGhlc2UgYXJlIHRyZWF0ZWQgYXMgZXhwbGljaXQgZGltZW5zaW9ucyBmb3IgdGhlIGl0ZW0gaXRzZWxmLlxuICAgICAgY29uc3QgaW5pdGlhbFdpZHRoID0gaXRlbS53aWR0aCA/PyAwXG4gICAgICBjb25zdCBpbml0aWFsSGVpZ2h0ID0gaXRlbS5oZWlnaHQgPz8gMFxuXG4gICAgICBjb25zdCBuZXN0ZWRGbGV4Qm94ID0gbmV3IEZsZXhCb3goXG4gICAgICAgIGluaXRpYWxXaWR0aCxcbiAgICAgICAgaW5pdGlhbEhlaWdodCxcbiAgICAgICAgbmVzdGVkQm94T3B0aW9ucyxcbiAgICAgIClcblxuICAgICAgLy8gQWRkIHRoZSBuZXcgRmxleEJveCAobmVzdGVkRmxleEJveCkgYXMgYSBjaGlsZCB0byB0aGUgY3VycmVudCBmbGV4Q29udGFpbmVyLlxuICAgICAgLy8gVGhlICdpdGVtJyBpdHNlbGYgcHJvdmlkZXMgdGhlIEZsZXhTdHlsZSBmb3IgdGhpcyBuZXN0ZWRGbGV4Qm94IEFTIEFOIElURU0uXG4gICAgICBmbGV4Q29udGFpbmVyLmFkZENoaWxkKG5lc3RlZEZsZXhCb3gsIGl0ZW0pXG5cbiAgICAgIF9wb3B1bGF0ZUZsZXhCb3hSZWN1cnNpdmUobmVzdGVkRmxleEJveCwgaXRlbS5jaGlsZHJlbikgLy8gUmVjdXJzZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGl0ZW0gaXMgYSBsZWFmIEZsZXhFbGVtZW50XG4gICAgICAvLyAnaXRlbScgcHJvdmlkZXMgdGhlIEZsZXhTdHlsZSBmb3IgdGhpcyBlbGVtZW50LlxuICAgICAgZmxleENvbnRhaW5lci5hZGRDaGlsZChpdGVtKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmxleEJveExheW91dCA9IChcbiAgcGFyZW50OiBGbGV4Qm94SXRlbSwgLy8gVGhpcyAncGFyZW50JyBGbGV4Qm94SXRlbSBkZXNjcmliZXMgdGhlIHJvb3QgZmxleCBjb250YWluZXJcbik6IFJlY29yZDxzdHJpbmcsIHsgcG9zaXRpb246IFBvc2l0aW9uOyBzaXplOiBTaXplIH0+ID0+IHtcbiAgLy8gVXNlIHBhcmVudC53aWR0aC9oZWlnaHQgZm9yIFJvb3RGbGV4Qm94IGRpbWVuc2lvbnMsIGRlZmF1bHRpbmcgdG8gMCBpZiB1bmRlZmluZWQuXG4gIGNvbnN0IHJvb3RXaWR0aCA9IHBhcmVudC53aWR0aCA/PyAwXG4gIGNvbnN0IHJvb3RIZWlnaHQgPSBwYXJlbnQuaGVpZ2h0ID8/IDBcblxuICAvLyBFeHRyYWN0IEZsZXhCb3hPcHRpb25zIGZvciB0aGUgcm9vdCBjb250YWluZXIgZnJvbSB0aGUgJ3BhcmVudCcgaXRlbS5cbiAgY29uc3Qgcm9vdE9wdHMgPSBfZ2V0RmxleEJveE9wdGlvbnMocGFyZW50KVxuXG4gIGNvbnN0IHJvb3QgPSBuZXcgUm9vdEZsZXhCb3gocm9vdFdpZHRoLCByb290SGVpZ2h0LCByb290T3B0cylcblxuICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSB0aGUgJ3Jvb3QnIEZsZXhCb3ggYmFzZWQgb24gJ3BhcmVudC5jaGlsZHJlbicuXG4gIF9wb3B1bGF0ZUZsZXhCb3hSZWN1cnNpdmUocm9vdCwgcGFyZW50LmNoaWxkcmVuKVxuXG4gIC8vIENvbXB1dGUgdGhlIGxheW91dCBhbmQgcmV0dXJuIHRoZSBtYXAuXG4gIHJldHVybiByb290LmdldExheW91dCgpXG59XG4iXSwKICAibWFwcGluZ3MiOiAiO0FBcUJBLElBQU0sZUFBMEI7QUFBQSxFQUM5QixVQUFVO0FBQUEsRUFDVixZQUFZO0FBQUEsRUFDWixXQUFXO0FBQUEsRUFDWCxXQUFXO0FBQUEsRUFDWCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQ1Y7QUFHQSxJQUFlLFdBQWYsTUFBd0I7QUFBQSxFQUN0QjtBQUFBLEVBQ0E7QUFBQTtBQUFBLEVBRWdCLE9BQWEsRUFBRSxPQUFPLEdBQUcsUUFBUSxFQUFFO0FBQUEsRUFDbkMsV0FBcUIsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFO0FBQUE7QUFBQSxFQUUzQztBQUFBLEVBRVAsWUFBWSxRQUE0QixDQUFDLEdBQUc7QUFDMUMsU0FBSyxRQUFRLEVBQUUsR0FBRyxjQUFjLEdBQUcsTUFBTTtBQUN6QyxTQUFLLEtBQUssTUFBTTtBQUNoQixTQUFLLFdBQVcsTUFBTTtBQUFBLEVBQ3hCO0FBSUY7QUFHTyxJQUFNLGNBQU4sY0FBMEIsU0FBUztBQUFBLEVBQ3hDLFFBQWM7QUFBQSxFQUVkO0FBQ0Y7QUFFTyxJQUFNLFVBQU4sTUFBTSxpQkFBZ0IsU0FBUztBQUFBLEVBQ3BCLFdBQXVCLENBQUM7QUFBQTtBQUFBLEVBR2pDLFlBQXVCO0FBQUEsRUFDdkIsWUFBWTtBQUFBLEVBQ1osU0FBUztBQUFBLEVBQ1QsaUJBQTBCO0FBQUEsRUFDMUIsYUFBb0I7QUFBQSxFQUUzQixZQUFZLE9BQWUsUUFBZ0IsT0FBdUIsQ0FBQyxHQUFHO0FBQ3BFLFVBQU0sQ0FBQyxDQUFDO0FBR1IsU0FBSyxLQUFLLFFBQVE7QUFDbEIsU0FBSyxLQUFLLFNBQVM7QUFDbkIsU0FBSyxLQUFLLEtBQUs7QUFDZixXQUFPLE9BQU8sTUFBTSxJQUFJO0FBQUEsRUFDMUI7QUFBQSxFQVNBLFNBQVMsTUFBVyxNQUFpQjtBQUNuQyxRQUFJLGdC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QUEsRUFDVDtBQUFBLEVBRVEsZUFDTixLQUNBLEtBQ0EsYUFBYSxFQUFFLFNBQVMsRUFBRSxHQUNwQjtBQUNOLGVBQVcsU0FBUyxJQUFJLFVBQVU7QUFDaEMsWUFBTSxLQUFLLE1BQU0sTUFBTSxNQUFNLFdBQVcsU0FBUztBQUNqRCxVQUFJLEVBQUUsSUFBSSxFQUFFLFVBQVUsTUFBTSxVQUFVLE1BQU0sTUFBTSxLQUFLO0FBQ3ZELFVBQUksaUJBQWlCLFNBQVM7QUFDNUIsYUFBSyxlQUFlLE9BQU8sS0FBSyxVQUFVO0FBQUEsTUFDNUM7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGOzs7QUNsUkEsU0FBUyxtQkFBbUIsTUFBbUM7QUFDN0QsUUFBTSxPQUF1QixFQUFFLElBQUksS0FBSyxHQUFHO0FBRTNDLE9BQUssWUFBYSxLQUFhLGFBQWE7QUFDNUMsT0FBSyxZQUFhLEtBQWEsYUFBYTtBQUM1QyxPQUFLLFNBQVUsS0FBYSxVQUFVO0FBQ3RDLE9BQUssaUJBQWtCLEtBQWEsa0JBQWtCO0FBQ3RELE9BQUssYUFBYyxLQUFhLGNBQWM7QUFDOUMsU0FBTztBQUNUO0FBR0EsU0FBUywwQkFDUCxlQUNBLE9BQ0E7QUFDQSxNQUFJLENBQUMsT0FBTztBQUNWO0FBQUEsRUFDRjtBQUVBLGFBQVcsUUFBUSxPQUFPO0FBS3hCLFFBQUksS0FBSyxZQUFZLEtBQUssU0FBUyxTQUFTLEdBQUc7QUFFN0MsWUFBTSxtQkFBbUIsbUJBQW1CLElBQUk7QUFJaEQsWUFBTSxlQUFlLEtBQUssU0FBUztBQUNuQyxZQUFNLGdCQUFnQixLQUFLLFVBQVU7QUFFckMsWUFBTSxnQkFBZ0IsSUFBSTtBQUFBLFFBQ3hCO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBSUEsb0JBQWMsU0FBUyxlQUFlLElBQUk7QUFFMUMsZ0NBQTBCLGVBQWUsS0FBSyxRQUFRO0FBQUEsSUFDeEQsT0FBTztBQUdMLG9CQUFjLFNBQVMsSUFBSTtBQUFBLElBQzdCO0FBQUEsRUFDRjtBQUNGO0FBRU8sSUFBTSxnQkFBZ0IsQ0FDM0IsV0FDdUQ7QUFFdkQsUUFBTSxZQUFZLE9BQU8sU0FBUztBQUNsQyxRQUFNLGFBQWEsT0FBTyxVQUFVO0FBR3BDLFFBQU0sV0FBVyxtQkFBbUIsTUFBTTtBQUUxQyxRQUFNLE9BQU8sSUFBSSxZQUFZLFdBQVcsWUFBWSxRQUFRO0FBRzVELDRCQUEwQixNQUFNLE9BQU8sUUFBUTtBQUcvQyxTQUFPLEtBQUssVUFBVTtBQUN4QjsiLAogICJuYW1lcyI6IFsiY29udGFpbmVyQ3Jvc3MiXQp9Cg==