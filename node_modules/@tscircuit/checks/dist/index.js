// lib/add-start-and-end-port-ids-if-missing.ts
function distance(x1, y1, x2, y2) {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}
var addStartAndEndPortIdsIfMissing = (soup) => {
  const pcbPorts = soup.filter((item) => item.type === "pcb_port");
  const pcbSmtPads = soup.filter(
    (item) => item.type === "pcb_smtpad"
  );
  const pcbTraces = soup.filter((item) => item.type === "pcb_trace");
  function findPortIdOverlappingPoint(point, options = {}) {
    const traceWidth = options.traceWidth || 0;
    const directPort = pcbPorts.find(
      (port) => distance(port.x, port.y, point.x, point.y) < 0.01
    );
    if (directPort) return directPort.pcb_port_id;
    if (options.isFirstOrLastPoint) {
      const smtPad = pcbSmtPads.find((pad) => {
        if (pad.shape === "rect") {
          return Math.abs(point.x - pad.x) < pad.width / 2 + traceWidth / 2 && Math.abs(point.y - pad.y) < pad.height / 2 + traceWidth / 2;
        } else if (pad.shape === "circle") {
          return distance(point.x, point.y, pad.x, pad.y) < pad.radius;
        }
      });
      if (smtPad) return smtPad.pcb_port_id ?? null;
    }
    return null;
  }
  for (const trace of pcbTraces) {
    for (let index = 0; index < trace.route.length; index++) {
      const segment = trace.route[index];
      const isFirstOrLastPoint = index === 0 || index === trace.route.length - 1;
      if (segment.route_type === "wire") {
        if (!segment.start_pcb_port_id && index === 0) {
          const startPortId = findPortIdOverlappingPoint(segment, {
            isFirstOrLastPoint,
            traceWidth: segment.width
          });
          if (startPortId) {
            segment.start_pcb_port_id = startPortId;
          }
        }
        if (!segment.end_pcb_port_id && index === trace.route.length - 1) {
          const endPortId = findPortIdOverlappingPoint(segment, {
            isFirstOrLastPoint,
            traceWidth: segment.width
          });
          if (endPortId) {
            segment.end_pcb_port_id = endPortId;
          }
        }
      }
    }
  }
};

// lib/check-each-pcb-port-connected-to-pcb-trace.ts
import { getFullConnectivityMapFromCircuitJson } from "circuit-json-to-connectivity-map";
function checkEachPcbPortConnectedToPcbTraces(circuitJson) {
  addStartAndEndPortIdsIfMissing(circuitJson);
  const sourceTraces = circuitJson.filter(
    (item) => item.type === "source_trace"
  );
  const pcbPorts = circuitJson.filter(
    (item) => item.type === "pcb_port"
  );
  const errors = [];
  const connectivityMap = getFullConnectivityMapFromCircuitJson(circuitJson);
  const sourcePortToPcbPort = /* @__PURE__ */ new Map();
  for (const pcbPort of pcbPorts) {
    sourcePortToPcbPort.set(pcbPort.source_port_id, pcbPort);
  }
  for (const sourceTrace of sourceTraces) {
    const connectedSourcePortIds = sourceTrace.connected_source_port_ids;
    if (connectedSourcePortIds.length < 2) {
      continue;
    }
    const pcbPortsInTrace = [];
    const missingPcbPorts = [];
    for (const sourcePortId of connectedSourcePortIds) {
      const pcbPort = sourcePortToPcbPort.get(sourcePortId);
      if (pcbPort) {
        pcbPortsInTrace.push(pcbPort);
      } else {
        missingPcbPorts.push(sourcePortId);
      }
    }
    if (pcbPortsInTrace.length < 2) {
      continue;
    }
    const firstPcbPort = pcbPortsInTrace[0];
    const referenceNetId = connectivityMap.getNetConnectedToId(
      firstPcbPort.pcb_port_id
    );
    const netElementIds = connectivityMap.getIdsConnectedToNet(referenceNetId);
    const pcbTraceIds = netElementIds.filter(
      (id) => circuitJson.some(
        (element) => element.type === "pcb_trace" && ("pcb_trace_id" in element && element.pcb_trace_id === id || "route_id" in element && element.route_id === id)
      )
    );
    if (pcbTraceIds.length === 0) {
      const uniqueComponentIds = new Set(
        pcbPortsInTrace.map((p) => p.pcb_component_id)
      );
      if (uniqueComponentIds.size > 1) {
        errors.push({
          type: "pcb_port_not_connected_error",
          message: `pcb_port_not_connected_error: Pcb ports [${pcbPortsInTrace.map((p) => p.pcb_port_id).join(", ")}] are not connected together through the same net.`,
          error_type: "pcb_port_not_connected_error",
          pcb_port_ids: pcbPortsInTrace.map((p) => p.pcb_port_id),
          pcb_component_ids: pcbPortsInTrace.map((p) => p.pcb_component_id),
          pcb_port_not_connected_error_id: `pcb_port_not_connected_error_trace_${sourceTrace.source_trace_id}`
        });
      }
    }
  }
  return errors;
}

// lib/check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping.ts
import { getReadableNameForElement, cju } from "@tscircuit/circuit-json-util";

// lib/data-structures/SpatialIndex.ts
var SpatialObjectIndex = class {
  buckets;
  objectsById;
  getBounds;
  getId;
  CELL_SIZE = 0.4;
  constructor({
    objects,
    getBounds,
    getId,
    CELL_SIZE
  }) {
    this.buckets = /* @__PURE__ */ new Map();
    this.objectsById = /* @__PURE__ */ new Map();
    this.getBounds = getBounds;
    this.getId = getId ?? (() => this._getNextId());
    this.CELL_SIZE = CELL_SIZE ?? this.CELL_SIZE;
    for (const obj of objects) {
      this.addObject(obj);
    }
  }
  _idCounter = 0;
  _getNextId() {
    return `${this._idCounter++}`;
  }
  addObject(obj) {
    const bounds = this.getBounds(obj);
    const spatialIndexId = this.getId(obj);
    const objWithId = { ...obj, spatialIndexId };
    this.objectsById.set(spatialIndexId, objWithId);
    const minBucketX = Math.floor(bounds.minX / this.CELL_SIZE);
    const minBucketY = Math.floor(bounds.minY / this.CELL_SIZE);
    const maxBucketX = Math.floor(bounds.maxX / this.CELL_SIZE);
    const maxBucketY = Math.floor(bounds.maxY / this.CELL_SIZE);
    for (let bx = minBucketX; bx <= maxBucketX; bx++) {
      for (let by = minBucketY; by <= maxBucketY; by++) {
        const bucketKey = `${bx}x${by}`;
        const bucket = this.buckets.get(bucketKey);
        if (!bucket) {
          this.buckets.set(bucketKey, [objWithId]);
        } else {
          bucket.push(objWithId);
        }
      }
    }
  }
  removeObject(id) {
    const obj = this.objectsById.get(id);
    if (!obj) return false;
    this.objectsById.delete(id);
    const bounds = this.getBounds(obj);
    const minBucketX = Math.floor(bounds.minX / this.CELL_SIZE);
    const minBucketY = Math.floor(bounds.minY / this.CELL_SIZE);
    const maxBucketX = Math.floor(bounds.maxX / this.CELL_SIZE);
    const maxBucketY = Math.floor(bounds.maxY / this.CELL_SIZE);
    for (let bx = minBucketX; bx <= maxBucketX; bx++) {
      for (let by = minBucketY; by <= maxBucketY; by++) {
        const bucketKey = `${bx}x${by}`;
        const bucket = this.buckets.get(bucketKey);
        if (bucket) {
          const index = bucket.findIndex((item) => item.spatialIndexId === id);
          if (index !== -1) {
            bucket.splice(index, 1);
            if (bucket.length === 0) {
              this.buckets.delete(bucketKey);
            }
          }
        }
      }
    }
    return true;
  }
  getBucketKey(x, y) {
    return `${Math.floor(x / this.CELL_SIZE)}x${Math.floor(y / this.CELL_SIZE)}`;
  }
  getObjectsInBounds(bounds, margin = 0) {
    const objects = [];
    const addedIds = /* @__PURE__ */ new Set();
    const minBucketX = Math.floor((bounds.minX - margin) / this.CELL_SIZE);
    const minBucketY = Math.floor((bounds.minY - margin) / this.CELL_SIZE);
    const maxBucketX = Math.floor((bounds.maxX + margin) / this.CELL_SIZE);
    const maxBucketY = Math.floor((bounds.maxY + margin) / this.CELL_SIZE);
    for (let bx = minBucketX; bx <= maxBucketX; bx++) {
      for (let by = minBucketY; by <= maxBucketY; by++) {
        const bucketKey = `${bx}x${by}`;
        const bucket = this.buckets.get(bucketKey) || [];
        for (const obj of bucket) {
          const id = obj.spatialIndexId;
          if (addedIds.has(id)) continue;
          addedIds.add(id);
          objects.push(obj);
        }
      }
    }
    return objects;
  }
};

// lib/check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping.ts
import {
  getFullConnectivityMapFromCircuitJson as getFullConnectivityMapFromCircuitJson2
} from "circuit-json-to-connectivity-map";

// lib/check-each-pcb-trace-non-overlapping/getCollidableBounds.ts
import { getBoundsOfPcbElements } from "@tscircuit/circuit-json-util";
var getCollidableBounds = (collidable) => {
  if (collidable.type === "pcb_trace_segment") {
    return {
      minX: Math.min(collidable.x1, collidable.x2),
      minY: Math.min(collidable.y1, collidable.y2),
      maxX: Math.max(collidable.x1, collidable.x2),
      maxY: Math.max(collidable.y1, collidable.y2)
    };
  }
  return getBoundsOfPcbElements([collidable]);
};

// lib/check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping.ts
import {
  segmentToBoundsMinDistance,
  segmentToCircleMinDistance
} from "@tscircuit/math-utils";

// lib/drc-defaults.ts
var DEFAULT_TRACE_MARGIN = 0.1;
var DEFAULT_TRACE_THICKNESS = 0.15;
var DEFAULT_VIA_BOARD_MARGIN = 0.3;
var DEFAULT_SAME_NET_VIA_MARGIN = 0.2;
var DEFAULT_DIFFERENT_NET_VIA_MARGIN = 0.3;
var EPSILON = 5e-3;

// lib/check-each-pcb-trace-non-overlapping/getPcbPortIdsConnectedToTraces.ts
function getPcbPortIdsConnectedToTrace(trace) {
  const connectedPcbPorts = /* @__PURE__ */ new Set();
  for (const segment of trace.route) {
    if (segment.route_type === "wire") {
      if (segment.start_pcb_port_id)
        connectedPcbPorts.add(segment.start_pcb_port_id);
      if (segment.end_pcb_port_id)
        connectedPcbPorts.add(segment.end_pcb_port_id);
    }
  }
  return Array.from(connectedPcbPorts);
}
function getPcbPortIdsConnectedToTraces(traces) {
  const connectedPorts = /* @__PURE__ */ new Set();
  for (const trace of traces) {
    for (const portId of getPcbPortIdsConnectedToTrace(trace)) {
      connectedPorts.add(portId);
    }
  }
  return Array.from(connectedPorts);
}

// lib/check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping.ts
import { segmentToSegmentMinDistance } from "@tscircuit/math-utils";
import { getPrimaryId } from "@tscircuit/circuit-json-util";

// lib/check-each-pcb-trace-non-overlapping/getClosestPointBetweenSegments.ts
var getClosestPointBetweenSegments = (segmentA, segmentB) => {
  const a1 = { x: segmentA.x1, y: segmentA.y1 };
  const a2 = { x: segmentA.x2, y: segmentA.y2 };
  const b1 = { x: segmentB.x1, y: segmentB.y1 };
  const b2 = { x: segmentB.x2, y: segmentB.y2 };
  const va = { x: a2.x - a1.x, y: a2.y - a1.y };
  const vb = { x: b2.x - b1.x, y: b2.y - b1.y };
  const lenSqrA = va.x * va.x + va.y * va.y;
  const lenSqrB = vb.x * vb.x + vb.y * vb.y;
  if (lenSqrA === 0 || lenSqrB === 0) {
    if (lenSqrA === 0 && lenSqrB === 0) {
      return {
        x: (a1.x + b1.x) / 2,
        y: (a1.y + b1.y) / 2
      };
    }
    if (lenSqrA === 0) {
      const t2 = clamp(
        ((a1.x - b1.x) * vb.x + (a1.y - b1.y) * vb.y) / lenSqrB,
        0,
        1
      );
      const closestOnB2 = {
        x: b1.x + t2 * vb.x,
        y: b1.y + t2 * vb.y
      };
      return {
        x: (a1.x + closestOnB2.x) / 2,
        y: (a1.y + closestOnB2.y) / 2
      };
    }
    const t = clamp(
      ((b1.x - a1.x) * va.x + (b1.y - a1.y) * va.y) / lenSqrA,
      0,
      1
    );
    const closestOnA2 = {
      x: a1.x + t * va.x,
      y: a1.y + t * va.y
    };
    return {
      x: (closestOnA2.x + b1.x) / 2,
      y: (closestOnA2.y + b1.y) / 2
    };
  }
  const w = { x: a1.x - b1.x, y: a1.y - b1.y };
  const dotAA = va.x * va.x + va.y * va.y;
  const dotAB = va.x * vb.x + va.y * vb.y;
  const dotAW = va.x * w.x + va.y * w.y;
  const dotBB = vb.x * vb.x + vb.y * vb.y;
  const dotBW = vb.x * w.x + vb.y * w.y;
  const denominator = dotAA * dotBB - dotAB * dotAB;
  if (denominator < 1e-10) {
    return closestPointsParallelSegments(
      a1,
      a2,
      b1,
      b2,
      va,
      vb,
      lenSqrA,
      lenSqrB
    );
  }
  let tA = (dotAB * dotBW - dotBB * dotAW) / denominator;
  let tB = (dotAA * dotBW - dotAB * dotAW) / denominator;
  tA = clamp(tA, 0, 1);
  tB = clamp(tB, 0, 1);
  tB = (tA * dotAB + dotBW) / dotBB;
  tB = clamp(tB, 0, 1);
  tA = (tB * dotAB - dotAW) / dotAA;
  tA = clamp(tA, 0, 1);
  const closestOnA = {
    x: a1.x + tA * va.x,
    y: a1.y + tA * va.y
  };
  const closestOnB = {
    x: b1.x + tB * vb.x,
    y: b1.y + tB * vb.y
  };
  const dx = closestOnA.x - closestOnB.x;
  const dy = closestOnA.y - closestOnB.y;
  const distance5 = Math.sqrt(dx * dx + dy * dy);
  const averagePoint = {
    x: (closestOnA.x + closestOnB.x) / 2,
    y: (closestOnA.y + closestOnB.y) / 2
  };
  return averagePoint;
};
var closestPointsParallelSegments = (a1, a2, b1, b2, va, vb, lenSqrA, lenSqrB) => {
  let tA = ((b1.x - a1.x) * va.x + (b1.y - a1.y) * va.y) / lenSqrA;
  tA = clamp(tA, 0, 1);
  const pointOnA1 = { x: a1.x + tA * va.x, y: a1.y + tA * va.y };
  let tA2 = ((b2.x - a1.x) * va.x + (b2.y - a1.y) * va.y) / lenSqrA;
  tA2 = clamp(tA2, 0, 1);
  const pointOnA2 = { x: a1.x + tA2 * va.x, y: a1.y + tA2 * va.y };
  let tB = ((a1.x - b1.x) * vb.x + (a1.y - b1.y) * vb.y) / lenSqrB;
  tB = clamp(tB, 0, 1);
  const pointOnB1 = { x: b1.x + tB * vb.x, y: b1.y + tB * vb.y };
  let tB2 = ((a2.x - b1.x) * vb.x + (a2.y - b1.y) * vb.y) / lenSqrB;
  tB2 = clamp(tB2, 0, 1);
  const pointOnB2 = { x: b1.x + tB2 * vb.x, y: b1.y + tB2 * vb.y };
  const distances = [
    {
      pointA: pointOnA1,
      pointB: b1,
      distance: Math.sqrt(
        (pointOnA1.x - b1.x) ** 2 + (pointOnA1.y - b1.y) ** 2
      )
    },
    {
      pointA: pointOnA2,
      pointB: b2,
      distance: Math.sqrt(
        (pointOnA2.x - b2.x) ** 2 + (pointOnA2.y - b2.y) ** 2
      )
    },
    {
      pointA: a1,
      pointB: pointOnB1,
      distance: Math.sqrt(
        (a1.x - pointOnB1.x) ** 2 + (a1.y - pointOnB1.y) ** 2
      )
    },
    {
      pointA: a2,
      pointB: pointOnB2,
      distance: Math.sqrt(
        (a2.x - pointOnB2.x) ** 2 + (a2.y - pointOnB2.y) ** 2
      )
    }
  ];
  const closestPair = distances.reduce(
    (closest, current) => current.distance < closest.distance ? current : closest
  );
  return {
    x: (closestPair.pointA.x + closestPair.pointB.x) / 2,
    y: (closestPair.pointA.y + closestPair.pointB.y) / 2
  };
};
var clamp = (value, min, max) => {
  return Math.max(min, Math.min(max, value));
};

// lib/check-each-pcb-trace-non-overlapping/getRadiusOfCircuitJsonElement.ts
var getRadiusOfCircuitJsonElement = (obj) => {
  if (obj.type === "pcb_via") {
    return obj.outer_diameter / 2;
  }
  if (obj.type === "pcb_plated_hole" && obj.shape === "circle") {
    return obj.outer_diameter / 2;
  }
  if (obj.type === "pcb_hole" && obj.hole_shape === "circle") {
    return obj.hole_diameter / 2;
  }
  if (obj.type === "pcb_smtpad" && obj.shape === "circle") {
    return obj.radius;
  }
  throw new Error(
    `Could not determine radius of element: ${JSON.stringify(obj)}`
  );
};

// lib/check-each-pcb-trace-non-overlapping/getClosestPointBetweenSegmentAndBounds.ts
var getClosestPointBetweenSegmentAndBounds = (segment, bounds) => {
  const p1 = { x: segment.x1, y: segment.y1 };
  const p2 = { x: segment.x2, y: segment.y2 };
  const minX = bounds.minX;
  const minY = bounds.minY;
  const maxX = bounds.maxX;
  const maxY = bounds.maxY;
  if (p1.x === p2.x && p1.y === p2.y) {
    const closestX = Math.max(minX, Math.min(maxX, p1.x));
    const closestY = Math.max(minY, Math.min(maxY, p1.y));
    if (closestX === p1.x && closestY === p1.y) {
      return { x: p1.x, y: p1.y };
    }
    return { x: closestX, y: closestY };
  }
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const tMinX = dx !== 0 ? (minX - p1.x) / dx : Number.NEGATIVE_INFINITY;
  const tMaxX = dx !== 0 ? (maxX - p1.x) / dx : Number.POSITIVE_INFINITY;
  const tMinY = dy !== 0 ? (minY - p1.y) / dy : Number.NEGATIVE_INFINITY;
  const tMaxY = dy !== 0 ? (maxY - p1.y) / dy : Number.POSITIVE_INFINITY;
  const tEnter = Math.max(Math.min(tMinX, tMaxX), Math.min(tMinY, tMaxY));
  const tExit = Math.min(Math.max(tMinX, tMaxX), Math.max(tMinY, tMaxY));
  if (tEnter <= tExit && tExit >= 0 && tEnter <= 1) {
    const t = Math.max(0, Math.min(1, tEnter));
    return {
      x: p1.x + t * dx,
      y: p1.y + t * dy
    };
  }
  const closestToP1 = {
    x: Math.max(minX, Math.min(maxX, p1.x)),
    y: Math.max(minY, Math.min(maxY, p1.y))
  };
  const closestToP2 = {
    x: Math.max(minX, Math.min(maxX, p2.x)),
    y: Math.max(minY, Math.min(maxY, p2.y))
  };
  const distToP1Squared = (closestToP1.x - p1.x) ** 2 + (closestToP1.y - p1.y) ** 2;
  const distToP2Squared = (closestToP2.x - p2.x) ** 2 + (closestToP2.y - p2.y) ** 2;
  const edges = [
    { start: { x: minX, y: minY }, end: { x: maxX, y: minY } },
    // Bottom edge
    { start: { x: maxX, y: minY }, end: { x: maxX, y: maxY } },
    // Right edge
    { start: { x: maxX, y: maxY }, end: { x: minX, y: maxY } },
    // Top edge
    { start: { x: minX, y: maxY }, end: { x: minX, y: minY } }
    // Left edge
  ];
  let minDistance = Math.min(distToP1Squared, distToP2Squared);
  let closestPoint = distToP1Squared <= distToP2Squared ? closestToP1 : closestToP2;
  const clamp2 = (value, min, max) => {
    return Math.max(min, Math.min(max, value));
  };
  for (const edge of edges) {
    const va = { x: p2.x - p1.x, y: p2.y - p1.y };
    const vb = { x: edge.end.x - edge.start.x, y: edge.end.y - edge.start.y };
    const w = { x: p1.x - edge.start.x, y: p1.y - edge.start.y };
    const dotAA = va.x * va.x + va.y * va.y;
    const dotAB = va.x * vb.x + va.y * vb.y;
    const dotAW = va.x * w.x + va.y * w.y;
    const dotBB = vb.x * vb.x + vb.y * vb.y;
    const dotBW = vb.x * w.x + vb.y * w.y;
    const denominator = dotAA * dotBB - dotAB * dotAB;
    if (Math.abs(denominator) < 1e-10) continue;
    let tA = (dotAB * dotBW - dotBB * dotAW) / denominator;
    let tB = (dotAA * dotBW - dotAB * dotAW) / denominator;
    tA = clamp2(tA, 0, 1);
    tB = clamp2(tB, 0, 1);
    const closestOnSegment = {
      x: p1.x + tA * va.x,
      y: p1.y + tA * va.y
    };
    const closestOnEdge = {
      x: edge.start.x + tB * vb.x,
      y: edge.start.y + tB * vb.y
    };
    const dx2 = closestOnSegment.x - closestOnEdge.x;
    const dy2 = closestOnSegment.y - closestOnEdge.y;
    const distSquared = dx2 * dx2 + dy2 * dy2;
    if (distSquared < minDistance) {
      minDistance = distSquared;
      closestPoint = {
        x: (closestOnSegment.x + closestOnEdge.x) / 2,
        y: (closestOnSegment.y + closestOnEdge.y) / 2
      };
    }
  }
  return closestPoint;
};

// lib/util/getLayersOfPcbElement.ts
import { all_layers } from "circuit-json";
function getLayersOfPcbElement(obj) {
  if (obj.type === "pcb_trace_segment") {
    return [obj.layer];
  }
  if (obj.type === "pcb_smtpad") {
    return [obj.layer];
  }
  if (obj.type === "pcb_plated_hole") {
    return Array.isArray(obj.layers) ? obj.layers : [...all_layers];
  }
  if (obj.type === "pcb_hole") {
    return [...all_layers];
  }
  if (obj.type === "pcb_via") {
    return Array.isArray(obj.layers) ? obj.layers : [...all_layers];
  }
  if (obj.type === "pcb_keepout") {
    return Array.isArray(obj.layers) ? obj.layers : [];
  }
  return [];
}

// lib/check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping.ts
function checkEachPcbTraceNonOverlapping(circuitJson, {
  connMap
} = {}) {
  const errors = [];
  connMap ??= getFullConnectivityMapFromCircuitJson2(circuitJson);
  const pcbTraces = cju(circuitJson).pcb_trace.list();
  const pcbTraceSegments = pcbTraces.flatMap((pcbTrace) => {
    const segments = [];
    for (let i = 0; i < pcbTrace.route.length - 1; i++) {
      const p1 = pcbTrace.route[i];
      const p2 = pcbTrace.route[i + 1];
      if (p1.route_type !== "wire") continue;
      if (p2.route_type !== "wire") continue;
      if (p1.layer !== p2.layer) continue;
      segments.push({
        type: "pcb_trace_segment",
        pcb_trace_id: pcbTrace.pcb_trace_id,
        _pcbTrace: pcbTrace,
        thickness: "width" in p1 ? p1.width : "width" in p2 ? p2.width : DEFAULT_TRACE_THICKNESS,
        layer: p1.layer,
        x1: p1.x,
        y1: p1.y,
        x2: p2.x,
        y2: p2.y
      });
    }
    return segments;
  });
  const pcbSmtPads = cju(circuitJson).pcb_smtpad.list();
  const pcbPlatedHoles = cju(circuitJson).pcb_plated_hole.list();
  const pcbHoles = cju(circuitJson).pcb_hole.list();
  const pcbVias = cju(circuitJson).pcb_via.list();
  const pcbKeepouts = cju(circuitJson).pcb_keepout.list();
  const allObjects = [
    ...pcbTraceSegments,
    ...pcbSmtPads,
    ...pcbPlatedHoles,
    ...pcbHoles,
    ...pcbVias,
    ...pcbKeepouts
  ];
  const spatialIndex = new SpatialObjectIndex({
    objects: allObjects,
    getBounds: getCollidableBounds
  });
  const getReadableName = (id) => getReadableNameForElement(circuitJson, id);
  const errorIds = /* @__PURE__ */ new Set();
  for (const segmentA of pcbTraceSegments) {
    const requiredMargin = DEFAULT_TRACE_MARGIN;
    const bounds = getCollidableBounds(segmentA);
    const nearbyObjects = spatialIndex.getObjectsInBounds(
      bounds,
      requiredMargin + segmentA.thickness / 2
    );
    if (segmentA.x1 === segmentA.x2 && segmentA.y1 === segmentA.y2) continue;
    for (const obj of nearbyObjects) {
      if (!getLayersOfPcbElement(obj).includes(segmentA.layer)) {
        continue;
      }
      if (obj.type === "pcb_trace_segment") {
        const segmentB = obj;
        if (segmentA.layer !== segmentB.layer) continue;
        if (connMap.areIdsConnected(segmentA.pcb_trace_id, segmentB.pcb_trace_id))
          continue;
        const gap2 = segmentToSegmentMinDistance(
          { x: segmentA.x1, y: segmentA.y1 },
          { x: segmentA.x2, y: segmentA.y2 },
          { x: segmentB.x1, y: segmentB.y1 },
          { x: segmentB.x2, y: segmentB.y2 }
        ) - segmentA.thickness / 2 - segmentB.thickness / 2;
        if (gap2 > DEFAULT_TRACE_MARGIN - EPSILON) continue;
        const pcb_trace_error_id = `overlap_${segmentA.pcb_trace_id}_${segmentB.pcb_trace_id}`;
        const pcb_trace_error_id_reverse = `overlap_${segmentB.pcb_trace_id}_${segmentA.pcb_trace_id}`;
        if (errorIds.has(pcb_trace_error_id)) continue;
        if (errorIds.has(pcb_trace_error_id_reverse)) continue;
        errorIds.add(pcb_trace_error_id);
        errors.push({
          type: "pcb_trace_error",
          error_type: "pcb_trace_error",
          message: `PCB trace ${getReadableName(segmentA.pcb_trace_id)} overlaps with ${getReadableName(segmentB.pcb_trace_id)} ${gap2 < 0 ? "(accidental contact)" : `(gap: ${gap2.toFixed(3)}mm)`}`,
          pcb_trace_id: segmentA.pcb_trace_id,
          source_trace_id: "",
          pcb_trace_error_id,
          pcb_component_ids: [],
          center: getClosestPointBetweenSegments(segmentA, segmentB),
          pcb_port_ids: getPcbPortIdsConnectedToTraces([
            segmentA._pcbTrace,
            segmentB._pcbTrace
          ])
        });
        continue;
      }
      const primaryObjId = getPrimaryId(obj);
      if (connMap.areIdsConnected(
        segmentA.pcb_trace_id,
        "pcb_trace_id" in obj ? obj.pcb_trace_id : primaryObjId
      ))
        continue;
      const isCircular = obj.type === "pcb_via" || obj.type === "pcb_plated_hole" && obj.shape === "circle" || obj.type === "pcb_hole" || obj.type === "pcb_smtpad" && obj.shape === "circle";
      if (isCircular) {
        const radius = getRadiusOfCircuitJsonElement(obj);
        const distance5 = segmentToCircleMinDistance(
          { x: segmentA.x1, y: segmentA.y1 },
          { x: segmentA.x2, y: segmentA.y2 },
          { x: obj.x, y: obj.y, radius }
        );
        const gap2 = distance5 - segmentA.thickness / 2;
        if (gap2 > DEFAULT_TRACE_MARGIN - EPSILON) continue;
        const pcb_trace_error_id = `overlap_${segmentA.pcb_trace_id}_${primaryObjId}`;
        if (errorIds.has(pcb_trace_error_id)) continue;
        errorIds.add(pcb_trace_error_id);
        errors.push({
          type: "pcb_trace_error",
          error_type: "pcb_trace_error",
          message: `PCB trace ${getReadableName(segmentA.pcb_trace_id)} overlaps with ${obj.type} "${getReadableName(getPrimaryId(obj))}" ${gap2 < 0 ? "(accidental contact)" : `(gap: ${gap2.toFixed(3)}mm)`}`,
          pcb_trace_id: segmentA.pcb_trace_id,
          center: getClosestPointBetweenSegmentAndBounds(
            segmentA,
            getCollidableBounds(obj)
          ),
          source_trace_id: "",
          pcb_trace_error_id,
          pcb_component_ids: [
            "pcb_component_id" in obj ? obj.pcb_component_id : void 0
          ].filter(Boolean),
          pcb_port_ids: [
            ...getPcbPortIdsConnectedToTraces([segmentA._pcbTrace]),
            "pcb_port_id" in obj ? obj.pcb_port_id : void 0
          ].filter(Boolean)
        });
      }
      const gap = segmentToBoundsMinDistance(
        { x: segmentA.x1, y: segmentA.y1 },
        { x: segmentA.x2, y: segmentA.y2 },
        getCollidableBounds(obj)
      ) - segmentA.thickness / 2;
      if (gap + EPSILON < requiredMargin) {
        const pcb_trace_error_id = `overlap_${segmentA.pcb_trace_id}_${primaryObjId}`;
        if (errorIds.has(pcb_trace_error_id)) continue;
        errorIds.add(pcb_trace_error_id);
        errors.push({
          type: "pcb_trace_error",
          error_type: "pcb_trace_error",
          message: `PCB trace ${getReadableName(segmentA.pcb_trace_id)} overlaps with ${obj.type} "${getReadableName(getPrimaryId(obj))}" ${gap < 0 ? "(accidental contact)" : `(gap: ${gap.toFixed(3)}mm)`}`,
          pcb_trace_id: segmentA.pcb_trace_id,
          source_trace_id: "",
          pcb_trace_error_id,
          pcb_component_ids: [
            "pcb_component_id" in obj ? obj.pcb_component_id : void 0
          ].filter(Boolean),
          center: getClosestPointBetweenSegmentAndBounds(
            segmentA,
            getCollidableBounds(obj)
          ),
          pcb_port_ids: [
            ...getPcbPortIdsConnectedToTraces([segmentA._pcbTrace]),
            "pcb_port_id" in obj ? obj.pcb_port_id : void 0
          ].filter(Boolean)
        });
      }
    }
  }
  return errors;
}

// lib/net-manager.ts
var NetManager = class {
  networks = /* @__PURE__ */ new Set();
  setConnected(nodes) {
    if (nodes.length < 2) return;
    let targetNetwork = null;
    for (const network of this.networks) {
      for (const node of nodes) {
        if (network.has(node)) {
          if (targetNetwork === null) {
            targetNetwork = network;
          } else if (targetNetwork !== network) {
            for (const mergeNode of network) {
              targetNetwork.add(mergeNode);
            }
            this.networks.delete(network);
          }
          break;
        }
      }
      if (targetNetwork !== null && targetNetwork !== network) break;
    }
    if (targetNetwork === null) {
      targetNetwork = new Set(nodes);
      this.networks.add(targetNetwork);
    } else {
      for (const node of nodes) {
        targetNetwork.add(node);
      }
    }
  }
  isConnected(nodes) {
    if (nodes.length < 2) return true;
    for (const network of this.networks) {
      if (nodes.every((node) => network.has(node))) {
        return true;
      }
    }
    return false;
  }
};

// lib/check-pcb-components-out-of-board/checkViasOffBoard.ts
import { getReadableNameForElement as getReadableNameForElement2 } from "@tscircuit/circuit-json-util";
function checkViasOffBoard(circuitJson) {
  const board = circuitJson.find((el) => el.type === "pcb_board");
  if (!board) return [];
  const vias = circuitJson.filter((el) => el.type === "pcb_via");
  if (vias.length === 0) return [];
  const boardMinX = board.center.x - board.width / 2;
  const boardMaxX = board.center.x + board.width / 2;
  const boardMinY = board.center.y - board.height / 2;
  const boardMaxY = board.center.y + board.height / 2;
  const errors = [];
  for (const via of vias) {
    const viaRadius = via.outer_diameter / 2;
    const viaMinX = via.x - viaRadius;
    const viaMaxX = via.x + viaRadius;
    const viaMinY = via.y - viaRadius;
    const viaMaxY = via.y + viaRadius;
    if (viaMinX < boardMinX + DEFAULT_VIA_BOARD_MARGIN || viaMaxX > boardMaxX - DEFAULT_VIA_BOARD_MARGIN || viaMinY < boardMinY + DEFAULT_VIA_BOARD_MARGIN || viaMaxY > boardMaxY - DEFAULT_VIA_BOARD_MARGIN) {
      const viaName = getReadableNameForElement2(circuitJson, via.pcb_via_id);
      errors.push({
        type: "pcb_placement_error",
        pcb_placement_error_id: `out_of_board_${via.pcb_via_id}`,
        message: `Via ${viaName} is outside or crossing the board boundary`,
        error_type: "pcb_placement_error"
      });
    }
  }
  return errors;
}

// lib/check-pcb-components-out-of-board/checkPcbComponentsOutOfBoard.ts
import { getReadableNameForElement as getReadableNameForElement3 } from "@tscircuit/circuit-json-util";
import * as Flatten from "@flatten-js/core";
import { rotateDEG, applyToPoint } from "transformation-matrix";
function isPolygonCCW(poly) {
  return poly.area() >= 0;
}
function rectanglePolygon({
  center,
  size,
  rotationDeg = 0
}) {
  const cx = center.x;
  const cy = center.y;
  const hw = size.width / 2;
  const hh = size.height / 2;
  const corners = [
    new Flatten.Point(cx - hw, cy - hh),
    new Flatten.Point(cx + hw, cy - hh),
    new Flatten.Point(cx + hw, cy + hh),
    new Flatten.Point(cx - hw, cy + hh)
  ];
  let poly = new Flatten.Polygon(corners);
  if (rotationDeg) {
    const matrix = rotateDEG(rotationDeg, cx, cy);
    const rotatedCorners = corners.map((pt) => {
      const p = applyToPoint(matrix, { x: pt.x, y: pt.y });
      return new Flatten.Point(p.x, p.y);
    });
    poly = new Flatten.Polygon(rotatedCorners);
  }
  if (!isPolygonCCW(poly)) poly.reverse();
  return poly;
}
function boardToPolygon({
  board
}) {
  if (board.outline && board.outline.length > 0) {
    const points = board.outline.map((p) => new Flatten.Point(p.x, p.y));
    const poly = new Flatten.Polygon(points);
    if (!isPolygonCCW(poly)) {
      poly.reverse();
    }
    return poly;
  }
  if (board.center && typeof board.width === "number" && typeof board.height === "number") {
    return rectanglePolygon({
      center: board.center,
      size: { width: board.width, height: board.height },
      rotationDeg: 0
    });
  }
  return null;
}
function getComponentName({
  circuitJson,
  component
}) {
  if (component.source_component_id) {
    const sourceComponent = circuitJson.find(
      (el) => el.type === "source_component" && el.source_component_id === component.source_component_id
    );
    if (sourceComponent && "name" in sourceComponent && sourceComponent.name) {
      return sourceComponent.name;
    }
  }
  return getReadableNameForElement3(circuitJson, component.pcb_component_id) || "Unknown";
}
function computeOverlapDistance(compPoly, boardPoly, componentCenter, componentWidth, componentHeight, rotationDeg) {
  const centerPoint = new Flatten.Point(componentCenter.x, componentCenter.y);
  if (!boardPoly.contains(centerPoint)) {
    const dist = boardPoly.distanceTo(centerPoint);
    return Array.isArray(dist) ? dist[0] : Number(dist) || 0;
  }
  const hw = componentWidth / 2;
  const hh = componentHeight / 2;
  const corners = [
    { x: componentCenter.x - hw, y: componentCenter.y - hh },
    { x: componentCenter.x + hw, y: componentCenter.y - hh },
    { x: componentCenter.x + hw, y: componentCenter.y + hh },
    { x: componentCenter.x - hw, y: componentCenter.y + hh }
  ];
  const midpoints = [];
  for (let i = 0; i < 4; i++) {
    const next = (i + 1) % 4;
    midpoints.push({
      x: (corners[i].x + corners[next].x) / 2,
      y: (corners[i].y + corners[next].y) / 2
    });
  }
  const matrix = rotateDEG(rotationDeg, componentCenter.x, componentCenter.y);
  const rotatePoint = (pt) => {
    const p = applyToPoint(matrix, pt);
    return new Flatten.Point(p.x, p.y);
  };
  const rotatedPoints = corners.concat(midpoints).map(rotatePoint);
  let maxDistance = 0;
  for (const pt of rotatedPoints) {
    if (!boardPoly.contains(pt)) {
      const dist = boardPoly.distanceTo(pt);
      const d = Array.isArray(dist) ? dist[0] : Number(dist) || 0;
      if (d > maxDistance) maxDistance = d;
    }
  }
  if (maxDistance > 0) {
    return maxDistance;
  }
  try {
    const intersection = Flatten.BooleanOperations.intersect(
      compPoly,
      boardPoly
    );
    let intersectionArea = 0;
    if (!intersection) {
      intersectionArea = 0;
    } else if (Array.isArray(intersection)) {
      intersectionArea = intersection.reduce(
        (sum, p) => sum + (typeof p.area === "function" ? p.area() : 0),
        0
      );
    } else if (typeof intersection.area === "function") {
      intersectionArea = intersection.area();
    } else {
      intersectionArea = 0;
    }
    const compArea = compPoly.area();
    if (intersectionArea > 0 && intersectionArea < compArea) {
      const overlapRatio = 1 - intersectionArea / compArea;
      const compWidth = Math.abs(componentWidth);
      const compHeight = Math.abs(componentHeight);
      return Math.min(compWidth, compHeight) * overlapRatio;
    } else if (intersectionArea === 0) {
      return 0.1;
    } else {
      return 0.1;
    }
  } catch {
    return 0.1;
  }
}
function checkPcbComponentsOutOfBoard(circuitJson) {
  const board = circuitJson.find(
    (el) => el.type === "pcb_board"
  );
  if (!board) return [];
  const boardPoly = boardToPolygon({ board });
  if (!boardPoly) return [];
  const components = circuitJson.filter(
    (el) => el.type === "pcb_component"
  );
  if (components.length === 0) return [];
  const errors = [];
  for (const c of components) {
    if (!c.center || typeof c.width !== "number" || typeof c.height !== "number")
      continue;
    if (c.width <= 0 || c.height <= 0) continue;
    const compPoly = rectanglePolygon({
      center: c.center,
      size: { width: c.width, height: c.height },
      rotationDeg: c.rotation || 0
    });
    if (compPoly.area() === 0) continue;
    const isInside = boardPoly.contains(compPoly);
    if (isInside) continue;
    const overlapDistance = computeOverlapDistance(
      compPoly,
      boardPoly,
      c.center,
      c.width,
      c.height,
      c.rotation || 0
    );
    const compName = getComponentName({ circuitJson, component: c });
    const overlapDistanceMm = Math.round(overlapDistance * 100) / 100;
    errors.push({
      type: "pcb_component_outside_board_error",
      error_type: "pcb_component_outside_board_error",
      pcb_component_outside_board_error_id: `pcb_component_outside_board_${c.pcb_component_id}`,
      message: `Component ${compName} (${c.pcb_component_id}) extends outside board boundaries by ${overlapDistanceMm}mm`,
      pcb_component_id: c.pcb_component_id,
      pcb_board_id: board.pcb_board_id,
      component_center: c.center,
      component_bounds: {
        min_x: compPoly.box.xmin,
        max_x: compPoly.box.xmax,
        min_y: compPoly.box.ymin,
        max_y: compPoly.box.ymax
      },
      subcircuit_id: c.subcircuit_id,
      source_component_id: c.source_component_id
    });
  }
  return errors;
}

// lib/check-same-net-via-spacing.ts
import { getReadableNameForElement as getReadableNameForElement4 } from "@tscircuit/circuit-json-util";
import {
  getFullConnectivityMapFromCircuitJson as getFullConnectivityMapFromCircuitJson3
} from "circuit-json-to-connectivity-map";
function distance2(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}
function checkSameNetViaSpacing(circuitJson, {
  connMap,
  minSpacing = DEFAULT_SAME_NET_VIA_MARGIN
} = {}) {
  const vias = circuitJson.filter((el) => el.type === "pcb_via");
  if (vias.length < 2) return [];
  connMap ??= getFullConnectivityMapFromCircuitJson3(circuitJson);
  const errors = [];
  const reported = /* @__PURE__ */ new Set();
  for (let i = 0; i < vias.length; i++) {
    for (let j = i + 1; j < vias.length; j++) {
      const viaA = vias[i];
      const viaB = vias[j];
      if (!connMap.areIdsConnected(viaA.pcb_via_id, viaB.pcb_via_id)) continue;
      const gap = distance2(viaA, viaB) - viaA.outer_diameter / 2 - viaB.outer_diameter / 2;
      if (gap + EPSILON >= minSpacing) continue;
      const pairId = [viaA.pcb_via_id, viaB.pcb_via_id].sort().join("_");
      if (reported.has(pairId)) continue;
      reported.add(pairId);
      errors.push({
        type: "pcb_via_clearance_error",
        pcb_error_id: `same_net_vias_close_${pairId}`,
        message: `Vias ${getReadableNameForElement4(
          circuitJson,
          viaA.pcb_via_id
        )} and ${getReadableNameForElement4(
          circuitJson,
          viaB.pcb_via_id
        )} are too close together (gap: ${gap.toFixed(3)}mm)`,
        error_type: "pcb_via_clearance_error",
        pcb_via_ids: [viaA.pcb_via_id, viaB.pcb_via_id],
        minimum_clearance: minSpacing,
        actual_clearance: gap,
        pcb_center: {
          x: (viaA.x + viaB.x) / 2,
          y: (viaA.y + viaB.y) / 2
        }
      });
    }
  }
  return errors;
}

// lib/check-different-net-via-spacing.ts
import { getReadableNameForElement as getReadableNameForElement5 } from "@tscircuit/circuit-json-util";
import {
  getFullConnectivityMapFromCircuitJson as getFullConnectivityMapFromCircuitJson4
} from "circuit-json-to-connectivity-map";
function distance3(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}
function checkDifferentNetViaSpacing(circuitJson, {
  connMap,
  minSpacing = DEFAULT_DIFFERENT_NET_VIA_MARGIN
} = {}) {
  const vias = circuitJson.filter((el) => el.type === "pcb_via");
  if (vias.length < 2) return [];
  connMap ??= getFullConnectivityMapFromCircuitJson4(circuitJson);
  const errors = [];
  const reported = /* @__PURE__ */ new Set();
  for (let i = 0; i < vias.length; i++) {
    for (let j = i + 1; j < vias.length; j++) {
      const viaA = vias[i];
      const viaB = vias[j];
      if (connMap.areIdsConnected(viaA.pcb_via_id, viaB.pcb_via_id)) continue;
      const gap = distance3(viaA, viaB) - viaA.outer_diameter / 2 - viaB.outer_diameter / 2;
      if (gap + EPSILON >= minSpacing) continue;
      const pairId = [viaA.pcb_via_id, viaB.pcb_via_id].sort().join("_");
      if (reported.has(pairId)) continue;
      reported.add(pairId);
      errors.push({
        type: "pcb_via_clearance_error",
        pcb_error_id: `different_net_vias_close_${pairId}`,
        message: `Vias ${getReadableNameForElement5(
          circuitJson,
          viaA.pcb_via_id
        )} and ${getReadableNameForElement5(
          circuitJson,
          viaB.pcb_via_id
        )} from different nets are too close together (gap: ${gap.toFixed(
          3
        )}mm)`,
        error_type: "pcb_via_clearance_error",
        pcb_via_ids: [viaA.pcb_via_id, viaB.pcb_via_id],
        minimum_clearance: minSpacing,
        actual_clearance: gap,
        pcb_center: {
          x: (viaA.x + viaB.x) / 2,
          y: (viaA.y + viaB.y) / 2
        }
      });
    }
  }
  return errors;
}

// lib/check-source-traces-have-pcb-traces.ts
function checkSourceTracesHavePcbTraces(circuitJson) {
  const errors = [];
  const sourceTraces = circuitJson.filter(
    (el) => el.type === "source_trace"
  );
  const pcbTraces = circuitJson.filter(
    (el) => el.type === "pcb_trace"
  );
  for (const sourceTrace of sourceTraces) {
    if (!sourceTrace.connected_source_port_ids?.length) continue;
    const hasPcbTrace = pcbTraces.some(
      (pcbTrace) => pcbTrace.source_trace_id === sourceTrace.source_trace_id
    );
    if (!hasPcbTrace) {
      const connectedPcbPorts = circuitJson.filter(
        (el) => el.type === "pcb_port" && sourceTrace.connected_source_port_ids.includes(el.source_port_id)
      );
      const connectedPcbComponentIds = Array.from(
        new Set(connectedPcbPorts.map((port) => port.pcb_component_id))
      );
      errors.push({
        type: "pcb_trace_missing_error",
        pcb_trace_missing_error_id: `pcb_trace_missing_${sourceTrace.source_trace_id}`,
        error_type: "pcb_trace_missing_error",
        message: `Trace [${sourceTrace.display_name ?? sourceTrace.source_trace_id}] is not connected (it has no PCB trace)`,
        source_trace_id: sourceTrace.source_trace_id,
        pcb_component_ids: connectedPcbComponentIds,
        pcb_port_ids: connectedPcbPorts.map((port) => port.pcb_port_id)
      });
    }
  }
  return errors;
}

// lib/check-trace-out-of-board/checkTraceOutOfBoard.ts
import { cju as cju2 } from "@tscircuit/circuit-json-util";
import { segmentToSegmentMinDistance as segmentToSegmentMinDistance2 } from "@tscircuit/math-utils";
var DEFAULT_BOARD_MARGIN = 0.2;
function getBoardPolygonPoints(board) {
  if (board.outline && board.outline.length > 0) {
    return board.outline.map((p) => ({ x: p.x, y: p.y }));
  }
  if (board.center && typeof board.width === "number" && typeof board.height === "number") {
    const cx = board.center.x;
    const cy = board.center.y;
    const hw = board.width / 2;
    const hh = board.height / 2;
    return [
      { x: cx - hw, y: cy - hh },
      // bottom-left
      { x: cx + hw, y: cy - hh },
      // bottom-right
      { x: cx + hw, y: cy + hh },
      // top-right
      { x: cx - hw, y: cy + hh }
      // top-left
    ];
  }
  return null;
}
function checkPcbTracesOutOfBoard(circuitJson, config = {}) {
  const errors = [];
  const margin = config.margin ?? DEFAULT_BOARD_MARGIN;
  const board = circuitJson.find(
    (el) => el.type === "pcb_board"
  );
  if (!board) return errors;
  const boardPoints = getBoardPolygonPoints(board);
  if (!boardPoints) return errors;
  const pcbTraces = cju2(circuitJson).pcb_trace.list();
  for (const trace of pcbTraces) {
    if (trace.route.length < 2) continue;
    for (let i = 0; i < trace.route.length - 1; i++) {
      const p1 = trace.route[i];
      const p2 = trace.route[i + 1];
      if (p1.route_type !== "wire" || p2.route_type !== "wire") continue;
      const traceWidth = "width" in p1 ? p1.width : "width" in p2 ? p2.width : 0.1;
      const segmentStart = { x: p1.x, y: p1.y };
      const segmentEnd = { x: p2.x, y: p2.y };
      let minDistance = Infinity;
      for (let j = 0; j < boardPoints.length; j++) {
        const edgeStart = boardPoints[j];
        const edgeEnd = boardPoints[(j + 1) % boardPoints.length];
        const distance5 = segmentToSegmentMinDistance2(
          segmentStart,
          segmentEnd,
          edgeStart,
          edgeEnd
        );
        if (distance5 < minDistance) {
          minDistance = distance5;
        }
      }
      const minimumDistance = traceWidth / 2 + margin;
      if (minDistance < minimumDistance) {
        const error = {
          type: "pcb_trace_error",
          error_type: "pcb_trace_error",
          pcb_trace_error_id: `trace_too_close_to_board_${trace.pcb_trace_id}_segment_${i}`,
          message: `Trace too close to board edge (${minDistance.toFixed(3)}mm < ${minimumDistance.toFixed(3)}mm required, margin: ${margin}mm)`,
          pcb_trace_id: trace.pcb_trace_id,
          source_trace_id: trace.source_trace_id || "",
          center: {
            x: (segmentStart.x + segmentEnd.x) / 2,
            y: (segmentStart.y + segmentEnd.y) / 2
          },
          pcb_component_ids: [],
          pcb_port_ids: []
        };
        errors.push(error);
      }
    }
  }
  return errors;
}

// lib/check-pcb-components-overlap/checkPcbComponentOverlap.ts
import {
  cju as cju3,
  getBoundsOfPcbElements as getBoundsOfPcbElements2,
  getPrimaryId as getPrimaryId2
} from "@tscircuit/circuit-json-util";
import { doBoundsOverlap } from "@tscircuit/math-utils";
import {
  getFullConnectivityMapFromCircuitJson as getFullConnectivityMapFromCircuitJson5
} from "circuit-json-to-connectivity-map";
function doPcbElementsOverlap(elem1, elem2) {
  const bounds1 = getBoundsOfPcbElements2([elem1]);
  const bounds2 = getBoundsOfPcbElements2([elem2]);
  return doBoundsOverlap(bounds1, bounds2);
}
function checkPcbComponentOverlap(circuitJson) {
  const errors = [];
  const connMap = getFullConnectivityMapFromCircuitJson5(circuitJson);
  const smtPads = cju3(circuitJson).pcb_smtpad.list();
  const platedHoles = cju3(circuitJson).pcb_plated_hole.list();
  const holes = cju3(circuitJson).pcb_hole.list();
  const componentMap = /* @__PURE__ */ new Map();
  for (const pad of smtPads) {
    const componentId = pad.pcb_component_id || `standalone_pad_${getPrimaryId2(pad)}`;
    if (!componentMap.has(componentId)) {
      componentMap.set(componentId, {
        component_id: componentId,
        elements: [],
        bounds: { minX: 0, minY: 0, maxX: 0, maxY: 0 }
      });
    }
    componentMap.get(componentId).elements.push(pad);
  }
  for (const hole of platedHoles) {
    const componentId = hole.pcb_component_id || `standalone_plated_hole_${getPrimaryId2(hole)}`;
    if (!componentMap.has(componentId)) {
      componentMap.set(componentId, {
        component_id: componentId,
        elements: [],
        bounds: { minX: 0, minY: 0, maxX: 0, maxY: 0 }
      });
    }
    componentMap.get(componentId).elements.push(hole);
  }
  for (const hole of holes) {
    const componentId = `standalone_hole_${getPrimaryId2(hole)}`;
    componentMap.set(componentId, {
      component_id: componentId,
      elements: [hole],
      bounds: { minX: 0, minY: 0, maxX: 0, maxY: 0 }
    });
  }
  for (const [componentId, componentData] of componentMap) {
    if (componentData.elements.length > 0) {
      componentData.bounds = getBoundsOfPcbElements2(componentData.elements);
    }
  }
  const componentsWithElements = Array.from(componentMap.values());
  for (let i = 0; i < componentsWithElements.length; i++) {
    for (let j = i + 1; j < componentsWithElements.length; j++) {
      const comp1 = componentsWithElements[i];
      const comp2 = componentsWithElements[j];
      if (!doBoundsOverlap(comp1.bounds, comp2.bounds)) {
        continue;
      }
      for (const elem1 of comp1.elements) {
        for (const elem2 of comp2.elements) {
          const id1 = getPrimaryId2(elem1);
          const id2 = getPrimaryId2(elem2);
          if (elem1.type === "pcb_smtpad" && elem2.type === "pcb_smtpad" && connMap.areIdsConnected(id1, id2)) {
            continue;
          }
          if (doPcbElementsOverlap(elem1, elem2)) {
            const error = {
              type: "pcb_footprint_overlap_error",
              pcb_error_id: `pcb_footprint_overlap_${id1}_${id2}`,
              error_type: "pcb_footprint_overlap_error",
              message: `PCB component ${elem1.type} "${id1}" overlaps with ${elem2.type} "${id2}"`
            };
            if (elem1.type === "pcb_smtpad" || elem2.type === "pcb_smtpad") {
              error.pcb_smtpad_ids = [];
              if (elem1.type === "pcb_smtpad") error.pcb_smtpad_ids.push(id1);
              if (elem2.type === "pcb_smtpad") error.pcb_smtpad_ids.push(id2);
            }
            if (elem1.type === "pcb_plated_hole" || elem2.type === "pcb_plated_hole") {
              error.pcb_plated_hole_ids = [];
              if (elem1.type === "pcb_plated_hole")
                error.pcb_plated_hole_ids.push(id1);
              if (elem2.type === "pcb_plated_hole")
                error.pcb_plated_hole_ids.push(id2);
            }
            if (elem1.type === "pcb_hole" || elem2.type === "pcb_hole") {
              error.pcb_hole_ids = [];
              if (elem1.type === "pcb_hole") error.pcb_hole_ids.push(id1);
              if (elem2.type === "pcb_hole") error.pcb_hole_ids.push(id2);
            }
            errors.push(error);
          }
        }
      }
    }
  }
  return errors;
}

// lib/check-traces-are-contiguous/is-point-in-pad.ts
function distance4(x1, y1, x2, y2) {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}
function isPointInPad(point, pad) {
  if (pad.type === "pcb_smtpad") {
    if (pad.shape === "circle") {
      return distance4(point.x, point.y, pad.x, pad.y) <= pad.radius;
    }
    if (pad.shape === "rect") {
      const halfWidth = pad.width / 2;
      const halfHeight = pad.height / 2;
      return Math.abs(point.x - pad.x) <= halfWidth && Math.abs(point.y - pad.y) <= halfHeight;
    }
    if (pad.shape === "rotated_rect") {
      const dx = point.x - pad.x;
      const dy = point.y - pad.y;
      const angle = -pad.ccw_rotation;
      const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
      const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
      return Math.abs(rotatedX) <= pad.width / 2 && Math.abs(rotatedY) <= pad.height / 2;
    }
    if (pad.shape === "pill") {
      const halfWidth = pad.width / 2;
      const halfHeight = pad.height / 2;
      const radius = pad.radius;
      if (Math.abs(point.x - pad.x) <= halfWidth - radius && Math.abs(point.y - pad.y) <= halfHeight) {
        return true;
      }
      const cornerX = Math.max(
        Math.abs(point.x - pad.x) - (halfWidth - radius),
        0
      );
      const cornerY = Math.max(
        Math.abs(point.y - pad.y) - (halfHeight - radius),
        0
      );
      return cornerX * cornerX + cornerY * cornerY <= radius * radius;
    }
  }
  if (pad.type === "pcb_plated_hole") {
    if (pad.shape === "circle") {
      return distance4(point.x, point.y, pad.x, pad.y) <= pad.outer_diameter / 2;
    }
    if (pad.shape === "oval" || pad.shape === "pill") {
      return Math.abs(point.x - pad.x) <= pad.outer_width / 2 && Math.abs(point.y - pad.y) <= pad.outer_height / 2;
    }
    if (pad.shape === "circular_hole_with_rect_pad") {
      return Math.abs(point.x - pad.x) <= pad.rect_pad_width / 2 && Math.abs(point.y - pad.y) <= pad.rect_pad_height / 2;
    }
    if (pad.shape === "pill_hole_with_rect_pad") {
      return Math.abs(point.x - pad.x) <= pad.rect_pad_width / 2 && Math.abs(point.y - pad.y) <= pad.rect_pad_height / 2;
    }
  }
  return false;
}

// lib/check-traces-are-contiguous/check-traces-are-contiguous.ts
import { getReadableNameForPcbPort } from "@tscircuit/circuit-json-util";
function checkTracesAreContiguous(circuitJson) {
  const errors = [];
  const pcbPorts = circuitJson.filter(
    (el) => el.type === "pcb_port"
  );
  const pcbTraces = circuitJson.filter(
    (el) => el.type === "pcb_trace"
  );
  const sourceTraces = circuitJson.filter(
    (el) => el.type === "source_trace"
  );
  const pcbSmtPads = circuitJson.filter(
    (el) => el.type === "pcb_smtpad"
  );
  const pcbPlatedHoles = circuitJson.filter(
    (el) => el.type === "pcb_plated_hole"
  );
  const padMap = /* @__PURE__ */ new Map();
  for (const pad of pcbSmtPads) {
    if (pad.pcb_port_id) {
      padMap.set(pad.pcb_port_id, pad);
    }
  }
  for (const hole of pcbPlatedHoles) {
    if (hole.pcb_port_id) {
      padMap.set(hole.pcb_port_id, hole);
    }
  }
  for (const trace of pcbTraces) {
    if (trace.route.length === 0) continue;
    const firstPoint = trace.route[0];
    const lastPoint = trace.route[trace.route.length - 1];
    const sourceTrace = sourceTraces.find(
      (st) => st.source_trace_id === trace.source_trace_id
    );
    const expectedPorts = sourceTrace ? pcbPorts.filter(
      (port) => sourceTrace.connected_source_port_ids?.includes(port.source_port_id)
    ) : [];
    for (let i = 1; i < trace.route.length - 1; i++) {
      const prevPoint = trace.route[i - 1];
      const currentPoint = trace.route[i];
      const nextPoint = trace.route[i + 1];
      if (currentPoint.route_type === "via") {
        const prevIsWire = prevPoint.route_type === "wire";
        const nextIsWire = nextPoint.route_type === "wire";
        if (prevIsWire && nextIsWire) {
          const prevAligned = Math.abs(prevPoint.x - currentPoint.x) < 1e-3 && Math.abs(prevPoint.y - currentPoint.y) < 1e-3;
          const nextAligned = Math.abs(nextPoint.x - currentPoint.x) < 1e-3 && Math.abs(nextPoint.y - currentPoint.y) < 1e-3;
          if (!prevAligned || !nextAligned) {
            const traceName2 = sourceTrace?.display_name || trace.source_trace_id || "unknown";
            errors.push({
              type: "pcb_trace_error",
              message: `Via in trace [${traceName2}] is misaligned at position {x: ${currentPoint.x}, y: ${currentPoint.y}}.`,
              source_trace_id: sourceTrace?.source_trace_id || trace.source_trace_id || `!${trace.pcb_trace_id}`,
              error_type: "pcb_trace_error",
              pcb_trace_id: trace.pcb_trace_id,
              pcb_trace_error_id: "",
              pcb_component_ids: [],
              pcb_port_ids: []
            });
          }
        }
      }
    }
    const traceName = sourceTrace?.display_name || trace.source_trace_id || "unknown";
    for (const port of expectedPorts) {
      if (!port.pcb_port_id) continue;
      const pad = padMap.get(port.pcb_port_id);
      if (!pad) continue;
      const isFirstPointConnected = firstPoint.route_type === "wire" && isPointInPad({ x: firstPoint.x, y: firstPoint.y }, pad);
      const isLastPointConnected = lastPoint.route_type === "wire" && isPointInPad({ x: lastPoint.x, y: lastPoint.y }, pad);
      if (!isFirstPointConnected && !isLastPointConnected) {
        const portName = getReadableNameForPcbPort(
          circuitJson,
          port.pcb_port_id
        ).replace("pcb_port", "");
        const padType = pad.type.replace(/pcb_/, "");
        const errorCenter = {
          x: (firstPoint.x + lastPoint.x) / 2,
          y: (firstPoint.y + lastPoint.y) / 2
        };
        errors.push({
          type: "pcb_trace_error",
          message: `Trace [${traceName}] is missing a connection to ${padType}${portName}`,
          source_trace_id: sourceTrace?.source_trace_id || trace.source_trace_id || `!${trace.pcb_trace_id}`,
          error_type: "pcb_trace_error",
          pcb_trace_id: trace.pcb_trace_id,
          pcb_trace_error_id: "",
          center: errorCenter,
          pcb_component_ids: [],
          pcb_port_ids: [port.pcb_port_id]
        });
      }
    }
    if (expectedPorts.length === 0) {
      let firstConnectsToAnyPad = false;
      let lastConnectsToAnyPad = false;
      for (const [portId, pad] of padMap) {
        if (firstPoint.route_type === "wire" && isPointInPad({ x: firstPoint.x, y: firstPoint.y }, pad)) {
          firstConnectsToAnyPad = true;
        }
        if (lastPoint.route_type === "wire" && isPointInPad({ x: lastPoint.x, y: lastPoint.y }, pad)) {
          lastConnectsToAnyPad = true;
        }
      }
      if (!firstConnectsToAnyPad && firstPoint.route_type === "wire") {
        errors.push({
          type: "pcb_trace_error",
          message: `Trace [${traceName}] has disconnected endpoint at (${firstPoint.x}, ${firstPoint.y})`,
          source_trace_id: sourceTrace?.source_trace_id || trace.source_trace_id || `!${trace.pcb_trace_id}`,
          error_type: "pcb_trace_error",
          pcb_trace_id: trace.pcb_trace_id,
          pcb_trace_error_id: "",
          center: { x: firstPoint.x, y: firstPoint.y },
          pcb_component_ids: [],
          pcb_port_ids: []
        });
      }
      if (!lastConnectsToAnyPad && lastPoint.route_type === "wire") {
        errors.push({
          type: "pcb_trace_error",
          message: `Trace [${traceName}] has disconnected endpoint at (${lastPoint.x}, ${lastPoint.y})`,
          source_trace_id: sourceTrace?.source_trace_id || trace.source_trace_id || `!${trace.pcb_trace_id}`,
          error_type: "pcb_trace_error",
          pcb_trace_id: trace.pcb_trace_id,
          pcb_trace_error_id: "",
          center: { x: lastPoint.x, y: lastPoint.y },
          pcb_component_ids: [],
          pcb_port_ids: []
        });
      }
    }
  }
  return errors;
}

// lib/run-all-checks.ts
async function runAllChecks(circuitJson) {
  return [
    ...checkEachPcbPortConnectedToPcbTraces(circuitJson),
    ...checkEachPcbTraceNonOverlapping(circuitJson),
    ...checkSameNetViaSpacing(circuitJson),
    ...checkDifferentNetViaSpacing(circuitJson),
    ...checkViasOffBoard(circuitJson),
    ...checkPcbComponentsOutOfBoard(circuitJson),
    ...checkTracesAreContiguous(circuitJson),
    ...checkSourceTracesHavePcbTraces(circuitJson),
    ...checkPcbTracesOutOfBoard(circuitJson),
    ...checkPcbComponentOverlap(circuitJson)
  ];
}
export {
  NetManager,
  checkDifferentNetViaSpacing,
  checkEachPcbPortConnectedToPcbTraces,
  checkEachPcbTraceNonOverlapping,
  checkPcbComponentOverlap,
  checkPcbComponentsOutOfBoard,
  checkPcbTracesOutOfBoard,
  checkSameNetViaSpacing,
  checkSourceTracesHavePcbTraces,
  checkViasOffBoard,
  runAllChecks
};
//# sourceMappingURL=index.js.map