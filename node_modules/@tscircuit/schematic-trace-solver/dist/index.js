// lib/solvers/BaseSolver/BaseSolver.ts
var BaseSolver = class {
  MAX_ITERATIONS = 1e5;
  solved = false;
  failed = false;
  iterations = 0;
  progress = 0;
  error = null;
  activeSubSolver;
  failedSubSolvers;
  timeToSolve;
  stats = {};
  /** DO NOT OVERRIDE! Override _step() instead */
  step() {
    if (this.solved) return;
    if (this.failed) return;
    this.iterations++;
    try {
      this._step();
    } catch (e) {
      this.error = `${this.constructor.name} error: ${e}`;
      this.failed = true;
      throw e;
    }
    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {
      this.tryFinalAcceptance();
    }
    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {
      this.error = `${this.constructor.name} ran out of iterations`;
      this.failed = true;
    }
    if ("computeProgress" in this) {
      this.progress = this.computeProgress();
    }
  }
  _step() {
  }
  getConstructorParams() {
    throw new Error("getConstructorParams not implemented");
  }
  solve() {
    const startTime = Date.now();
    while (!this.solved && !this.failed) {
      this.step();
    }
    const endTime = Date.now();
    this.timeToSolve = endTime - startTime;
  }
  visualize() {
    return {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
  }
  /**
   * Called when the solver is about to fail, but we want to see if we have an
   * "acceptable" or "passable" solution. Mostly used for optimizers that
   * have an aggressive early stopping criterion.
   */
  tryFinalAcceptance() {
  }
  /**
   * A lightweight version of the visualize method that can be used to stream
   * progress
   */
  preview() {
    return {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
  }
};

// lib/solvers/MspConnectionPairSolver/MspConnectionPairSolver.ts
import "connectivity-map";

// lib/solvers/MspConnectionPairSolver/getConnectivityMapFromInputProblem.ts
import { ConnectivityMap } from "connectivity-map";
var getConnectivityMapsFromInputProblem = (inputProblem) => {
  const directConnMap = new ConnectivityMap({});
  for (const directConn of inputProblem.directConnections) {
    directConnMap.addConnections([
      directConn.netId ? [directConn.netId, ...directConn.pinIds] : directConn.pinIds
    ]);
  }
  const netConnMap = new ConnectivityMap(directConnMap.netMap);
  for (const netConn of inputProblem.netConnections) {
    netConnMap.addConnections([[netConn.netId, ...netConn.pinIds]]);
  }
  return { directConnMap, netConnMap };
};

// lib/solvers/MspConnectionPairSolver/getMspConnectionPairsFromPins.ts
function getOrthogonalMinimumSpanningTree(pins, opts = {}) {
  const n = pins.length;
  const maxDistance = opts?.maxDistance ?? Number.POSITIVE_INFINITY;
  if (n <= 1) return [];
  {
    const seen = /* @__PURE__ */ new Set();
    for (const p of pins) {
      if (seen.has(p.pinId)) {
        throw new Error(`Duplicate pinId detected: "${p.pinId}"`);
      }
      seen.add(p.pinId);
    }
  }
  const manhattan = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
  const inTree = new Array(n).fill(false);
  const bestDist = new Array(n).fill(Number.POSITIVE_INFINITY);
  const parent = new Array(n).fill(-1);
  let startIndex = 0;
  for (let i = 1; i < n; i++) {
    if (pins[i].pinId < pins[startIndex].pinId) startIndex = i;
  }
  bestDist[startIndex] = 0;
  const edges = [];
  for (let iter = 0; iter < n; iter++) {
    let u = -1;
    let best = Number.POSITIVE_INFINITY;
    let bestId = "";
    for (let i = 0; i < n; i++) {
      if (!inTree[i]) {
        const d = bestDist[i];
        if (d < best || d === best && (bestId === "" || pins[i].pinId < bestId)) {
          best = d;
          bestId = pins[i].pinId;
          u = i;
        }
      }
    }
    inTree[u] = true;
    if (parent[u] !== -1) {
      edges.push([pins[u].pinId, pins[parent[u]].pinId]);
    }
    for (let v = 0; v < n; v++) {
      if (!inTree[v]) {
        const d0 = manhattan(pins[u], pins[v]);
        const isForbidden = opts?.forbidEdge?.(pins[u], pins[v]) ?? false;
        const d = d0 > maxDistance || isForbidden ? Number.POSITIVE_INFINITY : d0;
        if (d < bestDist[v] || d === bestDist[v] && pins[u].pinId < pins[parent[v]]?.pinId) {
          bestDist[v] = d;
          parent[v] = u;
        }
      }
    }
  }
  return edges;
}

// lib/solvers/SchematicTraceLinesSolver/SchematicTraceSingleLineSolver/getPinDirection.ts
var getPinDirection = (pin, chip) => {
  const { x, y } = pin;
  const { center, width, height } = chip;
  const yPlusEdge = center.y + height / 2;
  const yMinusEdge = center.y - height / 2;
  const xPlusEdge = center.x + width / 2;
  const xMinusEdge = center.x - width / 2;
  const yPlusDistance = yPlusEdge - y;
  const yMinusDistance = y - yMinusEdge;
  const xPlusDistance = xPlusEdge - x;
  const xMinusDistance = x - xMinusEdge;
  const minDistance = Math.min(
    yPlusDistance,
    yMinusDistance,
    xPlusDistance,
    xMinusDistance
  );
  if (minDistance === yPlusDistance) {
    return "y+";
  }
  if (minDistance === yMinusDistance) {
    return "y-";
  }
  if (minDistance === xPlusDistance) {
    return "x+";
  }
  return "x-";
};

// lib/solvers/SchematicTraceLinesSolver/SchematicTraceSingleLineSolver/getRestrictedCenterLines.ts
var getRestrictedCenterLines = (params) => {
  const { pins, inputProblem, pinIdMap, chipMap } = params;
  const findAllDirectlyConnectedPins = (startPinId) => {
    const visited = /* @__PURE__ */ new Set();
    const queue = [startPinId];
    visited.add(startPinId);
    const directConns = inputProblem.directConnections || [];
    while (queue.length) {
      const cur = queue.shift();
      for (const dc of directConns) {
        if (dc.pinIds.includes(cur)) {
          for (const p of dc.pinIds) {
            if (!visited.has(p)) {
              visited.add(p);
              queue.push(p);
            }
          }
        }
      }
    }
    return visited;
  };
  const p0 = pins[0].pinId;
  const p1 = pins[1].pinId;
  const relatedPinIds = /* @__PURE__ */ new Set([
    ...findAllDirectlyConnectedPins(p0),
    ...findAllDirectlyConnectedPins(p1)
  ]);
  const restrictedCenterLines = /* @__PURE__ */ new Map();
  const chipFacingMap = /* @__PURE__ */ new Map();
  const chipsOfFacingPins = new Set(pins.map((p) => p.chipId));
  for (const pinId of relatedPinIds) {
    const pin = pinIdMap.get(pinId);
    if (!pin) continue;
    const chip = chipMap[pin.chipId];
    if (!chip) continue;
    const facing = pin._facingDirection ?? getPinDirection(pin, chip);
    let entry = chipFacingMap.get(chip.chipId);
    if (!entry) {
      entry = { center: chip.center };
      const counts = { xPos: 0, xNeg: 0, yPos: 0, yNeg: 0 };
      for (const cp of chip.pins) {
        const cpFacing = cp._facingDirection ?? getPinDirection(cp, chip);
        if (cpFacing === "x+") counts.xPos++;
        if (cpFacing === "x-") counts.xNeg++;
        if (cpFacing === "y+") counts.yPos++;
        if (cpFacing === "y-") counts.yNeg++;
      }
      entry.counts = counts;
      chipFacingMap.set(chip.chipId, entry);
    }
    if (facing === "x+") entry.hasXPos = true;
    if (facing === "x-") entry.hasXNeg = true;
    if (facing === "y+") entry.hasYPos = true;
    if (facing === "y-") entry.hasYNeg = true;
  }
  for (const [chipId, faces] of chipFacingMap) {
    const axes = /* @__PURE__ */ new Set();
    const rcl = { axes };
    const counts = faces.counts;
    const anySideHasMultiplePins = !!(counts && (counts.xPos > 1 || counts.xNeg > 1 || counts.yPos > 1 || counts.yNeg > 1));
    const skipCenterRestriction = !anySideHasMultiplePins && chipsOfFacingPins.has(chipId);
    if (!skipCenterRestriction) {
      if (faces.hasXPos && faces.hasXNeg) {
        rcl.x = faces.center.x;
        axes.add("x");
      }
      if (faces.hasYPos && faces.hasYNeg) {
        rcl.y = faces.center.y;
        axes.add("y");
      }
    }
    if (axes.size > 0) {
      restrictedCenterLines.set(chipId, rcl);
    }
  }
  return restrictedCenterLines;
};

// lib/solvers/MspConnectionPairSolver/doesPairCrossRestrictedCenterLines.ts
var doesPairCrossRestrictedCenterLines = (params) => {
  const { inputProblem, chipMap, pinIdMap, p1, p2 } = params;
  const restrictedCenterLines = getRestrictedCenterLines({
    pins: [p1, p2],
    inputProblem,
    pinIdMap,
    chipMap
  });
  if (restrictedCenterLines.size === 0) return false;
  const EPS5 = 1e-9;
  const crossesSegment = (a, b) => {
    for (const [, rcl] of restrictedCenterLines) {
      if (rcl.axes.has("x") && typeof rcl.x === "number") {
        if ((a.x - rcl.x) * (b.x - rcl.x) < -EPS5) return true;
      }
      if (rcl.axes.has("y") && typeof rcl.y === "number") {
        if ((a.y - rcl.y) * (b.y - rcl.y) < -EPS5) return true;
      }
    }
    return false;
  };
  if (Math.abs(p1.x - p2.x) < EPS5 || Math.abs(p1.y - p2.y) < EPS5) {
    return crossesSegment({ x: p1.x, y: p1.y }, { x: p2.x, y: p2.y });
  }
  const elbowHV = { x: p2.x, y: p1.y };
  const elbowVH = { x: p1.x, y: p2.y };
  const hvCrosses = crossesSegment({ x: p1.x, y: p1.y }, elbowHV) || crossesSegment(elbowHV, { x: p2.x, y: p2.y });
  const vhCrosses = crossesSegment({ x: p1.x, y: p1.y }, elbowVH) || crossesSegment(elbowVH, { x: p2.x, y: p2.y });
  return hvCrosses && vhCrosses;
};

// lib/utils/getColorFromString.ts
var getColorFromString = (string, alpha = 1) => {
  const hash = string.split("").reduce((acc, char) => {
    return acc * 31 + char.charCodeAt(0);
  }, 0);
  return `hsl(${hash % 360}, 100%, 50%, ${alpha})`;
};

// lib/solvers/SchematicTracePipelineSolver/visualizeInputProblem.ts
var visualizeInputProblem = (inputProblem, opts = {}) => {
  const { connectionAlpha = 0.8, chipAlpha = 0.8 } = opts;
  const graphics = {
    lines: [],
    points: [],
    rects: []
  };
  const pinIdMap = /* @__PURE__ */ new Map();
  for (const chip of inputProblem.chips) {
    for (const pin of chip.pins) {
      pinIdMap.set(pin.pinId, pin);
    }
  }
  for (const chip of inputProblem.chips) {
    graphics.rects.push({
      label: chip.chipId,
      center: chip.center,
      width: chip.width,
      height: chip.height,
      fill: getColorFromString(chip.chipId, chipAlpha)
    });
    for (const pin of chip.pins) {
      graphics.points.push({
        label: `${pin.pinId}
${pin._facingDirection ?? getPinDirection(pin, chip)}`,
        x: pin.x,
        y: pin.y,
        color: getColorFromString(pin.pinId, 0.8)
      });
    }
  }
  for (const directConn of inputProblem.directConnections) {
    const [pinId1, pinId2] = directConn.pinIds;
    const pin1 = pinIdMap.get(pinId1);
    const pin2 = pinIdMap.get(pinId2);
    graphics.lines.push({
      points: [
        {
          x: pin1.x,
          y: pin1.y
        },
        {
          x: pin2.x,
          y: pin2.y
        }
      ],
      strokeColor: getColorFromString(
        directConn.netId ?? `${pinId1}-${pinId2}`,
        connectionAlpha
      )
    });
  }
  for (const netConn of inputProblem.netConnections) {
    const pins = netConn.pinIds.map((pinId) => pinIdMap.get(pinId));
    for (let i = 0; i < pins.length - 1; i++) {
      for (let j = i + 1; j < pins.length; j++) {
        const pin1 = pins[i];
        const pin2 = pins[j];
        graphics.lines.push({
          points: [
            { x: pin1.x, y: pin1.y },
            { x: pin2.x, y: pin2.y }
          ],
          strokeColor: getColorFromString(netConn.netId, connectionAlpha),
          strokeDash: "4 2"
        });
      }
    }
  }
  return graphics;
};

// lib/solvers/MspConnectionPairSolver/MspConnectionPairSolver.ts
var MspConnectionPairSolver = class extends BaseSolver {
  inputProblem;
  mspConnectionPairs = [];
  dcConnMap;
  globalConnMap;
  queuedDcNetIds;
  chipMap;
  maxMspPairDistance;
  pinMap;
  userNetIdByPinId;
  constructor({ inputProblem }) {
    super();
    this.inputProblem = inputProblem;
    this.maxMspPairDistance = inputProblem.maxMspPairDistance ?? 1;
    const { directConnMap, netConnMap } = getConnectivityMapsFromInputProblem(inputProblem);
    this.dcConnMap = directConnMap;
    this.globalConnMap = netConnMap;
    this.pinMap = {};
    for (const chip of inputProblem.chips) {
      for (const pin of chip.pins) {
        this.pinMap[pin.pinId] = { ...pin, chipId: chip.chipId };
      }
    }
    this.chipMap = {};
    for (const chip of inputProblem.chips) {
      this.chipMap[chip.chipId] = chip;
    }
    this.userNetIdByPinId = {};
    for (const dc of inputProblem.directConnections) {
      if (dc.netId) {
        const [a, b] = dc.pinIds;
        this.userNetIdByPinId[a] = dc.netId;
        this.userNetIdByPinId[b] = dc.netId;
      }
    }
    for (const nc of inputProblem.netConnections) {
      for (const pid of nc.pinIds) {
        this.userNetIdByPinId[pid] = nc.netId;
      }
    }
    this.queuedDcNetIds = Object.keys(netConnMap.netMap);
  }
  getConstructorParams() {
    return {
      inputProblem: this.inputProblem
    };
  }
  _step() {
    if (this.queuedDcNetIds.length === 0) {
      this.solved = true;
      return;
    }
    const dcNetId = this.queuedDcNetIds.shift();
    const allIds = this.globalConnMap.getIdsConnectedToNet(dcNetId);
    const directlyConnectedPins = allIds.filter((id) => !!this.pinMap[id]);
    if (directlyConnectedPins.length <= 1) {
      return;
    }
    if (directlyConnectedPins.length === 2) {
      const [pin1, pin2] = directlyConnectedPins;
      const p1 = this.pinMap[pin1];
      const p2 = this.pinMap[pin2];
      const manhattanDist = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
      if (manhattanDist > this.maxMspPairDistance) {
        return;
      }
      const pinIdMap2 = new Map(Object.entries(this.pinMap));
      if (doesPairCrossRestrictedCenterLines({
        inputProblem: this.inputProblem,
        chipMap: this.chipMap,
        pinIdMap: pinIdMap2,
        p1,
        p2
      })) {
        return;
      }
      const globalConnNetId = this.globalConnMap.getNetConnectedToId(pin1);
      const userNetId = this.userNetIdByPinId[pin1] ?? this.userNetIdByPinId[pin2];
      this.mspConnectionPairs.push({
        mspPairId: `${pin1}-${pin2}`,
        dcConnNetId: dcNetId,
        globalConnNetId,
        userNetId,
        pins: [p1, p2]
      });
      return;
    }
    const pinIdMap = new Map(Object.entries(this.pinMap));
    const msp = getOrthogonalMinimumSpanningTree(
      directlyConnectedPins.map((p) => this.pinMap[p]).filter(Boolean),
      {
        maxDistance: this.maxMspPairDistance,
        forbidEdge: (a, b) => doesPairCrossRestrictedCenterLines({
          inputProblem: this.inputProblem,
          chipMap: this.chipMap,
          pinIdMap,
          p1: a,
          p2: b
        })
      }
    );
    for (const [pin1, pin2] of msp) {
      const p1Obj = this.pinMap[pin1];
      const p2Obj = this.pinMap[pin2];
      if (doesPairCrossRestrictedCenterLines({
        inputProblem: this.inputProblem,
        chipMap: this.chipMap,
        pinIdMap,
        p1: p1Obj,
        p2: p2Obj
      })) {
        continue;
      }
      const globalConnNetId = this.globalConnMap.getNetConnectedToId(pin1);
      const userNetId = this.userNetIdByPinId[pin1] ?? this.userNetIdByPinId[pin2];
      this.mspConnectionPairs.push({
        mspPairId: `${pin1}-${pin2}`,
        dcConnNetId: dcNetId,
        globalConnNetId,
        userNetId,
        pins: [p1Obj, p2Obj]
      });
    }
  }
  visualize() {
    const graphics = visualizeInputProblem(this.inputProblem, {
      chipAlpha: 0.1,
      connectionAlpha: 0.1
    });
    for (const pair of this.mspConnectionPairs) {
      graphics.lines.push({
        points: [
          {
            x: pair.pins[0].x,
            y: pair.pins[0].y
          },
          {
            x: pair.pins[1].x,
            y: pair.pins[1].y
          }
        ],
        strokeColor: getColorFromString(pair.mspPairId, 0.75)
      });
    }
    return graphics;
  }
};

// lib/solvers/SchematicTraceLinesSolver/SchematicTraceLinesSolver.ts
import "graphics-debug";

// lib/solvers/SchematicTraceLinesSolver/SchematicTraceSingleLineSolver2/SchematicTraceSingleLineSolver2.ts
import { calculateElbow } from "calculate-elbow";

// lib/solvers/GuidelinesSolver/getInputChipBounds.ts
function getInputChipBounds(chip) {
  const halfWidth = chip.width / 2;
  const halfHeight = chip.height / 2;
  return {
    minX: chip.center.x - halfWidth,
    maxX: chip.center.x + halfWidth,
    minY: chip.center.y - halfHeight,
    maxY: chip.center.y + halfHeight
  };
}

// lib/solvers/SchematicTraceLinesSolver/SchematicTraceSingleLineSolver2/rect.ts
var chipToRect = (chip) => {
  const b = getInputChipBounds(chip);
  return { chipId: chip.chipId, ...b };
};
var getObstacleRects = (problem) => {
  return problem.chips.map(chipToRect);
};

// lib/solvers/SchematicTraceLinesSolver/SchematicTraceSingleLineSolver2/collisions.ts
var EPS = 1e-9;
var isVertical = (a, b, eps = EPS) => Math.abs(a.x - b.x) < eps;
var isHorizontal = (a, b, eps = EPS) => Math.abs(a.y - b.y) < eps;
var segmentIntersectsRect = (a, b, r, eps = EPS) => {
  const vert = isVertical(a, b, eps);
  const horz = isHorizontal(a, b, eps);
  if (!vert && !horz) return false;
  if (vert) {
    const x = a.x;
    if (x < r.minX - eps || x > r.maxX + eps) return false;
    const segMinY = Math.min(a.y, b.y);
    const segMaxY = Math.max(a.y, b.y);
    const overlap = Math.min(segMaxY, r.maxY) - Math.max(segMinY, r.minY);
    return overlap > eps;
  } else {
    const y = a.y;
    if (y < r.minY - eps || y > r.maxY + eps) return false;
    const segMinX = Math.min(a.x, b.x);
    const segMaxX = Math.max(a.x, b.x);
    const overlap = Math.min(segMaxX, r.maxX) - Math.max(segMinX, r.minX);
    return overlap > eps;
  }
};
var findFirstCollision = (pts, rects, opts = {}) => {
  for (let i = 0; i < pts.length - 1; i++) {
    const a = pts[i];
    const b = pts[i + 1];
    const excluded = opts.excludeRectIdsForSegment?.(i) ?? /* @__PURE__ */ new Set();
    for (const r of rects) {
      if (excluded.has(r.chipId)) continue;
      if (segmentIntersectsRect(a, b, r)) {
        return { segIndex: i, rect: r };
      }
    }
  }
  return null;
};
var isPathCollidingWithObstacles = (path, obstacles) => {
  for (let i = 0; i < path.length - 1; i++) {
    for (const obstacle of obstacles) {
      if (segmentIntersectsRect(path[i], path[i + 1], obstacle)) {
        return true;
      }
    }
  }
  return false;
};

// lib/solvers/SchematicTraceLinesSolver/SchematicTraceSingleLineSolver2/mid.ts
var EPS2 = 1e-9;
var aabbFromPoints = (a, b) => ({
  minX: Math.min(a.x, b.x),
  maxX: Math.max(a.x, b.x),
  minY: Math.min(a.y, b.y),
  maxY: Math.max(a.y, b.y)
});
var midBetweenPointAndRect = (axis, p, r, eps = EPS2) => {
  if (axis === "x") {
    if (p.x < r.minX - eps) {
      return [(p.x + r.minX) / 2];
    }
    if (p.x > r.maxX + eps) {
      return [(p.x + r.maxX) / 2];
    }
    return [r.minX - 0.2, r.maxX + 0.2];
  } else {
    if (p.y < r.minY - eps) {
      return [(p.y + r.minY) / 2];
    }
    if (p.y > r.maxY + eps) {
      return [(p.y + r.maxY) / 2];
    }
    return [r.minY - 0.2, r.maxY + 0.2];
  }
};
var candidateMidsFromSet = (axis, colliding, rectsById, collisionRectIds, aabb, eps = EPS2) => {
  const setRects = [...collisionRectIds].map((id) => rectsById.get(id)).filter((r) => !!r);
  if (axis === "x") {
    const leftBoundaries = [aabb.minX, ...setRects.map((r) => r.maxX)].filter(
      (v) => v < colliding.minX - eps
    );
    const rightBoundaries = [aabb.maxX, ...setRects.map((r) => r.minX)].filter(
      (v) => v > colliding.maxX + eps
    );
    const leftNeighbor = leftBoundaries.length > 0 ? Math.max(...leftBoundaries) : void 0;
    const rightNeighbor = rightBoundaries.length > 0 ? Math.min(...rightBoundaries) : void 0;
    const out = [];
    if (leftNeighbor !== void 0) {
      out.push((leftNeighbor + colliding.minX) / 2);
    }
    if (rightNeighbor !== void 0) {
      out.push((colliding.maxX + rightNeighbor) / 2);
    }
    return out;
  } else {
    const bottomBoundaries = [aabb.minY, ...setRects.map((r) => r.maxY)].filter(
      (v) => v < colliding.minY - eps
    );
    const topBoundaries = [aabb.maxY, ...setRects.map((r) => r.minY)].filter(
      (v) => v > colliding.maxY + eps
    );
    const bottomNeighbor = bottomBoundaries.length > 0 ? Math.max(...bottomBoundaries) : void 0;
    const topNeighbor = topBoundaries.length > 0 ? Math.min(...topBoundaries) : void 0;
    const out = [];
    if (bottomNeighbor !== void 0) {
      out.push((bottomNeighbor + colliding.minY) / 2);
    }
    if (topNeighbor !== void 0) {
      out.push((colliding.maxY + topNeighbor) / 2);
    }
    return out;
  }
};

// lib/solvers/SchematicTraceLinesSolver/SchematicTraceSingleLineSolver2/pathOps.ts
var EPS3 = 1e-9;
var shiftSegmentOrth = (pts, segIndex, axis, newCoord, eps = EPS3) => {
  if (segIndex < 0 || segIndex >= pts.length - 1) {
    return null;
  }
  const a = pts[segIndex];
  const b = pts[segIndex + 1];
  const vert = isVertical(a, b, eps);
  const horz = isHorizontal(a, b, eps);
  if (!vert && !horz) {
    return null;
  }
  if (vert && axis !== "x") {
    return null;
  }
  if (horz && axis !== "y") {
    return null;
  }
  const out = pts.map((p) => ({ ...p }));
  if (axis === "x") {
    if (Math.abs(a.x - newCoord) < eps && Math.abs(b.x - newCoord) < eps) {
      return null;
    }
    out[segIndex] = { ...out[segIndex], x: newCoord };
    out[segIndex + 1] = { ...out[segIndex + 1], x: newCoord };
  } else {
    if (Math.abs(a.y - newCoord) < eps && Math.abs(b.y - newCoord) < eps) {
      return null;
    }
    out[segIndex] = { ...out[segIndex], y: newCoord };
    out[segIndex + 1] = { ...out[segIndex + 1], y: newCoord };
  }
  if (segIndex - 1 >= 0) {
    const p = out[segIndex - 1];
    const q = out[segIndex];
    const manhattan = Math.abs(p.x - q.x) + Math.abs(p.y - q.y);
    if (manhattan < eps) {
      return null;
    }
  }
  if (segIndex + 2 <= out.length - 1) {
    const p = out[segIndex + 1];
    const q = out[segIndex + 2];
    const manhattan = Math.abs(p.x - q.x) + Math.abs(p.y - q.y);
    if (manhattan < eps) {
      return null;
    }
  }
  for (let i = 0; i < out.length - 1; i++) {
    const u = out[i];
    const v = out[i + 1];
    if (!isHorizontal(u, v, eps) && !isVertical(u, v, eps)) {
      return null;
    }
  }
  return out;
};
var pathKey = (pts, decimals = 6) => {
  const key = pts.map((p) => `${p.x.toFixed(decimals)},${p.y.toFixed(decimals)}`).join("|");
  return key;
};

// lib/solvers/SchematicTraceLinesSolver/SchematicTraceSingleLineSolver2/SchematicTraceSingleLineSolver2.ts
var SchematicTraceSingleLineSolver2 = class extends BaseSolver {
  pins;
  inputProblem;
  chipMap;
  obstacles;
  rectById;
  aabb;
  baseElbow;
  solvedTracePath = null;
  queue = [];
  visited = /* @__PURE__ */ new Set();
  constructor(params) {
    super();
    this.pins = params.pins;
    this.inputProblem = params.inputProblem;
    this.chipMap = params.chipMap;
    for (const pin of this.pins) {
      if (!pin._facingDirection) {
        const chip = this.chipMap[pin.chipId];
        pin._facingDirection = getPinDirection(pin, chip);
      }
    }
    this.obstacles = getObstacleRects(this.inputProblem);
    this.rectById = new Map(this.obstacles.map((r) => [r.chipId, r]));
    const [pin1, pin2] = this.pins;
    this.baseElbow = calculateElbow(
      {
        x: pin1.x,
        y: pin1.y,
        facingDirection: pin1._facingDirection
      },
      {
        x: pin2.x,
        y: pin2.y,
        facingDirection: pin2._facingDirection
      },
      { overshoot: 0.2 }
    );
    this.aabb = aabbFromPoints(
      { x: pin1.x, y: pin1.y },
      { x: pin2.x, y: pin2.y }
    );
    this.queue.push({ path: this.baseElbow, collisionChipIds: /* @__PURE__ */ new Set() });
    this.visited.add(pathKey(this.baseElbow));
  }
  getConstructorParams() {
    return {
      chipMap: this.chipMap,
      pins: this.pins,
      inputProblem: this.inputProblem
    };
  }
  axisOfSegment(a, b) {
    if (isVertical(a, b)) return "x";
    if (isHorizontal(a, b)) return "y";
    return null;
  }
  pathLength(pts) {
    let sum = 0;
    for (let i = 0; i < pts.length - 1; i++) {
      sum += Math.abs(pts[i + 1].x - pts[i].x) + Math.abs(pts[i + 1].y - pts[i].y);
    }
    return sum;
  }
  _step() {
    if (this.solvedTracePath) {
      this.solved = true;
      return;
    }
    const state = this.queue.shift();
    if (!state) {
      this.failed = true;
      this.error = "No collision-free path found";
      return;
    }
    const { path, collisionChipIds } = state;
    const [PA, PB] = this.pins;
    const collision = findFirstCollision(path, this.obstacles);
    if (!collision) {
      const first = path[0];
      const last = path[path.length - 1];
      const EPS5 = 1e-9;
      const samePoint = (p, q) => Math.abs(p.x - q.x) < EPS5 && Math.abs(p.y - q.y) < EPS5;
      if (samePoint(first, { x: PA.x, y: PA.y }) && samePoint(last, { x: PB.x, y: PB.y })) {
        this.solvedTracePath = path;
        this.solved = true;
      }
      return;
    }
    let { segIndex, rect } = collision;
    const isFirstSegment = segIndex === 0;
    const isLastSegment = segIndex === path.length - 2;
    if (isFirstSegment) {
      if (path.length < 3) {
        return;
      }
      segIndex = 1;
    } else if (isLastSegment) {
      if (path.length < 3) {
        return;
      }
      segIndex = path.length - 3;
    }
    const a = path[segIndex];
    const b = path[segIndex + 1];
    const axis = this.axisOfSegment(a, b);
    if (!axis) {
      return;
    }
    const candidates = [];
    if (collisionChipIds.size === 0) {
      const m1 = midBetweenPointAndRect(axis, { x: PA.x, y: PA.y }, rect);
      const m2 = midBetweenPointAndRect(axis, { x: PB.x, y: PB.y }, rect);
      const allCandidates = [...m1, ...m2];
      const uniqueCandidates = [...new Set(allCandidates)];
      candidates.push(...uniqueCandidates);
    } else {
      const mids = candidateMidsFromSet(
        axis,
        rect,
        this.rectById,
        collisionChipIds,
        this.aabb
      );
      candidates.push(...mids);
    }
    const newStates = [];
    for (const coord of candidates) {
      const newPath = shiftSegmentOrth(path, segIndex, axis, coord);
      if (!newPath) continue;
      const key = pathKey(newPath);
      if (this.visited.has(key)) continue;
      this.visited.add(key);
      const nextSet = new Set(collisionChipIds);
      nextSet.add(rect.chipId);
      const len = this.pathLength(newPath);
      newStates.push({ path: newPath, collisionRectIds: nextSet, len });
    }
    newStates.sort((a2, b2) => a2.len - b2.len);
    for (const st of newStates) {
      this.queue.push({ path: st.path, collisionChipIds: st.collisionRectIds });
    }
  }
  visualize() {
    const g = visualizeInputProblem(this.inputProblem, {
      chipAlpha: 0.1,
      connectionAlpha: 0.1
    });
    g.lines.push({
      points: this.baseElbow,
      strokeColor: "red",
      strokeDash: "4 4"
    });
    const [pin1, pin2] = this.pins;
    g.lines.push({
      points: [
        { x: pin1.x, y: pin1.y },
        { x: pin2.x, y: pin2.y }
      ],
      strokeColor: "blue",
      strokeDash: "5 5"
    });
    for (const { path, collisionChipIds: collisionRectIds } of this.queue) {
      g.lines.push({ points: path, strokeColor: "teal", strokeDash: "2 2" });
    }
    if (this.solvedTracePath) {
      g.lines.push({ points: this.solvedTracePath, strokeColor: "green" });
    } else if (this.queue.length > 0) {
      g.lines.push({ points: this.queue[0].path, strokeColor: "orange" });
    }
    return g;
  }
};

// lib/solvers/GuidelinesSolver/visualizeGuidelines.ts
import { getBounds } from "graphics-debug";

// lib/solvers/SchematicTraceLinesSolver/SchematicTraceLinesSolver.ts
var SchematicTraceLinesSolver = class extends BaseSolver {
  inputProblem;
  mspConnectionPairs;
  dcConnMap;
  globalConnMap;
  queuedConnectionPairs;
  chipMap;
  currentConnectionPair = null;
  solvedTracePaths = [];
  failedConnectionPairs = [];
  constructor(params) {
    super();
    this.inputProblem = params.inputProblem;
    this.mspConnectionPairs = params.mspConnectionPairs;
    this.dcConnMap = params.dcConnMap;
    this.globalConnMap = params.globalConnMap;
    this.chipMap = params.chipMap;
    this.queuedConnectionPairs = [...this.mspConnectionPairs];
  }
  getConstructorParams() {
    return {
      inputProblem: this.inputProblem,
      chipMap: this.chipMap,
      mspConnectionPairs: this.mspConnectionPairs,
      dcConnMap: this.dcConnMap,
      globalConnMap: this.globalConnMap
    };
  }
  _step() {
    if (this.activeSubSolver?.solved) {
      this.solvedTracePaths.push({
        ...this.currentConnectionPair,
        tracePath: this.activeSubSolver.solvedTracePath,
        mspConnectionPairIds: [this.currentConnectionPair.mspPairId],
        pinIds: [
          this.currentConnectionPair.pins[0].pinId,
          this.currentConnectionPair.pins[1].pinId
        ]
      });
      this.activeSubSolver = null;
      this.currentConnectionPair = null;
    }
    if (this.activeSubSolver?.failed) {
      if (this.currentConnectionPair) {
        this.failedConnectionPairs.push({
          ...this.currentConnectionPair,
          error: this.activeSubSolver.error || void 0
        });
      }
      this.activeSubSolver = null;
      this.currentConnectionPair = null;
    }
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      return;
    }
    const connectionPair = this.queuedConnectionPairs.shift();
    if (!connectionPair) {
      this.solved = true;
      return;
    }
    this.currentConnectionPair = connectionPair;
    const { pins } = connectionPair;
    this.activeSubSolver = new SchematicTraceSingleLineSolver2({
      inputProblem: this.inputProblem,
      pins,
      chipMap: this.chipMap
    });
  }
  visualize() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.visualize();
    }
    const graphics = visualizeInputProblem(this.inputProblem, {
      chipAlpha: 0.1,
      connectionAlpha: 0.1
    });
    for (const { mspPairId, tracePath } of this.solvedTracePaths) {
      graphics.lines.push({
        points: tracePath,
        strokeColor: "green"
      });
    }
    for (const pair of this.failedConnectionPairs) {
      graphics.lines.push({
        points: [
          { x: pair.pins[0].x, y: pair.pins[0].y },
          { x: pair.pins[1].x, y: pair.pins[1].y }
        ],
        strokeColor: "red",
        strokeDash: "4 2"
      });
    }
    return graphics;
  }
};

// lib/solvers/TraceOverlapShiftSolver/TraceOverlapIssueSolver/applyJogToTrace.ts
var applyJogToTerminalSegment = ({
  pts,
  segmentIndex: si,
  offset,
  JOG_SIZE,
  EPS: EPS5 = 1e-6
}) => {
  if (si !== 0 && si !== pts.length - 2) return;
  const start = pts[si];
  const end = pts[si + 1];
  const isVertical3 = Math.abs(start.x - end.x) < EPS5;
  const isHorizontal2 = Math.abs(start.y - end.y) < EPS5;
  if (!isVertical3 && !isHorizontal2) return;
  const segDir = isVertical3 ? end.y > start.y ? 1 : -1 : end.x > start.x ? 1 : -1;
  if (si === 0) {
    if (isVertical3) {
      const jogY = start.y + segDir * JOG_SIZE;
      pts.splice(
        1,
        1,
        { x: start.x, y: jogY },
        { x: start.x + offset, y: jogY },
        { x: end.x + offset, y: end.y }
      );
    } else {
      const jogX = start.x + segDir * JOG_SIZE;
      pts.splice(
        1,
        1,
        { x: jogX, y: start.y },
        { x: jogX, y: start.y + offset },
        { x: end.x, y: end.y + offset }
      );
    }
  } else {
    if (isVertical3) {
      const jogY = end.y - segDir * JOG_SIZE;
      pts.splice(
        si,
        1,
        { x: start.x + offset, y: start.y },
        { x: end.x + offset, y: jogY },
        { x: end.x, y: jogY }
      );
    } else {
      const jogX = end.x - segDir * JOG_SIZE;
      pts.splice(
        si,
        1,
        { x: start.x, y: start.y + offset },
        { x: jogX, y: end.y + offset },
        { x: jogX, y: end.y }
      );
    }
  }
};

// lib/solvers/TraceOverlapShiftSolver/TraceOverlapIssueSolver/TraceOverlapIssueSolver.ts
var TraceOverlapIssueSolver = class extends BaseSolver {
  overlappingTraceSegments;
  traceNetIslands;
  SHIFT_DISTANCE = 0.1;
  correctedTraceMap = {};
  constructor(params) {
    super();
    this.overlappingTraceSegments = params.overlappingTraceSegments;
    this.traceNetIslands = params.traceNetIslands;
    for (const { connNetId, pathsWithOverlap } of this.overlappingTraceSegments) {
      for (const {
        solvedTracePathIndex,
        traceSegmentIndex
      } of pathsWithOverlap) {
        const mspPairId = this.traceNetIslands[connNetId][solvedTracePathIndex].mspPairId;
        this.correctedTraceMap[mspPairId] = this.traceNetIslands[connNetId][solvedTracePathIndex];
      }
    }
  }
  _step() {
    const EPS5 = 1e-6;
    const offsets = this.overlappingTraceSegments.map((_, idx) => {
      const n = Math.floor(idx / 2) + 1;
      const signed = idx % 2 === 0 ? -n : n;
      return signed * this.SHIFT_DISTANCE;
    });
    const eq = (a, b) => Math.abs(a - b) < EPS5;
    const samePoint = (p, q) => !!p && !!q && eq(p.x, q.x) && eq(p.y, q.y);
    this.overlappingTraceSegments.forEach((group, gidx) => {
      const offset = offsets[gidx];
      const byPath = /* @__PURE__ */ new Map();
      for (const loc of group.pathsWithOverlap) {
        if (!byPath.has(loc.solvedTracePathIndex)) {
          byPath.set(loc.solvedTracePathIndex, /* @__PURE__ */ new Set());
        }
        byPath.get(loc.solvedTracePathIndex).add(loc.traceSegmentIndex);
      }
      for (const [pathIdx, segIdxSet] of byPath) {
        const original = this.traceNetIslands[group.connNetId][pathIdx];
        const current = this.correctedTraceMap[original.mspPairId] ?? original;
        const pts = current.tracePath.map((p) => ({ ...p }));
        const segIdxs = Array.from(segIdxSet).sort((a, b) => a - b);
        const segIdxsRev = Array.from(segIdxSet).sort((a, b) => a - b).reverse();
        const JOG_SIZE = this.SHIFT_DISTANCE;
        for (const si of segIdxsRev) {
          if (si < 0 || si >= pts.length - 1) continue;
          if (si === 0 || si === pts.length - 2) {
            applyJogToTerminalSegment({
              pts,
              segmentIndex: si,
              offset,
              JOG_SIZE,
              EPS: EPS5
            });
          } else {
            const start = pts[si];
            const end = pts[si + 1];
            const isVertical3 = Math.abs(start.x - end.x) < EPS5;
            const isHorizontal2 = Math.abs(start.y - end.y) < EPS5;
            if (!isVertical3 && !isHorizontal2) continue;
            if (isVertical3) {
              start.x += offset;
              end.x += offset;
            } else {
              start.y += offset;
              end.y += offset;
            }
          }
        }
        const cleaned = [];
        for (const p of pts) {
          if (cleaned.length === 0 || !samePoint(cleaned[cleaned.length - 1], p)) {
            cleaned.push(p);
          }
        }
        this.correctedTraceMap[original.mspPairId] = {
          ...current,
          tracePath: cleaned
        };
      }
    });
    this.solved = true;
  }
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    for (const group of this.overlappingTraceSegments) {
      for (const {
        solvedTracePathIndex,
        traceSegmentIndex
      } of group.pathsWithOverlap) {
        const path = this.traceNetIslands[group.connNetId][solvedTracePathIndex];
        const segStart = path.tracePath[traceSegmentIndex];
        const segEnd = path.tracePath[traceSegmentIndex + 1];
        graphics.lines.push({
          points: [segStart, segEnd],
          strokeColor: "red"
        });
      }
    }
    for (const trace of Object.values(this.correctedTraceMap)) {
      graphics.lines.push({
        points: trace.tracePath,
        strokeColor: "blue",
        strokeDash: "4 2"
      });
    }
    return graphics;
  }
};

// lib/solvers/TraceOverlapShiftSolver/TraceOverlapShiftSolver.ts
var TraceOverlapShiftSolver = class extends BaseSolver {
  inputProblem;
  inputTracePaths;
  globalConnMap;
  /**
   * A traceNetIsland is a set of traces that are connected via the globalConnMap
   */
  traceNetIslands = {};
  correctedTraceMap = {};
  cleanupPhase = null;
  constructor(params) {
    super();
    this.inputProblem = params.inputProblem;
    this.inputTracePaths = params.inputTracePaths;
    this.globalConnMap = params.globalConnMap;
    for (const tracePath of this.inputTracePaths) {
      const { mspPairId } = tracePath;
      this.correctedTraceMap[mspPairId] = tracePath;
    }
    this.traceNetIslands = this.computeTraceNetIslands();
  }
  getConstructorParams() {
    return {
      inputProblem: this.inputProblem,
      inputTracePaths: this.inputTracePaths,
      globalConnMap: this.globalConnMap
    };
  }
  computeTraceNetIslands() {
    const islands = {};
    for (const original of this.inputTracePaths) {
      const path = this.correctedTraceMap[original.mspPairId] ?? original;
      const key = path.globalConnNetId;
      if (!islands[key]) islands[key] = [];
      islands[key].push(path);
    }
    return islands;
  }
  findNextOverlapIssue() {
    const EPS5 = 2e-3;
    const netIds = Object.keys(this.traceNetIslands);
    for (let i = 0; i < netIds.length; i++) {
      for (let j = i + 1; j < netIds.length; j++) {
        const netA = netIds[i];
        const netB = netIds[j];
        const pathsA = this.traceNetIslands[netA] || [];
        const pathsB = this.traceNetIslands[netB] || [];
        const overlapsA = [];
        const overlapsB = [];
        const seenA = /* @__PURE__ */ new Set();
        const seenB = /* @__PURE__ */ new Set();
        const overlaps1D = (a1, a2, b1, b2) => {
          const minA = Math.min(a1, a2);
          const maxA = Math.max(a1, a2);
          const minB = Math.min(b1, b2);
          const maxB = Math.max(b1, b2);
          const overlap = Math.min(maxA, maxB) - Math.max(minA, minB);
          return overlap > EPS5;
        };
        for (let pa = 0; pa < pathsA.length; pa++) {
          const pathA = pathsA[pa];
          const ptsA = pathA.tracePath;
          for (let sa = 0; sa < ptsA.length - 1; sa++) {
            const a1 = ptsA[sa];
            const a2 = ptsA[sa + 1];
            const aVert = Math.abs(a1.x - a2.x) < EPS5;
            const aHorz = Math.abs(a1.y - a2.y) < EPS5;
            if (!aVert && !aHorz) continue;
            for (let pb = 0; pb < pathsB.length; pb++) {
              const pathB = pathsB[pb];
              const ptsB = pathB.tracePath;
              for (let sb = 0; sb < ptsB.length - 1; sb++) {
                const b1 = ptsB[sb];
                const b2 = ptsB[sb + 1];
                const bVert = Math.abs(b1.x - b2.x) < EPS5;
                const bHorz = Math.abs(b1.y - b2.y) < EPS5;
                if (!bVert && !bHorz) continue;
                if (aVert && bVert) {
                  if (Math.abs(a1.x - b1.x) < EPS5) {
                    if (overlaps1D(a1.y, a2.y, b1.y, b2.y)) {
                      const keyA = `${pa}:${sa}`;
                      const keyB = `${pb}:${sb}`;
                      if (!seenA.has(keyA)) {
                        overlapsA.push({
                          solvedTracePathIndex: pa,
                          traceSegmentIndex: sa
                        });
                        seenA.add(keyA);
                      }
                      if (!seenB.has(keyB)) {
                        overlapsB.push({
                          solvedTracePathIndex: pb,
                          traceSegmentIndex: sb
                        });
                        seenB.add(keyB);
                      }
                    }
                  }
                } else if (aHorz && bHorz) {
                  if (Math.abs(a1.y - b1.y) < EPS5) {
                    if (overlaps1D(a1.x, a2.x, b1.x, b2.x)) {
                      const keyA = `${pa}:${sa}`;
                      const keyB = `${pb}:${sb}`;
                      if (!seenA.has(keyA)) {
                        overlapsA.push({
                          solvedTracePathIndex: pa,
                          traceSegmentIndex: sa
                        });
                        seenA.add(keyA);
                      }
                      if (!seenB.has(keyB)) {
                        overlapsB.push({
                          solvedTracePathIndex: pb,
                          traceSegmentIndex: sb
                        });
                        seenB.add(keyB);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (overlapsA.length > 0 && overlapsB.length > 0) {
          return {
            overlappingTraceSegments: [
              { connNetId: netA, pathsWithOverlap: overlapsA },
              { connNetId: netB, pathsWithOverlap: overlapsB }
            ]
          };
        }
      }
    }
    return null;
  }
  findNextDiagonalSegment() {
    const EPS5 = 2e-3;
    for (const mspPairId in this.correctedTraceMap) {
      const tracePath = this.correctedTraceMap[mspPairId].tracePath;
      for (let i = 0; i < tracePath.length - 1; i++) {
        const p1 = tracePath[i];
        const p2 = tracePath[i + 1];
        const isHorizontal2 = Math.abs(p1.y - p2.y) < EPS5;
        const isVertical3 = Math.abs(p1.x - p2.x) < EPS5;
        if (!isHorizontal2 && !isVertical3) {
          return { mspPairId, tracePath, i, p1, p2 };
        }
      }
    }
    return null;
  }
  findAndFixNextDiagonalSegment() {
    const diagonalInfo = this.findNextDiagonalSegment();
    if (!diagonalInfo) {
      return false;
    }
    const { mspPairId, tracePath, i, p1, p2 } = diagonalInfo;
    const EPS5 = 2e-3;
    const p0 = i > 0 ? tracePath[i - 1] : null;
    const p3 = i + 2 < tracePath.length ? tracePath[i + 2] : null;
    const prevIsVertical = p0 ? Math.abs(p0.x - p1.x) < EPS5 : false;
    const prevIsHorizontal = p0 ? Math.abs(p0.y - p1.y) < EPS5 : false;
    const nextIsVertical = p3 ? Math.abs(p2.x - p3.x) < EPS5 : false;
    const nextIsHorizontal = p3 ? Math.abs(p2.y - p3.y) < EPS5 : false;
    const elbow1 = { x: p1.x, y: p2.y };
    const elbow2 = { x: p2.x, y: p1.y };
    let score1 = 0;
    if (prevIsVertical) score1++;
    if (nextIsHorizontal) score1++;
    let score2 = 0;
    if (prevIsHorizontal) score2++;
    if (nextIsVertical) score2++;
    const elbowPoint = score1 < score2 ? elbow1 : elbow2;
    tracePath.splice(i + 1, 0, elbowPoint);
    return true;
  }
  _step() {
    if (this.activeSubSolver?.solved) {
      for (const [mspPairId, newTrace] of Object.entries(
        this.activeSubSolver.correctedTraceMap
      )) {
        this.correctedTraceMap[mspPairId] = newTrace;
      }
      this.activeSubSolver = null;
      this.traceNetIslands = this.computeTraceNetIslands();
    }
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      return;
    }
    const overlapIssue = this.findNextOverlapIssue();
    if (overlapIssue === null) {
      if (this.cleanupPhase === null) {
        this.cleanupPhase = "diagonals";
      }
      if (this.cleanupPhase === "diagonals") {
        const fixedDiagonal = this.findAndFixNextDiagonalSegment();
        if (!fixedDiagonal) {
          this.cleanupPhase = "done";
          this.solved = true;
        }
        return;
      }
      this.solved = true;
      return;
    }
    const { overlappingTraceSegments } = overlapIssue;
    this.activeSubSolver = new TraceOverlapIssueSolver({
      overlappingTraceSegments,
      traceNetIslands: this.traceNetIslands
    });
  }
  visualize() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.visualize();
    }
    const graphics = visualizeInputProblem(this.inputProblem);
    graphics.circles = graphics.circles || [];
    for (const trace of Object.values(this.correctedTraceMap)) {
      graphics.lines.push({
        points: trace.tracePath,
        strokeColor: "purple"
      });
    }
    if (this.cleanupPhase === "diagonals") {
      const diagonalInfo = this.findNextDiagonalSegment();
      if (diagonalInfo) {
        graphics.lines.push({
          points: [diagonalInfo.p1, diagonalInfo.p2],
          strokeColor: "red",
          strokeWidth: 0.05
        });
      }
    }
    return graphics;
  }
};

// lib/data-structures/ChipObstacleSpatialIndex.ts
import Flatbush from "flatbush";
var ChipObstacleSpatialIndex = class {
  chips;
  spatialIndex;
  spatialIndexIdToChip;
  constructor(chips) {
    this.chips = chips.map((chip) => ({
      ...chip,
      bounds: getInputChipBounds(chip),
      spatialIndexId: null
    }));
    this.spatialIndexIdToChip = /* @__PURE__ */ new Map();
    this.spatialIndex = new Flatbush(chips.length);
    for (const chip of this.chips) {
      chip.spatialIndexId = this.spatialIndex.add(
        chip.bounds.minX,
        chip.bounds.minY,
        chip.bounds.maxX,
        chip.bounds.maxY
      );
      this.spatialIndexIdToChip.set(chip.spatialIndexId, chip);
    }
    this.spatialIndex.finish();
  }
  getChipsInBounds(bounds) {
    const chipSpatialIndexIds = this.spatialIndex.search(
      bounds.minX,
      bounds.minY,
      bounds.maxX,
      bounds.maxY
    );
    return chipSpatialIndexIds.map((id) => this.spatialIndexIdToChip.get(id));
  }
  doesOrthogonalLineIntersectChip(line, opts = {}) {
    const excludeChipIds = opts.excludeChipIds ?? [];
    const [p1, p2] = line;
    const { x: x1, y: y1 } = p1;
    const { x: x2, y: y2 } = p2;
    const chips = this.getChipsInBounds({
      minX: Math.min(x1, x2),
      minY: Math.min(y1, y2),
      maxX: Math.max(x1, x2),
      maxY: Math.max(y1, y2)
    }).filter((chip) => !excludeChipIds.includes(chip.chipId));
    return chips.length > 0;
  }
};

// lib/solvers/NetLabelPlacementSolver/SingleNetLabelPlacementSolver/geometry.ts
var NET_LABEL_HORIZONTAL_WIDTH = 0.45;
var NET_LABEL_HORIZONTAL_HEIGHT = 0.2;
function getDimsForOrientation(params) {
  const { orientation, netLabelWidth } = params;
  const horizWidth = typeof netLabelWidth === "number" ? netLabelWidth : NET_LABEL_HORIZONTAL_WIDTH;
  if (orientation === "y+" || orientation === "y-") {
    return {
      // Rotated, so width/height swap
      width: NET_LABEL_HORIZONTAL_HEIGHT,
      height: horizWidth
    };
  }
  return {
    width: horizWidth,
    height: NET_LABEL_HORIZONTAL_HEIGHT
  };
}
function getCenterFromAnchor(anchor, orientation, width, height) {
  switch (orientation) {
    case "x+":
      return { x: anchor.x + width / 2, y: anchor.y };
    case "x-":
      return { x: anchor.x - width / 2, y: anchor.y };
    case "y+":
      return { x: anchor.x, y: anchor.y + height / 2 };
    case "y-":
      return { x: anchor.x, y: anchor.y - height / 2 };
  }
}
function getRectBounds(center, w, h) {
  return {
    minX: center.x - w / 2,
    minY: center.y - h / 2,
    maxX: center.x + w / 2,
    maxY: center.y + h / 2
  };
}

// lib/solvers/NetLabelPlacementSolver/SingleNetLabelPlacementSolver/collisions.ts
function segmentIntersectsRect2(p1, p2, rect, EPS5 = 1e-9) {
  const isVert = Math.abs(p1.x - p2.x) < EPS5;
  const isHorz = Math.abs(p1.y - p2.y) < EPS5;
  if (!isVert && !isHorz) return false;
  if (isVert) {
    const x = p1.x;
    if (x < rect.minX - EPS5 || x > rect.maxX + EPS5) return false;
    const segMinY = Math.min(p1.y, p2.y);
    const segMaxY = Math.max(p1.y, p2.y);
    const overlap = Math.min(segMaxY, rect.maxY) - Math.max(segMinY, rect.minY);
    return overlap > EPS5;
  } else {
    const y = p1.y;
    if (y < rect.minY - EPS5 || y > rect.maxY + EPS5) return false;
    const segMinX = Math.min(p1.x, p2.x);
    const segMaxX = Math.max(p1.x, p2.x);
    const overlap = Math.min(segMaxX, rect.maxX) - Math.max(segMinX, rect.minX);
    return overlap > EPS5;
  }
}
function rectIntersectsAnyTrace(bounds, inputTraceMap, hostPathId, hostSegIndex) {
  for (const [pairId, solved] of Object.entries(inputTraceMap)) {
    const pts = solved.tracePath;
    for (let i = 0; i < pts.length - 1; i++) {
      if (pairId === hostPathId && i === hostSegIndex) continue;
      if (segmentIntersectsRect2(pts[i], pts[i + 1], bounds))
        return { hasIntersection: true, mspPairId: pairId, segIndex: i };
    }
  }
  return { hasIntersection: false };
}

// lib/solvers/NetLabelPlacementSolver/SingleNetLabelPlacementSolver/host.ts
function lengthOfTrace(path) {
  let sum = 0;
  const pts = path.tracePath;
  for (let i = 0; i < pts.length - 1; i++) {
    sum += Math.abs(pts[i + 1].x - pts[i].x) + Math.abs(pts[i + 1].y - pts[i].y);
  }
  return sum;
}
function chooseHostTraceForGroup(params) {
  const {
    inputProblem,
    inputTraceMap,
    globalConnNetId,
    fallbackTrace,
    mspConnectionPairIds
  } = params;
  const chipsById = Object.fromEntries(
    inputProblem.chips.map((c) => [c.chipId, c])
  );
  let groupTraces = Object.values(inputTraceMap).filter(
    (t) => t.globalConnNetId === globalConnNetId
  );
  if (mspConnectionPairIds && mspConnectionPairIds.length > 0) {
    const idSet = new Set(mspConnectionPairIds);
    groupTraces = groupTraces.filter(
      (t) => t.mspConnectionPairIds.some((id) => idSet.has(id))
    );
  }
  const chipIdsInGroup = /* @__PURE__ */ new Set();
  for (const t of groupTraces) {
    chipIdsInGroup.add(t.pins[0].chipId);
    chipIdsInGroup.add(t.pins[1].chipId);
  }
  let largestChipId = null;
  let largestPinCount = -1;
  for (const id of chipIdsInGroup) {
    const chip = chipsById[id];
    const count = chip?.pins?.length ?? 0;
    if (count > largestPinCount) {
      largestPinCount = count;
      largestChipId = id;
    }
  }
  const hostCandidates = largestChipId == null ? [] : groupTraces.filter(
    (t) => t.pins[0].chipId === largestChipId || t.pins[1].chipId === largestChipId
  );
  if (hostCandidates.length > 0) {
    return hostCandidates.reduce(
      (a, b) => lengthOfTrace(a) >= lengthOfTrace(b) ? a : b
    );
  }
  return fallbackTrace;
}

// lib/solvers/NetLabelPlacementSolver/SingleNetLabelPlacementSolver/anchors.ts
function anchorsForSegment(a, b) {
  return [
    { x: a.x, y: a.y },
    { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 },
    { x: b.x, y: b.y }
  ];
}

// lib/solvers/NetLabelPlacementSolver/SingleNetLabelPlacementSolver/solvePortOnlyPin.ts
function solveNetLabelPlacementForPortOnlyPin(params) {
  const {
    inputProblem,
    inputTraceMap,
    chipObstacleSpatialIndex,
    overlappingSameNetTraceGroup,
    availableOrientations,
    netLabelWidth
  } = params;
  const pinId = overlappingSameNetTraceGroup.portOnlyPinId;
  if (!pinId) {
    return {
      placement: null,
      testedCandidates: [],
      error: "No portOnlyPinId provided"
    };
  }
  let pin = null;
  let pinFacingDirection = null;
  for (const chip of inputProblem.chips) {
    const p = chip.pins.find((pp) => pp.pinId === pinId);
    if (p) {
      pin = { x: p.x, y: p.y };
      pinFacingDirection = p._facingDirection || getPinDirection(p, chip);
      break;
    }
  }
  if (!pin || !pinFacingDirection) {
    return {
      placement: null,
      testedCandidates: [],
      error: `Port-only pin not found: ${pinId}`
    };
  }
  const orientations = availableOrientations.length > 0 ? availableOrientations : ["x+", "x-", "y+", "y-"];
  const anchor = { x: pin.x, y: pin.y };
  const outwardOf = (o) => o === "x+" ? { x: 1, y: 0 } : o === "x-" ? { x: -1, y: 0 } : o === "y+" ? { x: 0, y: 1 } : { x: 0, y: -1 };
  const testedCandidates = [];
  for (const orientation of orientations) {
    const { width: width2, height: height2 } = getDimsForOrientation({
      orientation,
      netLabelWidth
    });
    const baseCenter2 = getCenterFromAnchor(anchor, orientation, width2, height2);
    const outward2 = outwardOf(orientation);
    const offset2 = 1e-3;
    const center = {
      x: baseCenter2.x + outward2.x * offset2,
      y: baseCenter2.y + outward2.y * offset2
    };
    const bounds = getRectBounds(center, width2, height2);
    const chips = chipObstacleSpatialIndex.getChipsInBounds(bounds);
    if (chips.length > 0) {
      testedCandidates.push({
        center,
        width: width2,
        height: height2,
        bounds,
        anchor,
        orientation,
        status: "chip-collision",
        hostSegIndex: -1
      });
      continue;
    }
    const traceIntersectionResult = rectIntersectsAnyTrace(
      bounds,
      inputTraceMap,
      "",
      -1
    );
    if (traceIntersectionResult.hasIntersection) {
      testedCandidates.push({
        center,
        width: width2,
        height: height2,
        bounds,
        anchor,
        orientation,
        status: "trace-collision",
        hostSegIndex: -1
      });
      continue;
    }
    testedCandidates.push({
      center,
      width: width2,
      height: height2,
      bounds,
      anchor,
      orientation,
      status: "ok",
      hostSegIndex: -1
    });
    const placement = {
      globalConnNetId: overlappingSameNetTraceGroup.globalConnNetId,
      dcConnNetId: void 0,
      netId: overlappingSameNetTraceGroup.netId,
      mspConnectionPairIds: [],
      pinIds: [pinId],
      orientation,
      anchorPoint: anchor,
      width: width2,
      height: height2,
      center
    };
    return { placement, testedCandidates };
  }
  const fallbackOrientation = pinFacingDirection;
  const { width, height } = getDimsForOrientation({
    orientation: fallbackOrientation,
    netLabelWidth
  });
  const baseCenter = getCenterFromAnchor(
    anchor,
    fallbackOrientation,
    width,
    height
  );
  const outward = outwardOf(fallbackOrientation);
  const offset = 1e-3;
  const fallbackCenter = {
    x: baseCenter.x + outward.x * offset,
    y: baseCenter.y + outward.y * offset
  };
  const fallbackPlacement = {
    globalConnNetId: overlappingSameNetTraceGroup.globalConnNetId,
    dcConnNetId: void 0,
    netId: overlappingSameNetTraceGroup.netId,
    mspConnectionPairIds: [],
    pinIds: [pinId],
    orientation: fallbackOrientation,
    anchorPoint: anchor,
    width,
    height,
    center: fallbackCenter
  };
  return { placement: fallbackPlacement, testedCandidates };
}

// lib/solvers/NetLabelPlacementSolver/SingleNetLabelPlacementSolver/SingleNetLabelPlacementSolver_visualize.ts
function visualizeSingleNetLabelPlacementSolver(solver) {
  const graphics = visualizeInputProblem(solver.inputProblem);
  const groupId = solver.overlappingSameNetTraceGroup.globalConnNetId;
  const host = chooseHostTraceForGroup({
    inputProblem: solver.inputProblem,
    inputTraceMap: solver.inputTraceMap,
    globalConnNetId: groupId,
    fallbackTrace: solver.overlappingSameNetTraceGroup.overlappingTraces
  });
  const groupStroke = getColorFromString(groupId, 0.9);
  const groupFill = getColorFromString(groupId, 0.5);
  for (const trace of Object.values(solver.inputTraceMap)) {
    const isHost = host ? trace.mspPairId === host.mspPairId : false;
    graphics.lines.push({
      points: trace.tracePath
      // strokeColor: isHost ? groupStroke : groupFill,
      // strokeDash: isHost ? undefined : "4 2",
    });
  }
  for (const c of solver.testedCandidates) {
    const fill = c.status === "ok" ? "rgba(0, 180, 0, 0.25)" : c.status === "chip-collision" ? "rgba(220, 0, 0, 0.25)" : c.status === "trace-collision" ? "rgba(220, 140, 0, 0.25)" : "rgba(120, 120, 120, 0.15)";
    const stroke = c.status === "ok" ? "green" : c.status === "chip-collision" ? "red" : c.status === "trace-collision" ? "orange" : "gray";
    graphics.rects.push({
      center: {
        x: (c.bounds.minX + c.bounds.maxX) / 2,
        y: (c.bounds.minY + c.bounds.maxY) / 2
      },
      width: c.width,
      height: c.height,
      fill,
      strokeColor: stroke
    });
    graphics.points.push({
      x: c.anchor.x,
      y: c.anchor.y,
      color: stroke
    });
  }
  if (solver.netLabelPlacement) {
    const p = solver.netLabelPlacement;
    graphics.rects.push({
      center: p.center,
      width: p.width,
      height: p.height,
      fill: "rgba(0, 128, 255, 0.35)",
      strokeColor: "blue"
    });
    graphics.points.push({
      x: p.anchorPoint.x,
      y: p.anchorPoint.y,
      color: "blue"
    });
  }
  return graphics;
}

// lib/solvers/NetLabelPlacementSolver/SingleNetLabelPlacementSolver/SingleNetLabelPlacementSolver.ts
var SingleNetLabelPlacementSolver = class extends BaseSolver {
  inputProblem;
  inputTraceMap;
  overlappingSameNetTraceGroup;
  availableOrientations;
  chipObstacleSpatialIndex;
  // Optional override for the width of the net label (per netId)
  netLabelWidth;
  netLabelPlacement = null;
  testedCandidates = [];
  constructor(params) {
    super();
    this.inputProblem = params.inputProblem;
    this.inputTraceMap = params.inputTraceMap;
    this.overlappingSameNetTraceGroup = params.overlappingSameNetTraceGroup;
    this.availableOrientations = params.availableOrientations;
    this.netLabelWidth = params.netLabelWidth;
    this.chipObstacleSpatialIndex = params.inputProblem._chipObstacleSpatialIndex ?? new ChipObstacleSpatialIndex(params.inputProblem.chips);
  }
  getConstructorParams() {
    return {
      inputProblem: this.inputProblem,
      inputTraceMap: this.inputTraceMap,
      overlappingSameNetTraceGroup: this.overlappingSameNetTraceGroup,
      availableOrientations: this.availableOrientations,
      netLabelWidth: this.netLabelWidth
    };
  }
  _step() {
    if (this.netLabelPlacement) {
      this.solved = true;
      return;
    }
    if (this.overlappingSameNetTraceGroup.portOnlyPinId) {
      const res = solveNetLabelPlacementForPortOnlyPin({
        inputProblem: this.inputProblem,
        inputTraceMap: this.inputTraceMap,
        chipObstacleSpatialIndex: this.chipObstacleSpatialIndex,
        overlappingSameNetTraceGroup: this.overlappingSameNetTraceGroup,
        availableOrientations: this.availableOrientations,
        netLabelWidth: this.netLabelWidth
      });
      this.testedCandidates.push(...res.testedCandidates);
      if (res.placement) {
        this.netLabelPlacement = res.placement;
        this.solved = true;
        return;
      }
      this.failed = true;
      this.error = res.error ?? "Could not place net label at port without collisions";
      return;
    }
    const groupId = this.overlappingSameNetTraceGroup.globalConnNetId;
    let host = chooseHostTraceForGroup({
      inputProblem: this.inputProblem,
      inputTraceMap: this.inputTraceMap,
      globalConnNetId: groupId,
      fallbackTrace: this.overlappingSameNetTraceGroup.overlappingTraces,
      mspConnectionPairIds: this.overlappingSameNetTraceGroup.mspConnectionPairIds
    });
    if (!host) {
      this.failed = true;
      this.error = "No host trace found for net label placement";
      return;
    }
    const traceIdSet = new Set(
      this.overlappingSameNetTraceGroup.mspConnectionPairIds ?? []
    );
    const tracesToScanBase = Object.values(this.inputTraceMap).filter(
      (t) => t.globalConnNetId === groupId && (traceIdSet.size === 0 || t.mspConnectionPairIds.some((id) => traceIdSet.has(id)))
    );
    const tracesToScan = this.availableOrientations.length === 1 ? [
      host,
      ...tracesToScanBase.filter((t) => t.mspPairId !== host.mspPairId)
    ] : [host];
    const orientations = this.availableOrientations.length > 0 ? this.availableOrientations : ["x+", "x-", "y+", "y-"];
    const singleOrientationMode = this.availableOrientations.length === 1;
    const scoreFor = (orientation, anchor) => {
      switch (orientation) {
        case "y+":
          return anchor.y;
        case "y-":
          return -anchor.y;
        case "x+":
          return anchor.x;
        case "x-":
          return -anchor.x;
      }
    };
    let bestCandidate = null;
    let bestScore = -Infinity;
    const EPS5 = 1e-6;
    for (const curr of tracesToScan) {
      const pts = curr.tracePath.slice();
      for (let si = 0; si < pts.length - 1; si++) {
        const a = pts[si];
        const b = pts[si + 1];
        const isH = Math.abs(a.y - b.y) < EPS5;
        const isV = Math.abs(a.x - b.x) < EPS5;
        if (!isH && !isV) continue;
        const segmentAllowed = isH ? ["y+", "y-"] : ["x+", "x-"];
        const candidateOrients = orientations.filter(
          (o) => segmentAllowed.includes(o)
        );
        if (candidateOrients.length === 0) continue;
        const anchors = anchorsForSegment(a, b);
        for (const anchor of anchors) {
          for (const orientation of candidateOrients) {
            const { width, height } = getDimsForOrientation({
              orientation,
              netLabelWidth: this.netLabelWidth
            });
            const center = getCenterFromAnchor(
              anchor,
              orientation,
              width,
              height
            );
            const outward = orientation === "x+" ? { x: 1, y: 0 } : orientation === "x-" ? { x: -1, y: 0 } : orientation === "y+" ? { x: 0, y: 1 } : { x: 0, y: -1 };
            const offset = 1e-4;
            const testCenter = {
              x: center.x + outward.x * offset,
              y: center.y + outward.y * offset
            };
            const bounds = getRectBounds(testCenter, width, height);
            const chips = this.chipObstacleSpatialIndex.getChipsInBounds(bounds);
            if (chips.length > 0) {
              this.testedCandidates.push({
                center: testCenter,
                width,
                height,
                bounds,
                anchor,
                orientation,
                status: "chip-collision",
                hostSegIndex: si
              });
              continue;
            }
            const traceIntersectionResult = rectIntersectsAnyTrace(
              bounds,
              this.inputTraceMap,
              curr.mspPairId,
              si
            );
            if (traceIntersectionResult.hasIntersection) {
              this.testedCandidates.push({
                center: testCenter,
                width,
                height,
                bounds,
                anchor,
                orientation,
                status: "trace-collision",
                hostSegIndex: si
              });
              continue;
            }
            this.testedCandidates.push({
              center: testCenter,
              width,
              height,
              bounds,
              anchor,
              orientation,
              status: "ok",
              hostSegIndex: si
            });
            if (singleOrientationMode) {
              const s = scoreFor(orientation, anchor);
              if (s > bestScore + 1e-9) {
                bestScore = s;
                bestCandidate = {
                  anchor,
                  orientation,
                  width,
                  height,
                  center,
                  hostSegIndex: si,
                  dcConnNetId: curr.dcConnNetId,
                  mspPairId: curr.mspPairId,
                  pinIds: [curr.pins[0].pinId, curr.pins[1].pinId]
                };
              }
              continue;
            }
            this.netLabelPlacement = {
              globalConnNetId: this.overlappingSameNetTraceGroup.globalConnNetId,
              dcConnNetId: curr.dcConnNetId,
              netId: this.overlappingSameNetTraceGroup.netId,
              mspConnectionPairIds: [curr.mspPairId],
              pinIds: [curr.pins[0].pinId, curr.pins[1].pinId],
              orientation,
              anchorPoint: anchor,
              width,
              height,
              center
            };
            this.solved = true;
            return;
          }
        }
      }
    }
    if (singleOrientationMode && bestCandidate) {
      this.netLabelPlacement = {
        globalConnNetId: this.overlappingSameNetTraceGroup.globalConnNetId,
        dcConnNetId: bestCandidate.dcConnNetId,
        netId: this.overlappingSameNetTraceGroup.netId,
        mspConnectionPairIds: [bestCandidate.mspPairId],
        pinIds: bestCandidate.pinIds,
        orientation: bestCandidate.orientation,
        anchorPoint: bestCandidate.anchor,
        width: bestCandidate.width,
        height: bestCandidate.height,
        center: bestCandidate.center
      };
      this.solved = true;
      return;
    }
    this.failed = true;
    this.error = "Could not place net label without collisions";
  }
  visualize() {
    return visualizeSingleNetLabelPlacementSolver(this);
  }
};

// lib/solvers/NetLabelPlacementSolver/NetLabelPlacementSolver.ts
var NetLabelPlacementSolver = class extends BaseSolver {
  inputProblem;
  inputTraceMap;
  overlappingSameNetTraceGroups;
  queuedOverlappingSameNetTraceGroups;
  netLabelPlacements = [];
  currentGroup = null;
  triedAnyOrientationFallbackForCurrentGroup = false;
  constructor(params) {
    super();
    this.inputProblem = params.inputProblem;
    this.inputTraceMap = params.inputTraceMap;
    this.overlappingSameNetTraceGroups = this.computeOverlappingSameNetTraceGroups();
    this.queuedOverlappingSameNetTraceGroups = [
      ...this.overlappingSameNetTraceGroups
    ];
  }
  computeOverlappingSameNetTraceGroups() {
    const byGlobal = {};
    for (const trace of Object.values(this.inputTraceMap)) {
      const key = trace.globalConnNetId;
      if (!byGlobal[key]) byGlobal[key] = [];
      byGlobal[key].push(trace);
    }
    const { netConnMap } = getConnectivityMapsFromInputProblem(
      this.inputProblem
    );
    const pinIdToPinMap = /* @__PURE__ */ new Map();
    for (const chip of this.inputProblem.chips) {
      for (const pin of chip.pins) {
        pinIdToPinMap.set(pin.pinId, pin);
      }
    }
    const userNetIdByPinId = {};
    for (const dc of this.inputProblem.directConnections) {
      if (dc.netId) {
        const [a, b] = dc.pinIds;
        userNetIdByPinId[a] = dc.netId;
        userNetIdByPinId[b] = dc.netId;
      }
    }
    for (const nc of this.inputProblem.netConnections) {
      for (const pid of nc.pinIds) {
        userNetIdByPinId[pid] = nc.netId;
      }
    }
    const groups = [];
    const allPinIds = this.inputProblem.chips.flatMap(
      (c) => c.pins.map((p) => p.pinId)
    );
    const allGlobalConnNetIds = /* @__PURE__ */ new Set();
    for (const pinId of allPinIds) {
      const netId = netConnMap.getNetConnectedToId(pinId);
      if (netId) {
        allGlobalConnNetIds.add(netId);
      }
    }
    for (const globalConnNetId of allGlobalConnNetIds) {
      const allIdsInNet = netConnMap.getIdsConnectedToNet(
        globalConnNetId
      );
      const pinsInNet = allIdsInNet.filter((id) => pinIdToPinMap.has(id));
      const adj = {};
      for (const pid of pinsInNet) adj[pid] = /* @__PURE__ */ new Set();
      for (const t of byGlobal[globalConnNetId] ?? []) {
        const a = t.pins[0].pinId;
        const b = t.pins[1].pinId;
        if (adj[a] && adj[b]) {
          adj[a].add(b);
          adj[b].add(a);
        }
      }
      const visited = /* @__PURE__ */ new Set();
      for (const pid of pinsInNet) {
        if (visited.has(pid)) continue;
        const stack = [pid];
        const component = /* @__PURE__ */ new Set();
        visited.add(pid);
        while (stack.length > 0) {
          const u = stack.pop();
          component.add(u);
          for (const v of adj[u] ?? []) {
            if (!visited.has(v)) {
              visited.add(v);
              stack.push(v);
            }
          }
        }
        const compTraces = (byGlobal[globalConnNetId] ?? []).filter(
          (t) => component.has(t.pins[0].pinId) && component.has(t.pins[1].pinId)
        );
        if (compTraces.length > 0) {
          const lengthOf = (path) => {
            let sum = 0;
            const pts = path.tracePath;
            for (let i = 0; i < pts.length - 1; i++) {
              sum += Math.abs(pts[i + 1].x - pts[i].x) + Math.abs(pts[i + 1].y - pts[i].y);
            }
            return sum;
          };
          let rep = compTraces[0];
          let repLen = lengthOf(rep);
          for (let i = 1; i < compTraces.length; i++) {
            const len = lengthOf(compTraces[i]);
            if (len > repLen) {
              rep = compTraces[i];
              repLen = len;
            }
          }
          let userNetId = compTraces.find((t) => t.userNetId != null)?.userNetId;
          if (!userNetId) {
            for (const p of component) {
              if (userNetIdByPinId[p]) {
                userNetId = userNetIdByPinId[p];
                break;
              }
            }
          }
          const mspConnectionPairIds = Array.from(
            new Set(
              compTraces.flatMap(
                (t) => t.mspConnectionPairIds ?? [t.mspPairId]
              )
            )
          );
          const group = {
            globalConnNetId,
            netId: userNetId,
            overlappingTraces: rep,
            mspConnectionPairIds
          };
          groups.push(group);
        } else {
          for (const p of component) {
            const userNetId = userNetIdByPinId[p];
            if (!userNetId) continue;
            groups.push({
              globalConnNetId,
              netId: userNetId,
              portOnlyPinId: p
            });
          }
        }
      }
    }
    return groups;
  }
  _step() {
    if (this.activeSubSolver?.solved) {
      this.netLabelPlacements.push(this.activeSubSolver.netLabelPlacement);
      this.activeSubSolver = null;
      this.currentGroup = null;
      this.triedAnyOrientationFallbackForCurrentGroup = false;
      return;
    }
    if (this.activeSubSolver?.failed) {
      const fullOrients = ["x+", "x-", "y+", "y-"];
      const currOrients = this.activeSubSolver.availableOrientations;
      const isAlreadyFull = currOrients.length === 4 && fullOrients.every((o) => currOrients.includes(o));
      if (!this.triedAnyOrientationFallbackForCurrentGroup && !isAlreadyFull && this.currentGroup) {
        this.triedAnyOrientationFallbackForCurrentGroup = true;
        const netLabelWidth2 = this.currentGroup.netId ? this.inputProblem.netConnections.find(
          (nc) => nc.netId === this.currentGroup.netId
        )?.netLabelWidth : void 0;
        this.activeSubSolver = new SingleNetLabelPlacementSolver({
          inputProblem: this.inputProblem,
          inputTraceMap: this.inputTraceMap,
          overlappingSameNetTraceGroup: this.currentGroup,
          availableOrientations: fullOrients,
          netLabelWidth: netLabelWidth2
        });
        return;
      }
      this.failed = true;
      this.error = this.activeSubSolver.error;
      return;
    }
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      return;
    }
    const nextOverlappingSameNetTraceGroup = this.queuedOverlappingSameNetTraceGroups.shift();
    if (!nextOverlappingSameNetTraceGroup) {
      this.solved = true;
      return;
    }
    const netId = nextOverlappingSameNetTraceGroup.netId ?? nextOverlappingSameNetTraceGroup.globalConnNetId;
    this.currentGroup = nextOverlappingSameNetTraceGroup;
    this.triedAnyOrientationFallbackForCurrentGroup = false;
    const netLabelWidth = this.currentGroup.netId ? this.inputProblem.netConnections.find(
      (nc) => nc.netId === this.currentGroup.netId
    )?.netLabelWidth : void 0;
    this.activeSubSolver = new SingleNetLabelPlacementSolver({
      inputProblem: this.inputProblem,
      inputTraceMap: this.inputTraceMap,
      overlappingSameNetTraceGroup: nextOverlappingSameNetTraceGroup,
      availableOrientations: this.inputProblem.availableNetLabelOrientations[netId] ?? ["x+", "x-", "y+", "y-"],
      netLabelWidth
    });
  }
  visualize() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.visualize();
    }
    const graphics = visualizeInputProblem(this.inputProblem);
    for (const trace of Object.values(this.inputTraceMap)) {
      graphics.lines.push({
        points: trace.tracePath,
        strokeColor: "purple"
      });
    }
    for (const p of this.netLabelPlacements) {
      graphics.rects.push({
        center: p.center,
        width: p.width,
        height: p.height,
        fill: getColorFromString(p.globalConnNetId, 0.35),
        strokeColor: getColorFromString(p.globalConnNetId, 0.9)
      });
      graphics.points.push({
        x: p.anchorPoint.x,
        y: p.anchorPoint.y,
        color: getColorFromString(p.globalConnNetId, 0.9)
      });
    }
    return graphics;
  }
};

// lib/solvers/TraceLabelOverlapAvoidanceSolver/sub-solvers/LabelMergingSolver/LabelMergingSolver.ts
var MergedNetLabelObstacleSolver = class extends BaseSolver {
  input;
  output;
  inputProblem;
  traces;
  constructor(solverInput) {
    super();
    this.input = solverInput;
    this.inputProblem = solverInput.inputProblem;
    this.traces = solverInput.traces;
    this.output = {
      netLabelPlacements: solverInput.netLabelPlacements,
      mergedLabelNetIdMap: {}
    };
  }
  _step() {
    const originalLabels = this.input.netLabelPlacements;
    const mergedLabelNetIdMap = {};
    if (!originalLabels || originalLabels.length === 0) {
      this.output = {
        netLabelPlacements: [],
        mergedLabelNetIdMap: {}
      };
      this.solved = true;
      return;
    }
    const labelGroups = {};
    for (const p of originalLabels) {
      if (p.pinIds.length === 0) continue;
      const chipId = p.pinIds[0].split(".")[0];
      if (!chipId) continue;
      const key = `${chipId}-${p.orientation}`;
      if (!(key in labelGroups)) {
        labelGroups[key] = [];
      }
      labelGroups[key].push(p);
    }
    const finalPlacements = [];
    for (const [key, group] of Object.entries(labelGroups)) {
      if (group.length <= 1) {
        finalPlacements.push(...group);
        continue;
      }
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      for (const p of group) {
        const bounds = getRectBounds(p.center, p.width, p.height);
        minX = Math.min(minX, bounds.minX);
        minY = Math.min(minY, bounds.minY);
        maxX = Math.max(maxX, bounds.maxX);
        maxY = Math.max(maxY, bounds.maxY);
      }
      const newWidth = maxX - minX;
      const newHeight = maxY - minY;
      const template = group[0];
      const syntheticId = `merged-group-${key}`;
      const originalNetIds = new Set(group.map((p) => p.globalConnNetId));
      mergedLabelNetIdMap[syntheticId] = originalNetIds;
      finalPlacements.push({
        ...template,
        globalConnNetId: syntheticId,
        width: newWidth,
        height: newHeight,
        center: { x: minX + newWidth / 2, y: minY + newHeight / 2 },
        pinIds: [...new Set(group.flatMap((p) => p.pinIds))],
        mspConnectionPairIds: [
          ...new Set(group.flatMap((p) => p.mspConnectionPairIds))
        ]
      });
    }
    this.output = {
      netLabelPlacements: finalPlacements,
      mergedLabelNetIdMap
    };
    this.solved = true;
  }
  getOutput() {
    return this.output;
  }
  visualize() {
    const graphics = visualizeInputProblem(this.inputProblem, {
      chipAlpha: 0.1,
      connectionAlpha: 0.1
    });
    if (!graphics.rects) graphics.rects = [];
    if (!graphics.lines) graphics.lines = [];
    if (!graphics.points) graphics.points = [];
    if (!graphics.texts) graphics.texts = [];
    const originalLabelsById = /* @__PURE__ */ new Map();
    for (const label of this.input.netLabelPlacements) {
      originalLabelsById.set(label.globalConnNetId, label);
    }
    for (const trace of this.traces) {
      const line = {
        points: trace.tracePath.map((p) => ({ x: p.x, y: p.y })),
        strokeColor: "blue"
      };
      graphics.lines.push(line);
    }
    for (const finalLabel of this.output.netLabelPlacements) {
      const isMerged = finalLabel.globalConnNetId.startsWith("merged-group-");
      const color = getColorFromString(finalLabel.globalConnNetId);
      if (isMerged) {
        graphics.rects.push({
          center: finalLabel.center,
          width: finalLabel.width,
          height: finalLabel.height,
          fill: color.replace(/, 1\)/, ", 0.2)"),
          // semi-transparent
          stroke: color,
          label: finalLabel.globalConnNetId
        });
        const originalNetIds = this.output.mergedLabelNetIdMap[finalLabel.globalConnNetId];
        if (originalNetIds) {
          for (const originalNetId of originalNetIds) {
            const originalLabel = originalLabelsById.get(originalNetId);
            if (originalLabel) {
              const bounds = getRectBounds(
                originalLabel.center,
                originalLabel.width,
                originalLabel.height
              );
              const p1 = { x: bounds.minX, y: bounds.minY };
              const p2 = { x: bounds.maxX, y: bounds.minY };
              const p3 = { x: bounds.maxX, y: bounds.maxY };
              const p4 = { x: bounds.minX, y: bounds.maxY };
              graphics.lines.push({
                points: [p1, p2, p3, p4, p1],
                strokeColor: color,
                strokeDash: "4 4"
              });
              graphics.lines.push({
                points: [originalLabel.center, finalLabel.center],
                strokeColor: color,
                strokeDash: "2 2"
              });
            }
          }
        }
      } else {
        graphics.rects.push({
          center: finalLabel.center,
          width: finalLabel.width,
          height: finalLabel.height,
          stroke: color,
          label: finalLabel.globalConnNetId
        });
      }
    }
    return graphics;
  }
};

// lib/solvers/TraceLabelOverlapAvoidanceSolver/detectTraceLabelOverlap.ts
var detectTraceLabelOverlap = (traces, netLabels) => {
  const overlaps = [];
  for (const trace of traces) {
    for (const label of netLabels) {
      const labelBounds = getRectBounds(label.center, label.width, label.height);
      for (let i = 0; i < trace.tracePath.length - 1; i++) {
        const p1 = trace.tracePath[i];
        const p2 = trace.tracePath[i + 1];
        if (segmentIntersectsRect2(p1, p2, labelBounds)) {
          if (trace.globalConnNetId === label.globalConnNetId) {
            break;
          }
          overlaps.push({ trace, label });
          break;
        }
      }
    }
  }
  return overlaps;
};

// lib/solvers/TraceLabelOverlapAvoidanceSolver/violation.ts
var findTraceViolationZone = (path, labelBounds) => {
  const isPointInside = (p) => p.x > labelBounds.minX && p.x < labelBounds.maxX && p.y > labelBounds.minY && p.y < labelBounds.maxY;
  let firstInsideIndex = -1;
  let lastInsideIndex = -1;
  for (let i = 0; i < path.length; i++) {
    if (isPointInside(path[i])) {
      if (firstInsideIndex === -1) {
        firstInsideIndex = i;
      }
      lastInsideIndex = i;
    }
  }
  return { firstInsideIndex, lastInsideIndex };
};

// lib/solvers/TraceLabelOverlapAvoidanceSolver/trySnipAndReconnect.ts
var generateSnipAndReconnectCandidates = ({
  initialTrace,
  firstInsideIndex,
  lastInsideIndex,
  labelBounds,
  paddingBuffer,
  detourCount
}) => {
  if (firstInsideIndex <= 0 || lastInsideIndex >= initialTrace.tracePath.length - 1) {
    return [];
  }
  const entryPoint = initialTrace.tracePath[firstInsideIndex - 1];
  const exitPoint = initialTrace.tracePath[lastInsideIndex + 1];
  const pathToEntry = initialTrace.tracePath.slice(0, firstInsideIndex);
  const pathFromExit = initialTrace.tracePath.slice(lastInsideIndex + 1);
  const allCandidateDetours = [];
  if (entryPoint.x !== exitPoint.x && entryPoint.y !== exitPoint.y) {
    allCandidateDetours.push([{ x: exitPoint.x, y: entryPoint.y }]);
    allCandidateDetours.push([{ x: entryPoint.x, y: exitPoint.y }]);
  } else if (entryPoint.x === exitPoint.x || entryPoint.y === exitPoint.y) {
    allCandidateDetours.push([]);
  }
  const buffer = paddingBuffer + detourCount * paddingBuffer;
  const leftX = labelBounds.minX - buffer;
  const rightX = labelBounds.maxX + buffer;
  const topY = labelBounds.maxY + buffer;
  const bottomY = labelBounds.minY - buffer;
  if ((entryPoint.x <= labelBounds.minX || exitPoint.x <= labelBounds.minX) && entryPoint.x < labelBounds.maxX && exitPoint.x < labelBounds.maxX) {
    allCandidateDetours.push([
      { x: leftX, y: entryPoint.y },
      { x: leftX, y: exitPoint.y }
    ]);
  }
  if ((entryPoint.x >= labelBounds.maxX || exitPoint.x >= labelBounds.maxX) && entryPoint.x > labelBounds.minX && exitPoint.x > labelBounds.minX) {
    allCandidateDetours.push([
      { x: rightX, y: entryPoint.y },
      { x: rightX, y: exitPoint.y }
    ]);
  }
  if ((entryPoint.y >= labelBounds.maxY || exitPoint.y >= labelBounds.maxY) && entryPoint.y > labelBounds.minY && exitPoint.y > labelBounds.minY) {
    allCandidateDetours.push([
      { x: entryPoint.x, y: topY },
      { x: exitPoint.x, y: topY }
    ]);
  }
  if ((entryPoint.y <= labelBounds.minY || exitPoint.y <= labelBounds.minY) && entryPoint.y < labelBounds.maxY && exitPoint.y < labelBounds.maxY) {
    allCandidateDetours.push([
      { x: entryPoint.x, y: bottomY },
      { x: exitPoint.x, y: bottomY }
    ]);
  }
  return allCandidateDetours.map((detour) => [
    ...pathToEntry,
    ...detour,
    ...pathFromExit
  ]);
};

// lib/solvers/TraceLabelOverlapAvoidanceSolver/tryFourPointDetour.ts
var generateFourPointDetourCandidates = ({
  initialTrace,
  label,
  labelBounds,
  paddingBuffer,
  detourCount
}) => {
  let collidingSegIndex = -1;
  for (let i = 0; i < initialTrace.tracePath.length - 1; i++) {
    if (segmentIntersectsRect(
      initialTrace.tracePath[i],
      initialTrace.tracePath[i + 1],
      labelBounds
    )) {
      collidingSegIndex = i;
      break;
    }
  }
  if (collidingSegIndex === -1) return [];
  const pA = initialTrace.tracePath[collidingSegIndex];
  const pB = initialTrace.tracePath[collidingSegIndex + 1];
  if (!pA || !pB) return [];
  const candidateDetours = [];
  const paddedLabelBounds = getRectBounds(
    label.center,
    label.width,
    label.height
  );
  const effectivePadding = paddingBuffer + detourCount * paddingBuffer;
  if (isVertical(pA, pB)) {
    const xCandidates = [
      paddedLabelBounds.maxX + effectivePadding,
      paddedLabelBounds.minX - effectivePadding
    ];
    for (const newX of xCandidates) {
      candidateDetours.push(
        pB.y > pA.y ? [
          { x: pA.x, y: paddedLabelBounds.minY - effectivePadding },
          { x: newX, y: paddedLabelBounds.minY - effectivePadding },
          { x: newX, y: paddedLabelBounds.maxY + effectivePadding },
          { x: pB.x, y: paddedLabelBounds.maxY + effectivePadding }
        ] : [
          { x: pA.x, y: paddedLabelBounds.maxY + effectivePadding },
          { x: newX, y: paddedLabelBounds.maxY + effectivePadding },
          { x: newX, y: paddedLabelBounds.minY - effectivePadding },
          { x: pB.x, y: paddedLabelBounds.minY - effectivePadding }
        ]
      );
    }
  } else {
    const yCandidates = [
      paddedLabelBounds.maxY + effectivePadding,
      paddedLabelBounds.minY - effectivePadding
    ];
    for (const newY of yCandidates) {
      candidateDetours.push(
        pB.x > pA.x ? [
          { x: paddedLabelBounds.minX - effectivePadding, y: pA.y },
          { x: paddedLabelBounds.minX - effectivePadding, y: newY },
          { x: paddedLabelBounds.maxX + effectivePadding, y: newY },
          { x: paddedLabelBounds.maxX + effectivePadding, y: pB.y }
        ] : [
          { x: paddedLabelBounds.maxX + effectivePadding, y: pA.y },
          { x: paddedLabelBounds.maxX + effectivePadding, y: newY },
          { x: paddedLabelBounds.minX - effectivePadding, y: newY },
          { x: paddedLabelBounds.minX - effectivePadding, y: pB.y }
        ]
      );
    }
  }
  return candidateDetours.map((detourPoints) => [
    ...initialTrace.tracePath.slice(0, collidingSegIndex + 1),
    ...detourPoints,
    ...initialTrace.tracePath.slice(collidingSegIndex + 1)
  ]);
};

// lib/solvers/TraceCleanupSolver/simplifyPath.ts
var simplifyPath = (path) => {
  if (path.length < 3) return path;
  const newPath = [path[0]];
  for (let i = 1; i < path.length - 1; i++) {
    const p1 = newPath[newPath.length - 1];
    const p2 = path[i];
    const p3 = path[i + 1];
    if (isVertical(p1, p2) && isVertical(p2, p3) || isHorizontal(p1, p2) && isHorizontal(p2, p3)) {
      continue;
    }
    newPath.push(p2);
  }
  newPath.push(path[path.length - 1]);
  if (newPath.length < 3) return newPath;
  const finalPath = [newPath[0]];
  for (let i = 1; i < newPath.length - 1; i++) {
    const p1 = finalPath[finalPath.length - 1];
    const p2 = newPath[i];
    const p3 = newPath[i + 1];
    if (isVertical(p1, p2) && isVertical(p2, p3) || isHorizontal(p1, p2) && isHorizontal(p2, p3)) {
      continue;
    }
    finalPath.push(p2);
  }
  finalPath.push(newPath[newPath.length - 1]);
  return finalPath;
};

// lib/solvers/TraceLabelOverlapAvoidanceSolver/rerouteCollidingTrace.ts
var generateRerouteCandidates = ({
  trace,
  label,
  paddingBuffer,
  detourCount
}) => {
  const initialTrace = { ...trace, tracePath: simplifyPath(trace.tracePath) };
  if (trace.globalConnNetId === label.globalConnNetId) {
    return [initialTrace.tracePath];
  }
  const labelPadding = paddingBuffer;
  const labelBoundsRaw = getRectBounds(label.center, label.width, label.height);
  const labelBounds = {
    minX: labelBoundsRaw.minX - labelPadding,
    minY: labelBoundsRaw.minY - labelPadding,
    maxX: labelBoundsRaw.maxX + labelPadding,
    maxY: labelBoundsRaw.maxY + labelPadding,
    chipId: `netlabel-${label.netId}`
  };
  const fourPointCandidates = generateFourPointDetourCandidates({
    initialTrace,
    label,
    labelBounds,
    paddingBuffer,
    detourCount
  });
  const { firstInsideIndex, lastInsideIndex } = findTraceViolationZone(
    initialTrace.tracePath,
    labelBounds
  );
  const snipReconnectCandidates = generateSnipAndReconnectCandidates({
    initialTrace,
    firstInsideIndex,
    lastInsideIndex,
    labelBounds,
    paddingBuffer,
    detourCount
  });
  return [...fourPointCandidates, ...snipReconnectCandidates];
};

// lib/solvers/TraceLabelOverlapAvoidanceSolver/sub-solvers/SingleOverlapSolver/SingleOverlapSolver.ts
var SingleOverlapSolver = class extends BaseSolver {
  queuedCandidatePaths;
  solvedTracePath = null;
  initialTrace;
  problem;
  obstacles;
  label;
  constructor(solverInput) {
    super();
    this.initialTrace = solverInput.trace;
    this.problem = solverInput.problem;
    this.label = solverInput.label;
    const candidates = generateRerouteCandidates({
      ...solverInput
    });
    const getPathLength = (pts) => {
      let len = 0;
      for (let i = 0; i < pts.length - 1; i++) {
        const dx = pts[i + 1].x - pts[i].x;
        const dy = pts[i + 1].y - pts[i].y;
        len += Math.sqrt(dx * dx + dy * dy);
      }
      return len;
    };
    this.queuedCandidatePaths = candidates.sort(
      (a, b) => getPathLength(a) - getPathLength(b)
    );
    this.obstacles = getObstacleRects(this.problem);
  }
  _step() {
    if (this.queuedCandidatePaths.length === 0) {
      this.failed = true;
      return;
    }
    const nextCandidatePath = this.queuedCandidatePaths.shift();
    const simplifiedPath = simplifyPath(nextCandidatePath);
    if (!isPathCollidingWithObstacles(simplifiedPath, this.obstacles)) {
      this.solvedTracePath = simplifiedPath;
      this.solved = true;
    }
  }
  visualize() {
    const graphics = visualizeInputProblem(this.problem, {
      chipAlpha: 0.1,
      connectionAlpha: 0.1
    });
    if (!graphics.lines) graphics.lines = [];
    if (!graphics.rects) graphics.rects = [];
    graphics.lines.push({
      points: this.initialTrace.tracePath,
      strokeColor: "red",
      strokeDash: "4 4"
    });
    graphics.rects.push({
      center: this.label.center,
      width: this.label.width,
      height: this.label.height,
      fill: "rgba(255, 0, 0, 0.2)"
    });
    if (this.queuedCandidatePaths.length > 0) {
      graphics.lines.push({
        points: this.queuedCandidatePaths[0],
        strokeColor: "orange"
      });
    }
    if (this.solvedTracePath) {
      graphics.lines.push({
        points: this.solvedTracePath,
        strokeColor: "green"
      });
    }
    return graphics;
  }
};

// lib/solvers/TraceLabelOverlapAvoidanceSolver/sub-solvers/OverlapAvoidanceStepSolver/OverlapAvoidanceStepSolver.ts
var OverlapAvoidanceStepSolver = class extends BaseSolver {
  inputProblem;
  netLabelPlacements;
  mergedLabelNetIdMap;
  allTraces;
  modifiedTraces = [];
  detourCountByLabel = {};
  PADDING_BUFFER = 0.1;
  activeSubSolver = null;
  overlapQueue = [];
  recentlyFailed = /* @__PURE__ */ new Set();
  constructor(solverInput) {
    super();
    this.inputProblem = solverInput.inputProblem;
    this.netLabelPlacements = solverInput.netLabelPlacements;
    this.mergedLabelNetIdMap = solverInput.mergedLabelNetIdMap;
    this.allTraces = [...solverInput.traces];
  }
  _step() {
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      if (this.activeSubSolver.solved) {
        const solvedPath = this.activeSubSolver.solvedTracePath;
        if (solvedPath) {
          const traceIndex = this.allTraces.findIndex(
            (t) => t.mspPairId === this.activeSubSolver.initialTrace.mspPairId
          );
          if (traceIndex !== -1) {
            this.allTraces[traceIndex].tracePath = solvedPath;
            this.modifiedTraces.push(this.allTraces[traceIndex]);
          }
        }
        this.activeSubSolver = null;
        this.recentlyFailed.clear();
      } else if (this.activeSubSolver.failed) {
        const overlapId = `${this.activeSubSolver.initialTrace.mspPairId}-${this.activeSubSolver.label.globalConnNetId}`;
        this.recentlyFailed.add(overlapId);
        this.activeSubSolver = null;
      }
      return;
    }
    const overlaps = detectTraceLabelOverlap(
      this.allTraces,
      this.netLabelPlacements
    ).filter((o) => {
      const originalNetIds = this.mergedLabelNetIdMap[o.label.globalConnNetId];
      if (originalNetIds) {
        return !originalNetIds.has(o.trace.globalConnNetId);
      }
      return o.trace.globalConnNetId !== o.label.globalConnNetId;
    });
    if (overlaps.length === 0) {
      this.solved = true;
      return;
    }
    const nonFailedOverlaps = overlaps.filter((o) => {
      const overlapId = `${o.trace.mspPairId}-${o.label.globalConnNetId}`;
      return !this.recentlyFailed.has(overlapId);
    });
    if (nonFailedOverlaps.length === 0) {
      this.solved = true;
      return;
    }
    this.overlapQueue = nonFailedOverlaps;
    const nextOverlap = this.overlapQueue.shift();
    if (nextOverlap) {
      const traceToFix = this.allTraces.find(
        (t) => t.mspPairId === nextOverlap.trace.mspPairId
      );
      if (traceToFix) {
        const labelId = nextOverlap.label.globalConnNetId;
        const detourCount = this.detourCountByLabel[labelId] || 0;
        this.detourCountByLabel[labelId] = detourCount + 1;
        this.activeSubSolver = new SingleOverlapSolver({
          trace: traceToFix,
          label: nextOverlap.label,
          problem: this.inputProblem,
          paddingBuffer: this.PADDING_BUFFER,
          detourCount
        });
      }
    }
  }
  getOutput() {
    return {
      allTraces: this.allTraces,
      modifiedTraces: this.modifiedTraces
    };
  }
  visualize() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.visualize();
    }
    const graphics = visualizeInputProblem(this.inputProblem);
    if (!graphics.lines) graphics.lines = [];
    for (const trace of this.allTraces) {
      graphics.lines.push({
        points: trace.tracePath,
        strokeColor: "purple"
      });
    }
    return graphics;
  }
};

// lib/solvers/TraceLabelOverlapAvoidanceSolver/TraceLabelOverlapAvoidanceSolver.ts
var TraceLabelOverlapAvoidanceSolver = class extends BaseSolver {
  inputProblem;
  traces;
  netLabelPlacements;
  // sub-solver instances
  labelMergingSolver;
  overlapAvoidanceSolver;
  pipelineStepIndex = 0;
  constructor(solverInput) {
    super();
    this.inputProblem = solverInput.inputProblem;
    this.traces = solverInput.traces;
    this.netLabelPlacements = solverInput.netLabelPlacements;
  }
  _step() {
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      if (this.activeSubSolver.solved) {
        this.activeSubSolver = null;
        this.pipelineStepIndex++;
      } else if (this.activeSubSolver.failed) {
        this.failed = true;
        this.activeSubSolver = null;
      }
      return;
    }
    switch (this.pipelineStepIndex) {
      case 0:
        this.labelMergingSolver = new MergedNetLabelObstacleSolver({
          netLabelPlacements: this.netLabelPlacements,
          inputProblem: this.inputProblem,
          traces: this.traces
        });
        this.activeSubSolver = this.labelMergingSolver;
        break;
      case 1:
        this.overlapAvoidanceSolver = new OverlapAvoidanceStepSolver({
          inputProblem: this.inputProblem,
          traces: this.traces,
          netLabelPlacements: this.labelMergingSolver.getOutput().netLabelPlacements,
          mergedLabelNetIdMap: this.labelMergingSolver.getOutput().mergedLabelNetIdMap
        });
        this.activeSubSolver = this.overlapAvoidanceSolver;
        break;
      default:
        this.solved = true;
        break;
    }
  }
  getOutput() {
    return {
      traces: this.overlapAvoidanceSolver?.getOutput().allTraces ?? this.traces,
      netLabelPlacements: this.labelMergingSolver?.getOutput().netLabelPlacements ?? this.netLabelPlacements
    };
  }
  visualize() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.visualize();
    }
    const graphics = visualizeInputProblem(this.inputProblem);
    if (!graphics.lines) graphics.lines = [];
    if (!graphics.rects) graphics.rects = [];
    const output = this.getOutput();
    for (const trace of output.traces) {
      graphics.lines.push({
        points: trace.tracePath,
        strokeColor: "purple"
      });
    }
    for (const label of output.netLabelPlacements) {
      const color = getColorFromString(label.globalConnNetId, 0.3);
      graphics.rects.push({
        center: label.center,
        width: label.width,
        height: label.height,
        fill: color,
        stroke: color.replace("0.3", "1"),
        label: label.globalConnNetId
      });
    }
    return graphics;
  }
};

// lib/solvers/SchematicTracePipelineSolver/correctPinsInsideChip.ts
var correctPinsInsideChips = (problem) => {
  for (const chip of problem.chips) {
    const bounds = getInputChipBounds(chip);
    for (const pin of chip.pins) {
      const isInside = pin.x > bounds.minX && pin.x < bounds.maxX && pin.y > bounds.minY && pin.y < bounds.maxY;
      if (!isInside) continue;
      const distLeft = pin.x - bounds.minX;
      const distRight = bounds.maxX - pin.x;
      const distBottom = pin.y - bounds.minY;
      const distTop = bounds.maxY - pin.y;
      const minDist = Math.min(distLeft, distRight, distBottom, distTop);
      if (minDist === distLeft) {
        pin.x = bounds.minX;
      } else if (minDist === distRight) {
        pin.x = bounds.maxX;
      } else if (minDist === distBottom) {
        pin.y = bounds.minY;
      } else {
        pin.y = bounds.maxY;
      }
      pin._facingDirection = void 0;
    }
  }
};

// lib/solvers/SchematicTracePipelineSolver/expandChipsToFitPins.ts
var expandChipsToFitPins = (problem) => {
  for (const chip of problem.chips) {
    const halfWidth = chip.width / 2;
    const halfHeight = chip.height / 2;
    let maxDx = 0;
    let maxDy = 0;
    for (const pin of chip.pins) {
      const dx = Math.abs(pin.x - chip.center.x);
      const dy = Math.abs(pin.y - chip.center.y);
      if (dx > maxDx) maxDx = dx;
      if (dy > maxDy) maxDy = dy;
    }
    const newHalfWidth = Math.max(halfWidth, maxDx);
    const newHalfHeight = Math.max(halfHeight, maxDy);
    if (newHalfWidth > halfWidth || newHalfHeight > halfHeight) {
      chip.width = newHalfWidth * 2;
      chip.height = newHalfHeight * 2;
      for (const pin of chip.pins) {
        pin._facingDirection = void 0;
      }
    }
  }
};

// lib/utils/does-trace-overlap-with-existing-traces.ts
import { doSegmentsIntersect } from "@tscircuit/math-utils";
function doesTraceOverlapWithExistingTraces(newTracePath, existingTraces) {
  for (let i = 0; i < newTracePath.length - 1; i++) {
    const newSegmentP1 = newTracePath[i];
    const newSegmentP2 = newTracePath[i + 1];
    for (const existingTrace of existingTraces) {
      for (let j = 0; j < existingTrace.tracePath.length - 1; j++) {
        const existingSegmentP1 = existingTrace.tracePath[j];
        const existingSegmentP2 = existingTrace.tracePath[j + 1];
        if (doSegmentsIntersect(
          newSegmentP1,
          newSegmentP2,
          existingSegmentP1,
          existingSegmentP2
        )) {
          return true;
        }
      }
    }
  }
  return false;
}

// lib/solvers/LongDistancePairSolver/LongDistancePairSolver.ts
var NEAREST_NEIGHBOR_COUNT = 3;
var distance = (p1, p2) => {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
};
var LongDistancePairSolver = class extends BaseSolver {
  constructor(params) {
    super();
    this.params = params;
    const { inputProblem, primaryMspConnectionPairs, alreadySolvedTraces } = this.params;
    this.inputProblem = inputProblem;
    this.allSolvedTraces = [...alreadySolvedTraces];
    const primaryConnectedPinIds = /* @__PURE__ */ new Set();
    for (const pair of primaryMspConnectionPairs) {
      primaryConnectedPinIds.add(pair.pins[0].pinId);
      primaryConnectedPinIds.add(pair.pins[1].pinId);
    }
    const { netConnMap } = getConnectivityMapsFromInputProblem(inputProblem);
    this.netConnMap = netConnMap;
    const pinMap = /* @__PURE__ */ new Map();
    for (const chip of inputProblem.chips) {
      this.chipMap[chip.chipId] = chip;
      for (const pin of chip.pins) {
        pinMap.set(pin.pinId, { ...pin, chipId: chip.chipId });
      }
    }
    const candidatePairs = [];
    const addedPairKeys = /* @__PURE__ */ new Set();
    for (const netId of Object.keys(netConnMap.netMap)) {
      const allPinIdsInNet = netConnMap.getIdsConnectedToNet(netId);
      if (allPinIdsInNet.length < 2) continue;
      const unconnectedPinIds = allPinIdsInNet.filter(
        (pinId) => !primaryConnectedPinIds.has(pinId)
      );
      for (const unconnectedPinId of unconnectedPinIds) {
        const sourcePin = pinMap.get(unconnectedPinId);
        if (!sourcePin) continue;
        const neighbors = allPinIdsInNet.filter((otherPinId) => otherPinId !== unconnectedPinId).flatMap((otherPinId) => {
          const targetPin = pinMap.get(otherPinId);
          if (!targetPin) return [];
          return [
            {
              pin: targetPin,
              distance: distance(sourcePin, targetPin)
            }
          ];
        }).sort((a, b) => a.distance - b.distance).slice(0, NEAREST_NEIGHBOR_COUNT);
        for (const neighbor of neighbors) {
          const pair = [sourcePin, neighbor.pin];
          const pairKey = pair.map((p) => p.pinId).sort().join("--");
          if (!addedPairKeys.has(pairKey)) {
            candidatePairs.push(pair);
            addedPairKeys.add(pairKey);
          }
        }
      }
    }
    this.queuedCandidatePairs = candidatePairs;
  }
  solvedLongDistanceTraces = [];
  queuedCandidatePairs = [];
  currentCandidatePair = null;
  subSolver = null;
  chipMap = {};
  inputProblem;
  netConnMap;
  newlyConnectedPinIds = /* @__PURE__ */ new Set();
  allSolvedTraces = [];
  getConstructorParams() {
    return this.params;
  }
  _step() {
    if (this.subSolver?.solved) {
      const newTracePath = this.subSolver.solvedTracePath;
      if (newTracePath && this.currentCandidatePair) {
        const isTraceClear = !doesTraceOverlapWithExistingTraces(
          newTracePath,
          this.allSolvedTraces
        );
        if (isTraceClear) {
          const [p1, p2] = this.currentCandidatePair;
          const globalConnNetId = this.netConnMap.getNetConnectedToId(p1.pinId);
          const mspPairId = `${p1.pinId}-${p2.pinId}`;
          const newSolvedTrace = {
            mspPairId,
            dcConnNetId: globalConnNetId,
            globalConnNetId,
            pins: [p1, p2],
            tracePath: newTracePath,
            mspConnectionPairIds: [mspPairId],
            pinIds: [p1.pinId, p2.pinId]
          };
          this.solvedLongDistanceTraces.push(newSolvedTrace);
          this.allSolvedTraces.push(newSolvedTrace);
          this.newlyConnectedPinIds.add(p1.pinId);
          this.newlyConnectedPinIds.add(p2.pinId);
        }
      }
      this.subSolver = null;
      this.currentCandidatePair = null;
    } else if (this.subSolver?.failed) {
      this.subSolver = null;
      this.currentCandidatePair = null;
    }
    if (this.subSolver) {
      this.subSolver.step();
      return;
    }
    while (this.queuedCandidatePairs.length > 0) {
      const nextPair = this.queuedCandidatePairs.shift();
      const [p1, p2] = nextPair;
      if (this.newlyConnectedPinIds.has(p1.pinId) || this.newlyConnectedPinIds.has(p2.pinId)) {
        continue;
      }
      this.currentCandidatePair = nextPair;
      this.subSolver = new SchematicTraceSingleLineSolver2({
        inputProblem: this.params.inputProblem,
        pins: this.currentCandidatePair,
        chipMap: this.chipMap
      });
      return;
    }
    this.solved = true;
  }
  visualize() {
    if (this.subSolver) {
      return this.subSolver.visualize();
    }
    const graphics = visualizeInputProblem(this.inputProblem);
    for (const trace of this.solvedLongDistanceTraces) {
      graphics.lines.push({
        points: trace.tracePath,
        strokeColor: "purple"
      });
    }
    for (const [p1, p2] of this.queuedCandidatePairs) {
      graphics.lines.push({
        points: [p1, p2],
        strokeColor: "gray",
        strokeDash: "4 4"
      });
    }
    return graphics;
  }
  getOutput() {
    if (!this.solved) {
      return { newTraces: [], allTracesMerged: this.params.alreadySolvedTraces };
    }
    return {
      newTraces: this.solvedLongDistanceTraces,
      allTracesMerged: [
        ...this.params.alreadySolvedTraces,
        ...this.solvedLongDistanceTraces
      ]
    };
  }
};

// lib/solvers/TraceCleanupSolver/hasCollisions.ts
import { segmentToBoxMinDistance } from "@tscircuit/math-utils";
var hasCollisions = (pathSegments, obstacles) => {
  for (let i = 0; i < pathSegments.length - 1; i++) {
    const p1 = pathSegments[i];
    const p2 = pathSegments[i + 1];
    for (const obstacle of obstacles) {
      const box = {
        center: {
          x: obstacle.minX + (obstacle.maxX - obstacle.minX) / 2,
          y: obstacle.minY + (obstacle.maxY - obstacle.minY) / 2
        },
        width: obstacle.maxX - obstacle.minX,
        height: obstacle.maxY - obstacle.minY
      };
      if (segmentToBoxMinDistance(p1, p2, box) <= 0) {
        return true;
      }
    }
  }
  return false;
};

// lib/solvers/TraceCleanupSolver/countTurns.ts
var countTurns = (points) => {
  let turns = 0;
  for (let i = 1; i < points.length - 1; i++) {
    const prev = points[i - 1];
    const curr = points[i];
    const next = points[i + 1];
    const prevVertical = prev.x === curr.x;
    const nextVertical = curr.x === next.x;
    if (prevVertical !== nextVertical) {
      turns++;
    }
  }
  return turns;
};

// lib/solvers/TraceCleanupSolver/tryConnectPoints.ts
var tryConnectPoints = (start, end) => {
  const candidates = [];
  if (start.x === end.x || start.y === end.y) {
    candidates.push([start, end]);
  } else {
    candidates.push([start, { x: end.x, y: start.y }, end]);
    candidates.push([start, { x: start.x, y: end.y }, end]);
  }
  return candidates;
};

// lib/solvers/TraceCleanupSolver/hasCollisionsWithLabels.ts
var hasCollisionsWithLabels = (pathSegments, labels) => {
  for (let i = 0; i < pathSegments.length - 1; i++) {
    const p1 = pathSegments[i];
    const p2 = pathSegments[i + 1];
    for (const label of labels) {
      if (segmentIntersectsRect(p1, p2, label)) {
        return true;
      }
    }
  }
  return false;
};

// lib/solvers/TraceCleanupSolver/recognizeStairStepPattern.ts
var recognizeStairStepPattern = (pathToCheck, startIdx) => {
  if (startIdx >= pathToCheck.length - 3) return -1;
  let endIdx = startIdx;
  let isStairStep = true;
  for (let i = startIdx; i < pathToCheck.length - 2 && i < startIdx + 10; i++) {
    if (i + 2 >= pathToCheck.length) break;
    const p1 = pathToCheck[i];
    const p2 = pathToCheck[i + 1];
    const p3 = pathToCheck[i + 2];
    const seg1Vertical = p1.x === p2.x;
    const seg2Vertical = p2.x === p3.x;
    if (seg1Vertical === seg2Vertical) {
      break;
    }
    const seg1Direction = seg1Vertical ? Math.sign(p2.y - p1.y) : Math.sign(p2.x - p1.x);
    if (i > startIdx) {
      const prevP = pathToCheck[i - 1];
      const prevSegVertical = prevP.x === p1.x;
      const prevDirection = prevSegVertical ? Math.sign(p1.y - prevP.y) : Math.sign(p1.x - prevP.x);
      if (seg1Vertical && prevSegVertical && seg1Direction !== prevDirection || !seg1Vertical && !prevSegVertical && seg1Direction !== prevDirection) {
        isStairStep = false;
        break;
      }
    }
    endIdx = i + 2;
  }
  return isStairStep && endIdx - startIdx >= 3 ? endIdx : -1;
};

// lib/solvers/TraceCleanupSolver/isSegmentAnEndpointSegment.ts
var isSegmentAnEndpointSegment = (p1, p2, originalPath) => {
  if (originalPath.length < 2) return false;
  const originalStart = originalPath[0];
  const originalEnd = originalPath[originalPath.length - 1];
  if (p1.x === originalStart.x && p1.y === originalStart.y && p2.x === originalPath[1].x && p2.y === originalPath[1].y) {
    return true;
  }
  if (p1.x === originalPath[originalPath.length - 2].x && p1.y === originalPath[originalPath.length - 2].y && p2.x === originalEnd.x && p2.y === originalEnd.y) {
    return true;
  }
  return false;
};

// lib/solvers/TraceCleanupSolver/turnMinimization.ts
var minimizeTurns = ({
  path,
  obstacles,
  labelBounds,
  originalPath
}) => {
  if (path.length <= 2) {
    return path;
  }
  let optimizedPath = [...path];
  let currentTurns = countTurns(optimizedPath);
  let improved = true;
  while (improved) {
    improved = false;
    for (let startIdx = 0; startIdx < optimizedPath.length - 3; startIdx++) {
      const stairEndIdx = recognizeStairStepPattern(optimizedPath, startIdx);
      if (stairEndIdx > 0) {
        if (isSegmentAnEndpointSegment(
          optimizedPath[startIdx],
          optimizedPath[startIdx + 1],
          originalPath
        ) || isSegmentAnEndpointSegment(
          optimizedPath[stairEndIdx - 1],
          optimizedPath[stairEndIdx],
          originalPath
        )) {
          continue;
        }
        const startPoint = optimizedPath[startIdx];
        const endPoint = optimizedPath[stairEndIdx];
        const connectionOptions = tryConnectPoints(startPoint, endPoint);
        for (const connection of connectionOptions) {
          const testPath = [
            ...optimizedPath.slice(0, startIdx + 1),
            ...connection.slice(1, -1),
            ...optimizedPath.slice(stairEndIdx)
          ];
          const collidesWithObstacles = hasCollisions(connection, obstacles);
          const collidesWithLabels = hasCollisionsWithLabels(
            connection,
            labelBounds
          );
          if (!collidesWithObstacles && !collidesWithLabels) {
            const newTurns = countTurns(testPath);
            optimizedPath = testPath;
            currentTurns = newTurns;
            improved = true;
            break;
          }
        }
        if (improved) break;
      }
    }
    if (!improved) {
      for (let startIdx = 0; startIdx < optimizedPath.length - 2; startIdx++) {
        const maxRemove = Math.min(
          optimizedPath.length - startIdx - 2,
          optimizedPath.length - 2
        );
        for (let removeCount = 1; removeCount <= maxRemove; removeCount++) {
          const endIdx = startIdx + removeCount + 1;
          if (endIdx >= optimizedPath.length) continue;
          if (isSegmentAnEndpointSegment(
            optimizedPath[startIdx],
            optimizedPath[startIdx + 1],
            originalPath
          ) || isSegmentAnEndpointSegment(
            optimizedPath[endIdx - 1],
            optimizedPath[endIdx],
            originalPath
          )) {
            continue;
          }
          const startPoint = optimizedPath[startIdx];
          const endPoint = optimizedPath[endIdx];
          const connectionOptions = tryConnectPoints(startPoint, endPoint);
          for (const connection of connectionOptions) {
            const testPath = [
              ...optimizedPath.slice(0, startIdx + 1),
              ...connection.slice(1, -1),
              ...optimizedPath.slice(endIdx)
            ];
            const connectionSegments = connection;
            const collidesWithObstacles = hasCollisions(
              connectionSegments,
              obstacles
            );
            const collidesWithLabels = hasCollisionsWithLabels(
              connectionSegments,
              labelBounds
            );
            if (!collidesWithObstacles && !collidesWithLabels) {
              const newTurns = countTurns(testPath);
              if (newTurns < currentTurns || newTurns === currentTurns && testPath.length < optimizedPath.length) {
                optimizedPath = testPath;
                currentTurns = newTurns;
                improved = true;
                break;
              }
            }
          }
          if (improved) break;
        }
        if (improved) break;
      }
    }
    if (!improved) {
      for (let i = 0; i < optimizedPath.length - 2; i++) {
        const p1 = optimizedPath[i];
        const p2 = optimizedPath[i + 1];
        const p3 = optimizedPath[i + 2];
        if (isSegmentAnEndpointSegment(p1, p2, originalPath) || isSegmentAnEndpointSegment(p2, p3, originalPath)) {
          continue;
        }
        const allVertical = p1.x === p2.x && p2.x === p3.x;
        const allHorizontal = p1.y === p2.y && p2.y === p3.y;
        if (allVertical || allHorizontal) {
          const testPath = [
            ...optimizedPath.slice(0, i + 1),
            ...optimizedPath.slice(i + 2)
          ];
          const collidesWithObstacles = hasCollisions([p1, p3], obstacles);
          const collidesWithLabels = hasCollisionsWithLabels(
            [p1, p3],
            labelBounds
          );
          if (!collidesWithObstacles && !collidesWithLabels) {
            optimizedPath = testPath;
            improved = true;
            break;
          }
        }
      }
    }
  }
  const finalSimplifiedPath = simplifyPath(optimizedPath);
  return finalSimplifiedPath;
};

// lib/solvers/TraceCleanupSolver/minimizeTurnsWithFilteredLabels.ts
var minimizeTurnsWithFilteredLabels = ({
  targetMspConnectionPairId,
  traces,
  inputProblem,
  allLabelPlacements,
  mergedLabelNetIdMap,
  paddingBuffer
}) => {
  const targetTrace = traces.find(
    (t) => t.mspPairId === targetMspConnectionPairId
  );
  if (!targetTrace) {
    throw new Error(`Target trace ${targetMspConnectionPairId} not found`);
  }
  const obstacleTraces = traces.filter(
    (t) => t.mspPairId !== targetMspConnectionPairId
  );
  const TRACE_WIDTH = 0.01;
  const traceObstacles = obstacleTraces.flatMap(
    (trace, i) => trace.tracePath.slice(0, -1).map((p1, pi) => {
      const p2 = trace.tracePath[pi + 1];
      return {
        chipId: `trace-obstacle-${i}-${pi}`,
        minX: Math.min(p1.x, p2.x) - TRACE_WIDTH / 2,
        minY: Math.min(p1.y, p2.y) - TRACE_WIDTH / 2,
        maxX: Math.max(p1.x, p2.x) + TRACE_WIDTH / 2,
        maxY: Math.max(p1.y, p2.y) + TRACE_WIDTH / 2
      };
    })
  );
  const staticObstaclesRaw = getObstacleRects(inputProblem);
  const PADDING = 0.01;
  const staticObstacles = staticObstaclesRaw.map((obs) => ({
    ...obs,
    minX: obs.minX - PADDING,
    minY: obs.minY - PADDING,
    maxX: obs.maxX + PADDING,
    maxY: obs.maxY + PADDING
  }));
  const combinedObstacles = [...staticObstacles, ...traceObstacles];
  const originalPath = targetTrace.tracePath;
  const filteredLabels = allLabelPlacements.filter((label) => {
    const originalNetIds = mergedLabelNetIdMap[label.globalConnNetId];
    if (originalNetIds) {
      return !originalNetIds.has(targetTrace.globalConnNetId);
    }
    return label.globalConnNetId !== targetTrace.globalConnNetId;
  });
  const labelBounds = filteredLabels.map((nl) => ({
    minX: nl.center.x - nl.width / 2 - paddingBuffer,
    maxX: nl.center.x + nl.width / 2 + paddingBuffer,
    minY: nl.center.y - nl.height / 2 - paddingBuffer,
    maxY: nl.center.y + nl.height / 2 + paddingBuffer
  }));
  const newPath = minimizeTurns({
    path: originalPath,
    obstacles: combinedObstacles,
    labelBounds,
    originalPath
  });
  return {
    ...targetTrace,
    tracePath: newPath
  };
};

// lib/solvers/TraceCleanupSolver/balanceZShapes.ts
var balanceZShapes = ({
  targetMspConnectionPairId,
  traces,
  inputProblem,
  allLabelPlacements,
  mergedLabelNetIdMap,
  paddingBuffer
}) => {
  const targetTrace = traces.find(
    (t) => t.mspPairId === targetMspConnectionPairId
  );
  if (!targetTrace) {
    throw new Error(`Target trace ${targetMspConnectionPairId} not found`);
  }
  const TOLERANCE = 1e-5;
  const obstacleTraces = traces.filter(
    (t) => t.mspPairId !== targetMspConnectionPairId
  );
  const TRACE_WIDTH = 0.01;
  const traceObstacles = obstacleTraces.flatMap(
    (trace, i) => trace.tracePath.slice(0, -1).map((p1, pi) => {
      const p2 = trace.tracePath[pi + 1];
      return {
        chipId: `trace-obstacle-${i}-${pi}`,
        minX: Math.min(p1.x, p2.x) - TRACE_WIDTH / 2,
        minY: Math.min(p1.y, p2.y) - TRACE_WIDTH / 2,
        maxX: Math.max(p1.x, p2.x) + TRACE_WIDTH / 2,
        maxY: Math.max(p1.y, p2.y) + TRACE_WIDTH / 2
      };
    })
  );
  const staticObstacles = getObstacleRects(inputProblem).map((obs) => ({
    ...obs,
    minX: obs.minX + TOLERANCE,
    maxX: obs.maxX - TOLERANCE,
    minY: obs.minY + TOLERANCE,
    maxY: obs.maxY - TOLERANCE
  }));
  const combinedObstacles = [...staticObstacles, ...traceObstacles];
  const segmentIntersectsAnyRect = (p1, p2, rects) => {
    for (const rect of rects) {
      if (segmentIntersectsRect(p1, p2, rect)) {
        return true;
      }
    }
    return false;
  };
  const filteredLabels = allLabelPlacements.filter((label) => {
    const originalNetIds = mergedLabelNetIdMap[label.globalConnNetId];
    if (originalNetIds) {
      return !originalNetIds.has(targetTrace.globalConnNetId);
    }
    return label.globalConnNetId !== targetTrace.globalConnNetId;
  });
  const labelBounds = filteredLabels.map((nl) => ({
    minX: nl.center.x - nl.width / 2 + TOLERANCE,
    maxX: nl.center.x + nl.width / 2 - TOLERANCE,
    minY: nl.center.y - nl.height / 2 + TOLERANCE,
    maxY: nl.center.y + nl.height / 2 - TOLERANCE
  }));
  const newPath = [...targetTrace.tracePath];
  if (newPath.length < 4) {
    return { ...targetTrace };
  }
  if (newPath.length === 4) {
    const [p0, p1, p2, p3] = newPath;
    let p1New;
    let p2New;
    const isHVHShape = p0.y === p1.y && p1.x === p2.x && p2.y === p3.y;
    if (isHVHShape) {
      const idealX = (p0.x + p3.x) / 2;
      p1New = { x: idealX, y: p1.y };
      p2New = { x: idealX, y: p2.y };
    } else {
      const idealY = (p0.y + p3.y) / 2;
      p1New = { x: p1.x, y: idealY };
      p2New = { x: p2.x, y: idealY };
    }
    const collides = segmentIntersectsAnyRect(p0, p1New, combinedObstacles) || segmentIntersectsAnyRect(p1New, p2New, combinedObstacles) || segmentIntersectsAnyRect(p2New, p3, combinedObstacles) || segmentIntersectsAnyRect(p0, p1New, labelBounds) || segmentIntersectsAnyRect(p1New, p2New, labelBounds) || segmentIntersectsAnyRect(p2New, p3, labelBounds);
    if (!collides) {
      newPath[1] = p1New;
      newPath[2] = p2New;
    }
    return { ...targetTrace, tracePath: simplifyPath(newPath) };
  }
  for (let i = 1; i < newPath.length - 4; i++) {
    const p1 = newPath[i];
    const p2 = newPath[i + 1];
    const p3 = newPath[i + 2];
    const p4 = newPath[i + 3];
    const isHVHZShape = p1.y === p2.y && p2.x === p3.x && p3.y === p4.y;
    const isVHVZShape = p1.x === p2.x && p2.y === p3.y && p3.x === p4.x;
    const isCollinearHorizontal = p1.y === p2.y && p2.y === p3.y && p3.y === p4.y;
    const isCollinearVertical = p1.x === p2.x && p2.x === p3.x && p3.x === p4.x;
    const isCollinear = isCollinearHorizontal || isCollinearVertical;
    let isSameDirection = false;
    if (isHVHZShape) {
      isSameDirection = Math.sign(p2.x - p1.x) === Math.sign(p4.x - p3.x);
    } else if (isVHVZShape) {
      isSameDirection = Math.sign(p2.y - p1.y) === Math.sign(p4.y - p3.y);
    }
    const isValidZShape = (isHVHZShape || isVHVZShape) && !isCollinear && isSameDirection;
    if (!isValidZShape) {
      continue;
    }
    let p2New;
    let p3New;
    const len1Original = isHVHZShape ? Math.abs(p1.x - p2.x) : Math.abs(p1.y - p2.y);
    const len2Original = isHVHZShape ? Math.abs(p3.x - p4.x) : Math.abs(p3.y - p4.y);
    if (Math.abs(len1Original - len2Original) < 1e-3) {
      continue;
    }
    if (isHVHZShape) {
      const idealX = (p1.x + p4.x) / 2;
      p2New = { x: idealX, y: p2.y };
      p3New = { x: idealX, y: p3.y };
    } else {
      const idealY = (p1.y + p4.y) / 2;
      p2New = { x: p2.x, y: idealY };
      p3New = { x: p3.x, y: idealY };
    }
    const collides = segmentIntersectsAnyRect(p1, p2New, combinedObstacles) || segmentIntersectsAnyRect(p2New, p3New, combinedObstacles) || segmentIntersectsAnyRect(p3New, p4, combinedObstacles) || segmentIntersectsAnyRect(p1, p2New, labelBounds) || segmentIntersectsAnyRect(p2New, p3New, labelBounds) || segmentIntersectsAnyRect(p3New, p4, labelBounds);
    if (!collides) {
      newPath[i + 1] = p2New;
      newPath[i + 2] = p3New;
      i = 0;
    }
  }
  const finalSimplifiedPath = simplifyPath(newPath);
  return {
    ...targetTrace,
    tracePath: finalSimplifiedPath
  };
};

// lib/solvers/TraceCleanupSolver/sub-solver/findAllLShapedTurns.ts
var findAllLShapedTurns = (tracePath) => {
  const lShapes = [];
  if (tracePath.length < 3) {
    return lShapes;
  }
  for (let i = 0; i < tracePath.length - 2; i++) {
    const p1 = tracePath[i];
    const p2 = tracePath[i + 1];
    const p3 = tracePath[i + 2];
    const dx1 = p2.x - p1.x;
    const dy1 = p2.y - p1.y;
    const dx2 = p3.x - p2.x;
    const dy2 = p3.y - p2.y;
    if ((dx1 === 0 && dy2 === 0 && dy1 !== 0 && dx2 !== 0 || // Vertical then Horizontal
    dy1 === 0 && dx2 === 0 && dx1 !== 0 && dy2 !== 0) && // Horizontal then Vertical
    dx1 * dx1 + dy1 * dy1 >= 0.25 && // p1-p2 arm length >= 0.5
    dx2 * dx2 + dy2 * dy2 >= 0.25) {
      lShapes.push({ p1, p2, p3 });
    }
  }
  return lShapes;
};

// lib/solvers/TraceCleanupSolver/sub-solver/getTraceObstacles.ts
var getTraceObstacles = (allTraces, excludeTraceId) => {
  const obstacles = [];
  for (const trace of allTraces) {
    if (trace.mspPairId !== excludeTraceId) {
      obstacles.push({ points: trace.tracePath });
    }
  }
  return obstacles;
};

// lib/solvers/TraceCleanupSolver/sub-solver/findIntersectionsWithObstacles.ts
import { getSegmentIntersection } from "@tscircuit/math-utils/line-intersections";
var findIntersectionsWithObstacles = (p1, p2, obstacles) => {
  const intersections = [];
  for (const obstacle of obstacles) {
    const obstaclePath = obstacle.points;
    for (let i = 0; i < obstaclePath.length - 1; i++) {
      const o1 = obstaclePath[i];
      const o2 = obstaclePath[i + 1];
      if (!o1 || !o2) {
        continue;
      }
      const intersection = getSegmentIntersection(p1, p2, o1, o2);
      if (intersection) {
        intersections.push(intersection);
      }
    }
  }
  return intersections;
};

// lib/solvers/TraceCleanupSolver/sub-solver/generateLShapeRerouteCandidates.ts
var EPS4 = 1e-6;
var isVertical2 = (a, b, eps = EPS4) => Math.abs(a.x - b.x) < eps;
var generateLShapeRerouteCandidates = ({
  lShape,
  rectangle,
  padding = 0.5,
  interactionPoint1,
  interactionPoint2
}) => {
  const { p1, p2, p3 } = lShape;
  const { x, y, width, height } = rectangle;
  let c2;
  let i1_padded = interactionPoint1;
  let i2_padded = interactionPoint2;
  if (Math.abs(p2.x - x) < EPS4 && Math.abs(p2.y - (y + height)) < EPS4) {
    c2 = { x: x + width + padding, y: y - padding };
    if (isVertical2(p1, p2)) {
      i1_padded = { x: interactionPoint1.x, y: interactionPoint1.y - padding };
    } else {
      i1_padded = { x: interactionPoint1.x + padding, y: interactionPoint1.y };
    }
    if (isVertical2(p2, p3)) {
      i2_padded = { x: interactionPoint2.x, y: interactionPoint2.y - padding };
    } else {
      i2_padded = { x: interactionPoint2.x + padding, y: interactionPoint2.y };
    }
  } else if (Math.abs(p2.x - (x + width)) < EPS4 && Math.abs(p2.y - (y + height)) < EPS4) {
    c2 = { x: x - padding, y: y - padding };
    if (isVertical2(p1, p2)) {
      i1_padded = { x: interactionPoint1.x, y: interactionPoint1.y - padding };
    } else {
      i1_padded = { x: interactionPoint1.x - padding, y: interactionPoint1.y };
    }
    if (isVertical2(p2, p3)) {
      i2_padded = { x: interactionPoint2.x, y: interactionPoint2.y - padding };
    } else {
      i2_padded = { x: interactionPoint2.x - padding, y: interactionPoint2.y };
    }
  } else if (Math.abs(p2.x - x) < EPS4 && Math.abs(p2.y - y) < EPS4) {
    c2 = { x: x + width + padding, y: y + height + padding };
    if (isVertical2(p1, p2)) {
      i1_padded = { x: interactionPoint1.x, y: interactionPoint1.y + padding };
    } else {
      i1_padded = { x: interactionPoint1.x + padding, y: interactionPoint1.y };
    }
    if (isVertical2(p2, p3)) {
      i2_padded = { x: interactionPoint2.x, y: interactionPoint2.y + padding };
    } else {
      i2_padded = { x: interactionPoint2.x + padding, y: interactionPoint2.y };
    }
  } else if (Math.abs(p2.x - (x + width)) < EPS4 && Math.abs(p2.y - y) < EPS4) {
    c2 = { x: x - padding, y: y + height + padding };
    if (isVertical2(p1, p2)) {
      i1_padded = { x: interactionPoint1.x, y: interactionPoint1.y + padding };
    } else {
      i1_padded = { x: interactionPoint1.x - padding, y: interactionPoint1.y };
    }
    if (isVertical2(p2, p3)) {
      i2_padded = { x: interactionPoint2.x, y: interactionPoint2.y + padding };
    } else {
      i2_padded = { x: interactionPoint2.x - padding, y: interactionPoint2.y };
    }
  } else {
    return [];
  }
  return [[i1_padded, c2, i2_padded]];
};

// lib/solvers/TraceCleanupSolver/sub-solver/isPathColliding.ts
import { getSegmentIntersection as getSegmentIntersection2 } from "@tscircuit/math-utils/line-intersections";
var isPathColliding = (path, allTraces, traceIdToExclude) => {
  if (path.length < 2) {
    return { isColliding: false };
  }
  for (let i = 0; i < path.length - 1; i++) {
    const pathSegP1 = path[i];
    const pathSegQ1 = path[i + 1];
    for (const existingTrace of allTraces) {
      if (existingTrace.mspPairId === traceIdToExclude) {
        continue;
      }
      for (let j = 0; j < existingTrace.tracePath.length - 1; j++) {
        const existingSegP2 = existingTrace.tracePath[j];
        const existingSegQ2 = existingTrace.tracePath[j + 1];
        const intersectionPoint = getSegmentIntersection2(
          pathSegP1,
          pathSegQ1,
          existingSegP2,
          existingSegQ2
        );
        if (intersectionPoint) {
          return {
            isColliding: true,
            collidingTraceId: existingTrace.mspPairId,
            collisionPoint: intersectionPoint
          };
        }
      }
    }
  }
  return { isColliding: false };
};

// lib/solvers/TraceCleanupSolver/sub-solver/generateRectangleCandidates.ts
var generateRectangleCandidates = (intersections1, intersections2) => {
  const rectangleCandidates = [];
  for (const p1 of intersections1) {
    for (const p2 of intersections2) {
      const minX = Math.min(p1.x, p2.x);
      const minY = Math.min(p1.y, p2.y);
      const maxX = Math.max(p1.x, p2.x);
      const maxY = Math.max(p1.y, p2.y);
      const width = maxX - minX;
      const height = maxY - minY;
      if (width > 1e-6 && height > 1e-6) {
        rectangleCandidates.push({
          rect: {
            x: minX,
            y: minY,
            width,
            height
          },
          i1: p1,
          i2: p2
        });
      }
    }
  }
  return rectangleCandidates;
};

// lib/solvers/TraceCleanupSolver/sub-solver/visualizeLSapes.ts
var visualizeLSapes = (lShapes) => {
  const graphics = { circles: [], lines: [] };
  const lShapesArray = Array.isArray(lShapes) ? lShapes : [lShapes];
  for (const lShape of lShapesArray) {
    graphics.circles.push({
      center: {
        x: lShape.p2.x,
        y: lShape.p2.y
      },
      radius: 0.01,
      fill: "blue"
    });
    graphics.lines.push({
      points: [lShape.p1, lShape.p2, lShape.p3],
      strokeColor: "lightblue"
    });
  }
  return graphics;
};

// lib/solvers/TraceCleanupSolver/sub-solver/visualizeIntersectionPoints.ts
var visualizeIntersectionPoints = (points, color = "red") => {
  const graphics = { circles: [] };
  for (const point of points) {
    graphics.circles.push({
      center: {
        x: point.x,
        y: point.y
      },
      radius: 0.01,
      fill: color
    });
  }
  return graphics;
};

// lib/solvers/TraceCleanupSolver/visualizeTightRectangle.ts
var visualizeTightRectangle = (rectangle) => {
  const graphics = { rects: [] };
  graphics.rects.push({
    center: {
      x: rectangle.x + rectangle.width / 2,
      y: rectangle.y + rectangle.height / 2
    },
    width: rectangle.width,
    height: rectangle.height,
    stroke: "green"
  });
  return graphics;
};

// lib/solvers/TraceCleanupSolver/sub-solver/visualizeCandidates.ts
var visualizeCandidates = (candidates, color = "gray", intersectionPoints = []) => {
  const graphics = { lines: [], circles: [] };
  for (const candidate of candidates) {
    graphics.lines.push({
      points: candidate,
      strokeColor: color
    });
  }
  for (const point of intersectionPoints) {
    graphics.circles.push({
      center: point,
      radius: 0.01,
      // Larger radius for intersection points
      fill: "green"
    });
  }
  return graphics;
};

// lib/solvers/TraceCleanupSolver/mergeGraphicsObjects.ts
var mergeGraphicsObjects = (objects) => {
  const merged = {
    lines: [],
    points: [],
    rects: [],
    circles: [],
    texts: []
  };
  for (const obj of objects) {
    if (!obj) continue;
    if (obj.lines) merged.lines.push(...obj.lines);
    if (obj.points) merged.points.push(...obj.points);
    if (obj.rects) merged.rects.push(...obj.rects);
    if (obj.circles) merged.circles.push(...obj.circles);
    if (obj.texts) merged.texts.push(...obj.texts);
  }
  return merged;
};

// lib/solvers/TraceCleanupSolver/sub-solver/visualizeCollision.ts
var visualizeCollision = (collisionInfo) => {
  const collisionGraphics = { circles: [] };
  if (collisionInfo?.isColliding && collisionInfo.collisionPoint) {
    collisionGraphics.circles.push({
      center: collisionInfo.collisionPoint,
      radius: 0.01,
      fill: "red"
    });
  }
  return collisionGraphics;
};

// lib/solvers/TraceCleanupSolver/sub-solver/UntangleTraceSubsolver.ts
var UntangleTraceSubsolver = class extends BaseSolver {
  input;
  lShapesToProcess = [];
  visualizationMode = "l_shapes";
  currentLShape = null;
  intersectionPoints = [];
  tightRectangle = null;
  candidates = [];
  bestRoute = null;
  lastCollision = null;
  collidingCandidate = null;
  rectangleCandidates = [];
  currentRectangleIndex = 0;
  isInitialStep = true;
  currentCandidateIndex = 0;
  lShapeProcessingStep = "idle";
  lShapeJustProcessed = false;
  bestRouteFound = null;
  constructor(solverInput) {
    super();
    this.input = solverInput;
    this.visualizationMode = "l_shapes";
    for (const trace of this.input.allTraces) {
      const lShapes = findAllLShapedTurns(trace.tracePath);
      this.lShapesToProcess.push(
        ...lShapes.map((l) => ({ ...l, traceId: trace.mspPairId }))
      );
    }
  }
  _step() {
    if (this.isInitialStep) {
      this.isInitialStep = false;
      return;
    }
    if (this.lShapeJustProcessed) {
      this._resetAfterLShapProcessing();
      return;
    }
    if (this.lShapesToProcess.length === 0 && this.currentLShape === null) {
      this.solved = true;
      return;
    }
    switch (this.lShapeProcessingStep) {
      case "idle":
        this._handleIdleStep();
        break;
      case "intersections":
        this._handleIntersectionsStep();
        break;
      case "rectangle_selection":
        this._handleRectangleSelectionStep();
        break;
      case "candidate_evaluation":
        this._handleCandidateEvaluationStep();
        break;
    }
  }
  _resetAfterLShapProcessing() {
    this.lShapeProcessingStep = "idle";
    this.currentLShape = null;
    this.currentCandidateIndex = 0;
    this.lShapeJustProcessed = false;
    this.visualizationMode = "l_shapes";
    this.intersectionPoints = [];
    this.tightRectangle = null;
    this.candidates = [];
    this.bestRoute = null;
    this.lastCollision = null;
    this.collidingCandidate = null;
  }
  _handleIdleStep() {
    this.currentLShape = this.lShapesToProcess.shift();
    if (!this.currentLShape) {
      this.solved = true;
      return;
    }
    this.lShapeProcessingStep = "intersections";
    this.visualizationMode = "l_shapes";
  }
  _handleIntersectionsStep() {
    if (!this.currentLShape.traceId) {
      this.lShapeProcessingStep = "idle";
      return;
    }
    const allObstacles = getTraceObstacles(
      this.input.allTraces,
      this.currentLShape.traceId
    );
    const intersections1 = findIntersectionsWithObstacles(
      this.currentLShape.p1,
      this.currentLShape.p2,
      allObstacles
    );
    const intersections2 = findIntersectionsWithObstacles(
      this.currentLShape.p2,
      this.currentLShape.p3,
      allObstacles
    );
    this.intersectionPoints = [...intersections1, ...intersections2];
    if (intersections1.length === 0 || intersections2.length === 0) {
      this.lShapeProcessingStep = "idle";
      return;
    }
    this.rectangleCandidates = generateRectangleCandidates(
      intersections1,
      intersections2
    );
    this.currentRectangleIndex = 0;
    this.lShapeProcessingStep = "rectangle_selection";
  }
  _handleRectangleSelectionStep() {
    if (this.currentRectangleIndex >= this.rectangleCandidates.length) {
      this.lShapeProcessingStep = "idle";
      return;
    }
    const { rect, i1, i2 } = this.rectangleCandidates[this.currentRectangleIndex];
    this.tightRectangle = rect;
    this.candidates = generateLShapeRerouteCandidates({
      lShape: this.currentLShape,
      rectangle: this.tightRectangle,
      padding: 2 * this.input.paddingBuffer,
      interactionPoint1: i1,
      interactionPoint2: i2
    });
    this.currentCandidateIndex = 0;
    this.lastCollision = null;
    this.collidingCandidate = null;
    this.visualizationMode = "candidates";
    this.lShapeProcessingStep = "candidate_evaluation";
  }
  _handleCandidateEvaluationStep() {
    this.visualizationMode = "candidates";
    if (this.bestRouteFound) {
      this._applyBestRoute(this.bestRouteFound);
      this.bestRouteFound = null;
      return;
    }
    if (this.currentCandidateIndex >= this.candidates.length) {
      this.currentRectangleIndex++;
      this.lShapeProcessingStep = "rectangle_selection";
      return;
    }
    const currentCandidate = this.candidates[this.currentCandidateIndex];
    const collisionResult = isPathColliding(
      currentCandidate,
      this.input.allTraces,
      this.currentLShape.traceId
    );
    if (!collisionResult?.isColliding) {
      this.bestRouteFound = currentCandidate;
      this.lastCollision = null;
      this.collidingCandidate = null;
    } else {
      this.lastCollision = collisionResult;
      this.collidingCandidate = currentCandidate;
      this.currentCandidateIndex++;
    }
  }
  _applyBestRoute(bestRoute) {
    this.bestRoute = bestRoute;
    this.collidingCandidate = null;
    this.lastCollision = null;
    const traceIndex = this.input.allTraces.findIndex(
      (trace) => trace.mspPairId === this.currentLShape.traceId
    );
    if (traceIndex !== -1) {
      const originalTrace = this.input.allTraces[traceIndex];
      const p2Index = originalTrace.tracePath.findIndex(
        (p) => p.x === this.currentLShape.p2.x && p.y === this.currentLShape.p2.y
      );
      if (p2Index !== -1) {
        const newTracePath = [
          ...originalTrace.tracePath.slice(0, p2Index),
          ...bestRoute,
          ...originalTrace.tracePath.slice(p2Index + 1)
        ];
        this.input.allTraces[traceIndex] = {
          ...originalTrace,
          tracePath: newTracePath
        };
        this.lShapesToProcess = this.lShapesToProcess.filter(
          (l) => l.traceId !== this.currentLShape.traceId
        );
      }
    }
    this.lShapeJustProcessed = true;
  }
  getOutput() {
    return { traces: this.input.allTraces };
  }
  visualize() {
    switch (this.visualizationMode) {
      case "l_shapes":
        return visualizeLSapes(this.lShapesToProcess);
      case "intersection_points":
        return mergeGraphicsObjects([
          this.currentLShape ? visualizeLSapes(this.currentLShape) : void 0,
          visualizeIntersectionPoints(this.intersectionPoints)
        ]);
      case "tight_rectangle":
        return mergeGraphicsObjects([
          this.currentLShape ? visualizeLSapes(this.currentLShape) : void 0,
          visualizeIntersectionPoints(this.intersectionPoints),
          this.tightRectangle ? visualizeTightRectangle(this.tightRectangle) : void 0
        ]);
      case "candidates": {
        if (this.lShapeJustProcessed) {
          const allTracesGraphics2 = { lines: [] };
          for (const trace of this.input.allTraces) {
            const isUpdatedTrace = trace.mspPairId === this.currentLShape?.traceId;
            for (let i = 0; i < trace.tracePath.length - 1; i++) {
              allTracesGraphics2.lines.push({
                points: [trace.tracePath[i], trace.tracePath[i + 1]],
                strokeColor: isUpdatedTrace ? "green" : "#ccc"
              });
            }
          }
          return allTracesGraphics2;
        }
        const allTracesGraphics = { lines: [] };
        for (const trace of this.input.allTraces) {
          for (let i = 0; i < trace.tracePath.length - 1; i++) {
            allTracesGraphics.lines.push({
              points: [trace.tracePath[i], trace.tracePath[i + 1]],
              strokeColor: "#ccc"
              // Light gray for other traces
            });
          }
        }
        let candidateToDraw;
        if (this.bestRouteFound) {
          candidateToDraw = this.bestRouteFound;
        } else if (this.lastCollision?.isColliding) {
          candidateToDraw = this.collidingCandidate ?? void 0;
        } else {
          if (this.currentCandidateIndex < this.candidates.length) {
            candidateToDraw = this.candidates[this.currentCandidateIndex];
          }
        }
        return mergeGraphicsObjects([
          allTracesGraphics,
          this.currentLShape ? visualizeLSapes(this.currentLShape) : void 0,
          this.tightRectangle ? visualizeTightRectangle(this.tightRectangle) : void 0,
          candidateToDraw ? visualizeCandidates(
            [candidateToDraw],
            this.bestRouteFound ? "green" : "blue",
            this.intersectionPoints
          ) : void 0,
          this.lastCollision ? visualizeCollision(this.lastCollision) : void 0
        ]);
      }
      default:
        return {};
    }
  }
};

// lib/solvers/TraceCleanupSolver/is4PointRectangle.ts
var is4PointRectangle = (path) => {
  if (path.length !== 4) return false;
  const [p0, p1, p2, p3] = path;
  const isHVHC = p0.y === p1.y && p1.x === p2.x && p2.y === p3.y && p0.x === p3.x;
  const isVHVC = p0.x === p1.x && p1.y === p2.y && p2.x === p3.x && p0.y === p3.y;
  return isHVHC || isVHVC;
};

// lib/solvers/TraceCleanupSolver/TraceCleanupSolver.ts
var TraceCleanupSolver = class extends BaseSolver {
  input;
  outputTraces;
  traceIdQueue;
  tracesMap;
  pipelineStep = "untangling_traces";
  activeTraceId = null;
  // New property
  activeSubSolver = null;
  constructor(solverInput) {
    super();
    this.input = solverInput;
    this.outputTraces = [...solverInput.allTraces];
    this.tracesMap = new Map(this.outputTraces.map((t) => [t.mspPairId, t]));
    this.traceIdQueue = Array.from(
      solverInput.allTraces.map((e) => e.mspPairId)
    );
  }
  _step() {
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      if (this.activeSubSolver.solved) {
        const output = this.activeSubSolver.getOutput();
        this.outputTraces = output.traces;
        this.tracesMap = new Map(this.outputTraces.map((t) => [t.mspPairId, t]));
        this.activeSubSolver = null;
        this.pipelineStep = "minimizing_turns";
      } else if (this.activeSubSolver.failed) {
        this.activeSubSolver = null;
        this.pipelineStep = "minimizing_turns";
      }
      return;
    }
    switch (this.pipelineStep) {
      case "untangling_traces":
        this._runUntangleTracesStep();
        break;
      case "minimizing_turns":
        this._runMinimizeTurnsStep();
        break;
      case "balancing_l_shapes":
        this._runBalanceLShapesStep();
        break;
    }
  }
  _runUntangleTracesStep() {
    this.activeSubSolver = new UntangleTraceSubsolver({
      ...this.input,
      allTraces: Array.from(this.tracesMap.values())
    });
  }
  _runMinimizeTurnsStep() {
    if (this.traceIdQueue.length === 0) {
      this.pipelineStep = "balancing_l_shapes";
      this.traceIdQueue = Array.from(
        this.input.allTraces.map((e) => e.mspPairId)
      );
      return;
    }
    this._processTrace("minimizing_turns");
  }
  _runBalanceLShapesStep() {
    if (this.traceIdQueue.length === 0) {
      this.solved = true;
      return;
    }
    this._processTrace("balancing_l_shapes");
  }
  _processTrace(step) {
    const targetMspConnectionPairId = this.traceIdQueue.shift();
    this.activeTraceId = targetMspConnectionPairId;
    const originalTrace = this.tracesMap.get(targetMspConnectionPairId);
    if (is4PointRectangle(originalTrace.tracePath)) {
      return;
    }
    const allTraces = Array.from(this.tracesMap.values());
    let updatedTrace;
    if (step === "minimizing_turns") {
      updatedTrace = minimizeTurnsWithFilteredLabels({
        ...this.input,
        targetMspConnectionPairId,
        traces: allTraces
      });
    } else {
      updatedTrace = balanceZShapes({
        ...this.input,
        targetMspConnectionPairId,
        traces: allTraces
      });
    }
    this.tracesMap.set(targetMspConnectionPairId, updatedTrace);
    this.outputTraces = Array.from(this.tracesMap.values());
  }
  getOutput() {
    return {
      traces: this.outputTraces
    };
  }
  visualize() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.visualize();
    }
    const graphics = visualizeInputProblem(this.input.inputProblem, {
      chipAlpha: 0.1,
      connectionAlpha: 0.1
    });
    if (!graphics.lines) graphics.lines = [];
    if (!graphics.points) graphics.points = [];
    if (!graphics.rects) graphics.rects = [];
    if (!graphics.circles) graphics.circles = [];
    if (!graphics.texts) graphics.texts = [];
    for (const trace of this.outputTraces) {
      const line = {
        points: trace.tracePath.map((p) => ({ x: p.x, y: p.y })),
        strokeColor: trace.mspPairId === this.activeTraceId ? "red" : "blue"
        // Highlight active trace
      };
      graphics.lines.push(line);
    }
    return graphics;
  }
};

// lib/solvers/SchematicTracePipelineSolver/SchematicTracePipelineSolver.ts
function definePipelineStep(solverName, solverClass, getConstructorParams, opts = {}) {
  return {
    solverName,
    solverClass,
    getConstructorParams,
    onSolved: opts.onSolved,
    shouldSkip: opts.shouldSkip
  };
}
var SchematicTracePipelineSolver = class extends BaseSolver {
  mspConnectionPairSolver;
  // guidelinesSolver?: GuidelinesSolver
  schematicTraceLinesSolver;
  longDistancePairSolver;
  traceOverlapShiftSolver;
  netLabelPlacementSolver;
  labelMergingSolver;
  traceLabelOverlapAvoidanceSolver;
  traceCleanupSolver;
  startTimeOfPhase;
  endTimeOfPhase;
  timeSpentOnPhase;
  firstIterationOfPhase;
  inputProblem;
  pipelineDef = [
    definePipelineStep(
      "mspConnectionPairSolver",
      MspConnectionPairSolver,
      () => [{ inputProblem: this.inputProblem }],
      {
        onSolved: (mspSolver) => {
        }
      }
    ),
    // definePipelineStep(
    //   "guidelinesSolver",
    //   GuidelinesSolver,
    //   () => [
    //     {
    //       inputProblem: this.inputProblem,
    //     },
    //   ],
    //   {
    //     onSolved: (guidelinesSolver) => {},
    //   },
    // ),
    definePipelineStep(
      "schematicTraceLinesSolver",
      SchematicTraceLinesSolver,
      () => [
        {
          mspConnectionPairs: this.mspConnectionPairSolver.mspConnectionPairs,
          dcConnMap: this.mspConnectionPairSolver.dcConnMap,
          globalConnMap: this.mspConnectionPairSolver.globalConnMap,
          inputProblem: this.inputProblem,
          // guidelines: this.guidelinesSolver!.guidelines,
          chipMap: this.mspConnectionPairSolver.chipMap
        }
      ]
    ),
    definePipelineStep(
      "longDistancePairSolver",
      LongDistancePairSolver,
      (instance) => [
        {
          inputProblem: instance.inputProblem,
          primaryMspConnectionPairs: instance.mspConnectionPairSolver.mspConnectionPairs,
          alreadySolvedTraces: instance.schematicTraceLinesSolver.solvedTracePaths
        }
      ],
      {
        onSolved: (schematicTraceLinesSolver) => {
        }
      }
    ),
    definePipelineStep(
      "traceOverlapShiftSolver",
      TraceOverlapShiftSolver,
      () => [
        {
          inputProblem: this.inputProblem,
          inputTracePaths: this.longDistancePairSolver?.getOutput().allTracesMerged,
          globalConnMap: this.mspConnectionPairSolver.globalConnMap
        }
      ],
      {
        onSolved: (_solver) => {
        }
      }
    ),
    definePipelineStep(
      "netLabelPlacementSolver",
      NetLabelPlacementSolver,
      () => [
        {
          inputProblem: this.inputProblem,
          inputTraceMap: this.traceOverlapShiftSolver?.correctedTraceMap ?? Object.fromEntries(
            this.longDistancePairSolver.getOutput().allTracesMerged.map(
              (p) => [p.mspPairId, p]
            )
          )
        }
      ],
      {
        onSolved: (_solver) => {
        }
      }
    ),
    definePipelineStep(
      "traceLabelOverlapAvoidanceSolver",
      TraceLabelOverlapAvoidanceSolver,
      (instance) => {
        const traceMap = instance.traceOverlapShiftSolver?.correctedTraceMap ?? Object.fromEntries(
          instance.longDistancePairSolver.getOutput().allTracesMerged.map((p) => [p.mspPairId, p])
        );
        const traces = Object.values(traceMap);
        const netLabelPlacements = instance.netLabelPlacementSolver.netLabelPlacements;
        return [
          {
            inputProblem: instance.inputProblem,
            traces,
            netLabelPlacements
          }
        ];
      }
    ),
    definePipelineStep("traceCleanupSolver", TraceCleanupSolver, (instance) => {
      const prevSolverOutput = instance.traceLabelOverlapAvoidanceSolver.getOutput();
      const traces = prevSolverOutput.traces;
      const labelMergingOutput = instance.traceLabelOverlapAvoidanceSolver.labelMergingSolver.getOutput();
      return [
        {
          inputProblem: instance.inputProblem,
          allTraces: traces,
          allLabelPlacements: labelMergingOutput.netLabelPlacements,
          mergedLabelNetIdMap: labelMergingOutput.mergedLabelNetIdMap,
          paddingBuffer: 0.1
        }
      ];
    }),
    definePipelineStep(
      "netLabelPlacementSolver",
      NetLabelPlacementSolver,
      (instance) => {
        const traces = instance.traceCleanupSolver?.getOutput().traces ?? instance.traceLabelOverlapAvoidanceSolver.getOutput().traces;
        return [
          {
            inputProblem: instance.inputProblem,
            inputTraceMap: Object.fromEntries(
              traces.map((trace) => [trace.mspPairId, trace])
            )
          }
        ];
      }
    )
  ];
  constructor(inputProblem) {
    super();
    this.inputProblem = this.cloneAndCorrectInputProblem(inputProblem);
    this.MAX_ITERATIONS = 1e6;
    this.startTimeOfPhase = {};
    this.endTimeOfPhase = {};
    this.timeSpentOnPhase = {};
    this.firstIterationOfPhase = {};
  }
  getConstructorParams() {
    return this.inputProblem;
  }
  currentPipelineStepIndex = 0;
  cloneAndCorrectInputProblem(original) {
    const cloned = structuredClone({
      ...original,
      _chipObstacleSpatialIndex: void 0
    });
    expandChipsToFitPins(cloned);
    correctPinsInsideChips(cloned);
    return cloned;
  }
  _step() {
    const pipelineStepDef = this.pipelineDef[this.currentPipelineStepIndex];
    if (!pipelineStepDef) {
      this.solved = true;
      return;
    }
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      if (this.activeSubSolver.solved) {
        this.endTimeOfPhase[pipelineStepDef.solverName] = performance.now();
        this.timeSpentOnPhase[pipelineStepDef.solverName] = this.endTimeOfPhase[pipelineStepDef.solverName] - this.startTimeOfPhase[pipelineStepDef.solverName];
        pipelineStepDef.onSolved?.(this);
        this.activeSubSolver = null;
        this.currentPipelineStepIndex++;
      } else if (this.activeSubSolver.failed) {
        this.error = this.activeSubSolver?.error;
        this.failed = true;
        this.activeSubSolver = null;
      }
      return;
    }
    const constructorParams = pipelineStepDef.getConstructorParams(this);
    this.activeSubSolver = new pipelineStepDef.solverClass(...constructorParams);
    this[pipelineStepDef.solverName] = this.activeSubSolver;
    this.timeSpentOnPhase[pipelineStepDef.solverName] = 0;
    this.startTimeOfPhase[pipelineStepDef.solverName] = performance.now();
    this.firstIterationOfPhase[pipelineStepDef.solverName] = this.iterations;
  }
  solveUntilPhase(phase) {
    while (this.getCurrentPhase().toLowerCase() !== phase.toLowerCase()) {
      this.step();
    }
  }
  getCurrentPhase() {
    return this.pipelineDef[this.currentPipelineStepIndex]?.solverName ?? "none";
  }
  visualize() {
    if (!this.solved && this.activeSubSolver)
      return this.activeSubSolver.visualize();
    const visualizations = [
      visualizeInputProblem(this.inputProblem),
      ...this.pipelineDef.map((p) => this[p.solverName]?.visualize()).filter(Boolean).map((viz, stepIndex) => {
        for (const rect of viz.rects ?? []) {
          rect.step = stepIndex;
        }
        for (const point of viz.points ?? []) {
          point.step = stepIndex;
        }
        for (const circle of viz.circles ?? []) {
          circle.step = stepIndex;
        }
        for (const text of viz.texts ?? []) {
          text.step = stepIndex;
        }
        for (const line of viz.lines ?? []) {
          line.step = stepIndex;
        }
        return viz;
      })
    ];
    if (visualizations.length === 1) {
      return visualizations[0];
    }
    const finalGraphics = {
      points: visualizations.flatMap((v) => v.points || []),
      rects: visualizations.flatMap((v) => v.rects || []),
      lines: visualizations.flatMap((v) => v.lines || []),
      circles: visualizations.flatMap((v) => v.circles || []),
      texts: visualizations.flatMap((v) => v.texts || [])
    };
    return finalGraphics;
  }
  /**
   * A lightweight version of the visualize method that can be used to stream
   * progress
   */
  preview() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.preview();
    }
    return super.preview();
  }
};
export {
  SchematicTracePipelineSolver,
  SchematicTraceSingleLineSolver2
};
