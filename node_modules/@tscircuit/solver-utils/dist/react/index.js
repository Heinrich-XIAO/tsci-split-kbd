// lib/react/GenericSolverDebugger.tsx
import React2, { useEffect as useEffect3, useMemo, useReducer as useReducer2 } from "react";
import { InteractiveGraphics } from "graphics-debug/react";

// lib/react/GenericSolverToolbar.tsx
import { useReducer, useRef as useRef2, useEffect as useEffect2 } from "react";

// lib/react/DownloadDropdown.tsx
import { useState, useRef, useEffect } from "react";
import { jsx, jsxs } from "react/jsx-runtime";
var deepRemoveUnderscoreProperties = (obj) => {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(deepRemoveUnderscoreProperties);
  }
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (!key.startsWith("_")) {
      result[key] = deepRemoveUnderscoreProperties(value);
    }
  }
  return result;
};
var DownloadDropdown = ({
  solver,
  className = ""
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const downloadJSON = () => {
    try {
      if (typeof solver.getConstructorParams !== "function") {
        alert(
          `getConstructorParams() is not implemented for ${solver.constructor.name}`
        );
        return;
      }
      const params = deepRemoveUnderscoreProperties(
        solver.getConstructorParams()
      );
      const blob = new Blob([JSON.stringify(params, null, 2)], {
        type: "application/json"
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${solver.constructor.name}_params.json`;
      a.click();
      URL.revokeObjectURL(url);
    } catch (error) {
      alert(
        `Error downloading params for ${solver.constructor.name}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
    setIsOpen(false);
  };
  const downloadPageTsx = () => {
    try {
      const params = deepRemoveUnderscoreProperties(
        solver.getConstructorParams()
      );
      const solverName = solver.constructor.name;
      const isSchematicTracePipelineSolver = solverName === "SchematicTracePipelineSolver";
      let content;
      if (isSchematicTracePipelineSolver) {
        content = `import { PipelineDebugger } from "site/components/PipelineDebugger"
import type { InputProblem } from "lib/types/InputProblem"

const inputProblem: InputProblem = ${JSON.stringify(params, null, 2)}

export default () => <PipelineDebugger inputProblem={inputProblem} />
`;
      } else {
        content = `import { useMemo } from "react"
import { GenericSolverDebugger } from "../components/GenericSolverDebugger"
import { ${solverName} } from "lib/solvers/${solverName}/${solverName}"

export const inputProblem = ${JSON.stringify(params, null, 2)}

export default () => {
  const solver = useMemo(() => {
    return new ${solverName}(inputProblem as any)
  }, [])
  return <GenericSolverDebugger solver={solver} />
}
`;
      }
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${solverName}.page.tsx`;
      a.click();
      URL.revokeObjectURL(url);
    } catch (error) {
      alert(
        `Error generating page.tsx for ${solver.constructor.name}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
    setIsOpen(false);
  };
  const downloadTestTs = () => {
    try {
      const params = deepRemoveUnderscoreProperties(
        solver.getConstructorParams()
      );
      const solverName = solver.constructor.name;
      const content = `import { ${solverName} } from "lib/solvers/${solverName}/${solverName}"
import { test, expect } from "bun:test"

test("${solverName} should solve problem correctly", () => {
  const input = ${JSON.stringify(params, null, 2)}
  
  const solver = new ${solverName}(input as any)
  solver.solve()

  expect(solver).toMatchSolverSnapshot(import.meta.path)
  
  // Add more specific assertions based on expected output
  // expect(solver.netLabelPlacementSolver!.netLabelPlacements).toMatchInlineSnapshot()
})
`;
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${solverName}.test.ts`;
      a.click();
      URL.revokeObjectURL(url);
    } catch (error) {
      alert(
        `Error generating test.ts for ${solver.constructor.name}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
    setIsOpen(false);
  };
  return /* @__PURE__ */ jsxs("div", { className: `relative ${className}`, ref: dropdownRef, children: [
    /* @__PURE__ */ jsx(
      "button",
      {
        className: "px-2 py-1 rounded text-xs cursor-pointer",
        onClick: () => setIsOpen(!isOpen),
        title: `Download options for ${solver.constructor.name}`,
        children: solver.constructor.name
      }
    ),
    isOpen && /* @__PURE__ */ jsxs("div", { className: "absolute top-full left-0 mt-1 bg-white border border-gray-300 rounded shadow-lg z-10 min-w-[150px]", children: [
      /* @__PURE__ */ jsx(
        "button",
        {
          className: "w-full text-left px-3 py-2 hover:bg-gray-100 text-xs",
          onClick: downloadJSON,
          children: "Download JSON"
        }
      ),
      /* @__PURE__ */ jsx(
        "button",
        {
          className: "w-full text-left px-3 py-2 hover:bg-gray-100 text-xs",
          onClick: downloadPageTsx,
          children: "Download page.tsx"
        }
      ),
      /* @__PURE__ */ jsx(
        "button",
        {
          className: "w-full text-left px-3 py-2 hover:bg-gray-100 text-xs",
          onClick: downloadTestTs,
          children: "Download test.ts"
        }
      )
    ] })
  ] });
};

// lib/react/SolverBreadcrumbInputDownloader.tsx
import { jsx as jsx2, jsxs as jsxs2 } from "react/jsx-runtime";
var getSolverChain = (solver) => {
  if (!solver.activeSubSolver) {
    return [solver];
  }
  return [solver, ...getSolverChain(solver.activeSubSolver)];
};
var SolverBreadcrumbInputDownloader = ({
  solver
}) => {
  const solverChain = getSolverChain(solver);
  return /* @__PURE__ */ jsx2("div", { className: "flex gap-1 items-center text-sm pt-1", children: solverChain.map((s, index) => /* @__PURE__ */ jsxs2("div", { className: "flex items-center", children: [
    index > 0 && /* @__PURE__ */ jsx2("span", { className: "text-gray-400 mx-1", children: "\u2192" }),
    /* @__PURE__ */ jsx2(DownloadDropdown, { solver: s })
  ] }, s.constructor.name)) });
};

// lib/react/GenericSolverToolbar.tsx
import { jsx as jsx3, jsxs as jsxs3 } from "react/jsx-runtime";
var GenericSolverToolbar = ({
  solver,
  triggerRender,
  animationSpeed = 25,
  onSolverStarted,
  onSolverCompleted
}) => {
  const [isAnimating, setIsAnimating] = useReducer((x) => !x, false);
  const animationRef = useRef2(void 0);
  const handleStep = () => {
    if (!solver.solved && !solver.failed) {
      solver.step();
      triggerRender();
    }
  };
  const handleSolve = () => {
    if (!solver.solved && !solver.failed) {
      if (onSolverStarted) {
        onSolverStarted(solver);
      }
      solver.solve();
      triggerRender();
      if (onSolverCompleted) {
        onSolverCompleted(solver);
      }
    }
  };
  const handleAnimate = () => {
    if (isAnimating) {
      if (animationRef.current) {
        clearInterval(animationRef.current);
        animationRef.current = void 0;
      }
      setIsAnimating();
    } else {
      setIsAnimating();
      animationRef.current = setInterval(() => {
        if (solver.solved || solver.failed) {
          if (animationRef.current) {
            clearInterval(animationRef.current);
            animationRef.current = void 0;
          }
          setIsAnimating();
          triggerRender();
          if (onSolverCompleted && solver.solved) {
            onSolverCompleted(solver);
          }
          return;
        }
        solver.step();
        triggerRender();
      }, animationSpeed);
    }
  };
  const handleNextStage = () => {
    const pipelineSolver = solver;
    if (pipelineSolver.getCurrentPhase && !solver.solved && !solver.failed) {
      const initialPhase = pipelineSolver.getCurrentPhase();
      while (pipelineSolver.getCurrentPhase() === initialPhase && !solver.solved && !solver.failed) {
        solver.step();
      }
      triggerRender();
    }
  };
  useEffect2(() => {
    return () => {
      if (animationRef.current) {
        clearInterval(animationRef.current);
      }
    };
  }, []);
  useEffect2(() => {
    if ((solver.solved || solver.failed) && isAnimating) {
      if (animationRef.current) {
        clearInterval(animationRef.current);
        animationRef.current = void 0;
      }
      setIsAnimating();
    }
  }, [solver.solved, solver.failed, isAnimating]);
  const isPipelineSolver = solver.getCurrentPhase !== void 0;
  const currentPhase = isPipelineSolver ? solver.getCurrentPhase() : null;
  return /* @__PURE__ */ jsxs3("div", { className: "space-y-2 p-2 border-b", children: [
    /* @__PURE__ */ jsx3("div", { className: "flex items-center", children: /* @__PURE__ */ jsx3(SolverBreadcrumbInputDownloader, { solver }) }),
    /* @__PURE__ */ jsxs3("div", { className: "flex gap-2 items-center flex-wrap", children: [
      /* @__PURE__ */ jsx3(
        "button",
        {
          onClick: handleStep,
          disabled: solver.solved || solver.failed || isAnimating,
          className: "bg-blue-500 hover:bg-blue-600 disabled:bg-gray-300 text-white px-3 py-1 rounded text-sm",
          children: "Step"
        }
      ),
      /* @__PURE__ */ jsx3(
        "button",
        {
          onClick: handleSolve,
          disabled: solver.solved || solver.failed || isAnimating,
          className: "bg-green-500 hover:bg-green-600 disabled:bg-gray-300 text-white px-3 py-1 rounded text-sm",
          children: "Solve"
        }
      ),
      /* @__PURE__ */ jsx3(
        "button",
        {
          onClick: handleAnimate,
          disabled: solver.solved || solver.failed,
          className: `px-3 py-1 rounded text-white text-sm ${isAnimating ? "bg-red-500 hover:bg-red-600" : "bg-yellow-500 hover:bg-yellow-600"} disabled:bg-gray-300`,
          children: isAnimating ? "Stop" : "Animate"
        }
      ),
      isPipelineSolver && /* @__PURE__ */ jsx3(
        "button",
        {
          onClick: handleNextStage,
          disabled: solver.solved || solver.failed || isAnimating,
          className: "bg-purple-500 hover:bg-purple-600 disabled:bg-gray-300 text-white px-3 py-1 rounded text-sm",
          children: "Next Stage"
        }
      ),
      /* @__PURE__ */ jsxs3("div", { className: "text-sm text-gray-600", children: [
        "Iterations: ",
        solver.iterations
      ] }),
      solver.timeToSolve !== void 0 && /* @__PURE__ */ jsxs3("div", { className: "text-sm text-gray-600", children: [
        "Time: ",
        (solver.timeToSolve / 1e3).toFixed(3),
        "s"
      ] }),
      currentPhase && /* @__PURE__ */ jsxs3("div", { className: "text-sm text-gray-600", children: [
        "Phase: ",
        /* @__PURE__ */ jsx3("span", { className: "font-medium", children: currentPhase })
      ] }),
      solver.solved && /* @__PURE__ */ jsx3("div", { className: "px-2 py-1 bg-green-100 text-green-800 rounded text-sm", children: "Solved" }),
      solver.failed && /* @__PURE__ */ jsx3("div", { className: "px-2 py-1 bg-red-100 text-red-800 rounded text-sm", children: "Failed" })
    ] }),
    solver.error && /* @__PURE__ */ jsxs3("div", { className: "text-red-600 text-sm", children: [
      "Error: ",
      solver.error
    ] })
  ] });
};

// lib/react/GenericSolverDebugger.tsx
import { jsx as jsx4, jsxs as jsxs4 } from "react/jsx-runtime";
var ErrorBoundary = class extends React2.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(error) {
    console.error("InteractiveGraphics render error:", error);
  }
  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
};
function SimpleGraphicsSVG({ graphics }) {
  const points = graphics.points ?? [];
  const lines = graphics.lines ?? [];
  const rects = graphics.rects ?? [];
  const circles = graphics.circles ?? [];
  const texts = graphics.texts ?? [];
  let minX = Number.POSITIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  const consider = (x, y) => {
    if (typeof x === "number") {
      if (x < minX) minX = x;
      if (x > maxX) maxX = x;
    }
    if (typeof y === "number") {
      if (y < minY) minY = y;
      if (y > maxY) maxY = y;
    }
  };
  for (const p of points) consider(p.x, p.y);
  for (const l of lines) {
    const pts = l.points ?? [];
    for (const p of pts) consider(p.x, p.y);
  }
  for (const r of rects) {
    const x = r.x ?? 0;
    const y = r.y ?? 0;
    const w = r.width ?? 0;
    const h = r.height ?? 0;
    consider(x, y);
    consider(x + w, y + h);
  }
  for (const c of circles) {
    const x = c.x ?? 0;
    const y = c.y ?? 0;
    const rad = c.radius ?? 1;
    consider(x - rad, y - rad);
    consider(x + rad, y + rad);
  }
  for (const t of texts) consider(t.x, t.y);
  if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) {
    minX = -20;
    minY = -20;
    maxX = 20;
    maxY = 20;
  }
  const pad = 10;
  const vbX = minX - pad;
  const vbY = minY - pad;
  const vbW = Math.max(1, maxX - minX + 2 * pad);
  const vbH = Math.max(1, maxY - minY + 2 * pad);
  return /* @__PURE__ */ jsxs4(
    "svg",
    {
      className: "w-full h-[400px] bg-white",
      viewBox: `${vbX} ${vbY} ${vbW} ${vbH}`,
      role: "img",
      "aria-label": "Graphics fallback",
      children: [
        rects.map((r, i) => /* @__PURE__ */ jsx4(
          "rect",
          {
            x: r.x ?? 0,
            y: r.y ?? 0,
            width: r.width ?? 0,
            height: r.height ?? 0,
            fill: "none",
            stroke: r.strokeColor ?? "black",
            strokeWidth: r.strokeWidth ?? 1
          },
          `rect-${i}`
        )),
        lines.map((l, i) => /* @__PURE__ */ jsx4(
          "polyline",
          {
            fill: "none",
            stroke: l.strokeColor ?? "black",
            strokeWidth: l.strokeWidth ?? 1,
            points: (l.points ?? []).map((p) => `${p.x ?? 0},${p.y ?? 0}`).join(" ")
          },
          `line-${i}`
        )),
        circles.map((c, i) => /* @__PURE__ */ jsx4(
          "circle",
          {
            cx: c.x ?? 0,
            cy: c.y ?? 0,
            r: c.radius ?? 1.5,
            fill: c.fillColor ?? "none",
            stroke: c.strokeColor ?? "black",
            strokeWidth: c.strokeWidth ?? 1
          },
          `circle-${i}`
        )),
        points.map((p, i) => /* @__PURE__ */ jsx4(
          "circle",
          {
            cx: p.x ?? 0,
            cy: p.y ?? 0,
            r: p.radius ?? 1.5,
            fill: p.color ?? "black"
          },
          `point-${i}`
        )),
        texts.map((t, i) => /* @__PURE__ */ jsx4(
          "text",
          {
            x: t.x ?? 0,
            y: t.y ?? 0,
            fontSize: t.fontSize ?? 10,
            fill: t.color ?? "black",
            children: t.text ?? ""
          },
          `text-${i}`
        ))
      ]
    }
  );
}
var GenericSolverDebugger = ({
  solver,
  animationSpeed = 25,
  onSolverStarted,
  onSolverCompleted
}) => {
  const [renderCount, incRenderCount] = useReducer2((x) => x + 1, 0);
  const visualization = useMemo(() => {
    try {
      return solver.visualize() || { points: [], lines: [], rects: [], circles: [] };
    } catch (error) {
      console.error("Visualization error:", error);
      return { points: [], lines: [], rects: [], circles: [] };
    }
  }, [solver, renderCount]);
  const graphicsAreEmpty = useMemo(
    () => (visualization.rects?.length || 0) === 0 && (visualization.lines?.length || 0) === 0 && (visualization.points?.length || 0) === 0 && (visualization.circles?.length || 0) === 0,
    [visualization]
  );
  useEffect3(() => {
    if (typeof document === "undefined") return;
    if (!document.querySelector(
      'script[src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"]'
    )) {
      const script = document.createElement("script");
      script.src = "https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4";
      document.head.appendChild(script);
    }
  }, []);
  return /* @__PURE__ */ jsxs4("div", { children: [
    /* @__PURE__ */ jsx4(
      GenericSolverToolbar,
      {
        solver,
        triggerRender: incRenderCount,
        animationSpeed,
        onSolverStarted,
        onSolverCompleted
      }
    ),
    graphicsAreEmpty ? /* @__PURE__ */ jsx4("div", { className: "p-4 text-gray-500", children: "No Graphics Yet" }) : /* @__PURE__ */ jsx4(
      ErrorBoundary,
      {
        fallback: /* @__PURE__ */ jsx4(SimpleGraphicsSVG, { graphics: visualization }),
        children: /* @__PURE__ */ jsx4(InteractiveGraphics, { graphics: visualization })
      }
    )
  ] });
};
export {
  DownloadDropdown,
  GenericSolverDebugger,
  GenericSolverToolbar,
  SolverBreadcrumbInputDownloader,
  getSolverChain
};
