// lib/BaseSolver.ts
var BaseSolver = class {
  MAX_ITERATIONS = 1e5;
  solved = false;
  failed = false;
  iterations = 0;
  progress = 0;
  error = null;
  activeSubSolver;
  failedSubSolvers;
  timeToSolve;
  stats = {};
  _setupDone = false;
  setup() {
    if (this._setupDone) return;
    this._setup();
    this._setupDone = true;
  }
  /** Override this method to perform setup logic */
  _setup() {
  }
  /** DO NOT OVERRIDE! Override _step() instead */
  step() {
    if (!this._setupDone) {
      this.setup();
    }
    if (this.solved) return;
    if (this.failed) return;
    this.iterations++;
    try {
      this._step();
    } catch (e) {
      this.error = `${this.constructor.name} error: ${e}`;
      console.error(this.error);
      this.failed = true;
      throw e;
    }
    if (!this.solved && this.iterations >= this.MAX_ITERATIONS) {
      this.tryFinalAcceptance();
    }
    if (!this.solved && this.iterations >= this.MAX_ITERATIONS) {
      this.error = `${this.constructor.name} ran out of iterations`;
      console.error(this.error);
      this.failed = true;
    }
    if ("computeProgress" in this) {
      this.progress = this.computeProgress();
    }
  }
  /** Override this method to implement solver logic */
  _step() {
  }
  getConstructorParams() {
    throw new Error("getConstructorParams not implemented");
  }
  /**
   * Override this method to return the standardized output of the solver.
   * This method should only be called after the solver has completed successfully.
   * Returns null by default - solvers with outputs should override this method.
   */
  getOutput() {
    return null;
  }
  solve() {
    const startTime = Date.now();
    while (!this.solved && !this.failed) {
      this.step();
    }
    const endTime = Date.now();
    this.timeToSolve = endTime - startTime;
  }
  visualize() {
    return {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
  }
  /**
   * Called when the solver is about to fail, but we want to see if we have an
   * "acceptable" or "passable" solution. Mostly used for optimizers that
   * have an aggressive early stopping criterion.
   */
  tryFinalAcceptance() {
  }
  /**
   * A lightweight version of the visualize method that can be used to stream
   * progress
   */
  preview() {
    return {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
  }
};

// lib/BasePipelineSolver.ts
function definePipelineStep(solverName, solverClass, getConstructorParams, opts = {}) {
  return {
    solverName,
    solverClass,
    getConstructorParams,
    onSolved: opts.onSolved
  };
}
var BasePipelineSolver = class extends BaseSolver {
  startTimeOfPhase = {};
  endTimeOfPhase = {};
  timeSpentOnPhase = {};
  firstIterationOfPhase = {};
  currentPipelineStepIndex = 0;
  inputProblem;
  /** Stores the outputs from each completed pipeline step */
  pipelineOutputs = {};
  constructor(inputProblem) {
    super();
    this.inputProblem = inputProblem;
    this.MAX_ITERATIONS = 1e6;
  }
  _step() {
    const pipelineStepDef = this.pipelineDef[this.currentPipelineStepIndex];
    if (!pipelineStepDef) {
      this.solved = true;
      return;
    }
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      if (this.activeSubSolver.solved) {
        this.endTimeOfPhase[pipelineStepDef.solverName] = performance.now();
        this.timeSpentOnPhase[pipelineStepDef.solverName] = this.endTimeOfPhase[pipelineStepDef.solverName] - this.startTimeOfPhase[pipelineStepDef.solverName];
        const output = this.activeSubSolver.getOutput();
        if (output !== null) {
          this.pipelineOutputs[pipelineStepDef.solverName] = output;
        }
        pipelineStepDef.onSolved?.(this);
        this.activeSubSolver = null;
        this.currentPipelineStepIndex++;
      } else if (this.activeSubSolver.failed) {
        this.error = this.activeSubSolver?.error;
        this.failed = true;
        this.activeSubSolver = null;
      }
      return;
    }
    const constructorParams = pipelineStepDef.getConstructorParams(this);
    this.activeSubSolver = new pipelineStepDef.solverClass(...constructorParams);
    this[pipelineStepDef.solverName] = this.activeSubSolver;
    this.timeSpentOnPhase[pipelineStepDef.solverName] = 0;
    this.startTimeOfPhase[pipelineStepDef.solverName] = performance.now();
    this.firstIterationOfPhase[pipelineStepDef.solverName] = this.iterations;
  }
  solveUntilPhase(phase) {
    while (this.getCurrentPhase().toLowerCase() !== phase.toLowerCase()) {
      this.step();
      if (this.failed || this.solved) break;
    }
  }
  getCurrentPhase() {
    return this.pipelineDef[this.currentPipelineStepIndex]?.solverName ?? "none";
  }
  getPhaseProgress() {
    const totalPhases = this.pipelineDef.length;
    if (totalPhases === 0) return 1;
    const currentPhaseProgress = this.activeSubSolver?.progress ?? 0;
    return (this.currentPipelineStepIndex + currentPhaseProgress) / totalPhases;
  }
  getPhaseStats() {
    const stats = {};
    for (const step of this.pipelineDef) {
      const timeSpent = this.timeSpentOnPhase[step.solverName] || 0;
      const firstIteration = this.firstIterationOfPhase[step.solverName] || 0;
      const currentIteration = this.iterations;
      const iterations = step.solverName === this.getCurrentPhase() ? currentIteration - firstIteration : 0;
      const completed = this.currentPipelineStepIndex > this.pipelineDef.findIndex((s) => s.solverName === step.solverName);
      stats[step.solverName] = {
        timeSpent,
        iterations,
        completed
      };
    }
    return stats;
  }
  visualize() {
    if (!this.solved && this.activeSubSolver) {
      return this.activeSubSolver.visualize();
    }
    const visualizations = this.pipelineDef.map((step, stepIndex) => {
      const solver = this[step.solverName];
      const viz = solver?.visualize();
      if (!viz) return null;
      for (const rect of viz.rects ?? []) {
        rect.step = stepIndex;
      }
      for (const point of viz.points ?? []) {
        point.step = stepIndex;
      }
      for (const circle of viz.circles ?? []) {
        circle.step = stepIndex;
      }
      for (const text of viz.texts ?? []) {
        text.step = stepIndex;
      }
      for (const line of viz.lines ?? []) {
        line.step = stepIndex;
      }
      return viz;
    }).filter(Boolean);
    if (visualizations.length === 0) {
      return { points: [], rects: [], lines: [], circles: [], texts: [] };
    }
    if (visualizations.length === 1) {
      return visualizations[0];
    }
    return {
      points: visualizations.flatMap((v) => v.points || []),
      rects: visualizations.flatMap((v) => v.rects || []),
      lines: visualizations.flatMap((v) => v.lines || []),
      circles: visualizations.flatMap((v) => v.circles || []),
      texts: visualizations.flatMap((v) => v.texts || [])
    };
  }
  preview() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.preview();
    }
    return super.preview();
  }
  computeProgress() {
    return this.getPhaseProgress();
  }
  /**
   * Get the output from a specific pipeline step
   */
  getStepOutput(stepName) {
    return this.pipelineOutputs[stepName];
  }
  /**
   * Get all pipeline outputs
   */
  getAllOutputs() {
    return { ...this.pipelineOutputs };
  }
  /**
   * Check if a step has completed and produced output
   */
  hasStepOutput(stepName) {
    return stepName in this.pipelineOutputs;
  }
  /**
   * Get a solver instance by name
   */
  getSolver(stepName) {
    return this[stepName];
  }
};
export {
  BasePipelineSolver,
  BaseSolver,
  definePipelineStep
};
