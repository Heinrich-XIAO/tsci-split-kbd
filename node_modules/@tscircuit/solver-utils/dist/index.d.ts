import { GraphicsObject } from 'graphics-debug';

/**
 * A base class for solvers implementing the standard solve() interface.
 *
 * Solvers should override _step() to implement their logic.
 *
 * Solvers should override visualize() to return a GraphicsObject representing
 * the current state of the solver.
 *
 * Solvers should override getConstructorParams() to return the parameters
 * needed to construct the solver.
 */
declare class BaseSolver {
    MAX_ITERATIONS: number;
    solved: boolean;
    failed: boolean;
    iterations: number;
    progress: number;
    error: string | null;
    activeSubSolver?: BaseSolver | null;
    failedSubSolvers?: BaseSolver[];
    timeToSolve?: number;
    stats: Record<string, any>;
    _setupDone: boolean;
    setup(): void;
    /** Override this method to perform setup logic */
    _setup(): void;
    /** DO NOT OVERRIDE! Override _step() instead */
    step(): void;
    /** Override this method to implement solver logic */
    _step(): void;
    getConstructorParams(): void;
    /**
     * Override this method to return the standardized output of the solver.
     * This method should only be called after the solver has completed successfully.
     * Returns null by default - solvers with outputs should override this method.
     */
    getOutput(): any;
    solve(): void;
    visualize(): GraphicsObject;
    /**
     * Called when the solver is about to fail, but we want to see if we have an
     * "acceptable" or "passable" solution. Mostly used for optimizers that
     * have an aggressive early stopping criterion.
     */
    tryFinalAcceptance(): void;
    /**
     * A lightweight version of the visualize method that can be used to stream
     * progress
     */
    preview(): GraphicsObject;
}

interface PipelineStep<T extends BaseSolver> {
    solverName: string;
    solverClass: new (...args: any[]) => T;
    getConstructorParams: (pipelineInstance: any) => any[];
    onSolved?: (pipelineInstance: any) => void;
}
declare function definePipelineStep<T extends BaseSolver, P, Instance extends BasePipelineSolver<any>>(solverName: string, solverClass: new (params: P) => T, getConstructorParams: (instance: Instance) => [P], opts?: {
    onSolved?: (instance: Instance) => void;
}): PipelineStep<T>;
declare abstract class BasePipelineSolver<TInput> extends BaseSolver {
    startTimeOfPhase: Record<string, number>;
    endTimeOfPhase: Record<string, number>;
    timeSpentOnPhase: Record<string, number>;
    firstIterationOfPhase: Record<string, number>;
    currentPipelineStepIndex: number;
    inputProblem: TInput;
    /** Stores the outputs from each completed pipeline step */
    pipelineOutputs: Record<string, any>;
    abstract pipelineDef: PipelineStep<any>[];
    constructor(inputProblem: TInput);
    _step(): void;
    solveUntilPhase(phase: string): void;
    getCurrentPhase(): string;
    getPhaseProgress(): number;
    getPhaseStats(): Record<string, {
        timeSpent: number;
        iterations: number;
        completed: boolean;
    }>;
    visualize(): GraphicsObject;
    preview(): GraphicsObject;
    computeProgress(): number;
    /**
     * Get the output from a specific pipeline step
     */
    getStepOutput<T = any>(stepName: string): T | undefined;
    /**
     * Get all pipeline outputs
     */
    getAllOutputs(): Record<string, any>;
    /**
     * Check if a step has completed and produced output
     */
    hasStepOutput(stepName: string): boolean;
    /**
     * Get a solver instance by name
     */
    getSolver<T extends BaseSolver>(stepName: string): T | undefined;
}

export { BasePipelineSolver, BaseSolver, type PipelineStep, definePipelineStep };
