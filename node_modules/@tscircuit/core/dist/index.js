var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// lib/components/index.ts
var components_exports = {};
__export(components_exports, {
  AnalogSimulation: () => AnalogSimulation,
  Battery: () => Battery,
  Board: () => Board,
  Breakout: () => Breakout,
  BreakoutPoint: () => BreakoutPoint,
  CadAssembly: () => CadAssembly,
  CadModel: () => CadModel,
  Capacitor: () => Capacitor,
  Chip: () => Chip,
  Constraint: () => Constraint3,
  CopperPour: () => CopperPour,
  Crystal: () => Crystal,
  Cutout: () => Cutout,
  Diode: () => Diode,
  FabricationNoteDimension: () => FabricationNoteDimension,
  FabricationNotePath: () => FabricationNotePath,
  FabricationNoteRect: () => FabricationNoteRect,
  FabricationNoteText: () => FabricationNoteText,
  Footprint: () => Footprint,
  Fuse: () => Fuse,
  Group: () => Group6,
  Hole: () => Hole,
  Inductor: () => Inductor,
  Jumper: () => Jumper,
  Keepout: () => Keepout,
  Led: () => Led,
  Mosfet: () => Mosfet,
  Net: () => Net,
  NetLabel: () => NetLabel,
  NormalComponent: () => NormalComponent3,
  Panel: () => Panel,
  PcbNoteDimension: () => PcbNoteDimension,
  PcbNoteLine: () => PcbNoteLine,
  PcbNotePath: () => PcbNotePath,
  PcbNoteRect: () => PcbNoteRect,
  PcbNoteText: () => PcbNoteText,
  PcbTrace: () => PcbTrace,
  PinHeader: () => PinHeader,
  Pinout: () => Pinout,
  PlatedHole: () => PlatedHole,
  Port: () => Port,
  Potentiometer: () => Potentiometer,
  PowerSource: () => PowerSource,
  PrimitiveComponent: () => PrimitiveComponent2,
  PushButton: () => PushButton,
  Renderable: () => Renderable,
  Resistor: () => Resistor,
  Resonator: () => Resonator,
  SchematicArc: () => SchematicArc,
  SchematicBox: () => SchematicBox,
  SchematicCell: () => SchematicCell,
  SchematicCircle: () => SchematicCircle,
  SchematicLine: () => SchematicLine,
  SchematicRect: () => SchematicRect,
  SchematicRow: () => SchematicRow,
  SchematicTable: () => SchematicTable,
  SchematicText: () => SchematicText,
  SilkscreenCircle: () => SilkscreenCircle,
  SilkscreenLine: () => SilkscreenLine,
  SilkscreenPath: () => SilkscreenPath,
  SilkscreenRect: () => SilkscreenRect,
  SilkscreenText: () => SilkscreenText,
  SmtPad: () => SmtPad,
  SolderJumper: () => SolderJumper,
  Subcircuit: () => Subcircuit,
  Switch: () => Switch,
  Symbol: () => SymbolComponent,
  TestPoint: () => TestPoint,
  Trace: () => Trace3,
  TraceHint: () => TraceHint,
  Transistor: () => Transistor,
  Via: () => Via,
  VoltageProbe: () => VoltageProbe,
  VoltageSource: () => VoltageSource
});

// lib/components/base-components/NormalComponent/NormalComponent.ts
import { fp } from "@tscircuit/footprinter";
import {
  distance as distance5,
  pcb_manual_edit_conflict_warning,
  pcb_component_invalid_layer_error,
  point3 as point32,
  rotation as rotation2,
  schematic_manual_edit_conflict_warning,
  unknown_error_finding_part
} from "circuit-json";
import { decomposeTSR as decomposeTSR5 } from "transformation-matrix";
import Debug5 from "debug";

// lib/fiber/create-instance-from-react-element.ts
import "react";
import ReactReconciler from "react-reconciler";
import { DefaultEventPriority } from "react-reconciler/constants.js";

// lib/components/base-components/Renderable.ts
import Debug from "debug";
var debug = Debug("tscircuit:renderable");
var orderedRenderPhases = [
  "ReactSubtreesRender",
  "InflateSubcircuitCircuitJson",
  "SourceNameDuplicateComponentRemoval",
  "PcbFootprintStringRender",
  "InitializePortsFromChildren",
  "CreateNetsFromProps",
  "AssignFallbackProps",
  "CreateTracesFromProps",
  "CreateTracesFromNetLabels",
  "CreateTraceHintsFromProps",
  "SourceGroupRender",
  "AssignNameToUnnamedComponents",
  "SourceRender",
  "SourceParentAttachment",
  "PortMatching",
  "OptimizeSelectorCache",
  "SourceTraceRender",
  "SourceAddConnectivityMapKey",
  "SourceDesignRuleChecks",
  "SimulationRender",
  "SchematicComponentRender",
  "SchematicPortRender",
  "SchematicPrimitiveRender",
  "SchematicComponentSizeCalculation",
  "SchematicLayout",
  "SchematicTraceRender",
  "SchematicReplaceNetLabelsWithSymbols",
  "PcbComponentRender",
  "PcbPrimitiveRender",
  "PcbFootprintLayout",
  "PcbPortRender",
  "PcbPortAttachment",
  "PcbComponentSizeCalculation",
  "PcbComponentAnchorAlignment",
  "PcbLayout",
  "PcbBoardAutoSize",
  "PcbTraceHintRender",
  "PcbManualTraceRender",
  "PcbTraceRender",
  "PcbRouteNetIslands",
  "PcbCopperPourRender",
  "PcbDesignRuleChecks",
  "SilkscreenOverlapAdjustment",
  "CadModelRender",
  "PartsEngineRender",
  "SimulationSpiceEngineRender"
];
var asyncPhaseDependencies = {
  PcbFootprintLayout: ["PcbFootprintStringRender"],
  PcbComponentSizeCalculation: ["PcbFootprintStringRender"],
  PcbLayout: ["PcbFootprintStringRender"],
  PcbBoardAutoSize: ["PcbFootprintStringRender"],
  PcbTraceHintRender: ["PcbFootprintStringRender"],
  PcbManualTraceRender: ["PcbFootprintStringRender"],
  PcbCopperPourRender: [
    "PcbFootprintStringRender",
    "PcbTraceRender",
    "PcbRouteNetIslands"
  ],
  PcbTraceRender: ["PcbFootprintStringRender"],
  PcbRouteNetIslands: ["PcbFootprintStringRender"],
  PcbDesignRuleChecks: ["PcbFootprintStringRender"],
  SilkscreenOverlapAdjustment: ["PcbFootprintStringRender"],
  CadModelRender: ["PcbFootprintStringRender"],
  PartsEngineRender: ["PcbFootprintStringRender"],
  PcbComponentAnchorAlignment: ["PcbFootprintStringRender"]
};
var globalRenderCounter = 0;
var Renderable = class _Renderable {
  renderPhaseStates;
  shouldBeRemoved = false;
  children;
  /** PCB-only SMTPads, PlatedHoles, Holes, Silkscreen elements etc. */
  isPcbPrimitive = false;
  /** Schematic-only, lines, boxes, indicators etc. */
  isSchematicPrimitive = false;
  _renderId;
  _currentRenderPhase = null;
  _asyncEffects = [];
  parent = null;
  constructor(props) {
    this._renderId = `${globalRenderCounter++}`;
    this.children = [];
    this.renderPhaseStates = {};
    for (const phase of orderedRenderPhases) {
      this.renderPhaseStates[phase] = {
        initialized: false,
        dirty: false
      };
    }
  }
  _markDirty(phase) {
    this.renderPhaseStates[phase].dirty = true;
    const phaseIndex = orderedRenderPhases.indexOf(phase);
    for (let i = phaseIndex + 1; i < orderedRenderPhases.length; i++) {
      this.renderPhaseStates[orderedRenderPhases[i]].dirty = true;
    }
    if (this.parent?._markDirty) {
      this.parent._markDirty(phase);
    }
  }
  _queueAsyncEffect(effectName, effect) {
    const asyncEffect = {
      promise: effect(),
      // TODO don't start effects until end of render cycle
      phase: this._currentRenderPhase,
      effectName,
      complete: false
    };
    this._asyncEffects.push(asyncEffect);
    if ("root" in this && this.root) {
      ;
      this.root.emit("asyncEffect:start", {
        effectName,
        componentDisplayName: this.getString(),
        phase: asyncEffect.phase
      });
    }
    asyncEffect.promise.then(() => {
      asyncEffect.complete = true;
      if ("root" in this && this.root) {
        ;
        this.root.emit("asyncEffect:end", {
          effectName,
          componentDisplayName: this.getString(),
          phase: asyncEffect.phase
        });
      }
    }).catch((error) => {
      console.error(
        `Async effect error in ${asyncEffect.phase} "${effectName}":
${error.stack}`
      );
      asyncEffect.complete = true;
      if ("root" in this && this.root) {
        ;
        this.root.emit("asyncEffect:end", {
          effectName,
          componentDisplayName: this.getString(),
          phase: asyncEffect.phase,
          error: error.toString()
        });
      }
    });
  }
  _emitRenderLifecycleEvent(phase, startOrEnd) {
    debug(`${phase}:${startOrEnd} ${this.getString()}`);
    const granular_event_type = `renderable:renderLifecycle:${phase}:${startOrEnd}`;
    const eventPayload = {
      renderId: this._renderId,
      componentDisplayName: this.getString(),
      type: granular_event_type
    };
    if ("root" in this && this.root) {
      ;
      this.root.emit(granular_event_type, eventPayload);
      this.root.emit("renderable:renderLifecycle:anyEvent", {
        ...eventPayload,
        type: granular_event_type
      });
    }
  }
  getString() {
    return this.constructor.name;
  }
  _hasIncompleteAsyncEffects() {
    return this._asyncEffects.some((effect) => !effect.complete);
  }
  _hasIncompleteAsyncEffectsInSubtreeForPhase(phase) {
    for (const e of this._asyncEffects) {
      if (!e.complete && e.phase === phase) return true;
    }
    for (const child of this.children) {
      const renderableChild = child;
      if (renderableChild._hasIncompleteAsyncEffectsInSubtreeForPhase(phase))
        return true;
    }
    return false;
  }
  getCurrentRenderPhase() {
    return this._currentRenderPhase;
  }
  getRenderGraph() {
    return {
      id: this._renderId,
      currentPhase: this._currentRenderPhase,
      renderPhaseStates: this.renderPhaseStates,
      shouldBeRemoved: this.shouldBeRemoved,
      children: this.children.map(
        (child) => child.getRenderGraph()
      )
    };
  }
  getTopLevelRenderable() {
    let current = this;
    while (current.parent && current.parent instanceof _Renderable) {
      current = current.parent;
    }
    return current;
  }
  runRenderCycle() {
    for (const renderPhase of orderedRenderPhases) {
      this.runRenderPhaseForChildren(renderPhase);
      this.runRenderPhase(renderPhase);
    }
  }
  /**
   * This runs all the render methods for a given phase, calling one of:
   * - doInitial*
   * - update*
   *  -remove*
   *  ...depending on the current state of the component.
   */
  runRenderPhase(phase) {
    this._currentRenderPhase = phase;
    const phaseState = this.renderPhaseStates[phase];
    const isInitialized = phaseState.initialized;
    const isDirty = phaseState.dirty;
    if (!isInitialized && this.shouldBeRemoved) return;
    if (this.shouldBeRemoved && isInitialized) {
      this._emitRenderLifecycleEvent(phase, "start");
      this?.[`remove${phase}`]?.();
      phaseState.initialized = false;
      phaseState.dirty = false;
      this._emitRenderLifecycleEvent(phase, "end");
      return;
    }
    const prevPhaseIndex = orderedRenderPhases.indexOf(phase) - 1;
    if (prevPhaseIndex >= 0) {
      const prevPhase = orderedRenderPhases[prevPhaseIndex];
      const hasIncompleteEffects = this._asyncEffects.filter((e) => e.phase === prevPhase).some((e) => !e.complete);
      if (hasIncompleteEffects) return;
    }
    const deps = asyncPhaseDependencies[phase] || [];
    if (deps.length > 0) {
      const root = this.getTopLevelRenderable();
      for (const depPhase of deps) {
        if (root._hasIncompleteAsyncEffectsInSubtreeForPhase(depPhase)) {
          return;
        }
      }
    }
    this._emitRenderLifecycleEvent(phase, "start");
    if (isInitialized) {
      if (isDirty) {
        ;
        this?.[`update${phase}`]?.();
        phaseState.dirty = false;
      }
      this._emitRenderLifecycleEvent(phase, "end");
      return;
    }
    phaseState.dirty = false;
    this?.[`doInitial${phase}`]?.();
    phaseState.initialized = true;
    this._emitRenderLifecycleEvent(phase, "end");
  }
  runRenderPhaseForChildren(phase) {
    for (const child of this.children) {
      child.runRenderPhaseForChildren(phase);
      child.runRenderPhase(phase);
    }
  }
  renderError(message) {
    if (typeof message === "string") {
      throw new Error(message);
    }
    throw new Error(JSON.stringify(message, null, 2));
  }
};

// lib/fiber/catalogue.ts
var catalogue = {};
var extendCatalogue = (objects) => {
  const altKeys = Object.fromEntries(
    Object.entries(objects).map(([key, v]) => [key.toLowerCase(), v])
  );
  Object.assign(catalogue, objects);
  Object.assign(catalogue, altKeys);
};

// lib/errors/InvalidProps.ts
var InvalidProps = class extends Error {
  constructor(componentName, originalProps, formattedError) {
    let message;
    const propsWithError = Object.keys(formattedError).filter(
      (k) => k !== "_errors"
    );
    const invalidPinLabelMessages = [];
    const pinLabels = originalProps.pinLabels;
    if (pinLabels) {
      for (const [pin, labelOrLabels] of Object.entries(pinLabels)) {
        const labels = Array.isArray(labelOrLabels) ? labelOrLabels : [labelOrLabels];
        for (const label of labels) {
          if (typeof label === "string" && (label.startsWith(" ") || label.endsWith(" "))) {
            invalidPinLabelMessages.push(
              `pinLabels.${pin} ("${label}" has leading or trailing spaces)`
            );
          }
        }
      }
    }
    const propMessage = propsWithError.map((k) => {
      if (k === "pinLabels" && invalidPinLabelMessages.length > 0) {
        return invalidPinLabelMessages.join(", ");
      }
      if (formattedError[k]._errors[0]) {
        return `${k} (${formattedError[k]._errors[0]})`;
      }
      return `${k} (${JSON.stringify(formattedError[k])})`;
    }).join(", ");
    if ("name" in originalProps) {
      message = `Invalid props for ${componentName} "${originalProps.name}": ${propMessage}`;
    } else if ("footprint" in originalProps && typeof originalProps.footprint === "string") {
      message = `Invalid props for ${componentName} (unnamed ${originalProps.footprint} component): ${propMessage}`;
    } else {
      message = `Invalid props for ${componentName} (unnamed): ${propMessage}`;
    }
    super(message);
    this.componentName = componentName;
    this.originalProps = originalProps;
    this.formattedError = formattedError;
  }
};

// lib/fiber/create-instance-from-react-element.ts
import { identity as identity2 } from "transformation-matrix";

// lib/components/base-components/PrimitiveComponent/PrimitiveComponent.ts
import "debug";

// lib/utils/selector-matching/is-matching-selector.ts
function isMatchingSelector(component, selector) {
  const idMatch = selector.match(/^#(\w+)/);
  if (idMatch) {
    return component.props.id === idMatch[1];
  }
  const classMatch = selector.match(/^\.(\w+)/);
  if (classMatch) {
    return component.isMatchingNameOrAlias(classMatch[1]);
  }
  let [type, ...conditions] = selector.split(/(?=[#.[])/);
  if (type === "pin") type = "port";
  if (type && type !== "*" && component.lowercaseComponentName !== type.toLowerCase()) {
    return false;
  }
  return conditions.every((condition) => {
    if (condition.startsWith("#")) {
      return component.props.id === condition.slice(1);
    }
    if (condition.startsWith(".")) {
      return component.isMatchingNameOrAlias(condition.slice(1));
    }
    const match = condition.match(/\[(\w+)=['"]?(.+?)['"]?\]/);
    if (!match) return true;
    const [, prop, value] = match;
    return component.props[prop].toString() === value;
  });
}

// lib/components/base-components/PrimitiveComponent/PrimitiveComponent.ts
import { symbols } from "schematic-symbols";
import {
  applyToPoint,
  compose,
  flipY,
  identity,
  rotate,
  translate
} from "transformation-matrix";
import { z } from "zod";
import { selectOne, selectAll } from "css-select";

// lib/components/base-components/PrimitiveComponent/cssSelectPrimitiveComponentAdapter.ts
var cssSelectPrimitiveComponentAdapter = {
  // Is the node an element?
  isTag: (node) => true,
  // Get the parent of the node
  getParent: (node) => node.parent,
  // Get the children of the node
  getChildren: (node) => node.children,
  // Get the name of the tag
  getName: (node) => node.lowercaseComponentName,
  // Get the attribute value
  getAttributeValue: (node, name) => {
    if (name === "class" && "getNameAndAliases" in node) {
      return node.getNameAndAliases().join(" ");
    }
    if (name === "name" && node._parsedProps?.name) {
      return node._parsedProps.name;
    }
    if (node._parsedProps && name in node._parsedProps) {
      const value = node._parsedProps[name];
      return typeof value === "string" ? value : value !== null && value !== void 0 ? String(value) : null;
    }
    if (name in node) {
      const value = node[name];
      return typeof value === "string" ? value : value !== null && value !== void 0 ? String(value) : null;
    }
    const reverseMap = node._attributeLowerToCamelNameMap;
    if (reverseMap) {
      const camelCaseName = reverseMap[name];
      if (camelCaseName && camelCaseName in node) {
        const value = node[camelCaseName];
        return typeof value === "string" ? value : value !== null && value !== void 0 ? String(value) : null;
      }
    }
    return null;
  },
  // Check if a node has an attribute
  hasAttrib: (node, name) => {
    if (name === "class") {
      return !!node._parsedProps?.name;
    }
    if (node._parsedProps && name in node._parsedProps) {
      return true;
    }
    if (name in node) {
      return true;
    }
    const reverseMap = node._attributeLowerToCamelNameMap;
    if (reverseMap) {
      const camelCaseName = reverseMap[name];
      if (camelCaseName && camelCaseName in node) {
        return true;
      }
    }
    return false;
  },
  // Get the siblings of the node
  getSiblings: (node) => {
    if (!node.parent) return [];
    return node.parent.children;
  },
  // Get the previous sibling
  prevElementSibling: (node) => {
    if (!node.parent) return null;
    const siblings = node.parent.children;
    const idx = siblings.indexOf(node);
    return idx > 0 ? siblings[idx - 1] : null;
  },
  // Get the text content
  getText: () => "",
  // Remove the node
  removeSubsets: (nodes) => {
    return nodes.filter(
      (node, i) => !nodes.some(
        (other, j) => i !== j && other !== node && other.getDescendants().includes(node)
      )
    );
  },
  // Determine if element a is a subset of element b
  existsOne: (test, nodes) => {
    return nodes.some(test);
  },
  // Find all elements matching a selector
  findAll: (test, nodes) => {
    const result = [];
    const recurse = (node) => {
      if (test(node)) {
        result.push(node);
      }
      for (const child of node.children) {
        recurse(child);
      }
    };
    for (const node of nodes) {
      recurse(node);
    }
    return result;
  },
  // Find one element matching a selector
  findOne: (test, nodes) => {
    for (const node of nodes) {
      if (test(node)) return node;
      const children = node.children;
      if (children.length > 0) {
        const result = cssSelectPrimitiveComponentAdapter.findOne(
          test,
          children
        );
        if (result) return result;
      }
    }
    return null;
  },
  equals: (a, b) => {
    return a._renderId === b._renderId;
  },
  isHovered: (elem) => false,
  isVisited: (elem) => false,
  isActive: (elem) => false
};
var cssSelectPrimitiveComponentAdapterWithoutSubcircuits = {
  ...cssSelectPrimitiveComponentAdapter,
  getChildren: (node) => node.children.filter((c) => !c.isSubcircuit)
};
var cssSelectPrimitiveComponentAdapterOnlySubcircuits = {
  ...cssSelectPrimitiveComponentAdapter,
  getChildren: (node) => node.children.filter((c) => c.isSubcircuit)
};

// lib/components/base-components/PrimitiveComponent/preprocessSelector.ts
var buildPlusMinusNetErrorMessage = (selector, component) => {
  const netName = selector.split("net.")[1]?.split(/[ >]/)[0] ?? selector;
  const componentName = component?.componentName ?? "Unknown component";
  return `Net names cannot contain "+" or "-" (component "${componentName}" received "${netName}" via "${selector}"). Try using underscores instead, e.g. VCC_P`;
};
var preprocessSelector = (selector, component) => {
  if (/net\.[^\s>]*\./.test(selector)) {
    throw new Error(
      'Net names cannot contain a period, try using "sel.net..." to autocomplete with conventional net names, e.g. V3_3'
    );
  }
  if (/net\.[^\s>]*[+-]/.test(selector)) {
    throw new Error(buildPlusMinusNetErrorMessage(selector, component));
  }
  if (/net\.[0-9]/.test(selector)) {
    const match = selector.match(/net\.([^ >]+)/);
    const netName = match ? match[1] : "";
    throw new Error(
      `Net name "${netName}" cannot start with a number, try using a prefix like "VBUS1"`
    );
  }
  return selector.replace(/ pin(?=[\d.])/g, " port").replace(/ subcircuit\./g, " group[isSubcircuit=true]").replace(/([^ ])\>([^ ])/g, "$1 > $2").replace(
    /(^|[ >])(?!pin\.)(?!port\.)(?!net\.)([A-Z][A-Za-z0-9_-]*)\.([A-Za-z0-9_-]+)/g,
    (_, sep, name, pin) => {
      const pinPart = /^\d+$/.test(pin) ? `pin${pin}` : pin;
      return `${sep}.${name} > .${pinPart}`;
    }
  ).trim();
};

// lib/components/base-components/PrimitiveComponent/PrimitiveComponent.ts
var cssSelectOptionsInsideSubcircuit = {
  adapter: cssSelectPrimitiveComponentAdapterWithoutSubcircuits,
  cacheResults: true
};
var PrimitiveComponent2 = class extends Renderable {
  parent = null;
  children;
  childrenPendingRemoval;
  get config() {
    return {
      componentName: "",
      zodProps: z.object({}).passthrough()
    };
  }
  props;
  _parsedProps;
  get componentName() {
    return this.config.componentName;
  }
  getInheritedProperty(propertyName) {
    let current = this;
    while (current) {
      if (current._parsedProps && propertyName in current._parsedProps) {
        return current._parsedProps[propertyName];
      }
      current = current.parent;
    }
    if (this.root?.platform && propertyName in this.root.platform) {
      return this.root.platform[propertyName];
    }
    return void 0;
  }
  getInheritedMergedProperty(propertyName) {
    const parentPropertyObject = this.parent?.getInheritedMergedProperty?.(propertyName);
    const myPropertyObject = this._parsedProps?.[propertyName];
    return { ...parentPropertyObject, ...myPropertyObject };
  }
  get lowercaseComponentName() {
    return this.componentName.toLowerCase();
  }
  externallyAddedAliases;
  /**
   * An subcircuit is self-contained. All the selectors inside
   * a subcircuit are relative to the subcircuit group. You can have multiple
   * subcircuits and their selectors will not interact with each other (even if the
   * components share the same names) unless you explicitly break out some ports
   */
  get isSubcircuit() {
    return Boolean(this.props.subcircuit) || this.lowercaseComponentName === "group" && this?.parent?.isRoot;
  }
  get isGroup() {
    return this.lowercaseComponentName === "group";
  }
  get name() {
    return this._parsedProps.name ?? this.fallbackUnassignedName;
  }
  /**
   * A primitive container is a component that contains one or more ports and
   * primitive components that are designed to interact.
   *
   * For example a resistor contains ports and smtpads that interact, so the
   * resistor is a primitive container. Inside a primitive container, the ports
   * and pads are likely to reference each other and look for eachother during
   * the port matching phase.
   *
   */
  isPrimitiveContainer = false;
  canHaveTextChildren = false;
  source_group_id = null;
  source_component_id = null;
  schematic_component_id = null;
  pcb_component_id = null;
  cad_component_id = null;
  fallbackUnassignedName;
  constructor(props) {
    super(props);
    this.children = [];
    this.childrenPendingRemoval = [];
    this.props = props ?? {};
    this.externallyAddedAliases = [];
    const zodProps = "partial" in this.config.zodProps ? this.config.zodProps.partial({
      name: true
    }) : this.config.zodProps;
    const parsePropsResult = zodProps.safeParse(props ?? {});
    if (parsePropsResult.success) {
      this._parsedProps = parsePropsResult.data;
    } else {
      throw new InvalidProps(
        this.lowercaseComponentName,
        this.props,
        parsePropsResult.error.format()
      );
    }
  }
  setProps(props) {
    const newProps = this.config.zodProps.parse({
      ...this.props,
      ...props
    });
    const oldProps = this.props;
    this.props = newProps;
    this._parsedProps = this.config.zodProps.parse(props);
    this.onPropsChange({
      oldProps,
      newProps,
      changedProps: Object.keys(props)
    });
    this.parent?.onChildChanged?.(this);
  }
  _getPcbRotationBeforeLayout() {
    const { pcbRotation } = this.props;
    if (typeof pcbRotation === "string") {
      return parseFloat(pcbRotation);
    }
    return pcbRotation ?? null;
  }
  /**
   * Computes a transformation matrix from the props of this component for PCB
   * components
   */
  computePcbPropsTransform() {
    const { _parsedProps: props } = this;
    const rotation5 = this._getPcbRotationBeforeLayout() ?? 0;
    const matrix = compose(
      translate(props.pcbX ?? 0, props.pcbY ?? 0),
      rotate(rotation5 * Math.PI / 180)
    );
    return matrix;
  }
  /**
   * Compute a transformation matrix combining all parent transforms for PCB
   * components, including this component's translation and rotation.
   *
   * This is used to compute this component's position as well as all children
   * components positions before layout is applied
   */
  _computePcbGlobalTransformBeforeLayout() {
    const manualPlacement = this.getSubcircuit()._getPcbManualPlacementForComponent(this);
    if (manualPlacement && this.props.pcbX === void 0 && this.props.pcbY === void 0) {
      const rotation5 = this._getPcbRotationBeforeLayout() ?? 0;
      return compose(
        this.parent?._computePcbGlobalTransformBeforeLayout() ?? identity(),
        compose(
          translate(manualPlacement.x, manualPlacement.y),
          rotate(rotation5 * Math.PI / 180)
        )
      );
    }
    if (this.isPcbPrimitive) {
      const primitiveContainer = this.getPrimitiveContainer();
      if (primitiveContainer) {
        const isFlipped = primitiveContainer._parsedProps.layer === "bottom";
        if (isFlipped) {
          return compose(
            this.parent?._computePcbGlobalTransformBeforeLayout() ?? identity(),
            flipY(),
            this.computePcbPropsTransform()
          );
        }
      }
    }
    return compose(
      this.parent?._computePcbGlobalTransformBeforeLayout() ?? identity(),
      this.computePcbPropsTransform()
    );
  }
  getPrimitiveContainer() {
    if (this.isPrimitiveContainer) return this;
    return this.parent?.getPrimitiveContainer?.() ?? null;
  }
  /**
   * Walk up the component hierarchy to find the nearest NormalComponent ancestor.
   * This is useful for primitive components that need access to component IDs
   * (pcb_component_id, schematic_component_id, source_component_id) from their
   * parent NormalComponent, even when there are intermediate primitive containers
   * like Symbol in the hierarchy.
   */
  getParentNormalComponent() {
    let current = this.parent;
    while (current) {
      if (current.isPrimitiveContainer && current.doInitialPcbComponentRender) {
        return current;
      }
      current = current.parent;
    }
    return null;
  }
  /**
   * Compute the PCB bounds of this component the circuit json elements
   * associated with it.
   */
  _getPcbCircuitJsonBounds() {
    return {
      center: { x: 0, y: 0 },
      bounds: { left: 0, top: 0, right: 0, bottom: 0 },
      width: 0,
      height: 0
    };
  }
  /**
   * Determine if this pcb primitive should be flipped because the primitive
   * container is flipped
   *
   * TODO use footprint.originalLayer instead of assuming everything is defined
   * relative to the top layer
   */
  _getPcbPrimitiveFlippedHelpers() {
    const container = this.getPrimitiveContainer();
    const isFlipped = !container ? false : container._parsedProps.layer === "bottom";
    const maybeFlipLayer = (layer) => {
      if (isFlipped) {
        return layer === "top" ? "bottom" : "top";
      }
      return layer;
    };
    return { isFlipped, maybeFlipLayer };
  }
  /**
   * Set the position of this component from the layout solver. This method
   * should operate using CircuitJson associated with this component, like
   * _getPcbCircuitJsonBounds it can be called multiple times as different
   * parents apply layout to their children.
   */
  _setPositionFromLayout(newCenter) {
    throw new Error(
      `_setPositionFromLayout not implemented for ${this.componentName}`
    );
  }
  /**
   * Computes a transformation matrix from the props of this component for
   * schematic components
   */
  computeSchematicPropsTransform() {
    const { _parsedProps: props } = this;
    return compose(translate(props.schX ?? 0, props.schY ?? 0));
  }
  /**
   * Compute a transformation matrix combining all parent transforms for this
   * component
   */
  computeSchematicGlobalTransform() {
    const manualPlacementTransform = this._getSchematicGlobalManualPlacementTransform(this);
    if (manualPlacementTransform) return manualPlacementTransform;
    return compose(
      this.parent?.computeSchematicGlobalTransform?.() ?? identity(),
      this.computeSchematicPropsTransform()
    );
  }
  _getSchematicSymbolName() {
    const { _parsedProps: props } = this;
    const base_symbol_name = this.config.schematicSymbolName;
    const orientationRotationMap = {
      horizontal: 0,
      pos_left: 0,
      neg_right: 0,
      pos_right: 180,
      neg_left: 180,
      pos_top: 270,
      neg_bottom: 90,
      vertical: 270,
      pos_bottom: 90,
      neg_top: 90
    };
    let normalizedRotation = props.schOrientation !== void 0 ? orientationRotationMap[props.schOrientation] : props.schRotation;
    if (normalizedRotation === void 0) {
      normalizedRotation = 0;
    }
    normalizedRotation = normalizedRotation % 360;
    if (normalizedRotation < 0) {
      normalizedRotation += 360;
    }
    if (props.schRotation !== void 0 && normalizedRotation % 90 !== 0) {
      throw new Error(
        `Schematic rotation ${props.schRotation} is not supported for ${this.componentName}`
      );
    }
    const symbol_name_horz = `${base_symbol_name}_horz`;
    const symbol_name_vert = `${base_symbol_name}_vert`;
    const symbol_name_up = `${base_symbol_name}_up`;
    const symbol_name_down = `${base_symbol_name}_down`;
    const symbol_name_left = `${base_symbol_name}_left`;
    const symbol_name_right = `${base_symbol_name}_right`;
    if (symbol_name_right in symbols && normalizedRotation === 0) {
      return symbol_name_right;
    }
    if (symbol_name_up in symbols && normalizedRotation === 90) {
      return symbol_name_up;
    }
    if (symbol_name_left in symbols && normalizedRotation === 180) {
      return symbol_name_left;
    }
    if (symbol_name_down in symbols && normalizedRotation === 270) {
      return symbol_name_down;
    }
    if (symbol_name_horz in symbols) {
      if (normalizedRotation === 0) return symbol_name_horz;
      if (normalizedRotation === 180) return symbol_name_horz;
    }
    if (symbol_name_vert in symbols) {
      if (normalizedRotation === 90) return symbol_name_vert;
      if (normalizedRotation === 270) return symbol_name_vert;
    }
    if (base_symbol_name in symbols) return base_symbol_name;
    return void 0;
  }
  _getSchematicSymbolNameOrThrow() {
    const symbol_name = this._getSchematicSymbolName();
    if (!symbol_name) {
      throw new Error(
        `No schematic symbol found (given: "${this.config.schematicSymbolName}")`
      );
    }
    return symbol_name;
  }
  getSchematicSymbol() {
    const symbol_name = this._getSchematicSymbolName();
    if (!symbol_name) return null;
    return symbols[symbol_name] ?? null;
  }
  /**
   * Subcircuit groups have a prop called "layout" that can include manual
   * placements for pcb components. These are typically added from an IDE
   */
  _getPcbManualPlacementForComponent(component) {
    if (!this.isSubcircuit) return null;
    const manualEdits = this.props.manualEdits;
    if (!manualEdits) return null;
    const placementConfigPositions = manualEdits?.pcb_placements;
    if (!placementConfigPositions) return null;
    for (const position of placementConfigPositions) {
      if (isMatchingSelector(component, position.selector) || component.props.name === position.selector) {
        const center = applyToPoint(
          this._computePcbGlobalTransformBeforeLayout(),
          position.center
        );
        return center;
      }
    }
    return null;
  }
  _getSchematicManualPlacementForComponent(component) {
    if (!this.isSubcircuit) return null;
    const manualEdits = this.props.manualEdits;
    if (!manualEdits) return null;
    const placementConfigPositions = manualEdits.schematic_placements;
    if (!placementConfigPositions) return null;
    for (const position of placementConfigPositions) {
      if (isMatchingSelector(component, position.selector) || component.props.name === position.selector) {
        const center = applyToPoint(
          this.computeSchematicGlobalTransform(),
          position.center
        );
        return center;
      }
    }
    return null;
  }
  _getSchematicGlobalManualPlacementTransform(component) {
    const manualEdits = this.getSubcircuit()?._parsedProps.manualEdits;
    if (!manualEdits) return null;
    for (const position of manualEdits.schematic_placements ?? []) {
      if (isMatchingSelector(component, position.selector) || component.props.name === position.selector) {
        if (position.relative_to === "group_center") {
          return compose(
            this.parent?._computePcbGlobalTransformBeforeLayout() ?? identity(),
            translate(position.center.x, position.center.y)
          );
        }
      }
    }
    return null;
  }
  _getGlobalPcbPositionBeforeLayout() {
    return applyToPoint(this._computePcbGlobalTransformBeforeLayout(), {
      x: 0,
      y: 0
    });
  }
  _getGlobalSchematicPositionBeforeLayout() {
    return applyToPoint(this.computeSchematicGlobalTransform(), { x: 0, y: 0 });
  }
  get root() {
    return this.parent?.root ?? null;
  }
  onAddToParent(parent) {
    this.parent = parent;
  }
  /**
   * Called whenever the props change
   */
  onPropsChange(params) {
  }
  onChildChanged(child) {
    this.parent?.onChildChanged?.(child);
  }
  add(component) {
    const textContent = component.__text;
    if (typeof textContent === "string") {
      if (this.canHaveTextChildren || textContent.trim() === "") {
        return;
      }
      throw new Error(
        `Invalid JSX Element: Expected a React component but received text "${textContent}"`
      );
    }
    if (Object.keys(component).length === 0) {
      return;
    }
    if (this.lowercaseComponentName === "board" && component.lowercaseComponentName === "board") {
      throw new Error("Nested boards are not supported");
    }
    if (component.lowercaseComponentName === "panel") {
      throw new Error("<panel> must be a root-level element");
    }
    if (!component.onAddToParent) {
      throw new Error(
        `Invalid JSX Element: Expected a React component but received "${JSON.stringify(
          component
        )}"`
      );
    }
    component.onAddToParent(this);
    component.parent = this;
    this.children.push(component);
  }
  addAll(components) {
    for (const component of components) {
      this.add(component);
    }
  }
  remove(component) {
    this.children = this.children.filter((c) => c !== component);
    this.childrenPendingRemoval.push(component);
    component.shouldBeRemoved = true;
  }
  getSubcircuitSelector() {
    const name = this.name;
    const endPart = name ? `${this.lowercaseComponentName}.${name}` : this.lowercaseComponentName;
    if (!this.parent) return endPart;
    if (this.parent.isSubcircuit) return endPart;
    return `${this.parent.getSubcircuitSelector()} > ${endPart}`;
  }
  getFullPathSelector() {
    const name = this.name;
    const endPart = name ? `${this.lowercaseComponentName}.${name}` : this.lowercaseComponentName;
    const parentSelector = this.parent?.getFullPathSelector?.();
    if (!parentSelector) return endPart;
    return `${parentSelector} > ${endPart}`;
  }
  getNameAndAliases() {
    return [this.name, ...this._parsedProps.portHints ?? []].filter(Boolean);
  }
  isMatchingNameOrAlias(name) {
    return this.getNameAndAliases().includes(name);
  }
  isMatchingAnyOf(aliases) {
    return this.getNameAndAliases().some(
      (a) => aliases.map((a2) => a2.toString()).includes(a)
    );
  }
  getPcbSize() {
    throw new Error(`getPcbSize not implemented for ${this.componentName}`);
  }
  doesSelectorMatch(selector) {
    const myTypeNames = [this.componentName, this.lowercaseComponentName];
    const myClassNames = [this.name].filter(Boolean);
    const parts = selector.trim().split(/\> /)[0];
    const firstPart = parts[0];
    if (parts.length > 1) return false;
    if (selector === "*") return true;
    if (selector[0] === "#" && selector.slice(1) === this.props.id) return true;
    if (selector[0] === "." && myClassNames.includes(selector.slice(1)))
      return true;
    if (/^[a-zA-Z0-9_]/.test(firstPart) && myTypeNames.includes(firstPart))
      return true;
    return false;
  }
  getSubcircuit() {
    if (this.isSubcircuit) return this;
    const group = this.parent?.getSubcircuit?.();
    if (!group)
      throw new Error("Component is not inside an opaque group (no board?)");
    return group;
  }
  getGroup() {
    if (this.isGroup) return this;
    return this.parent?.getGroup?.() ?? null;
  }
  doInitialAssignNameToUnnamedComponents() {
    if (!this._parsedProps.name) {
      this.fallbackUnassignedName = this.getSubcircuit().getNextAvailableName(this);
    }
  }
  doInitialOptimizeSelectorCache() {
    if (!this.isSubcircuit) return;
    const ports = this.selectAll("port");
    for (const port of ports) {
      const parentComponent = port.getParentNormalComponent?.() ?? port.parent;
      const parentAliases = parentComponent?.getNameAndAliases();
      const portAliases = port.getNameAndAliases();
      if (!parentAliases) continue;
      for (const parentAlias of parentAliases) {
        for (const portAlias of portAliases) {
          const selectors = [
            `.${parentAlias} > .${portAlias}`,
            `.${parentAlias} .${portAlias}`
          ];
          for (const selector of selectors) {
            const ar = this._cachedSelectAllQueries.get(selector);
            if (ar) {
              ar.push(port);
            } else {
              this._cachedSelectAllQueries.set(selector, [port]);
            }
          }
        }
      }
    }
    for (const [selector, ports2] of this._cachedSelectAllQueries.entries()) {
      if (ports2.length === 1) {
        this._cachedSelectOneQueries.set(selector, ports2[0]);
      }
    }
  }
  _cachedSelectAllQueries = /* @__PURE__ */ new Map();
  selectAll(selectorRaw) {
    if (this._cachedSelectAllQueries.has(selectorRaw)) {
      return this._cachedSelectAllQueries.get(selectorRaw);
    }
    const selector = preprocessSelector(selectorRaw, this);
    const result = selectAll(
      selector,
      this,
      cssSelectOptionsInsideSubcircuit
    );
    if (result.length > 0) {
      this._cachedSelectAllQueries.set(selectorRaw, result);
      return result;
    }
    const [firstpart, ...rest] = selector.split(" ");
    const subcircuit = selectOne(firstpart, this, {
      adapter: cssSelectPrimitiveComponentAdapterOnlySubcircuits
    });
    if (!subcircuit) return [];
    const result2 = subcircuit.selectAll(rest.join(" "));
    this._cachedSelectAllQueries.set(selectorRaw, result2);
    return result2;
  }
  _cachedSelectOneQueries = /* @__PURE__ */ new Map();
  selectOne(selectorRaw, options) {
    if (this._cachedSelectOneQueries.has(selectorRaw)) {
      return this._cachedSelectOneQueries.get(selectorRaw);
    }
    const selector = preprocessSelector(selectorRaw, this);
    if (options?.port) {
      options.type = "port";
    }
    let result = null;
    if (options?.type) {
      const allMatching = selectAll(
        selector,
        this,
        cssSelectOptionsInsideSubcircuit
      );
      result = allMatching.find(
        (n) => n.lowercaseComponentName === options.type
      );
    }
    result ??= selectOne(
      selector,
      this,
      cssSelectOptionsInsideSubcircuit
    );
    if (result) {
      this._cachedSelectOneQueries.set(selectorRaw, result);
      return result;
    }
    const [firstpart, ...rest] = selector.split(" ");
    const subcircuit = selectOne(firstpart, this, {
      adapter: cssSelectPrimitiveComponentAdapterOnlySubcircuits
    });
    if (!subcircuit) return null;
    result = subcircuit.selectOne(rest.join(" "), options);
    this._cachedSelectOneQueries.set(selectorRaw, result);
    return result;
  }
  getAvailablePcbLayers() {
    if (this.isPcbPrimitive) {
      const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
      if ("layer" in this._parsedProps || this.componentName === "SmtPad") {
        const layer = maybeFlipLayer(this._parsedProps.layer ?? "top");
        return [layer];
      }
      if ("layers" in this._parsedProps) {
        return this._parsedProps.layers;
      }
      if (this.componentName === "PlatedHole") {
        return this.root?._getBoard()?.allLayers ?? ["top", "bottom"];
      }
      return [];
    }
    return [];
  }
  /**
   * Returns all descendants
   *
   * NOTE: This crosses subcircuit boundaries, you may want to use
   * getSelectableDescendants instead
   */
  getDescendants() {
    const descendants = [];
    for (const child of this.children) {
      descendants.push(child);
      descendants.push(...child.getDescendants());
    }
    return descendants;
  }
  /**
   * Returns all descendants that are accessible without crossing a subcircuit
   * boundary
   */
  getSelectableDescendants() {
    const descendants = [];
    for (const child of this.children) {
      if (child.isSubcircuit) {
        descendants.push(child);
      } else {
        descendants.push(child);
        descendants.push(...child.getSelectableDescendants());
      }
    }
    return descendants;
  }
  /**
   * Return the number of pins in this component, this is important for
   * NormalComponents
   */
  _getPinCount() {
    return 0;
  }
  /**
   * If this component represents a SchematicBox (like a Chip), return the
   * dimensions of the box, which allows computing the position of ports etc.
   */
  _getSchematicBoxDimensions() {
    return null;
  }
  _getSchematicBoxComponentDimensions() {
    if (this.getSchematicSymbol()) return null;
    if (!this.config.shouldRenderAsSchematicBox) return null;
    const { _parsedProps: props } = this;
    const dimensions = {
      schWidth: props.schWidth,
      schHeight: props.schHeight
    };
    return dimensions;
  }
  // TODO we shouldn't need to override this, errors can be rendered and handled
  // by the Renderable class, however, the Renderable class currently doesn't
  // have access to the database or cleanup
  renderError(message) {
    if (typeof message === "string") {
      return super.renderError(message);
    }
    switch (message.type) {
      case "pcb_placement_error":
        this.root?.db.pcb_placement_error.insert(message);
        break;
      case "pcb_via_clearance_error":
        this.root?.db.pcb_via_clearance_error.insert(message);
        break;
      case "pcb_trace_error":
        this.root?.db.pcb_trace_error.insert(message);
        break;
      case "pcb_manual_edit_conflict_warning":
        this.root?.db.pcb_manual_edit_conflict_warning.insert(message);
        break;
      default:
        this.root?.db.pcb_placement_error.insert(message);
    }
  }
  getString() {
    const { lowercaseComponentName: cname, _parsedProps: props, parent } = this;
    if (props?.pinNumber !== void 0 && parent?.props?.name && props?.name) {
      return `<${cname}#${this._renderId}(pin:${props.pinNumber} .${parent?.props.name}>.${props.name}) />`;
    }
    if (parent?.props?.name && props?.name) {
      return `<${cname}#${this._renderId}(.${parent?.props.name}>.${props?.name}) />`;
    }
    if (props?.from && props?.to) {
      return `<${cname}#${this._renderId}(from:${props.from} to:${props?.to}) />`;
    }
    if (props?.name) {
      return `<${cname}#${this._renderId} name=".${props?.name}" />`;
    }
    if (props?.portHints) {
      return `<${cname}#${this._renderId}(${props.portHints.map((ph) => `.${ph}`).join(", ")}) />`;
    }
    return `<${cname}#${this._renderId} />`;
  }
  get [Symbol.toStringTag]() {
    return this.getString();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.getString();
  }
};

// lib/components/primitive-components/ErrorPlaceholder.ts
import { z as z2 } from "zod";
var ErrorPlaceholderComponent = class extends PrimitiveComponent2 {
  constructor(props, error) {
    super(props);
    this._parsedProps = {
      ...props,
      error,
      type: props.type || "unknown",
      component_name: props.name,
      error_type: "source_failed_to_create_component_error",
      message: error instanceof Error ? error.message : String(error),
      pcbX: props.pcbX,
      pcbY: props.pcbY,
      schX: props.schX,
      schY: props.schY
    };
  }
  get config() {
    return {
      componentName: "ErrorPlaceholder",
      zodProps: z2.object({}).passthrough()
    };
  }
  doInitialSourceRender() {
    if (this.root?.db) {
      const pcbPosition = this._getGlobalPcbPositionBeforeLayout();
      const schematicPosition = this._getGlobalSchematicPositionBeforeLayout();
      this.root.db.source_failed_to_create_component_error.insert({
        component_name: this._parsedProps.component_name,
        error_type: "source_failed_to_create_component_error",
        message: `Could not create ${this._parsedProps.componentType ?? "component"}${this._parsedProps.name ? ` "${this._parsedProps.name}"` : ""}. ${this._parsedProps.error?.formattedError?._errors?.join("; ") || this._parsedProps.message}`,
        pcb_center: pcbPosition,
        schematic_center: schematicPosition
      });
    }
  }
};
function createErrorPlaceholderComponent(props, error) {
  return new ErrorPlaceholderComponent(props, error);
}

// lib/fiber/create-instance-from-react-element.ts
function prepare(object, state) {
  const instance = object;
  instance.__tsci = {
    ...state
  };
  return object;
}
var hostConfig = {
  supportsMutation: true,
  createInstance(type, props) {
    const target = catalogue[type];
    if (!target) {
      if (Object.keys(catalogue).length === 0) {
        throw new Error(
          "No components registered in catalogue, did you forget to import lib/register-catalogue in your test file?"
        );
      }
      throw new Error(
        `Unsupported component type "${type}". No element with this name is registered in the @tscircuit/core catalogue. Check for typos or see https://docs.tscircuit.com/category/built-in-elements for a list of valid components. To add your own component, see docs/CREATING_NEW_COMPONENTS.md`
      );
    }
    try {
      const instance = prepare(new target(props), {});
      return instance;
    } catch (error) {
      return createErrorPlaceholderComponent(
        { ...props, componentType: type },
        error
      );
    }
  },
  createTextInstance(text) {
    return { __text: text };
  },
  appendInitialChild(parentInstance, child) {
    parentInstance.add(child);
  },
  appendChild(parentInstance, child) {
    parentInstance.add(child);
  },
  appendChildToContainer(container, child) {
    container.add(child);
  },
  finalizeInitialChildren() {
    return false;
  },
  prepareUpdate() {
    return null;
  },
  shouldSetTextContent() {
    return false;
  },
  getRootHostContext() {
    return {};
  },
  getChildHostContext() {
    return {};
  },
  prepareForCommit() {
    return null;
  },
  resetAfterCommit() {
  },
  commitMount() {
  },
  commitUpdate() {
  },
  removeChild() {
  },
  clearContainer() {
  },
  supportsPersistence: false,
  getPublicInstance(instance) {
    return instance;
  },
  preparePortalMount(containerInfo) {
    throw new Error("Function not implemented.");
  },
  scheduleTimeout(fn, delay) {
    throw new Error("Function not implemented.");
  },
  cancelTimeout(id) {
    throw new Error("Function not implemented.");
  },
  noTimeout: void 0,
  isPrimaryRenderer: false,
  getInstanceFromNode(node) {
    throw new Error("Function not implemented.");
  },
  beforeActiveInstanceBlur() {
    throw new Error("Function not implemented.");
  },
  afterActiveInstanceBlur() {
    throw new Error("Function not implemented.");
  },
  prepareScopeUpdate: (scopeInstance, instance) => {
    throw new Error("Function not implemented.");
  },
  getInstanceFromScope: (scopeInstance) => {
    throw new Error("Function not implemented.");
  },
  detachDeletedInstance: (node) => {
    throw new Error("Function not implemented.");
  },
  // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
  getCurrentEventPriority: () => DefaultEventPriority,
  // @ts-expect-error
  // https://github.com/diegomura/react-pdf/blob/fabecc56727dfb6d590a3fa1e11f50250ecbbea1/packages/reconciler/src/reconciler-31.js#L57
  getCurrentUpdatePriority: () => DefaultEventPriority,
  resolveUpdatePriority: () => DefaultEventPriority,
  setCurrentUpdatePriority: () => {
  },
  maySuspendCommit: () => false,
  supportsHydration: false
};
var reconciler = ReactReconciler(hostConfig);
var createInstanceFromReactElement = (reactElm) => {
  const rootContainer = {
    children: [],
    props: {
      name: "$root"
    },
    add(instance) {
      instance.parent = this;
      this.children.push(instance);
    },
    computePcbGlobalTransform() {
      return identity2();
    }
  };
  const containerErrors = [];
  const container = reconciler.createContainer(
    // TODO Replace with store like react-three-fiber
    // https://github.com/pmndrs/react-three-fiber/blob/a457290856f57741bf8beef4f6ff9dbf4879c0a5/packages/fiber/src/core/index.tsx#L172
    // https://github.com/pmndrs/react-three-fiber/blob/master/packages/fiber/src/core/store.ts#L168
    rootContainer,
    0,
    null,
    false,
    null,
    "tsci",
    (error) => {
      console.log("Error in createContainer");
      console.error(error);
      containerErrors.push(error);
    },
    null
  );
  reconciler.updateContainerSync(reactElm, container, null, () => {
  });
  reconciler.flushSyncWork();
  if (containerErrors.length > 0) {
    throw containerErrors[0];
  }
  const rootInstance = reconciler.getPublicRootInstance(
    container
  );
  if (rootInstance) return rootInstance;
  return rootContainer.children[0];
};

// lib/soup/underscorifyPinStyles.ts
import "circuit-json";
import "zod";

// lib/utils/schematic/parsePinNumberFromLabelsOrThrow.ts
var parsePinNumberFromLabelsOrThrow = (pinNumberOrLabel, pinLabels) => {
  if (typeof pinNumberOrLabel === "number") {
    return pinNumberOrLabel;
  }
  if (pinNumberOrLabel.startsWith("pin")) {
    const pinNumber = Number(pinNumberOrLabel.slice(3));
    return pinNumber;
  }
  if (!pinLabels) {
    throw new Error(
      `No pin labels provided and pin number or label is not a number: "${pinNumberOrLabel}"`
    );
  }
  for (const pinNumberKey in pinLabels) {
    const aliases = Array.isArray(pinLabels[pinNumberKey]) ? pinLabels[pinNumberKey] : [pinLabels[pinNumberKey]];
    if (aliases.includes(pinNumberOrLabel)) {
      return Number(pinNumberKey.replace("pin", ""));
    }
  }
  throw new Error(
    `No pin labels provided and pin number or label is not a number: "${pinNumberOrLabel}"`
  );
};

// lib/soup/underscorifyPinStyles.ts
var underscorifyPinStyles = (pinStyles, pinLabels) => {
  if (!pinStyles) return void 0;
  const underscorePinStyles = {};
  const mergedStyles = {};
  for (const [pinNameOrLabel, pinStyle] of Object.entries(pinStyles)) {
    const pinNumber = parsePinNumberFromLabelsOrThrow(pinNameOrLabel, pinLabels);
    mergedStyles[pinNumber] = {
      ...mergedStyles[pinNumber],
      ...pinStyle
    };
  }
  for (const [pinNumber, pinStyle] of Object.entries(mergedStyles)) {
    const pinKey = `pin${pinNumber}`;
    underscorePinStyles[pinKey] = {
      bottom_margin: pinStyle.bottomMargin,
      left_margin: pinStyle.leftMargin,
      right_margin: pinStyle.rightMargin,
      top_margin: pinStyle.topMargin
    };
  }
  return underscorePinStyles;
};

// lib/soup/underscorifyPortArrangement.ts
var underscorifyPortArrangement = (portArrangement) => {
  if (!portArrangement) return void 0;
  if ("leftSide" in portArrangement || "rightSide" in portArrangement || "topSide" in portArrangement || "bottomSide" in portArrangement) {
    return {
      left_side: portArrangement.leftSide,
      right_side: portArrangement.rightSide,
      top_side: portArrangement.topSide,
      bottom_side: portArrangement.bottomSide
    };
  }
  if ("leftPinCount" in portArrangement || "rightPinCount" in portArrangement || "topPinCount" in portArrangement || "bottomPinCount" in portArrangement) {
    return {
      left_size: portArrangement.leftPinCount,
      right_size: portArrangement.rightPinCount,
      top_size: portArrangement.topPinCount,
      bottom_size: portArrangement.bottomPinCount
    };
  }
  if ("leftSize" in portArrangement || "rightSize" in portArrangement || "topSize" in portArrangement || "bottomSize" in portArrangement) {
    return {
      left_size: portArrangement.leftSize,
      right_size: portArrangement.rightSize,
      top_size: portArrangement.topSize,
      bottom_size: portArrangement.bottomSize
    };
  }
  return void 0;
};

// lib/components/primitive-components/Net.ts
import { z as z4 } from "zod";

// lib/utils/pairs.ts
function pairs(arr) {
  const result = [];
  for (let i = 0; i < arr.length - 1; i++) {
    result.push([arr[i], arr[i + 1]]);
  }
  return result;
}

// lib/components/primitive-components/Net.ts
import { autoroute } from "@tscircuit/infgrid-ijump-astar";
var netProps = z4.object({
  name: z4.string().refine(
    (val) => !/[+-]/.test(val),
    (val) => ({
      message: `Net names cannot contain "+" or "-" (component "Net" received "${val}"). Try using underscores instead, e.g. VCC_P`
    })
  )
});
var Net = class extends PrimitiveComponent2 {
  source_net_id;
  subcircuit_connectivity_map_key = null;
  get config() {
    return {
      componentName: "Net",
      zodProps: netProps
    };
  }
  getPortSelector() {
    return `net.${this.props.name}`;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const isGround = props.name.startsWith("GND");
    const isPositiveVoltageSource = props.name.startsWith("V");
    const net = db.source_net.insert({
      name: props.name,
      member_source_group_ids: [],
      is_ground: isGround,
      is_power: isPositiveVoltageSource,
      // @ts-ignore
      is_positive_voltage_source: isPositiveVoltageSource
    });
    this.source_net_id = net.source_net_id;
  }
  doInitialSourceParentAttachment() {
    const subcircuit = this.getSubcircuit();
    if (!subcircuit) return;
    const { db } = this.root;
    db.source_net.update(this.source_net_id, {
      subcircuit_id: subcircuit.subcircuit_id
    });
  }
  /**
   * Get all ports connected to this net.
   *
   * TODO currently we're not checking for indirect connections (traces that are
   * connected to other traces that are in turn connected to the net)
   */
  getAllConnectedPorts() {
    const allPorts = this.getSubcircuit().selectAll("port");
    const connectedPorts = [];
    for (const port of allPorts) {
      const traces = port._getDirectlyConnectedTraces();
      for (const trace of traces) {
        if (trace._isExplicitlyConnectedToNet(this)) {
          connectedPorts.push(port);
          break;
        }
      }
    }
    return connectedPorts;
  }
  /**
   * Get all traces that are directly connected to this net, i.e. they list
   * this net in their path, from, or to props
   */
  _getAllDirectlyConnectedTraces() {
    const allTraces = this.getSubcircuit().selectAll("trace");
    const connectedTraces = [];
    for (const trace of allTraces) {
      if (trace._isExplicitlyConnectedToNet(this)) {
        connectedTraces.push(trace);
      }
    }
    return connectedTraces;
  }
  /**
   * Add PCB Traces to connect net islands together. A net island is a set of
   * ports that are connected to each other. If a there are multiple net islands
   * that means that the net is not fully connected and we need to add traces
   * such that the nets are fully connected
   *
   * Sometimes this phase doesn't find any net islands if the autorouter did
   * a good job and connected the islands. In some sense this is a "backup"
   * routing phase for autorouters that don't care about connecting nets.
   *
   * This should only run if the autorouter is sequential-trace
   */
  doInitialPcbRouteNetIslands() {
    if (this.root?.pcbDisabled) return;
    if (this.getSubcircuit()._parsedProps.routingDisabled) return;
    if (this.getSubcircuit()._getAutorouterConfig().groupMode !== "sequential-trace")
      return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const traces = this._getAllDirectlyConnectedTraces().filter(
      (trace) => (trace._portsRoutedOnPcb?.length ?? 0) > 0
    );
    const islands = [];
    for (const trace of traces) {
      const tracePorts = trace._portsRoutedOnPcb;
      const traceIsland = islands.find(
        (island) => tracePorts.some((port) => island.ports.includes(port))
      );
      if (!traceIsland) {
        islands.push({ ports: [...tracePorts], traces: [trace] });
        continue;
      }
      traceIsland.traces.push(trace);
      traceIsland.ports.push(...tracePorts);
    }
    if (islands.length === 0) {
      return;
    }
    const islandPairs = pairs(islands);
    for (const [A, B] of islandPairs) {
      const Apositions = A.ports.map(
        (port) => port._getGlobalPcbPositionBeforeLayout()
      );
      const Bpositions = B.ports.map(
        (port) => port._getGlobalPcbPositionBeforeLayout()
      );
      let closestDist = Infinity;
      let closestPair = [-1, -1];
      for (let i = 0; i < Apositions.length; i++) {
        const Apos = Apositions[i];
        for (let j = 0; j < Bpositions.length; j++) {
          const Bpos = Bpositions[j];
          const dist = Math.sqrt(
            (Apos.x - Bpos.x) ** 2 + (Apos.y - Bpos.y) ** 2
          );
          if (dist < closestDist) {
            closestDist = dist;
            closestPair = [i, j];
          }
        }
      }
      const Aport = A.ports[closestPair[0]];
      const Bport = B.ports[closestPair[1]];
      const pcbElements = db.toArray().filter(
        (elm) => elm.type === "pcb_smtpad" || elm.type === "pcb_trace" || elm.type === "pcb_plated_hole" || elm.type === "pcb_hole" || elm.type === "source_port" || elm.type === "pcb_port"
      );
      const { solution } = autoroute(
        pcbElements.concat([
          {
            type: "source_trace",
            source_trace_id: "__net_trace_tmp",
            connected_source_port_ids: [
              Aport.source_port_id,
              Bport.source_port_id
            ]
          }
        ])
        // Remove as any when autorouting-dataset has been updated
      );
      const trace = solution[0];
      if (!trace) {
        this.renderError({
          pcb_trace_error_id: "",
          pcb_trace_id: "__net_trace_tmp",
          pcb_component_ids: [
            Aport.pcb_component_id,
            Bport.pcb_component_id
          ].filter(Boolean),
          pcb_port_ids: [Aport.pcb_port_id, Bport.pcb_port_id].filter(
            Boolean
          ),
          type: "pcb_trace_error",
          error_type: "pcb_trace_error",
          message: `Failed to route net islands for "${this.getString()}"`,
          source_trace_id: "__net_trace_tmp"
        });
        return;
      }
      db.pcb_trace.insert(trace);
    }
  }
  renderError(message) {
    if (typeof message === "string") {
      return super.renderError(message);
    }
    this.root?.db.pcb_trace_error.insert(message);
  }
};

// lib/utils/components/createNetsFromProps.ts
var createNetsFromProps = (component, props) => {
  for (const prop of props) {
    if (typeof prop === "string" && prop.startsWith("net.")) {
      if (/net\.[^\s>]*\./.test(prop)) {
        throw new Error(
          'Net names cannot contain a period, try using "sel.net..." to autocomplete with conventional net names, e.g. V3_3'
        );
      }
      if (/net\.[^\s>]*[+-]/.test(prop)) {
        const netName = prop.split("net.")[1];
        const message = `Net names cannot contain "+" or "-" (component "${component.componentName}" received "${netName}" via "${prop}"). Try using underscores instead, e.g. VCC_P`;
        throw new Error(message);
      }
      if (/net\.[0-9]/.test(prop)) {
        const netName = prop.split("net.")[1];
        throw new Error(
          `Net name "${netName}" cannot start with a number, try using a prefix like "VBUS1"`
        );
      }
      const subcircuit = component.getSubcircuit();
      if (!subcircuit.selectOne(prop)) {
        const net = new Net({
          name: prop.split("net.")[1]
        });
        subcircuit.add(net);
      }
    }
  }
};

// lib/components/primitive-components/SmtPad.ts
import { smtPadProps } from "@tscircuit/props";
import {
  distance
} from "circuit-json";
import { applyToPoint as applyToPoint2, decomposeTSR } from "transformation-matrix";
var SmtPad = class extends PrimitiveComponent2 {
  pcb_smtpad_id = null;
  matchedPort = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SmtPad",
      zodProps: smtPadProps
    };
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    if (props.shape === "circle") {
      return { width: props.radius * 2, height: props.radius * 2 };
    }
    if (props.shape === "rect") {
      return { width: props.width, height: props.height };
    }
    if (props.shape === "rotated_rect") {
      const rotationDegrees = props.ccwRotation ?? 0;
      const angleRad = rotationDegrees * Math.PI / 180;
      const cosAngle = Math.cos(angleRad);
      const sinAngle = Math.sin(angleRad);
      const width = Math.abs(props.width * cosAngle) + Math.abs(props.height * sinAngle);
      const height = Math.abs(props.width * sinAngle) + Math.abs(props.height * cosAngle);
      return { width, height };
    }
    if (props.shape === "polygon") {
      const points = props.points;
      const xs = points.map((p) => p.x);
      const ys = points.map((p) => p.y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      return { width: maxX - minX, height: maxY - minY };
    }
    if (props.shape === "pill") {
      return { width: props.width, height: props.height };
    }
    throw new Error(
      `getPcbSize for shape "${props.shape}" not implemented for ${this.componentName}`
    );
  }
  doInitialPortMatching() {
    const parentPorts = this.getPrimitiveContainer()?.selectAll(
      "port"
    );
    if (!this.props.portHints) {
      return;
    }
    for (const port of parentPorts) {
      if (port.isMatchingAnyOf(this.props.portHints)) {
        this.matchedPort = port;
        port.registerMatch(this);
        return;
      }
    }
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const isCoveredWithSolderMask = props.coveredWithSolderMask ?? false;
    const shouldCreateSolderPaste = !isCoveredWithSolderMask;
    const subcircuit = this.getSubcircuit();
    const position = this._getGlobalPcbPositionBeforeLayout();
    const globalTransform = this._computePcbGlobalTransformBeforeLayout();
    const decomposedTransform = decomposeTSR(
      this._computePcbGlobalTransformBeforeLayout()
    );
    const rotationDegrees = decomposedTransform.rotation.angle * 180 / Math.PI;
    const normalizedRotationDegrees = (rotationDegrees % 360 + 360) % 360;
    const rotationTolerance = 0.01;
    const isAxisAligned = Math.abs(normalizedRotationDegrees) < rotationTolerance || Math.abs(normalizedRotationDegrees - 180) < rotationTolerance || Math.abs(normalizedRotationDegrees - 360) < rotationTolerance;
    const isRotated90Degrees = Math.abs(normalizedRotationDegrees - 90) < rotationTolerance || Math.abs(normalizedRotationDegrees - 270) < rotationTolerance;
    let finalRotationDegrees = Math.abs(normalizedRotationDegrees - 360) < rotationTolerance ? 0 : normalizedRotationDegrees;
    const transformRotationBeforeFlip = finalRotationDegrees;
    const { maybeFlipLayer, isFlipped } = this._getPcbPrimitiveFlippedHelpers();
    if (isFlipped) {
      finalRotationDegrees = (360 - finalRotationDegrees + 360) % 360;
    }
    const portHints = props.portHints?.map((ph) => ph.toString()) ?? [];
    let pcb_smtpad = null;
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id;
    if (props.shape === "circle") {
      pcb_smtpad = db.pcb_smtpad.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        // port likely isn't matched
        layer: maybeFlipLayer(props.layer ?? "top"),
        shape: "circle",
        radius: props.radius,
        port_hints: portHints,
        is_covered_with_solder_mask: isCoveredWithSolderMask,
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0
      });
      if (shouldCreateSolderPaste)
        db.pcb_solder_paste.insert({
          layer: pcb_smtpad.layer,
          shape: "circle",
          radius: pcb_smtpad.radius * 0.7,
          x: pcb_smtpad.x,
          y: pcb_smtpad.y,
          pcb_component_id: pcb_smtpad.pcb_component_id,
          pcb_smtpad_id: pcb_smtpad.pcb_smtpad_id,
          subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
          pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
        });
    } else if (props.shape === "rect") {
      const hasRotation = !isAxisAligned && !isRotated90Degrees;
      if (hasRotation) {
        pcb_smtpad = db.pcb_smtpad.insert({
          pcb_component_id,
          pcb_port_id: this.matchedPort?.pcb_port_id,
          layer: maybeFlipLayer(props.layer ?? "top"),
          shape: "rotated_rect",
          width: props.width,
          height: props.height,
          corner_radius: props.cornerRadius ?? void 0,
          x: position.x,
          y: position.y,
          ccw_rotation: finalRotationDegrees,
          port_hints: portHints,
          is_covered_with_solder_mask: isCoveredWithSolderMask,
          subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
          pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
        });
      } else {
        pcb_smtpad = db.pcb_smtpad.insert({
          pcb_component_id,
          pcb_port_id: this.matchedPort?.pcb_port_id,
          layer: maybeFlipLayer(props.layer ?? "top"),
          shape: "rect",
          width: isRotated90Degrees ? props.height : props.width,
          height: isRotated90Degrees ? props.width : props.height,
          corner_radius: props.cornerRadius ?? void 0,
          port_hints: portHints,
          is_covered_with_solder_mask: isCoveredWithSolderMask,
          x: position.x,
          y: position.y,
          subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
          pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
        });
      }
      if (shouldCreateSolderPaste) {
        if (pcb_smtpad.shape === "rect") {
          db.pcb_solder_paste.insert({
            layer: maybeFlipLayer(props.layer ?? "top"),
            shape: "rect",
            width: pcb_smtpad.width * 0.7,
            height: pcb_smtpad.height * 0.7,
            x: pcb_smtpad.x,
            y: pcb_smtpad.y,
            pcb_component_id: pcb_smtpad.pcb_component_id,
            pcb_smtpad_id: pcb_smtpad.pcb_smtpad_id,
            subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
            pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
          });
        } else if (pcb_smtpad.shape === "rotated_rect") {
          db.pcb_solder_paste.insert({
            layer: maybeFlipLayer(props.layer ?? "top"),
            shape: "rotated_rect",
            width: pcb_smtpad.width * 0.7,
            height: pcb_smtpad.height * 0.7,
            x: pcb_smtpad.x,
            y: pcb_smtpad.y,
            ccw_rotation: pcb_smtpad.ccw_rotation,
            pcb_component_id: pcb_smtpad.pcb_component_id,
            pcb_smtpad_id: pcb_smtpad.pcb_smtpad_id,
            subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
            pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
          });
        }
      }
    } else if (props.shape === "rotated_rect") {
      const baseRotation = props.ccwRotation ?? 0;
      const combinedRotationBeforeFlip = (transformRotationBeforeFlip + baseRotation + 360) % 360;
      const padRotation = isFlipped ? (360 - combinedRotationBeforeFlip + 360) % 360 : combinedRotationBeforeFlip;
      pcb_smtpad = db.pcb_smtpad.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        layer: maybeFlipLayer(props.layer ?? "top"),
        shape: "rotated_rect",
        width: props.width,
        height: props.height,
        corner_radius: props.cornerRadius ?? void 0,
        x: position.x,
        y: position.y,
        ccw_rotation: padRotation,
        port_hints: portHints,
        is_covered_with_solder_mask: isCoveredWithSolderMask,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      if (shouldCreateSolderPaste)
        db.pcb_solder_paste.insert({
          layer: maybeFlipLayer(props.layer ?? "top"),
          shape: "rotated_rect",
          width: pcb_smtpad.width * 0.7,
          height: pcb_smtpad.height * 0.7,
          x: position.x,
          y: position.y,
          ccw_rotation: padRotation,
          pcb_component_id,
          pcb_smtpad_id: pcb_smtpad.pcb_smtpad_id,
          subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
          pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
        });
    } else if (props.shape === "polygon") {
      const transformedPoints = props.points.map((point) => {
        const transformed = applyToPoint2(globalTransform, {
          x: distance.parse(point.x),
          y: distance.parse(point.y)
        });
        return {
          x: transformed.x,
          y: transformed.y
        };
      });
      pcb_smtpad = db.pcb_smtpad.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        // port likely isn't matched
        layer: maybeFlipLayer(props.layer ?? "top"),
        shape: "polygon",
        points: transformedPoints,
        port_hints: portHints,
        is_covered_with_solder_mask: isCoveredWithSolderMask,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
    } else if (props.shape === "pill") {
      pcb_smtpad = db.pcb_smtpad.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        // port likely isn't matched
        layer: maybeFlipLayer(props.layer ?? "top"),
        shape: "pill",
        x: position.x,
        y: position.y,
        radius: props.radius,
        height: props.height,
        width: props.width,
        port_hints: portHints,
        is_covered_with_solder_mask: isCoveredWithSolderMask,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
    }
    if (pcb_smtpad) {
      this.pcb_smtpad_id = pcb_smtpad.pcb_smtpad_id;
    }
  }
  doInitialPcbPortAttachment() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    db.pcb_smtpad.update(this.pcb_smtpad_id, {
      pcb_port_id: this.matchedPort?.pcb_port_id
    });
  }
  _getPcbCircuitJsonBounds() {
    const { db } = this.root;
    const smtpad = db.pcb_smtpad.get(this.pcb_smtpad_id);
    if (smtpad.shape === "rect") {
      return {
        center: { x: smtpad.x, y: smtpad.y },
        bounds: {
          left: smtpad.x - smtpad.width / 2,
          top: smtpad.y + smtpad.height / 2,
          right: smtpad.x + smtpad.width / 2,
          bottom: smtpad.y - smtpad.height / 2
        },
        width: smtpad.width,
        height: smtpad.height
      };
    }
    if (smtpad.shape === "rotated_rect") {
      const angleRad = smtpad.ccw_rotation * Math.PI / 180;
      const cosAngle = Math.cos(angleRad);
      const sinAngle = Math.sin(angleRad);
      const w2 = smtpad.width / 2;
      const h2 = smtpad.height / 2;
      const xExtent = Math.abs(w2 * cosAngle) + Math.abs(h2 * sinAngle);
      const yExtent = Math.abs(w2 * sinAngle) + Math.abs(h2 * cosAngle);
      return {
        center: { x: smtpad.x, y: smtpad.y },
        bounds: {
          left: smtpad.x - xExtent,
          right: smtpad.x + xExtent,
          top: smtpad.y - yExtent,
          bottom: smtpad.y + yExtent
        },
        width: xExtent * 2,
        height: yExtent * 2
      };
    }
    if (smtpad.shape === "circle") {
      return {
        center: { x: smtpad.x, y: smtpad.y },
        bounds: {
          left: smtpad.x - smtpad.radius,
          top: smtpad.y - smtpad.radius,
          right: smtpad.x + smtpad.radius,
          bottom: smtpad.y + smtpad.radius
        },
        width: smtpad.radius * 2,
        height: smtpad.radius * 2
      };
    }
    if (smtpad.shape === "polygon") {
      const points = smtpad.points;
      const xs = points.map((p) => p.x);
      const ys = points.map((p) => p.y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      return {
        center: { x: (minX + maxX) / 2, y: (minY + maxY) / 2 },
        bounds: {
          left: minX,
          top: maxY,
          right: maxX,
          bottom: minY
        },
        width: maxX - minX,
        height: maxY - minY
      };
    }
    if (smtpad.shape === "pill") {
      const halfWidth = smtpad.width / 2;
      const halfHeight = smtpad.height / 2;
      return {
        center: { x: smtpad.x, y: smtpad.y },
        bounds: {
          left: smtpad.x - halfWidth,
          top: smtpad.y - halfHeight,
          right: smtpad.x + halfWidth,
          bottom: smtpad.y + halfHeight
        },
        width: smtpad.width,
        height: smtpad.height
      };
    }
    throw new Error(
      `circuitJson bounds calculation not implemented for shape "${smtpad.shape}"`
    );
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    db.pcb_smtpad.update(this.pcb_smtpad_id, {
      x: newCenter.x,
      y: newCenter.y
    });
    const solderPaste = db.pcb_solder_paste.list().find((elm) => elm.pcb_smtpad_id === this.pcb_smtpad_id);
    if (solderPaste) {
      db.pcb_solder_paste.update(solderPaste.pcb_solder_paste_id, {
        x: newCenter.x,
        y: newCenter.y
      });
    }
    this.matchedPort?._setPositionFromLayout(newCenter);
  }
};

// lib/components/primitive-components/SilkscreenPath.ts
import { silkscreenPathProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint3 } from "transformation-matrix";
var SilkscreenPath = class extends PrimitiveComponent2 {
  pcb_silkscreen_path_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SilkscreenPath",
      zodProps: silkscreenPathProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const layer = maybeFlipLayer(props.layer ?? "top");
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for SilkscreenPath. Must be "top" or "bottom".`
      );
    }
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const subcircuit = this.getSubcircuit();
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id;
    const pcb_silkscreen_path = db.pcb_silkscreen_path.insert({
      pcb_component_id,
      layer,
      route: props.route.map((p) => {
        const transformedPosition = applyToPoint3(transform, {
          x: p.x,
          y: p.y
        });
        return {
          ...p,
          x: transformedPosition.x,
          y: transformedPosition.y
        };
      }),
      stroke_width: props.strokeWidth ?? 0.1,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
    });
    this.pcb_silkscreen_path_id = pcb_silkscreen_path.pcb_silkscreen_path_id;
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const currentPath = db.pcb_silkscreen_path.get(this.pcb_silkscreen_path_id);
    if (!currentPath) return;
    let currentCenterX = 0;
    let currentCenterY = 0;
    for (const point of currentPath.route) {
      currentCenterX += point.x;
      currentCenterY += point.y;
    }
    currentCenterX /= currentPath.route.length;
    currentCenterY /= currentPath.route.length;
    const offsetX = newCenter.x - currentCenterX;
    const offsetY = newCenter.y - currentCenterY;
    const newRoute = currentPath.route.map((point) => ({
      ...point,
      x: point.x + offsetX,
      y: point.y + offsetY
    }));
    db.pcb_silkscreen_path.update(this.pcb_silkscreen_path_id, {
      route: newRoute
    });
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    if (!props.route || props.route.length === 0) {
      return { width: 0, height: 0 };
    }
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const point of props.route) {
      minX = Math.min(minX, point.x);
      maxX = Math.max(maxX, point.x);
      minY = Math.min(minY, point.y);
      maxY = Math.max(maxY, point.y);
    }
    return {
      width: maxX - minX,
      height: maxY - minY
    };
  }
};

// lib/components/primitive-components/PcbTrace.ts
import { z as z5 } from "zod";
import { pcb_trace_route_point } from "circuit-json";
import { applyToPoint as applyToPoint4 } from "transformation-matrix";
var pcbTraceProps = z5.object({
  route: z5.array(pcb_trace_route_point),
  // If this primitive PcbTrace needs to be associated with a source_trace_id
  // it can be added as a prop here. For footprints, it's often not needed.
  source_trace_id: z5.string().optional()
});
var PcbTrace = class extends PrimitiveComponent2 {
  pcb_trace_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "PcbTrace",
      zodProps: pcbTraceProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const container = this.getPrimitiveContainer();
    const subcircuit = this.getSubcircuit();
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const parentTransform = this._computePcbGlobalTransformBeforeLayout();
    const transformedRoute = props.route.map((point) => {
      const { x, y, ...restOfPoint } = point;
      const transformedPoint = applyToPoint4(parentTransform, { x, y });
      if (point.route_type === "wire" && point.layer) {
        return {
          ...transformedPoint,
          ...restOfPoint,
          layer: maybeFlipLayer(point.layer)
        };
      }
      return { ...transformedPoint, ...restOfPoint };
    });
    const pcb_trace = db.pcb_trace.insert({
      pcb_component_id: container.pcb_component_id,
      source_trace_id: props.source_trace_id,
      route: transformedRoute,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
    });
    this.pcb_trace_id = pcb_trace.pcb_trace_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    if (!props.route || props.route.length === 0) {
      return { width: 0, height: 0 };
    }
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const point of props.route) {
      minX = Math.min(minX, point.x);
      maxX = Math.max(maxX, point.x);
      minY = Math.min(minY, point.y);
      maxY = Math.max(maxY, point.y);
      if (point.route_type === "wire") {
        minX = Math.min(minX, point.x - point.width / 2);
        maxX = Math.max(maxX, point.x + point.width / 2);
        minY = Math.min(minY, point.y - point.width / 2);
        maxY = Math.max(maxY, point.y + point.width / 2);
      }
    }
    if (minX === Infinity || maxX === -Infinity || minY === Infinity || maxY === -Infinity) {
      return { width: 0, height: 0 };
    }
    return {
      width: maxX - minX,
      height: maxY - minY
    };
  }
};

// lib/components/primitive-components/PlatedHole.ts
import { platedHoleProps } from "@tscircuit/props";
var PlatedHole = class extends PrimitiveComponent2 {
  pcb_plated_hole_id = null;
  matchedPort = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "PlatedHole",
      zodProps: platedHoleProps
    };
  }
  getAvailablePcbLayers() {
    return ["top", "inner1", "inner2", "bottom"];
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    if (props.shape === "circle") {
      return { width: props.outerDiameter, height: props.outerDiameter };
    }
    if (props.shape === "oval" || props.shape === "pill") {
      return { width: props.outerWidth, height: props.outerHeight };
    }
    if (props.shape === "circular_hole_with_rect_pad") {
      return { width: props.rectPadWidth, height: props.rectPadHeight };
    }
    if (props.shape === "pill_hole_with_rect_pad") {
      return { width: props.rectPadWidth, height: props.rectPadHeight };
    }
    if (props.shape === "hole_with_polygon_pad") {
      if (!props.padOutline || props.padOutline.length === 0) {
        throw new Error(
          "padOutline is required for hole_with_polygon_pad shape"
        );
      }
      const xs = props.padOutline.map(
        (p) => typeof p.x === "number" ? p.x : parseFloat(String(p.x))
      );
      const ys = props.padOutline.map(
        (p) => typeof p.y === "number" ? p.y : parseFloat(String(p.y))
      );
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      return { width: maxX - minX, height: maxY - minY };
    }
    throw new Error(
      `getPcbSize for shape "${props.shape}" not implemented for ${this.componentName}`
    );
  }
  _getPcbCircuitJsonBounds() {
    const { db } = this.root;
    const platedHole = db.pcb_plated_hole.get(this.pcb_plated_hole_id);
    const size = this.getPcbSize();
    return {
      center: { x: platedHole.x, y: platedHole.y },
      bounds: {
        left: platedHole.x - size.width / 2,
        top: platedHole.y + size.height / 2,
        right: platedHole.x + size.width / 2,
        bottom: platedHole.y - size.height / 2
      },
      width: size.width,
      height: size.height
    };
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    db.pcb_plated_hole.update(this.pcb_plated_hole_id, {
      x: newCenter.x,
      y: newCenter.y
    });
    this.matchedPort?._setPositionFromLayout(newCenter);
  }
  doInitialPortMatching() {
    const parentPorts = this.getPrimitiveContainer()?.selectAll(
      "port"
    );
    if (!this.props.portHints) {
      return;
    }
    for (const port of parentPorts) {
      if (port.isMatchingAnyOf(this.props.portHints)) {
        this.matchedPort = port;
        port.registerMatch(this);
        return;
      }
    }
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const position = this._getGlobalPcbPositionBeforeLayout();
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id;
    const subcircuit = this.getSubcircuit();
    if (props.shape === "circle") {
      const pcb_plated_hole = db.pcb_plated_hole.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        // @ts-ignore - some issue with circuit-json union type
        outer_diameter: props.outerDiameter,
        hole_diameter: props.holeDiameter,
        shape: "circle",
        port_hints: this.getNameAndAliases(),
        x: position.x,
        y: position.y,
        layers: ["top", "bottom"],
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      this.pcb_plated_hole_id = pcb_plated_hole.pcb_plated_hole_id;
      db.pcb_solder_paste.insert({
        layer: "top",
        shape: "circle",
        // @ts-ignore: no idea why this is triggering
        radius: props.outerDiameter / 2,
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      db.pcb_solder_paste.insert({
        layer: "bottom",
        shape: "circle",
        // @ts-ignore: no idea why this is triggering
        radius: props.outerDiameter / 2,
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
    } else if (props.shape === "pill" && props.rectPad) {
      const pcb_plated_hole = db.pcb_plated_hole.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        outer_width: props.outerWidth,
        outer_height: props.outerHeight,
        hole_width: props.holeWidth,
        hole_height: props.holeHeight,
        shape: "rotated_pill_hole_with_rect_pad",
        type: "pcb_plated_hole",
        port_hints: this.getNameAndAliases(),
        pcb_plated_hole_id: this.pcb_plated_hole_id,
        x: position.x,
        y: position.y,
        layers: ["top", "bottom"],
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
        hole_shape: "rotated_pill",
        pad_shape: "rect",
        hole_ccw_rotation: props.pcbRotation ?? 0,
        rect_ccw_rotation: props.pcbRotation ?? 0,
        rect_pad_width: props.outerWidth,
        rect_pad_height: props.outerHeight,
        hole_offset_x: props.holeOffsetX,
        hole_offset_y: props.holeOffsetY
      });
      this.pcb_plated_hole_id = pcb_plated_hole.pcb_plated_hole_id;
    } else if (props.shape === "pill" || props.shape === "oval") {
      const pcb_plated_hole = db.pcb_plated_hole.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        outer_width: props.outerWidth,
        outer_height: props.outerHeight,
        hole_width: props.holeWidth,
        hole_height: props.holeHeight,
        shape: props.shape,
        port_hints: this.getNameAndAliases(),
        x: position.x,
        y: position.y,
        layers: ["top", "bottom"],
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
        ccw_rotation: props.pcbRotation ?? 0
        // NOTE: currently PcbPlatedHoleOval erroneously includes both the shape "pill" and "oval"
      });
      this.pcb_plated_hole_id = pcb_plated_hole.pcb_plated_hole_id;
      db.pcb_solder_paste.insert({
        layer: "top",
        shape: props.shape,
        // @ts-ignore: no idea why this is triggering
        width: props.outerWidth,
        height: props.outerHeight,
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      db.pcb_solder_paste.insert({
        layer: "bottom",
        shape: props.shape,
        // @ts-ignore: no idea why this is triggering
        width: props.outerWidth,
        height: props.outerHeight,
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
    } else if (props.shape === "circular_hole_with_rect_pad") {
      const pcb_plated_hole = db.pcb_plated_hole.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        hole_diameter: props.holeDiameter,
        rect_pad_width: props.rectPadWidth,
        rect_pad_height: props.rectPadHeight,
        shape: "circular_hole_with_rect_pad",
        port_hints: this.getNameAndAliases(),
        x: position.x,
        y: position.y,
        layers: ["top", "bottom"],
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
        hole_offset_x: props.holeOffsetX,
        hole_offset_y: props.holeOffsetY,
        rect_border_radius: props.rectBorderRadius ?? 0
      });
      this.pcb_plated_hole_id = pcb_plated_hole.pcb_plated_hole_id;
    } else if (props.shape === "pill_hole_with_rect_pad") {
      const pcb_plated_hole = db.pcb_plated_hole.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        hole_width: props.holeWidth,
        hole_height: props.holeHeight,
        rect_pad_width: props.rectPadWidth,
        rect_pad_height: props.rectPadHeight,
        hole_offset_x: props.holeOffsetX,
        hole_offset_y: props.holeOffsetY,
        shape: "pill_hole_with_rect_pad",
        port_hints: this.getNameAndAliases(),
        x: position.x,
        y: position.y,
        layers: ["top", "bottom"],
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      this.pcb_plated_hole_id = pcb_plated_hole.pcb_plated_hole_id;
    } else if (props.shape === "hole_with_polygon_pad") {
      const padOutline = (props.padOutline || []).map((point) => {
        const x = typeof point.x === "number" ? point.x : parseFloat(String(point.x));
        const y = typeof point.y === "number" ? point.y : parseFloat(String(point.y));
        return {
          x,
          y
        };
      });
      const pcb_plated_hole = db.pcb_plated_hole.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        shape: "hole_with_polygon_pad",
        hole_shape: props.holeShape || "circle",
        hole_diameter: props.holeDiameter,
        hole_width: props.holeWidth,
        hole_height: props.holeHeight,
        pad_outline: padOutline,
        hole_offset_x: typeof props.holeOffsetX === "number" ? props.holeOffsetX : parseFloat(String(props.holeOffsetX || 0)),
        hole_offset_y: typeof props.holeOffsetY === "number" ? props.holeOffsetY : parseFloat(String(props.holeOffsetY || 0)),
        port_hints: this.getNameAndAliases(),
        x: position.x,
        y: position.y,
        layers: ["top", "bottom"],
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      this.pcb_plated_hole_id = pcb_plated_hole.pcb_plated_hole_id;
    }
  }
  doInitialPcbPortAttachment() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    db.pcb_plated_hole.update(this.pcb_plated_hole_id, {
      pcb_port_id: this.matchedPort?.pcb_port_id
    });
  }
};

// lib/components/primitive-components/Keepout.ts
import { pcbKeepoutProps } from "@tscircuit/props";
import { decomposeTSR as decomposeTSR2 } from "transformation-matrix";
var Keepout = class extends PrimitiveComponent2 {
  pcb_keepout_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "Keepout",
      zodProps: pcbKeepoutProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const subcircuit = this.getSubcircuit();
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const position = this._getGlobalPcbPositionBeforeLayout();
    const decomposedMat = decomposeTSR2(
      this._computePcbGlobalTransformBeforeLayout()
    );
    const isRotated90 = Math.abs(decomposedMat.rotation.angle * (180 / Math.PI) - 90) % 180 < 0.01;
    let pcb_keepout = null;
    if (props.shape === "circle") {
      pcb_keepout = db.pcb_keepout.insert({
        layers: ["top"],
        shape: "circle",
        // @ts-ignore: no idea why this is triggering
        radius: props.radius,
        center: {
          x: position.x,
          y: position.y
        },
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: subcircuit?.getGroup()?.pcb_group_id ?? void 0
      });
    } else if (props.shape === "rect") {
      pcb_keepout = db.pcb_keepout.insert({
        layers: ["top"],
        shape: "rect",
        ...isRotated90 ? { width: props.height, height: props.width } : { width: props.width, height: props.height },
        // @ts-ignore: no idea why this is triggering
        center: {
          x: position.x,
          y: position.y
        },
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: subcircuit?.getGroup()?.pcb_group_id ?? void 0
      });
    }
    if (pcb_keepout) {
      this.pcb_keepout_id = pcb_keepout.pcb_keepout_id;
    }
  }
};

// lib/components/primitive-components/Hole.ts
import { holeProps } from "@tscircuit/props";
var Hole = class extends PrimitiveComponent2 {
  pcb_hole_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "Hole",
      zodProps: holeProps
    };
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    const isPill = props.shape === "pill";
    const isRect = props.shape === "rect";
    if (isPill) {
      return {
        width: props.width,
        height: props.height
      };
    } else if (isRect) {
      return {
        width: props.width,
        height: props.height
      };
    } else {
      return {
        width: props.diameter,
        height: props.diameter
      };
    }
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const subcircuit = this.getSubcircuit();
    const position = this._getGlobalPcbPositionBeforeLayout();
    if (props.shape === "pill") {
      if (props.pcbRotation && props.pcbRotation !== 0) {
        const inserted_hole = db.pcb_hole.insert({
          type: "pcb_hole",
          hole_shape: "rotated_pill",
          hole_width: props.width,
          hole_height: props.height,
          x: position.x,
          y: position.y,
          ccw_rotation: props.pcbRotation,
          subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
          pcb_group_id: subcircuit?.getGroup()?.pcb_group_id ?? void 0
        });
        this.pcb_hole_id = inserted_hole.pcb_hole_id;
      } else {
        const inserted_hole = db.pcb_hole.insert({
          type: "pcb_hole",
          hole_shape: "pill",
          hole_width: props.width,
          hole_height: props.height,
          x: position.x,
          y: position.y,
          subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
          pcb_group_id: subcircuit?.getGroup()?.pcb_group_id ?? void 0
        });
        this.pcb_hole_id = inserted_hole.pcb_hole_id;
      }
    } else if (props.shape === "rect") {
      const inserted_hole = db.pcb_hole.insert({
        type: "pcb_hole",
        hole_shape: "rect",
        hole_width: props.width,
        hole_height: props.height,
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: subcircuit?.getGroup()?.pcb_group_id ?? void 0
      });
      this.pcb_hole_id = inserted_hole.pcb_hole_id;
    } else {
      const inserted_hole = db.pcb_hole.insert({
        type: "pcb_hole",
        hole_shape: "circle",
        hole_diameter: props.diameter,
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: subcircuit?.getGroup()?.pcb_group_id ?? void 0
      });
      this.pcb_hole_id = inserted_hole.pcb_hole_id;
    }
  }
  _getPcbCircuitJsonBounds() {
    const { db } = this.root;
    const hole = db.pcb_hole.get(this.pcb_hole_id);
    const size = this.getPcbSize();
    return {
      center: { x: hole.x, y: hole.y },
      bounds: {
        left: hole.x - size.width / 2,
        top: hole.y - size.height / 2,
        right: hole.x + size.width / 2,
        bottom: hole.y + size.height / 2
      },
      width: size.width,
      height: size.height
    };
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    db.pcb_hole.update(this.pcb_hole_id, {
      x: newCenter.x,
      y: newCenter.y
    });
  }
};

// lib/components/primitive-components/SilkscreenText.ts
import { silkscreenTextProps } from "@tscircuit/props";
import { decomposeTSR as decomposeTSR3 } from "transformation-matrix";
var SilkscreenText = class extends PrimitiveComponent2 {
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SilkscreenText",
      zodProps: silkscreenTextProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const container = this.getPrimitiveContainer();
    const position = this._getGlobalPcbPositionBeforeLayout();
    const { maybeFlipLayer, isFlipped } = this._getPcbPrimitiveFlippedHelpers();
    const subcircuit = this.getSubcircuit();
    let rotation5 = 0;
    if (props.pcbRotation !== void 0 && props.pcbRotation !== 0) {
      rotation5 = props.pcbRotation;
    } else {
      const globalTransform = this._computePcbGlobalTransformBeforeLayout();
      const decomposedTransform = decomposeTSR3(globalTransform);
      rotation5 = decomposedTransform.rotation.angle * 180 / Math.PI;
    }
    if (isFlipped) {
      rotation5 = (rotation5 + 180) % 360;
    }
    const uniqueLayers = new Set(props.layers);
    if (props.layer) uniqueLayers.add(props.layer);
    const targetLayers = uniqueLayers.size > 0 ? Array.from(uniqueLayers) : ["top"];
    const fontSize = props.fontSize ?? this.getInheritedProperty("pcbStyle")?.silkscreenFontSize ?? 1;
    for (const layer of targetLayers) {
      db.pcb_silkscreen_text.insert({
        anchor_alignment: props.anchorAlignment,
        anchor_position: {
          x: position.x,
          y: position.y
        },
        font: props.font ?? "tscircuit2024",
        font_size: fontSize,
        layer: maybeFlipLayer(layer),
        text: props.text ?? "",
        ccw_rotation: rotation5,
        pcb_component_id: container.pcb_component_id,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
    }
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    const fontSize = props.fontSize ?? this.getInheritedProperty("pcbStyle")?.silkscreenFontSize ?? 1;
    const text = props.text ?? "";
    const textWidth = text.length * fontSize;
    const textHeight = fontSize;
    return { width: textWidth * fontSize, height: textHeight * fontSize };
  }
};

// lib/components/primitive-components/Cutout.ts
import { applyToPoint as applyToPoint5 } from "transformation-matrix";
import { cutoutProps } from "@tscircuit/props";
var Cutout = class extends PrimitiveComponent2 {
  pcb_cutout_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "Cutout",
      zodProps: cutoutProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const subcircuit = this.getSubcircuit();
    const pcb_group_id = this.getGroup()?.pcb_group_id ?? void 0;
    const globalPosition = this._getGlobalPcbPositionBeforeLayout();
    const container = this.getPrimitiveContainer();
    const parentRotation = container?._parsedProps.pcbRotation ?? 0;
    let inserted_pcb_cutout = void 0;
    if (props.shape === "rect") {
      const rotationDeg = typeof parentRotation === "string" ? parseInt(parentRotation.replace("deg", ""), 10) : parentRotation;
      const isRotated90 = Math.abs(rotationDeg % 180) === 90;
      const rectData = {
        shape: "rect",
        center: globalPosition,
        width: isRotated90 ? props.height : props.width,
        height: isRotated90 ? props.width : props.height,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id
      };
      inserted_pcb_cutout = db.pcb_cutout.insert(rectData);
    } else if (props.shape === "circle") {
      const circleData = {
        shape: "circle",
        center: globalPosition,
        radius: props.radius,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id
      };
      inserted_pcb_cutout = db.pcb_cutout.insert(circleData);
    } else if (props.shape === "polygon") {
      const transform = this._computePcbGlobalTransformBeforeLayout();
      const transformedPoints = props.points.map(
        (p) => applyToPoint5(transform, p)
      );
      const polygonData = {
        shape: "polygon",
        points: transformedPoints,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id
      };
      inserted_pcb_cutout = db.pcb_cutout.insert(polygonData);
    }
    if (inserted_pcb_cutout) {
      this.pcb_cutout_id = inserted_pcb_cutout.pcb_cutout_id;
    }
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    if (props.shape === "rect") {
      return { width: props.width, height: props.height };
    }
    if (props.shape === "circle") {
      return { width: props.radius * 2, height: props.radius * 2 };
    }
    if (props.shape === "polygon") {
      if (props.points.length === 0) return { width: 0, height: 0 };
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const point of props.points) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
      return { width: maxX - minX, height: maxY - minY };
    }
    return { width: 0, height: 0 };
  }
  _getPcbCircuitJsonBounds() {
    if (!this.pcb_cutout_id) return super._getPcbCircuitJsonBounds();
    const { db } = this.root;
    const cutout = db.pcb_cutout.get(this.pcb_cutout_id);
    if (!cutout) return super._getPcbCircuitJsonBounds();
    if (cutout.shape === "rect") {
      return {
        center: cutout.center,
        bounds: {
          left: cutout.center.x - cutout.width / 2,
          top: cutout.center.y + cutout.height / 2,
          // Assuming Y is up
          right: cutout.center.x + cutout.width / 2,
          bottom: cutout.center.y - cutout.height / 2
        },
        width: cutout.width,
        height: cutout.height
      };
    } else if (cutout.shape === "circle") {
      return {
        center: cutout.center,
        bounds: {
          left: cutout.center.x - cutout.radius,
          top: cutout.center.y + cutout.radius,
          right: cutout.center.x + cutout.radius,
          bottom: cutout.center.y - cutout.radius
        },
        width: cutout.radius * 2,
        height: cutout.radius * 2
      };
    } else if (cutout.shape === "polygon") {
      if (cutout.points.length === 0) return super._getPcbCircuitJsonBounds();
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const point of cutout.points) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
      return {
        center: { x: (minX + maxX) / 2, y: (minY + maxY) / 2 },
        bounds: { left: minX, top: maxY, right: maxX, bottom: minY },
        width: maxX - minX,
        height: maxY - minY
      };
    }
    return super._getPcbCircuitJsonBounds();
  }
  _setPositionFromLayout(newCenter) {
    if (!this.pcb_cutout_id) return;
    const { db } = this.root;
    const cutout = db.pcb_cutout.get(this.pcb_cutout_id);
    if (!cutout) return;
    if (cutout.shape === "rect" || cutout.shape === "circle") {
      db.pcb_cutout.update(this.pcb_cutout_id, {
        ...cutout,
        center: newCenter
      });
    } else if (cutout.shape === "polygon") {
      const oldCenter = this._getPcbCircuitJsonBounds().center;
      const dx = newCenter.x - oldCenter.x;
      const dy = newCenter.y - oldCenter.y;
      const newPoints = cutout.points.map((p) => ({
        x: p.x + dx,
        y: p.y + dy
      }));
      db.pcb_cutout.update(this.pcb_cutout_id, {
        ...cutout,
        points: newPoints
      });
    }
  }
};

// lib/utils/createPinrowSilkscreenText.ts
var createPinrowSilkscreenText = ({
  elm,
  pinLabels,
  layer,
  readableRotation,
  anchorAlignment
}) => {
  const pinNum = elm.text.replace(/[{}]/g, "").toLowerCase();
  let label = pinNum;
  if (Array.isArray(pinLabels)) {
    const index = parseInt(pinNum.replace(/[^\d]/g, ""), 10) - 1;
    label = String(pinLabels[index] ?? pinNum);
  } else if (typeof pinLabels === "object") {
    label = String(pinLabels[pinNum] ?? pinNum);
  }
  return new SilkscreenText({
    anchorAlignment: anchorAlignment || "center",
    text: label ?? pinNum,
    layer: layer || "top",
    fontSize: elm.font_size + 0.2,
    pcbX: isNaN(elm.anchor_position.x) ? 0 : elm.anchor_position.x,
    pcbY: elm.anchor_position.y,
    pcbRotation: readableRotation ?? 0
  });
};

// lib/utils/createComponentsFromCircuitJson.ts
var calculateCcwRotation = (componentRotationStr, elementCcwRotation) => {
  const componentAngle = parseInt(componentRotationStr || "0", 10);
  let totalRotation;
  if (elementCcwRotation !== void 0 && elementCcwRotation !== null) {
    totalRotation = elementCcwRotation - componentAngle;
  } else {
    totalRotation = componentAngle;
  }
  const normalizedRotation = (totalRotation % 360 + 360) % 360;
  return normalizedRotation;
};
var createComponentsFromCircuitJson = ({
  componentName,
  componentRotation,
  footprinterString,
  pinLabels,
  pcbPinLabels
}, circuitJson) => {
  const components = [];
  for (const elm of circuitJson) {
    if (elm.type === "pcb_smtpad" && elm.shape === "rect") {
      components.push(
        new SmtPad({
          pcbX: elm.x,
          pcbY: elm.y,
          layer: elm.layer,
          shape: "rect",
          height: elm.height,
          width: elm.width,
          portHints: elm.port_hints,
          rectBorderRadius: elm.rect_border_radius
        })
      );
    } else if (elm.type === "pcb_smtpad" && elm.shape === "circle") {
      components.push(
        new SmtPad({
          pcbX: elm.x,
          pcbY: elm.y,
          layer: elm.layer,
          shape: "circle",
          radius: elm.radius,
          portHints: elm.port_hints
        })
      );
    } else if (elm.type === "pcb_smtpad" && elm.shape === "pill") {
      components.push(
        new SmtPad({
          shape: "pill",
          height: elm.height,
          width: elm.width,
          radius: elm.radius,
          portHints: elm.port_hints,
          pcbX: elm.x,
          pcbY: elm.y,
          layer: elm.layer
        })
      );
    } else if (elm.type === "pcb_silkscreen_path") {
      components.push(
        new SilkscreenPath({
          layer: elm.layer,
          route: elm.route,
          strokeWidth: elm.stroke_width
        })
      );
    } else if (elm.type === "pcb_plated_hole") {
      if (elm.shape === "circle") {
        components.push(
          new PlatedHole({
            pcbX: elm.x,
            pcbY: elm.y,
            shape: "circle",
            holeDiameter: elm.hole_diameter,
            outerDiameter: elm.outer_diameter,
            portHints: elm.port_hints
          })
        );
      } else if (elm.shape === "circular_hole_with_rect_pad") {
        components.push(
          new PlatedHole({
            pcbX: elm.x,
            pcbY: elm.y,
            shape: "circular_hole_with_rect_pad",
            holeDiameter: elm.hole_diameter,
            rectPadHeight: elm.rect_pad_height,
            rectPadWidth: elm.rect_pad_width,
            portHints: elm.port_hints,
            rectBorderRadius: elm.rect_border_radius,
            holeOffsetX: elm.hole_offset_x,
            holeOffsetY: elm.hole_offset_y
          })
        );
      } else if (elm.shape === "pill" || elm.shape === "oval") {
        components.push(
          new PlatedHole({
            pcbX: elm.x,
            pcbY: elm.y,
            shape: elm.shape,
            holeWidth: elm.hole_width,
            holeHeight: elm.hole_height,
            outerWidth: elm.outer_width,
            outerHeight: elm.outer_height,
            portHints: elm.port_hints
          })
        );
      } else if (elm.shape === "pill_hole_with_rect_pad") {
        components.push(
          new PlatedHole({
            pcbX: elm.x,
            pcbY: elm.y,
            shape: "pill_hole_with_rect_pad",
            holeShape: "pill",
            padShape: "rect",
            holeWidth: elm.hole_width,
            holeHeight: elm.hole_height,
            rectPadWidth: elm.rect_pad_width,
            rectPadHeight: elm.rect_pad_height,
            portHints: elm.port_hints,
            holeOffsetX: elm.hole_offset_x,
            holeOffsetY: elm.hole_offset_y
          })
        );
      } else if (elm.shape === "hole_with_polygon_pad") {
        components.push(
          new PlatedHole({
            pcbX: elm.x,
            pcbY: elm.y,
            shape: "hole_with_polygon_pad",
            holeShape: elm.hole_shape || "circle",
            holeDiameter: elm.hole_diameter,
            holeWidth: elm.hole_width,
            holeHeight: elm.hole_height,
            padOutline: elm.pad_outline || [],
            holeOffsetX: elm.hole_offset_x,
            holeOffsetY: elm.hole_offset_y,
            portHints: elm.port_hints
          })
        );
      }
    } else if (elm.type === "pcb_keepout" && elm.shape === "circle") {
      components.push(
        new Keepout({
          pcbX: elm.center.x,
          pcbY: elm.center.y,
          shape: "circle",
          radius: elm.radius
        })
      );
    } else if (elm.type === "pcb_keepout" && elm.shape === "rect") {
      components.push(
        new Keepout({
          pcbX: elm.center.x,
          pcbY: elm.center.y,
          shape: "rect",
          width: elm.width,
          height: elm.height
        })
      );
    } else if (elm.type === "pcb_hole" && elm.hole_shape === "circle") {
      components.push(
        new Hole({
          pcbX: elm.x,
          pcbY: elm.y,
          diameter: elm.hole_diameter
        })
      );
    } else if (elm.type === "pcb_hole" && elm.hole_shape === "rect") {
      components.push(
        new Hole({
          pcbX: elm.x,
          pcbY: elm.y,
          shape: "rect",
          width: elm.hole_width,
          height: elm.hole_height
        })
      );
    } else if (elm.type === "pcb_hole" && elm.hole_shape === "pill") {
      components.push(
        new Hole({
          pcbX: elm.x,
          pcbY: elm.y,
          shape: "pill",
          width: elm.hole_width,
          height: elm.hole_height
        })
      );
    } else if (elm.type === "pcb_hole" && elm.hole_shape === "rotated_pill") {
      components.push(
        new Hole({
          pcbX: elm.x,
          pcbY: elm.y,
          shape: "pill",
          width: elm.hole_width,
          height: elm.hole_height,
          pcbRotation: elm.ccw_rotation
        })
      );
    } else if (elm.type === "pcb_cutout") {
      if (elm.shape === "rect") {
        components.push(
          new Cutout({
            pcbX: elm.center.x,
            pcbY: elm.center.y,
            shape: "rect",
            width: elm.width,
            height: elm.height
          })
        );
      } else if (elm.shape === "circle") {
        components.push(
          new Cutout({
            pcbX: elm.center.x,
            pcbY: elm.center.y,
            shape: "circle",
            radius: elm.radius
          })
        );
      } else if (elm.shape === "polygon") {
        components.push(
          new Cutout({
            shape: "polygon",
            points: elm.points
          })
        );
      }
    } else if (elm.type === "pcb_silkscreen_text") {
      const ccwRotation = calculateCcwRotation(
        componentRotation,
        elm.ccw_rotation
      );
      if (footprinterString?.includes("pinrow") && elm.text.includes("PIN")) {
        components.push(
          createPinrowSilkscreenText({
            elm,
            pinLabels: pcbPinLabels ?? pinLabels ?? {},
            layer: elm.layer,
            readableRotation: ccwRotation,
            anchorAlignment: elm.anchor_alignment
          })
        );
      } else {
        components.push(
          new SilkscreenText({
            anchorAlignment: elm.anchor_alignment || "center",
            text: componentName,
            fontSize: elm.font_size + 0.2,
            pcbX: Number.isNaN(elm.anchor_position.x) ? 0 : elm.anchor_position.x,
            pcbY: elm.anchor_position.y,
            pcbRotation: ccwRotation ?? 0
          })
        );
      }
    } else if (elm.type === "pcb_trace") {
      components.push(
        new PcbTrace({
          route: elm.route
        })
      );
    }
  }
  return components;
};

// lib/utils/get-bounds-of-pcb-components.ts
function getBoundsOfPcbComponents(components) {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let hasValidComponents = false;
  for (const child of components) {
    if (child.isPcbPrimitive && !child.componentName.startsWith("Silkscreen")) {
      const { x, y } = child._getGlobalPcbPositionBeforeLayout();
      const { width: width2, height: height2 } = child.getPcbSize();
      minX = Math.min(minX, x - width2 / 2);
      minY = Math.min(minY, y - height2 / 2);
      maxX = Math.max(maxX, x + width2 / 2);
      maxY = Math.max(maxY, y + height2 / 2);
      hasValidComponents = true;
    } else if (child.children.length > 0) {
      const childBounds = getBoundsOfPcbComponents(child.children);
      if (childBounds.width > 0 || childBounds.height > 0) {
        minX = Math.min(minX, childBounds.minX);
        minY = Math.min(minY, childBounds.minY);
        maxX = Math.max(maxX, childBounds.maxX);
        maxY = Math.max(maxY, childBounds.maxY);
        hasValidComponents = true;
      }
    }
  }
  if (!hasValidComponents) {
    return {
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
  }
  let width = maxX - minX;
  let height = maxY - minY;
  if (width < 0) width = 0;
  if (height < 0) height = 0;
  return {
    minX,
    minY,
    maxX,
    maxY,
    width,
    height
  };
}

// lib/utils/autorouting/getBoundsForSchematic.ts
function normalizeAngle(angle) {
  const normalized = angle % 360;
  return normalized < 0 ? normalized + 360 : normalized;
}
function isAngleBetween(angle, start, end, direction) {
  if (direction === "counterclockwise") {
    if (end >= start) {
      return angle >= start && angle <= end;
    }
    return angle >= start || angle <= end;
  }
  if (end <= start) {
    return angle <= start && angle >= end;
  }
  return angle <= start || angle >= end;
}
function getArcBounds(elm) {
  const center = elm.center;
  const radius = elm.radius;
  const startAngle = elm.start_angle_degrees;
  const endAngle = elm.end_angle_degrees;
  const direction = elm.direction ?? "counterclockwise";
  if (!center || typeof center.x !== "number" || typeof center.y !== "number" || typeof radius !== "number" || typeof startAngle !== "number" || typeof endAngle !== "number") {
    return null;
  }
  const start = normalizeAngle(startAngle);
  const end = normalizeAngle(endAngle);
  const consideredAngles = /* @__PURE__ */ new Set([start, end]);
  const cardinalAngles = [0, 90, 180, 270];
  for (const cardinal of cardinalAngles) {
    if (isAngleBetween(cardinal, start, end, direction)) {
      consideredAngles.add(cardinal);
    }
  }
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const angle of consideredAngles) {
    const radians = angle * Math.PI / 180;
    const x = center.x + radius * Math.cos(radians);
    const y = center.y + radius * Math.sin(radians);
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  }
  if (!Number.isFinite(minX) || !Number.isFinite(minY)) {
    return null;
  }
  return { minX, maxX, minY, maxY };
}
function getBoundsForSchematic(db) {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const elm of db) {
    let cx, cy, w, h;
    if (elm.type === "schematic_component") {
      cx = elm.center?.x;
      cy = elm.center?.y;
      w = elm.size?.width;
      h = elm.size?.height;
    } else if (elm.type === "schematic_box") {
      cx = elm.x;
      cy = elm.y;
      w = elm.width;
      h = elm.height;
    } else if (elm.type === "schematic_port") {
      cx = elm.center?.x;
      cy = elm.center?.y;
      w = 0.2;
      h = 0.2;
    } else if (elm.type === "schematic_text") {
      cx = elm.position?.x;
      cy = elm.position?.y;
      w = (elm.text?.length ?? 0) * 0.1;
      h = 0.2;
    } else if (elm.type === "schematic_line") {
      const x1 = elm.x1 ?? 0;
      const y1 = elm.y1 ?? 0;
      const x2 = elm.x2 ?? 0;
      const y2 = elm.y2 ?? 0;
      cx = (x1 + x2) / 2;
      cy = (y1 + y2) / 2;
      w = Math.abs(x2 - x1);
      h = Math.abs(y2 - y1);
    } else if (elm.type === "schematic_rect") {
      cx = elm.center?.x;
      cy = elm.center?.y;
      w = elm.width;
      h = elm.height;
    } else if (elm.type === "schematic_circle") {
      cx = elm.center?.x;
      cy = elm.center?.y;
      const radius = elm.radius;
      if (typeof radius === "number") {
        w = radius * 2;
        h = radius * 2;
      }
    } else if (elm.type === "schematic_arc") {
      const bounds = getArcBounds(elm);
      if (bounds) {
        minX = Math.min(minX, bounds.minX);
        maxX = Math.max(maxX, bounds.maxX);
        minY = Math.min(minY, bounds.minY);
        maxY = Math.max(maxY, bounds.maxY);
      }
      continue;
    }
    if (typeof cx === "number" && typeof cy === "number" && typeof w === "number" && typeof h === "number") {
      minX = Math.min(minX, cx - w / 2);
      maxX = Math.max(maxX, cx + w / 2);
      minY = Math.min(minY, cy - h / 2);
      maxY = Math.max(maxY, cy + h / 2);
    }
  }
  return { minX, maxX, minY, maxY };
}

// lib/utils/get-relative-direction.ts
function getRelativeDirection(pointA, pointB) {
  const dx = pointB.x - pointA.x;
  const dy = pointB.y - pointA.y;
  if (Math.abs(dx) > Math.abs(dy)) {
    return dx >= 0 ? "right" : "left";
  }
  return dy >= 0 ? "up" : "down";
}

// lib/components/primitive-components/Port/Port.ts
import "schematic-symbols";
import { applyToPoint as applyToPoint6, compose as compose3, translate as translate3 } from "transformation-matrix";
import { z as z6 } from "zod";

// lib/components/primitive-components/Port/areAllPcbPrimitivesOverlapping.ts
var areAllPcbPrimitivesOverlapping = (pcbPrimitives) => {
  if (pcbPrimitives.length <= 1) return true;
  const bounds = pcbPrimitives.map((p) => {
    const circuitBounds = p._getPcbCircuitJsonBounds();
    return {
      left: circuitBounds.bounds.left,
      right: circuitBounds.bounds.right,
      top: circuitBounds.bounds.top,
      bottom: circuitBounds.bounds.bottom
    };
  });
  const overlaps = Array(bounds.length).fill(false).map(() => Array(bounds.length).fill(false));
  for (let i = 0; i < bounds.length; i++) {
    for (let j = i + 1; j < bounds.length; j++) {
      const a = bounds[i];
      const b = bounds[j];
      overlaps[i][j] = overlaps[j][i] = !(a.right < b.left || a.left > b.right || a.bottom > b.top || a.top < b.bottom);
    }
  }
  const visited = /* @__PURE__ */ new Set();
  const dfs = (node) => {
    visited.add(node);
    for (let i = 0; i < bounds.length; i++) {
      if (overlaps[node][i] && !visited.has(i)) {
        dfs(i);
      }
    }
  };
  dfs(0);
  return visited.size === bounds.length;
};

// lib/components/primitive-components/Port/getCenterOfPcbPrimitives.ts
var getCenterOfPcbPrimitives = (pcbPrimitives) => {
  if (pcbPrimitives.length === 0) {
    throw new Error("Cannot get center of empty PCB primitives array");
  }
  const positions = pcbPrimitives.map((p) => p._getPcbCircuitJsonBounds().center).filter(Boolean);
  const sumX = positions.reduce((sum, pos) => sum + pos.x, 0);
  const sumY = positions.reduce((sum, pos) => sum + pos.y, 0);
  return {
    x: sumX / positions.length,
    y: sumY / positions.length
  };
};

// lib/components/primitive-components/Port/Port.ts
var portProps = z6.object({
  name: z6.string().optional(),
  pinNumber: z6.number().optional(),
  aliases: z6.array(z6.string()).optional(),
  layer: z6.string().optional(),
  layers: z6.array(z6.string()).optional(),
  schX: z6.number().optional(),
  schY: z6.number().optional(),
  direction: z6.enum(["up", "down", "left", "right"]).optional(),
  connectsTo: z6.union([z6.string(), z6.array(z6.string())]).optional()
});
var Port = class extends PrimitiveComponent2 {
  source_port_id = null;
  pcb_port_id = null;
  schematic_port_id = null;
  schematicSymbolPortDef = null;
  matchedComponents;
  facingDirection = null;
  originDescription = null;
  get config() {
    return {
      componentName: "Port",
      zodProps: portProps
    };
  }
  constructor(props, opts = {}) {
    if (!props.name && props.pinNumber !== void 0)
      props.name = `pin${props.pinNumber}`;
    if (!props.name) {
      throw new Error("Port must have a name or a pinNumber");
    }
    super(props);
    if (opts.originDescription) {
      this.originDescription = opts.originDescription;
    }
    this.matchedComponents = [];
  }
  isGroupPort() {
    return this.parent?.componentName === "Group";
  }
  isComponentPort() {
    return !this.isGroupPort();
  }
  _getConnectedPortsFromConnectsTo() {
    const { _parsedProps: props } = this;
    const connectsTo = props.connectsTo;
    if (!connectsTo) return [];
    const connectedPorts = [];
    const connectsToArray = Array.isArray(connectsTo) ? connectsTo : [connectsTo];
    for (const connection of connectsToArray) {
      const port = this.getSubcircuit().selectOne(connection, {
        type: "port"
      });
      if (port) {
        connectedPorts.push(port);
      }
    }
    return connectedPorts;
  }
  _isBoardPinoutFromAttributes() {
    const parent = this.parent;
    if (parent?._parsedProps?.pinAttributes) {
      const pinAttributes = parent._parsedProps.pinAttributes;
      for (const alias of this.getNameAndAliases()) {
        if (pinAttributes[alias]?.includeInBoardPinout) {
          return true;
        }
      }
    }
  }
  _getGlobalPcbPositionBeforeLayout() {
    const matchedPcbElm = this.matchedComponents.find((c) => c.isPcbPrimitive);
    const parentComponent = this.parent;
    if (parentComponent && !parentComponent.props.footprint) {
      throw new Error(
        `${parentComponent.componentName} "${parentComponent.props.name}" does not have a footprint. Add a footprint prop, e.g. <${parentComponent.componentName.toLowerCase()} footprint="..." />`
      );
    }
    if (!matchedPcbElm) {
      throw new Error(
        `Port ${this} has no matching PCB primitives. This often means the footprint's pads lack matching port hints.`
      );
    }
    return matchedPcbElm?._getGlobalPcbPositionBeforeLayout() ?? { x: 0, y: 0 };
  }
  _getPcbCircuitJsonBounds() {
    if (!this.pcb_port_id) {
      return super._getPcbCircuitJsonBounds();
    }
    const { db } = this.root;
    const pcb_port = db.pcb_port.get(this.pcb_port_id);
    return {
      center: { x: pcb_port.x, y: pcb_port.y },
      bounds: { left: 0, top: 0, right: 0, bottom: 0 },
      width: 0,
      height: 0
    };
  }
  _getGlobalPcbPositionAfterLayout() {
    return this._getPcbCircuitJsonBounds().center;
  }
  _getPortsInternallyConnectedToThisPort() {
    const parent = this.parent;
    if (!parent || !parent._getInternallyConnectedPins) return [];
    const internallyConnectedPorts = parent._getInternallyConnectedPins();
    for (const ports of internallyConnectedPorts) {
      if (ports.some((port) => port === this)) {
        return ports;
      }
    }
    return [];
  }
  /**
   * Return true if this port has a schematic representation and can be rendered
   * to the schematic.
   *
   * Sometimes things like mounting holes don't have a schematic representation
   * and aren't rendered to the schematic.
   *
   * It's common for a schematic symbol to not have a representation for all of
   * the pins on a footprint, e.g. a pushbutton has 4 pins but is typically
   * represented by a two-pin symbol. In these cases, it's best to use
   * internallyConnectedPorts or externallyConnectedPorts to ensure the things
   * are rendered properly.
   */
  _hasSchematicPort() {
    const { schX, schY } = this._parsedProps;
    if (schX !== void 0 && schY !== void 0) {
      return true;
    }
    const parentNormalComponent = this.getParentNormalComponent();
    const symbol = parentNormalComponent?.getSchematicSymbol();
    if (symbol) {
      if (this.schematicSymbolPortDef) return true;
      const portsInternallyConnectedToThisPort = this._getPortsInternallyConnectedToThisPort();
      if (portsInternallyConnectedToThisPort.some((p) => p.schematicSymbolPortDef))
        return true;
      return false;
    }
    const parentBoxDim = parentNormalComponent?._getSchematicBoxDimensions();
    if (parentBoxDim && this.props.pinNumber !== void 0) {
      const localPortPosition = parentBoxDim.getPortPositionByPinNumber(
        this.props.pinNumber
      );
      if (localPortPosition) return true;
    }
    return false;
  }
  _getGlobalSchematicPositionBeforeLayout() {
    const { schX, schY } = this._parsedProps;
    if (schX !== void 0 && schY !== void 0) {
      return { x: schX, y: schY };
    }
    const parentNormalComponent = this.getParentNormalComponent();
    const symbol = parentNormalComponent?.getSchematicSymbol();
    if (symbol) {
      let schematicSymbolPortDef = this.schematicSymbolPortDef;
      if (!schematicSymbolPortDef) {
        schematicSymbolPortDef = this._getPortsInternallyConnectedToThisPort().find(
          (p) => p.schematicSymbolPortDef
        )?.schematicSymbolPortDef ?? null;
        if (!schematicSymbolPortDef) {
          throw new Error(
            `Couldn't find schematicSymbolPortDef for port ${this.getString()}, searched internally connected ports and none had a schematicSymbolPortDef. Why are we trying to get the schematic position of this port?`
          );
        }
      }
      const transform = compose3(
        parentNormalComponent.computeSchematicGlobalTransform(),
        translate3(-symbol.center.x, -symbol.center.y)
      );
      return applyToPoint6(transform, schematicSymbolPortDef);
    }
    const parentBoxDim = parentNormalComponent?._getSchematicBoxDimensions();
    if (parentBoxDim && this.props.pinNumber !== void 0) {
      const localPortPosition = parentBoxDim.getPortPositionByPinNumber(
        this.props.pinNumber
      );
      if (!localPortPosition) {
        throw new Error(
          `Couldn't find position for schematic_port for port ${this.getString()} inside of the schematic box`
        );
      }
      return applyToPoint6(
        parentNormalComponent.computeSchematicGlobalTransform(),
        localPortPosition
      );
    }
    throw new Error(
      `Couldn't find position for schematic_port for port ${this.getString()}`
    );
  }
  _getGlobalSchematicPositionAfterLayout() {
    const { db } = this.root;
    if (!this.schematic_port_id) {
      throw new Error(
        `Can't get schematic port position after layout for "${this.getString()}", no schematic_port_id`
      );
    }
    const schematic_port = db.schematic_port.get(this.schematic_port_id);
    if (!schematic_port)
      throw new Error(
        `Schematic port not found when trying to get post-layout position: ${this.schematic_port_id}`
      );
    return schematic_port.center;
  }
  /**
   * Smtpads and platedholes call this method to register themselves as a match
   * for this port. All the matching is done by primitives other than the Port,
   * but everyone registers themselves as a match with their Port.
   */
  registerMatch(component) {
    this.matchedComponents.push(component);
  }
  getNameAndAliases() {
    const { _parsedProps: props } = this;
    return Array.from(
      /* @__PURE__ */ new Set([
        ...props.name ? [props.name] : [],
        ...props.aliases ?? [],
        ...typeof props.pinNumber === "number" ? [`pin${props.pinNumber}`, props.pinNumber.toString()] : [],
        ...this.externallyAddedAliases ?? []
      ])
    );
  }
  _getMatchingPinAttributes() {
    const pinAttributes = this.parent?._parsedProps?.pinAttributes;
    if (!pinAttributes) return [];
    const matches = [];
    for (const alias of this.getNameAndAliases()) {
      const attributes = pinAttributes[alias];
      if (attributes) {
        matches.push(attributes);
      }
    }
    return matches;
  }
  _shouldIncludeInBoardPinout() {
    return this._getMatchingPinAttributes().some(
      (attributes) => attributes.includeInBoardPinout === true
    );
  }
  isMatchingPort(port) {
    return this.isMatchingAnyOf(port.getNameAndAliases());
  }
  getPortSelector() {
    const parentComponent = this.getParentNormalComponent() ?? this.parent;
    return `.${parentComponent?.props.name} > port.${this.props.name}`;
  }
  getAvailablePcbLayers() {
    const { layer, layers } = this._parsedProps;
    if (layers) return layers;
    if (layer) return [layer];
    return Array.from(
      new Set(this.matchedComponents.flatMap((c) => c.getAvailablePcbLayers()))
    );
  }
  /**
   * Return traces that are explicitly connected to this port (not via a net)
   */
  _getDirectlyConnectedTraces() {
    const allSubcircuitTraces = this.getSubcircuit().selectAll(
      "trace"
    );
    const connectedTraces = allSubcircuitTraces.filter((trace) => !trace._couldNotFindPort).filter((trace) => trace._isExplicitlyConnectedToPort(this));
    return connectedTraces;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const port_hints = this.getNameAndAliases();
    const parentNormalComponent = this.getParentNormalComponent();
    const parentWithSourceId = this.parent?.source_component_id ? this.parent : parentNormalComponent;
    const source_component_id = parentWithSourceId?.source_component_id ?? null;
    const source_port = db.source_port.insert({
      name: props.name,
      pin_number: props.pinNumber,
      port_hints,
      source_component_id,
      subcircuit_id: this.getSubcircuit()?.subcircuit_id
    });
    this.source_port_id = source_port.source_port_id;
  }
  doInitialSourceParentAttachment() {
    const { db } = this.root;
    const parentNormalComponent = this.getParentNormalComponent();
    const parentWithSourceId = this.parent?.source_component_id ? this.parent : parentNormalComponent;
    if (this.isGroupPort()) {
      db.source_port.update(this.source_port_id, {
        source_component_id: null,
        subcircuit_id: this.getSubcircuit()?.subcircuit_id
      });
      return;
    }
    if (!parentWithSourceId?.source_component_id) {
      throw new Error(
        `${this.getString()} has no parent source component (parent: ${this.parent?.getString()})`
      );
    }
    db.source_port.update(this.source_port_id, {
      source_component_id: parentWithSourceId.source_component_id,
      subcircuit_id: this.getSubcircuit()?.subcircuit_id
    });
    this.source_component_id = parentWithSourceId.source_component_id;
  }
  doInitialPcbPortRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { matchedComponents } = this;
    if (this.isGroupPort()) {
      const connectedPorts = this._getConnectedPortsFromConnectsTo();
      if (connectedPorts.length === 0) {
        return;
      }
      const connectedPort = connectedPorts[0];
      if (!connectedPort.pcb_port_id) {
        return;
      }
      const connectedPcbPort = db.pcb_port.get(connectedPort.pcb_port_id);
      const matchCenter2 = { x: connectedPcbPort.x, y: connectedPcbPort.y };
      const subcircuit = this.getSubcircuit();
      const pcb_port = db.pcb_port.insert({
        pcb_component_id: void 0,
        layers: connectedPort.getAvailablePcbLayers(),
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
        ...matchCenter2,
        source_port_id: this.source_port_id,
        is_board_pinout: false
      });
      this.pcb_port_id = pcb_port.pcb_port_id;
      return;
    }
    const parentNormalComponent = this.getParentNormalComponent();
    const parentWithPcbComponentId = this.parent?.pcb_component_id ? this.parent : parentNormalComponent;
    if (!parentWithPcbComponentId?.pcb_component_id) {
      throw new Error(
        `${this.getString()} has no parent pcb component, cannot render pcb_port (parent: ${this.parent?.getString()}, parentNormalComponent: ${parentNormalComponent?.getString()})`
      );
    }
    const pcbMatches = matchedComponents.filter((c) => c.isPcbPrimitive);
    if (pcbMatches.length === 0) return;
    let matchCenter = null;
    if (pcbMatches.length === 1) {
      matchCenter = pcbMatches[0]._getPcbCircuitJsonBounds().center;
    }
    if (pcbMatches.length > 1) {
      if (!areAllPcbPrimitivesOverlapping(pcbMatches)) {
        throw new Error(
          `${this.getString()} has multiple non-overlapping pcb matches, unclear how to place pcb_port: ${pcbMatches.map((c) => c.getString()).join(", ")}. (Note: tscircuit core does not currently allow you to specify internally connected pcb primitives with the same port hints, try giving them different port hints and specifying they are connected externally- or file an issue)`
        );
      }
      matchCenter = getCenterOfPcbPrimitives(pcbMatches);
    }
    if (matchCenter) {
      const subcircuit = this.getSubcircuit();
      const isBoardPinout = this._shouldIncludeInBoardPinout();
      const pcb_port = db.pcb_port.insert({
        pcb_component_id: parentWithPcbComponentId.pcb_component_id,
        layers: this.getAvailablePcbLayers(),
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
        ...isBoardPinout ? { is_board_pinout: true } : {},
        ...matchCenter,
        source_port_id: this.source_port_id,
        is_board_pinout: this._isBoardPinoutFromAttributes()
      });
      this.pcb_port_id = pcb_port.pcb_port_id;
    } else {
      const pcbMatch = pcbMatches[0];
      throw new Error(
        `${pcbMatch.getString()} does not have a center or _getGlobalPcbPositionBeforeLayout method (needed for pcb_port placement)`
      );
    }
  }
  updatePcbPortRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    if (this.pcb_port_id) return;
    if (this.isGroupPort()) {
      const connectedPorts = this._getConnectedPortsFromConnectsTo();
      if (connectedPorts.length === 0) return;
      const connectedPort = connectedPorts[0];
      if (!connectedPort.pcb_port_id) return;
      const connectedPcbPort = db.pcb_port.get(connectedPort.pcb_port_id);
      const matchCenter2 = { x: connectedPcbPort.x, y: connectedPcbPort.y };
      const subcircuit2 = this.getSubcircuit();
      const pcb_port2 = db.pcb_port.insert({
        pcb_component_id: void 0,
        layers: connectedPort.getAvailablePcbLayers(),
        subcircuit_id: subcircuit2?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
        ...matchCenter2,
        source_port_id: this.source_port_id,
        is_board_pinout: false
      });
      this.pcb_port_id = pcb_port2.pcb_port_id;
      return;
    }
    const pcbMatches = this.matchedComponents.filter((c) => c.isPcbPrimitive);
    if (pcbMatches.length === 0) return;
    let matchCenter = null;
    if (pcbMatches.length === 1) {
      matchCenter = pcbMatches[0]._getPcbCircuitJsonBounds().center;
    }
    if (pcbMatches.length > 1) {
      try {
        if (areAllPcbPrimitivesOverlapping(pcbMatches)) {
          matchCenter = getCenterOfPcbPrimitives(pcbMatches);
        }
      } catch {
      }
    }
    if (!matchCenter) return;
    const parentNormalComponent = this.getParentNormalComponent();
    const parentWithPcbComponentId = this.parent?.pcb_component_id ? this.parent : parentNormalComponent;
    const subcircuit = this.getSubcircuit();
    const isBoardPinout = this._shouldIncludeInBoardPinout();
    const pcb_port = db.pcb_port.insert({
      pcb_component_id: parentWithPcbComponentId?.pcb_component_id,
      layers: this.getAvailablePcbLayers(),
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
      ...isBoardPinout ? { is_board_pinout: true } : {},
      ...matchCenter,
      source_port_id: this.source_port_id,
      is_board_pinout: this._isBoardPinoutFromAttributes()
    });
    this.pcb_port_id = pcb_port.pcb_port_id;
  }
  /**
   * Get the best display label for this port based on port_hints
   * Filters out generic patterns and applies showPinAliases logic
   */
  _getBestDisplayPinLabel() {
    const { db } = this.root;
    const sourcePort = db.source_port.get(this.source_port_id);
    const labelHints = [];
    for (const portHint of sourcePort?.port_hints ?? []) {
      if (portHint.match(/^(pin)?\d+$/)) continue;
      if (portHint.match(/^(left|right)/) && !sourcePort?.name.match(/^(left|right)/))
        continue;
      labelHints.push(portHint);
    }
    const parentNormalComponent = this.getParentNormalComponent();
    const showPinAliases = parentNormalComponent?.props?.showPinAliases;
    if (showPinAliases && labelHints.length > 0) {
      return labelHints.join("/");
    } else if (labelHints.length > 0) {
      return labelHints[0];
    }
    return void 0;
  }
  doInitialSchematicPortRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const { schX, schY } = props;
    const container = schX !== void 0 && schY !== void 0 ? this.getParentNormalComponent() : this.getPrimitiveContainer();
    if (!container) return;
    if (!this._hasSchematicPort()) return;
    const containerCenter = container._getGlobalSchematicPositionBeforeLayout();
    const portCenter = this._getGlobalSchematicPositionBeforeLayout();
    let localPortInfo = null;
    const containerDims = container._getSchematicBoxDimensions();
    if (containerDims && props.pinNumber !== void 0) {
      localPortInfo = containerDims.getPortPositionByPinNumber(props.pinNumber);
    }
    if (this.getSubcircuit().props._schDebugObjectsEnabled) {
      db.schematic_debug_object.insert({
        shape: "rect",
        center: portCenter,
        size: {
          width: 0.1,
          height: 0.1
        },
        label: "obstacle"
      });
    }
    if (!localPortInfo?.side) {
      this.facingDirection = getRelativeDirection(containerCenter, portCenter);
    } else {
      this.facingDirection = {
        left: "left",
        right: "right",
        top: "up",
        bottom: "down"
      }[localPortInfo.side];
    }
    const bestDisplayPinLabel = this._getBestDisplayPinLabel();
    const parentNormalComponent = this.getParentNormalComponent();
    const schematicPortInsertProps = {
      type: "schematic_port",
      schematic_component_id: parentNormalComponent?.schematic_component_id,
      center: portCenter,
      source_port_id: this.source_port_id,
      facing_direction: this.facingDirection,
      distance_from_component_edge: 0.4,
      side_of_component: localPortInfo?.side,
      pin_number: props.pinNumber,
      true_ccw_index: localPortInfo?.trueIndex,
      display_pin_label: bestDisplayPinLabel,
      is_connected: false
    };
    for (const attributes of this._getMatchingPinAttributes()) {
      if (attributes.requiresPower) {
        schematicPortInsertProps.has_input_arrow = true;
      }
      if (attributes.providesPower) {
        schematicPortInsertProps.has_output_arrow = true;
      }
    }
    const schematic_port = db.schematic_port.insert(schematicPortInsertProps);
    this.schematic_port_id = schematic_port.schematic_port_id;
  }
  _getSubcircuitConnectivityKey() {
    return this.root?.db.source_port.get(this.source_port_id)?.subcircuit_connectivity_map_key;
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    if (!this.pcb_port_id) return;
    db.pcb_port.update(this.pcb_port_id, {
      x: newCenter.x,
      y: newCenter.y
    });
  }
  _hasMatchedPcbPrimitive() {
    return this.matchedComponents.some((c) => c.isPcbPrimitive);
  }
  /**
   * Return the text that should be used for the net label for this port if a
   * trace can't be drawn. This net label text usually doesn't appear at this
   * port, but appears at the port it connects to.
   */
  _getNetLabelText() {
    return `${this.parent?.props.name}_${this.props.name}`;
  }
};

// lib/utils/getPortFromHints.ts
var getPinNumberFromLabels = (labels) => {
  const pinNumber = labels.find((p) => /^(pin)?\d+$/.test(p));
  if (!pinNumber) return null;
  return Number.parseInt(pinNumber.replace(/^pin/, ""));
};
function getPortFromHints(hints, opts) {
  const pinNumber = getPinNumberFromLabels(hints);
  if (!pinNumber) return null;
  const aliasesFromHints = hints.filter(
    (p) => p.toString() !== pinNumber.toString() && p !== `pin${pinNumber}`
  );
  const aliases = [
    ...aliasesFromHints,
    ...opts?.additionalAliases?.[`pin${pinNumber}`] ?? []
  ];
  return new Port({
    pinNumber,
    aliases
  });
}

// lib/utils/schematic/getSizeOfSidesFromPortArrangement.ts
var hasExplicitPinMapping = (pa) => {
  for (const side of [
    "leftSide",
    "rightSide",
    "topSide",
    "bottomSide"
  ]) {
    if (side in pa && typeof pa[side] === "number") {
      throw new Error(
        `A number was specified for "${side}", you probably meant to use "size" not "side"`
      );
    }
  }
  return "leftSide" in pa || "rightSide" in pa || "topSide" in pa || "bottomSide" in pa;
};
var getSizeOfSidesFromPortArrangement = (pa) => {
  if (hasExplicitPinMapping(pa)) {
    return {
      leftSize: pa.leftSide?.pins.length ?? 0,
      rightSize: pa.rightSide?.pins.length ?? 0,
      topSize: pa.topSide?.pins.length ?? 0,
      bottomSize: pa.bottomSide?.pins.length ?? 0
    };
  }
  const { leftSize = 0, rightSize = 0, topSize = 0, bottomSize = 0 } = pa;
  return { leftSize, rightSize, topSize, bottomSize };
};

// lib/utils/schematic/getAllDimensionsForSchematicBox.ts
var DEFAULT_SCHEMATIC_BOX_PADDING_MM = 0.4;
function isExplicitPinMappingArrangement(arrangement) {
  const a = arrangement;
  return a.leftSide !== void 0 || a.rightSide !== void 0 || a.topSide !== void 0 || a.bottomSide !== void 0;
}
var getAllDimensionsForSchematicBox = (params) => {
  const portDistanceFromEdge = params.portDistanceFromEdge ?? 0.4;
  let sidePinCounts = params.schPortArrangement ? getSizeOfSidesFromPortArrangement(params.schPortArrangement) : null;
  const sideLengths = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  let pinCount = params.pinCount ?? null;
  if (pinCount === null) {
    if (sidePinCounts) {
      pinCount = sidePinCounts.leftSize + sidePinCounts.rightSize + sidePinCounts.topSize;
    } else {
      throw new Error("Could not determine pin count for the schematic box");
    }
  }
  if (pinCount && !sidePinCounts) {
    const rightSize = Math.floor(pinCount / 2);
    sidePinCounts = {
      leftSize: pinCount - rightSize,
      rightSize,
      topSize: 0,
      bottomSize: 0
    };
  }
  if (!sidePinCounts) {
    sidePinCounts = {
      leftSize: 0,
      rightSize: 0,
      topSize: 0,
      bottomSize: 0
    };
  }
  const getPinNumberUsingSideIndex = ({
    side,
    sideIndex,
    truePinIndex: truePinIndex2
  }) => {
    if (!params.schPortArrangement) return truePinIndex2 + 1;
    if (!isExplicitPinMappingArrangement(params.schPortArrangement))
      return truePinIndex2 + 1;
    const normalCcwDirection = {
      left: "top-to-bottom",
      bottom: "left-to-right",
      right: "bottom-to-top",
      top: "right-to-left"
    }[side];
    const directionAlongSide = params.schPortArrangement?.[`${side}Side`]?.direction ?? normalCcwDirection;
    const pinsDefinitionForSide = params.schPortArrangement?.[`${side}Side`]?.pins;
    let sideIndexWithDirectionCorrection = sideIndex;
    if (directionAlongSide !== normalCcwDirection) {
      sideIndexWithDirectionCorrection = pinsDefinitionForSide.length - sideIndex - 1;
    }
    return parsePinNumberFromLabelsOrThrow(
      pinsDefinitionForSide[sideIndexWithDirectionCorrection],
      params.pinLabels
    );
  };
  const orderedTruePorts = [];
  let currentDistanceFromEdge = 0;
  let truePinIndex = 0;
  for (let sideIndex = 0; sideIndex < sidePinCounts.leftSize; sideIndex++) {
    const pinNumber = getPinNumberUsingSideIndex({
      side: "left",
      sideIndex,
      truePinIndex
    });
    const pinStyle = params.numericSchPinStyle?.[`pin${pinNumber}`] ?? params.numericSchPinStyle?.[pinNumber];
    if (pinStyle?.topMargin) {
      currentDistanceFromEdge += pinStyle.topMargin;
    }
    orderedTruePorts.push({
      trueIndex: truePinIndex,
      pinNumber,
      side: "left",
      distanceFromOrthogonalEdge: currentDistanceFromEdge
    });
    if (pinStyle?.bottomMargin) {
      currentDistanceFromEdge += pinStyle.bottomMargin;
    }
    const isLastPinOnSide = sideIndex === sidePinCounts.leftSize - 1;
    if (!isLastPinOnSide) {
      currentDistanceFromEdge += params.schPinSpacing;
    } else {
      sideLengths.left = currentDistanceFromEdge;
    }
    truePinIndex++;
  }
  currentDistanceFromEdge = 0;
  for (let sideIndex = 0; sideIndex < sidePinCounts.bottomSize; sideIndex++) {
    const pinNumber = getPinNumberUsingSideIndex({
      side: "bottom",
      sideIndex,
      truePinIndex
    });
    const pinStyle = params.numericSchPinStyle?.[`pin${pinNumber}`] ?? params.numericSchPinStyle?.[pinNumber];
    if (pinStyle?.leftMargin) {
      currentDistanceFromEdge += pinStyle.leftMargin;
    }
    orderedTruePorts.push({
      trueIndex: truePinIndex,
      pinNumber,
      side: "bottom",
      distanceFromOrthogonalEdge: currentDistanceFromEdge
    });
    if (pinStyle?.rightMargin) {
      currentDistanceFromEdge += pinStyle.rightMargin;
    }
    const isLastPinOnSide = sideIndex === sidePinCounts.bottomSize - 1;
    if (!isLastPinOnSide) {
      currentDistanceFromEdge += params.schPinSpacing;
    } else {
      sideLengths.bottom = currentDistanceFromEdge;
    }
    truePinIndex++;
  }
  currentDistanceFromEdge = 0;
  for (let sideIndex = 0; sideIndex < sidePinCounts.rightSize; sideIndex++) {
    const pinNumber = getPinNumberUsingSideIndex({
      side: "right",
      sideIndex,
      truePinIndex
    });
    const pinStyle = params.numericSchPinStyle?.[`pin${pinNumber}`] ?? params.numericSchPinStyle?.[pinNumber];
    if (pinStyle?.bottomMargin) {
      currentDistanceFromEdge += pinStyle.bottomMargin;
    }
    orderedTruePorts.push({
      trueIndex: truePinIndex,
      pinNumber,
      side: "right",
      distanceFromOrthogonalEdge: currentDistanceFromEdge
    });
    if (pinStyle?.topMargin) {
      currentDistanceFromEdge += pinStyle.topMargin;
    }
    const isLastPinOnSide = sideIndex === sidePinCounts.rightSize - 1;
    if (!isLastPinOnSide) {
      currentDistanceFromEdge += params.schPinSpacing;
    } else {
      sideLengths.right = currentDistanceFromEdge;
    }
    truePinIndex++;
  }
  currentDistanceFromEdge = 0;
  for (let sideIndex = 0; sideIndex < sidePinCounts.topSize; sideIndex++) {
    const pinNumber = getPinNumberUsingSideIndex({
      side: "top",
      sideIndex,
      truePinIndex
    });
    const pinStyle = params.numericSchPinStyle?.[`pin${pinNumber}`] ?? params.numericSchPinStyle?.[pinNumber];
    if (pinStyle?.rightMargin) {
      currentDistanceFromEdge += pinStyle.rightMargin;
    }
    orderedTruePorts.push({
      trueIndex: truePinIndex,
      pinNumber,
      side: "top",
      distanceFromOrthogonalEdge: currentDistanceFromEdge
    });
    if (pinStyle?.leftMargin) {
      currentDistanceFromEdge += pinStyle.leftMargin;
    }
    const isLastPinOnSide = sideIndex === sidePinCounts.topSize - 1;
    if (!isLastPinOnSide) {
      currentDistanceFromEdge += params.schPinSpacing;
    } else {
      sideLengths.top = currentDistanceFromEdge;
    }
    truePinIndex++;
  }
  let resolvedSchWidth = params.schWidth;
  if (resolvedSchWidth === void 0) {
    resolvedSchWidth = Math.max(
      sideLengths.top + DEFAULT_SCHEMATIC_BOX_PADDING_MM,
      sideLengths.bottom + DEFAULT_SCHEMATIC_BOX_PADDING_MM
    );
    if (params.pinLabels) {
      const leftRightPins = orderedTruePorts.filter(
        (p) => p.side === "left" || p.side === "right"
      );
      const hasLeftRightLabels = leftRightPins.some(
        (p) => params.pinLabels?.[`pin${p.pinNumber}`] || params.pinLabels?.[p.pinNumber]
      );
      if (hasLeftRightLabels) {
        const MIN_WIDTH_FOR_SIDE_PINS = 0.5;
        resolvedSchWidth = Math.max(resolvedSchWidth, MIN_WIDTH_FOR_SIDE_PINS);
      }
    }
    const labelWidth = params.pinLabels ? Math.max(
      ...Object.values(params.pinLabels).map(
        (label) => label.length * 0.1
        // Estimated text width
      )
    ) : 0;
    const LABEL_PADDING = labelWidth > 0 ? 1.1 : 0;
    resolvedSchWidth = Math.max(resolvedSchWidth, labelWidth + LABEL_PADDING);
  }
  let schHeight = params.schHeight;
  if (!schHeight) {
    schHeight = Math.max(
      sideLengths.left + DEFAULT_SCHEMATIC_BOX_PADDING_MM,
      sideLengths.right + DEFAULT_SCHEMATIC_BOX_PADDING_MM
    );
  }
  const trueEdgePositions = {
    // Top left corner
    left: {
      x: -resolvedSchWidth / 2 - portDistanceFromEdge,
      y: sideLengths.left / 2
    },
    // bottom left corner
    bottom: {
      x: -sideLengths.bottom / 2,
      y: -schHeight / 2 - portDistanceFromEdge
    },
    // bottom right corner
    right: {
      x: resolvedSchWidth / 2 + portDistanceFromEdge,
      y: -sideLengths.right / 2
    },
    // top right corner
    top: {
      x: sideLengths.top / 2,
      y: schHeight / 2 + portDistanceFromEdge
    }
  };
  const trueEdgeTraversalDirections = {
    left: { x: 0, y: -1 },
    right: { x: 0, y: 1 },
    top: { x: -1, y: 0 },
    bottom: { x: 1, y: 0 }
  };
  const truePortsWithPositions = orderedTruePorts.map((p) => {
    const { distanceFromOrthogonalEdge, side } = p;
    const edgePos = trueEdgePositions[side];
    const edgeDir = trueEdgeTraversalDirections[side];
    return {
      x: edgePos.x + distanceFromOrthogonalEdge * edgeDir.x,
      y: edgePos.y + distanceFromOrthogonalEdge * edgeDir.y,
      ...p
    };
  });
  return {
    getPortPositionByPinNumber(pinNumber) {
      const port = truePortsWithPositions.find(
        (p) => p.pinNumber.toString() === pinNumber.toString()
      );
      if (!port) {
        return null;
      }
      return port;
    },
    getSize() {
      return { width: resolvedSchWidth, height: schHeight };
    },
    getSizeIncludingPins() {
      return {
        width: resolvedSchWidth + (sidePinCounts.leftSize || sidePinCounts.rightSize ? 0.4 : 0),
        height: schHeight + (sidePinCounts.topSize || sidePinCounts.bottomSize ? 0.4 : 0)
      };
    },
    pinCount
  };
};

// lib/components/base-components/NormalComponent/NormalComponent.ts
import {
  isValidElement as isReactElement2,
  isValidElement
} from "react";
import { symbols as symbols2 } from "schematic-symbols";
import { z as z9 } from "zod";

// lib/components/primitive-components/Footprint.ts
import { footprintProps } from "@tscircuit/props";
import * as kiwi from "@lume/kiwi";
import Debug3 from "debug";
var debug2 = Debug3("tscircuit:core:footprint");
var Footprint = class extends PrimitiveComponent2 {
  get config() {
    return {
      componentName: "Footprint",
      zodProps: footprintProps
    };
  }
  /**
   * A footprint is a constrainedlayout, the db elements are adjusted according
   * to any constraints that are defined.
   */
  doInitialPcbFootprintLayout() {
    if (this.root?.pcbDisabled) return;
    const constraints = this.children.filter(
      (child) => child.componentName === "Constraint"
    );
    if (constraints.length === 0) return;
    const { isFlipped } = this._getPcbPrimitiveFlippedHelpers();
    const maybeFlipLeftRight = (props) => {
      if (isFlipped) {
        if ("left" in props && "right" in props) {
          return {
            ...props,
            left: props.right,
            right: props.left
          };
        }
      }
      return props;
    };
    const involvedComponents = constraints.flatMap(
      (constraint) => constraint._getAllReferencedComponents().componentsWithSelectors
    ).map(({ component, selector, componentSelector, edge }) => ({
      component,
      selector,
      componentSelector,
      edge,
      bounds: component._getPcbCircuitJsonBounds()
    }));
    if (involvedComponents.some((c) => c.edge)) {
      throw new Error(
        "edge constraints not implemented yet for footprint layout, contributions welcome!"
      );
    }
    function getComponentDetails(selector) {
      return involvedComponents.find(({ selector: s }) => s === selector);
    }
    const solver = new kiwi.Solver();
    const kVars = {};
    function getKVar(name) {
      if (!(name in kVars)) {
        kVars[name] = new kiwi.Variable(name);
        solver.addEditVariable(kVars[name], kiwi.Strength.weak);
      }
      return kVars[name];
    }
    for (const { selector, bounds: bounds2 } of involvedComponents) {
      const kvx = getKVar(`${selector}_x`);
      const kvy = getKVar(`${selector}_y`);
      solver.suggestValue(kvx, bounds2.center.x);
      solver.suggestValue(kvy, bounds2.center.y);
    }
    for (const constraint of constraints) {
      const props = constraint._parsedProps;
      if ("xDist" in props) {
        const { xDist, left, right, edgeToEdge, centerToCenter } = maybeFlipLeftRight(props);
        const leftVar = getKVar(`${left}_x`);
        const rightVar = getKVar(`${right}_x`);
        const leftBounds = getComponentDetails(left)?.bounds;
        const rightBounds = getComponentDetails(right)?.bounds;
        if (centerToCenter) {
          const expr = new kiwi.Expression(rightVar, [-1, leftVar]);
          solver.addConstraint(
            new kiwi.Constraint(
              expr,
              kiwi.Operator.Eq,
              props.xDist,
              kiwi.Strength.required
            )
          );
        } else if (edgeToEdge) {
          const expr = new kiwi.Expression(
            rightVar,
            -rightBounds.width / 2,
            [-1, leftVar],
            -leftBounds.width / 2
          );
          solver.addConstraint(
            new kiwi.Constraint(
              expr,
              kiwi.Operator.Eq,
              props.xDist,
              kiwi.Strength.required
            )
          );
        }
      } else if ("yDist" in props) {
        const { yDist, top, bottom, edgeToEdge, centerToCenter } = props;
        const topVar = getKVar(`${top}_y`);
        const bottomVar = getKVar(`${bottom}_y`);
        const topBounds = getComponentDetails(top)?.bounds;
        const bottomBounds = getComponentDetails(bottom)?.bounds;
        if (centerToCenter) {
          const expr = new kiwi.Expression(topVar, [-1, bottomVar]);
          solver.addConstraint(
            new kiwi.Constraint(
              expr,
              kiwi.Operator.Eq,
              props.yDist,
              kiwi.Strength.required
            )
          );
        } else if (edgeToEdge) {
          const expr = new kiwi.Expression(
            topVar,
            topBounds.height / 2,
            [-1, bottomVar],
            -bottomBounds.height / 2
          );
          solver.addConstraint(
            new kiwi.Constraint(
              expr,
              kiwi.Operator.Eq,
              props.yDist,
              kiwi.Strength.required
            )
          );
        }
      } else if ("sameY" in props) {
        const { for: selectors } = props;
        if (selectors.length < 2) continue;
        const vars = selectors.map((selector) => getKVar(`${selector}_y`));
        const expr = new kiwi.Expression(...vars.slice(1));
        solver.addConstraint(
          new kiwi.Constraint(
            expr,
            kiwi.Operator.Eq,
            vars[0],
            kiwi.Strength.required
          )
        );
      } else if ("sameX" in props) {
        const { for: selectors } = props;
        if (selectors.length < 2) continue;
        const vars = selectors.map((selector) => getKVar(`${selector}_x`));
        const expr = new kiwi.Expression(...vars.slice(1));
        solver.addConstraint(
          new kiwi.Constraint(
            expr,
            kiwi.Operator.Eq,
            vars[0],
            kiwi.Strength.required
          )
        );
      }
    }
    solver.updateVariables();
    if (debug2.enabled) {
      console.log("Solution to layout constraints:");
      console.table(
        Object.entries(kVars).map(([key, kvar]) => ({
          var: key,
          val: kvar.value()
        }))
      );
    }
    const bounds = {
      left: Infinity,
      right: -Infinity,
      top: -Infinity,
      bottom: Infinity
    };
    for (const {
      selector,
      bounds: { width, height }
    } of involvedComponents) {
      const kvx = getKVar(`${selector}_x`);
      const kvy = getKVar(`${selector}_y`);
      const newLeft = kvx.value() - width / 2;
      const newRight = kvx.value() + width / 2;
      const newTop = kvy.value() + height / 2;
      const newBottom = kvy.value() - height / 2;
      bounds.left = Math.min(bounds.left, newLeft);
      bounds.right = Math.max(bounds.right, newRight);
      bounds.top = Math.max(bounds.top, newTop);
      bounds.bottom = Math.min(bounds.bottom, newBottom);
    }
    const globalOffset = {
      x: -(bounds.right + bounds.left) / 2,
      y: -(bounds.top + bounds.bottom) / 2
    };
    const containerPos = this.getPrimitiveContainer()._getGlobalPcbPositionBeforeLayout();
    globalOffset.x += containerPos.x;
    globalOffset.y += containerPos.y;
    for (const { component, selector } of involvedComponents) {
      const kvx = getKVar(`${selector}_x`);
      const kvy = getKVar(`${selector}_y`);
      component._setPositionFromLayout({
        x: kvx.value() + globalOffset.x,
        y: kvy.value() + globalOffset.y
      });
    }
  }
};

// lib/components/primitive-components/CadModel.ts
import { cadmodelProps, point3 } from "@tscircuit/props";
import { z as z7 } from "zod";
import { distance as distance2 } from "circuit-json";
import { decomposeTSR as decomposeTSR4 } from "transformation-matrix";

// lib/components/base-components/NormalComponent/utils/getFileExtension.ts
var getFileExtension = (filename) => {
  if (!filename) return null;
  const withoutQuery = filename.split("?")[0];
  const sanitized = withoutQuery.split("#")[0];
  const lastSegment = sanitized.split("/").pop() ?? sanitized;
  if (!lastSegment.includes(".")) return null;
  const extension = lastSegment.split(".").pop();
  return extension?.toLowerCase() ?? null;
};

// lib/utils/constructAssetUrl.ts
var joinUrlPath = (base, path) => {
  const trimmedBase = base.replace(/\/+$/, "");
  const trimmedPath = path.replace(/^\/+/, "");
  return `${trimmedBase}/${trimmedPath}`;
};
var constructAssetUrl = (targetUrl, baseUrl) => {
  if (!baseUrl) {
    return targetUrl;
  }
  if (!targetUrl.startsWith("/")) {
    return targetUrl;
  }
  try {
    const baseUrlObj = new URL(baseUrl);
    if (baseUrlObj.pathname !== "/" && targetUrl.startsWith(baseUrlObj.pathname)) {
      return new URL(targetUrl, baseUrlObj.origin).toString();
    }
    return joinUrlPath(baseUrl, targetUrl);
  } catch (error) {
    return targetUrl;
  }
};

// lib/components/primitive-components/CadModel.ts
var rotation = z7.union([z7.number(), z7.string()]);
var rotation3 = z7.object({ x: rotation, y: rotation, z: rotation });
var CadModel = class extends PrimitiveComponent2 {
  get config() {
    return {
      componentName: "CadModel",
      zodProps: cadmodelProps
    };
  }
  doInitialCadModelRender() {
    const parent = this._findParentWithPcbComponent();
    if (!parent) return;
    if (!parent.pcb_component_id) return;
    const { db } = this.root;
    const { boardThickness = 0 } = this.root?._getBoard() ?? {};
    const bounds = parent._getPcbCircuitJsonBounds();
    const pcb_component = db.pcb_component.get(parent.pcb_component_id);
    const props = this._parsedProps;
    if (!props || typeof props.modelUrl !== "string" && typeof props.stepUrl !== "string")
      return;
    const parentTransform = parent._computePcbGlobalTransformBeforeLayout();
    const decomposedTransform = decomposeTSR4(parentTransform);
    const accumulatedRotation = decomposedTransform.rotation.angle * 180 / Math.PI;
    const rotationOffset = rotation3.parse({ x: 0, y: 0, z: 0 });
    if (typeof props.rotationOffset === "number") {
      rotationOffset.z = Number(props.rotationOffset);
    } else if (typeof props.rotationOffset === "object") {
      const parsed = rotation3.parse(props.rotationOffset);
      rotationOffset.x = Number(parsed.x);
      rotationOffset.y = Number(parsed.y);
      rotationOffset.z = Number(parsed.z);
    }
    const positionOffset = point3.parse({
      x: props.pcbX ?? 0,
      y: props.pcbY ?? 0,
      z: props.pcbZ ?? 0,
      ...typeof props.positionOffset === "object" ? props.positionOffset : {}
    });
    const zOffsetFromSurface = props.zOffsetFromSurface !== void 0 ? distance2.parse(props.zOffsetFromSurface) : 0;
    const layer = parent.props.layer === "bottom" ? "bottom" : "top";
    const ext = props.modelUrl ? getFileExtension(props.modelUrl) : void 0;
    const urlProps = {};
    if (ext === "stl")
      urlProps.model_stl_url = this._addCachebustToModelUrl(props.modelUrl);
    else if (ext === "obj")
      urlProps.model_obj_url = this._addCachebustToModelUrl(props.modelUrl);
    else if (ext === "gltf")
      urlProps.model_gltf_url = this._addCachebustToModelUrl(props.modelUrl);
    else if (ext === "glb")
      urlProps.model_glb_url = this._addCachebustToModelUrl(props.modelUrl);
    else if (ext === "step" || ext === "stp")
      urlProps.model_step_url = this._addCachebustToModelUrl(props.modelUrl);
    else if (ext === "wrl" || ext === "vrml")
      urlProps.model_wrl_url = this._addCachebustToModelUrl(props.modelUrl);
    else urlProps.model_stl_url = this._addCachebustToModelUrl(props.modelUrl);
    if (props.stepUrl) {
      const transformed = this._addCachebustToModelUrl(props.stepUrl);
      if (transformed) urlProps.model_step_url = transformed;
    }
    const cad = db.cad_component.insert({
      position: {
        x: bounds.center.x + Number(positionOffset.x),
        y: bounds.center.y + Number(positionOffset.y),
        z: (layer === "bottom" ? -boardThickness / 2 : boardThickness / 2) + (layer === "bottom" ? -zOffsetFromSurface : zOffsetFromSurface) + Number(positionOffset.z)
      },
      rotation: {
        x: Number(rotationOffset.x),
        y: (layer === "top" ? 0 : 180) + Number(rotationOffset.y),
        z: layer === "bottom" ? -(accumulatedRotation + Number(rotationOffset.z)) + 180 : accumulatedRotation + Number(rotationOffset.z)
      },
      pcb_component_id: parent.pcb_component_id,
      source_component_id: parent.source_component_id,
      model_unit_to_mm_scale_factor: typeof props.modelUnitToMmScale === "number" ? props.modelUnitToMmScale : void 0,
      ...urlProps
    });
    this.cad_component_id = cad.cad_component_id;
  }
  _findParentWithPcbComponent() {
    let p = this.parent;
    while (p && !p.pcb_component_id) p = p.parent;
    return p;
  }
  _addCachebustToModelUrl(url) {
    if (!url) return url;
    const baseUrl = this.root?.platform?.projectBaseUrl;
    const transformedUrl = constructAssetUrl(url, baseUrl);
    if (!transformedUrl.includes("modelcdn.tscircuit.com"))
      return transformedUrl;
    const origin = this.root?.getClientOrigin() ?? "";
    return `${transformedUrl}${transformedUrl.includes("?") ? "&" : "?"}cachebust_origin=${encodeURIComponent(origin)}`;
  }
};

// lib/components/primitive-components/CadAssembly.ts
import { cadassemblyProps } from "@tscircuit/props";
var CadAssembly = class extends PrimitiveComponent2 {
  isPrimitiveContainer = true;
  get config() {
    return {
      componentName: "CadAssembly",
      zodProps: cadassemblyProps
    };
  }
};

// lib/utils/schematic/getNumericSchPinStyle.ts
var getNumericSchPinStyle = (pinStyles, pinLabels) => {
  if (!pinStyles) return void 0;
  const numericPinStyles = {};
  for (const [pinNameOrLabel, pinStyle] of Object.entries(pinStyles)) {
    const pinNumber = parsePinNumberFromLabelsOrThrow(pinNameOrLabel, pinLabels);
    const pinStyleWithSideFirst = {
      leftMargin: pinStyle.marginLeft ?? pinStyle.leftMargin,
      rightMargin: pinStyle.marginRight ?? pinStyle.rightMargin,
      topMargin: pinStyle.marginTop ?? pinStyle.topMargin,
      bottomMargin: pinStyle.marginBottom ?? pinStyle.bottomMargin
    };
    numericPinStyles[`pin${pinNumber}`] = {
      ...numericPinStyles[`pin${pinNumber}`],
      ...pinStyleWithSideFirst
    };
  }
  return numericPinStyles;
};

// lib/components/primitive-components/Trace/Trace.ts
import "@tscircuit/infgrid-ijump-astar";
import { traceProps } from "@tscircuit/props";
import "circuit-json";
import "circuit-json-to-connectivity-map";

// lib/utils/autorouting/DirectLineRouter.ts
var DirectLineRouter = class {
  input;
  constructor({ input }) {
    this.input = input;
  }
  solveAndMapToTraces() {
    const traces = [];
    for (const connection of this.input.connections) {
      if (connection.pointsToConnect.length !== 2) continue;
      const [start, end] = connection.pointsToConnect;
      const trace = {
        type: "pcb_trace",
        pcb_trace_id: "",
        connection_name: connection.name,
        route: [
          {
            route_type: "wire",
            x: start.x,
            y: start.y,
            layer: "top",
            width: 0.1
          },
          {
            route_type: "wire",
            x: end.x,
            y: end.y,
            layer: "top",
            width: 0.1
          }
        ]
      };
      traces.push(trace);
    }
    return traces;
  }
};

// lib/utils/autorouting/computeObstacleBounds.ts
var computeObstacleBounds = (obstacles) => {
  const minX = Math.min(...obstacles.map((o) => o.center.x));
  const maxX = Math.max(...obstacles.map((o) => o.center.x));
  const minY = Math.min(...obstacles.map((o) => o.center.y));
  const maxY = Math.max(...obstacles.map((o) => o.center.y));
  return { minX, maxX, minY, maxY };
};

// lib/utils/autorouting/findPossibleTraceLayerCombinations.ts
var LAYER_SELECTION_PREFERENCE = ["top", "bottom", "inner1", "inner2"];
var findPossibleTraceLayerCombinations = (hints, layer_path = []) => {
  const candidates = [];
  if (layer_path.length === 0) {
    const starting_layers = hints[0].layers;
    for (const layer of starting_layers) {
      candidates.push(
        ...findPossibleTraceLayerCombinations(hints.slice(1), [layer])
      );
    }
    return candidates;
  }
  if (hints.length === 0) return [];
  const current_hint = hints[0];
  const is_possibly_via = current_hint.via || current_hint.optional_via;
  const last_layer = layer_path[layer_path.length - 1];
  if (hints.length === 1) {
    const last_hint = current_hint;
    if (last_hint.layers && is_possibly_via) {
      return last_hint.layers.map((layer) => ({
        layer_path: [...layer_path, layer]
      }));
    }
    if (last_hint.layers?.includes(last_layer)) {
      return [{ layer_path: [...layer_path, last_layer] }];
    }
    return [];
  }
  if (!is_possibly_via) {
    if (current_hint.layers) {
      if (!current_hint.layers.includes(last_layer)) {
        return [];
      }
    }
    return findPossibleTraceLayerCombinations(
      hints.slice(1),
      layer_path.concat([last_layer])
    );
  }
  const candidate_next_layers = (current_hint.optional_via ? LAYER_SELECTION_PREFERENCE : LAYER_SELECTION_PREFERENCE.filter((layer) => layer !== last_layer)).filter(
    (layer) => !current_hint.layers || current_hint.layers?.includes(layer)
  );
  for (const candidate_next_layer of candidate_next_layers) {
    candidates.push(
      ...findPossibleTraceLayerCombinations(
        hints.slice(1),
        layer_path.concat(candidate_next_layer)
      )
    );
  }
  return candidates;
};

// lib/utils/autorouting/getDominantDirection.ts
function getDominantDirection(edge) {
  const delta = {
    x: edge.to.x - edge.from.x,
    y: edge.to.y - edge.from.y
  };
  const absX = Math.abs(delta.x);
  const absY = Math.abs(delta.y);
  if (absX > absY) {
    return delta.x > 0 ? "right" : "left";
  }
  return delta.y > 0 ? "down" : "up";
}

// lib/utils/autorouting/mergeRoutes.ts
function pdist(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}
var mergeRoutes = (routes) => {
  if (routes.length === 1) return routes[0];
  if (routes.some((r) => r.length === 0)) {
    throw new Error("Cannot merge routes with zero length");
  }
  const merged = [];
  const first_route_fp = routes[0][0];
  const first_route_lp = routes[0][routes[0].length - 1];
  const second_route_fp = routes[1][0];
  const second_route_lp = routes[1][routes[1].length - 1];
  const best_reverse_dist = Math.min(
    pdist(first_route_fp, second_route_fp),
    pdist(first_route_fp, second_route_lp)
  );
  const best_normal_dist = Math.min(
    pdist(first_route_lp, second_route_fp),
    pdist(first_route_lp, second_route_lp)
  );
  if (best_reverse_dist < best_normal_dist) {
    merged.push(...routes[0].reverse());
  } else {
    merged.push(...routes[0]);
  }
  for (let i = 1; i < routes.length; i++) {
    const last_merged_point = merged[merged.length - 1];
    const next_route = routes[i];
    const next_first_point = next_route[0];
    const next_last_point = next_route[next_route.length - 1];
    const distance_to_first = pdist(last_merged_point, next_first_point);
    const distance_to_last = pdist(last_merged_point, next_last_point);
    if (distance_to_first < distance_to_last) {
      merged.push(...next_route);
    } else {
      merged.push(...next_route.reverse());
    }
  }
  for (let i = 1; i < merged.length - 1; i++) {
    const lastPoint = merged[i - 1];
    const currentPoint = merged[i];
    if (lastPoint.route_type !== "wire") continue;
    if (currentPoint.route_type !== "wire") continue;
    if (lastPoint.layer !== currentPoint.layer) {
      merged.splice(i, 0, {
        x: lastPoint.x,
        y: lastPoint.y,
        from_layer: lastPoint.layer,
        to_layer: currentPoint.layer,
        route_type: "via"
      });
    }
  }
  return merged;
};

// lib/utils/getClosest.ts
var getDistance = (a, b) => {
  const aPos = "_getGlobalPcbPositionBeforeLayout" in a ? a._getGlobalPcbPositionBeforeLayout() : a;
  const bPos = "_getGlobalPcbPositionBeforeLayout" in b ? b._getGlobalPcbPositionBeforeLayout() : b;
  return Math.sqrt((aPos.x - bPos.x) ** 2 + (aPos.y - bPos.y) ** 2);
};
function getClosest(point, candidates) {
  if (candidates.length === 0)
    throw new Error("No candidates given to getClosest method");
  let closest = candidates[0];
  let closestDist = Infinity;
  for (const candidate of candidates) {
    const dist = getDistance(point, candidate);
    if (dist < closestDist) {
      closest = candidate;
      closestDist = dist;
    }
  }
  return closest;
}

// lib/utils/schematic/countComplexElements.ts
var countComplexElements = (junctions, edges) => {
  let count = 0;
  count += junctions.length ?? 0;
  count += edges.filter((edge) => edge.is_crossing).length;
  for (let i = 1; i < edges.length; i++) {
    const prev = edges[i - 1];
    const curr = edges[i];
    const prevVertical = Math.abs(prev.from.x - prev.to.x) < 0.01;
    const currVertical = Math.abs(curr.from.x - curr.to.x) < 0.01;
    if (prevVertical !== currVertical) count++;
  }
  return count;
};

// lib/utils/schematic/getEnteringEdgeFromDirection.ts
var getEnteringEdgeFromDirection = (direction) => {
  return {
    up: "bottom",
    down: "top",
    left: "right",
    right: "left"
  }[direction] ?? null;
};

// lib/utils/schematic/getStubEdges.ts
import { distance as distance3 } from "@tscircuit/math-utils";
var getStubEdges = ({
  firstEdge,
  firstEdgePort,
  firstDominantDirection,
  lastEdge,
  lastEdgePort,
  lastDominantDirection
}) => {
  if (firstEdge && firstEdgePort) {
    return getStubEdges({
      lastEdge: {
        from: firstEdge.to,
        to: firstEdge.from
      },
      lastEdgePort: firstEdgePort,
      lastDominantDirection: firstDominantDirection
    }).reverse().map((e) => ({
      from: e.to,
      to: e.from
    }));
  }
  let edges = [];
  if (lastEdge && lastEdgePort) {
    const intermediatePoint = { x: lastEdge.to.x, y: lastEdge.to.y };
    if (lastDominantDirection === "left" || lastDominantDirection === "right") {
      intermediatePoint.x = lastEdgePort.position.x;
      edges.push({
        from: lastEdge.to,
        to: { ...intermediatePoint }
      });
      edges.push({
        from: intermediatePoint,
        to: { ...lastEdgePort.position }
      });
    } else {
      intermediatePoint.y = lastEdgePort.position.y;
      edges.push({
        from: lastEdge.to,
        to: { ...intermediatePoint }
      });
      edges.push({
        from: intermediatePoint,
        to: { ...lastEdgePort.position }
      });
    }
  }
  edges = edges.filter((e) => distance3(e.from, e.to) > 0.01);
  return edges;
};

// lib/utils/try-now.ts
function tryNow(fn) {
  try {
    return [fn(), null];
  } catch (e) {
    return [null, e];
  }
}

// lib/components/primitive-components/Trace/Trace.ts
import "zod";

// lib/components/primitive-components/Trace/trace-utils/get-max-length-from-connected-capacitors.ts
var getMaxLengthFromConnectedCapacitors = (ports, { db }) => {
  const capacitorMaxLengths = ports.map((port) => {
    const sourcePort = db.source_port.get(port.source_port_id);
    if (!sourcePort?.source_component_id) return null;
    const sourceComponent = db.source_component.get(
      sourcePort.source_component_id
    );
    if (sourceComponent?.ftype === "simple_capacitor") {
      return sourceComponent.max_decoupling_trace_length;
    }
    return null;
  }).filter((length7) => length7 !== null);
  if (capacitorMaxLengths.length === 0) return void 0;
  return Math.min(...capacitorMaxLengths);
};

// lib/components/primitive-components/Trace/trace-utils/get-trace-display-name.ts
function getTraceDisplayName({
  ports,
  nets
}) {
  if (ports.length >= 2) {
    return `${ports[0]?.selector} to ${ports[1]?.selector}`;
  }
  if (ports.length === 1 && nets.length === 1) {
    return `${ports[0]?.selector} to net.${nets[0]._parsedProps.name}`;
  }
  return void 0;
}

// lib/utils/is-route-outside-board.ts
var isRouteOutsideBoard = (mergedRoute, { db }) => {
  const pcbBoard = db.pcb_board.list()[0];
  if (pcbBoard.outline) {
    const boardOutline = pcbBoard.outline;
    const isInsidePolygon = (point, polygon) => {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    };
    return mergedRoute.some((point) => !isInsidePolygon(point, boardOutline));
  }
  const boardWidth = pcbBoard.width;
  const boardHeight = pcbBoard.height;
  const boardCenterX = pcbBoard.center.x;
  const boardCenterY = pcbBoard.center.y;
  const outsideBoard = mergedRoute.some((point) => {
    return point.x < boardCenterX - boardWidth / 2 || point.y < boardCenterY - boardHeight / 2 || point.x > boardCenterX + boardWidth / 2 || point.y > boardCenterY + boardHeight / 2;
  });
  return outsideBoard;
};

// lib/utils/obstacles/getObstaclesFromRoute.ts
var isCloseTo = (a, b) => Math.abs(a - b) < 1e-4;
var getObstaclesFromRoute = (route, source_trace_id, { viaDiameter = 0.5 } = {}) => {
  const obstacles = [];
  for (let i = 0; i < route.length - 1; i++) {
    const [start, end] = [route[i], route[i + 1]];
    const prev = i - 1 >= 0 ? route[i - 1] : null;
    const isHorz = isCloseTo(start.y, end.y);
    const isVert = isCloseTo(start.x, end.x);
    if (!isHorz && !isVert) {
      throw new Error(
        `getObstaclesFromTrace currently only supports horizontal and vertical traces (not diagonals) Conflicting trace: ${source_trace_id}, start: (${start.x}, ${start.y}), end: (${end.x}, ${end.y})`
      );
    }
    const obstacle = {
      type: "rect",
      layers: [start.layer],
      center: {
        x: (start.x + end.x) / 2,
        y: (start.y + end.y) / 2
      },
      width: isHorz ? Math.abs(start.x - end.x) : 0.1,
      // TODO use route width
      height: isVert ? Math.abs(start.y - end.y) : 0.1,
      // TODO use route width
      connectedTo: [source_trace_id]
    };
    obstacles.push(obstacle);
    if (prev && prev.layer === start.layer && start.layer !== end.layer) {
      const via = {
        type: "rect",
        layers: [start.layer, end.layer],
        center: {
          x: start.x,
          y: start.y
        },
        connectedTo: [source_trace_id],
        width: viaDiameter,
        height: viaDiameter
      };
      obstacles.push(via);
    }
  }
  return obstacles;
};

// lib/utils/obstacles/generateApproximatingRects.ts
function generateApproximatingRects(rotatedRect, numRects = 4) {
  const { center, width, height, rotation: rotation5 } = rotatedRect;
  const rects = [];
  const angleRad = rotation5 * Math.PI / 180;
  const cosAngle = Math.cos(angleRad);
  const sinAngle = Math.sin(angleRad);
  const normalizedRotation = (rotation5 % 360 + 360) % 360;
  const sliceAlongWidth = height <= width ? normalizedRotation >= 45 && normalizedRotation < 135 || normalizedRotation >= 225 && normalizedRotation < 315 : normalizedRotation >= 135 && normalizedRotation < 225 || normalizedRotation >= 315 || normalizedRotation < 45;
  if (sliceAlongWidth) {
    const sliceWidth = width / numRects;
    for (let i = 0; i < numRects; i++) {
      const x = (i - numRects / 2 + 0.5) * sliceWidth;
      const rotatedX = -x * cosAngle;
      const rotatedY = -x * sinAngle;
      const coverageWidth = sliceWidth * 1.1;
      const coverageHeight = Math.abs(height * cosAngle) + Math.abs(sliceWidth * sinAngle);
      rects.push({
        center: {
          x: center.x + rotatedX,
          y: center.y + rotatedY
        },
        width: coverageWidth,
        height: coverageHeight
      });
    }
  } else {
    const sliceHeight = height / numRects;
    for (let i = 0; i < numRects; i++) {
      const y = (i - numRects / 2 + 0.5) * sliceHeight;
      const rotatedX = -y * sinAngle;
      const rotatedY = y * cosAngle;
      const coverageWidth = Math.abs(width * cosAngle) + Math.abs(sliceHeight * sinAngle);
      const coverageHeight = sliceHeight * 1.1;
      rects.push({
        center: {
          x: center.x + rotatedX,
          y: center.y + rotatedY
        },
        width: coverageWidth,
        height: coverageHeight
      });
    }
  }
  return rects;
}

// lib/utils/obstacles/fillPolygonWithRects.ts
function fillPolygonWithRects(polygon, options = {}) {
  if (polygon.length < 3) return [];
  const { rectHeight = 0.1 } = options;
  const rects = [];
  const yCoords = polygon.map((p) => p.y);
  const minY = Math.min(...yCoords);
  const maxY = Math.max(...yCoords);
  for (let y = minY; y < maxY; y += rectHeight) {
    const scanlineY = y + rectHeight / 2;
    const intersections = [];
    for (let i = 0; i < polygon.length; i++) {
      const p1 = polygon[i];
      const p2 = polygon[(i + 1) % polygon.length];
      if (p1.y <= scanlineY && p2.y > scanlineY || p2.y <= scanlineY && p1.y > scanlineY) {
        const x = (scanlineY - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x;
        intersections.push(x);
      }
    }
    intersections.sort((a, b) => a - b);
    for (let i = 0; i < intersections.length; i += 2) {
      if (i + 1 < intersections.length) {
        const x1 = intersections[i];
        const x2 = intersections[i + 1];
        const width = x2 - x1;
        if (width > 1e-6) {
          rects.push({
            center: {
              x: x1 + width / 2,
              y: scanlineY
            },
            width,
            height: rectHeight
          });
        }
      }
    }
  }
  return rects;
}

// lib/utils/obstacles/fillCircleWithRects.ts
function fillCircleWithRects(circle, options = {}) {
  const { center, radius } = circle;
  const { rectHeight = 0.1 } = options;
  const rects = [];
  const numSlices = Math.ceil(radius * 2 / rectHeight);
  for (let i = 0; i < numSlices; i++) {
    const y = center.y - radius + (i + 0.5) * rectHeight;
    const dy = y - center.y;
    const halfWidth = Math.sqrt(radius * radius - dy * dy);
    if (halfWidth > 0) {
      rects.push({
        center: {
          x: center.x,
          y
        },
        width: halfWidth * 2,
        height: rectHeight
      });
    }
  }
  return rects;
}

// lib/utils/obstacles/getObstaclesFromCircuitJson.ts
var EVERY_LAYER = ["top", "inner1", "inner2", "bottom"];
var getObstaclesFromCircuitJson = (soup, connMap) => {
  const withNetId = (idList) => connMap ? idList.concat(
    idList.map((id) => connMap?.getNetConnectedToId(id)).filter(Boolean)
  ) : idList;
  const obstacles = [];
  for (const element of soup) {
    if (element.type === "pcb_smtpad") {
      if (element.shape === "circle") {
        obstacles.push({
          // @ts-ignore
          type: "oval",
          layers: [element.layer],
          center: {
            x: element.x,
            y: element.y
          },
          width: element.radius * 2,
          height: element.radius * 2,
          connectedTo: withNetId([element.pcb_smtpad_id])
        });
      } else if (element.shape === "rect") {
        obstacles.push({
          type: "rect",
          layers: [element.layer],
          center: {
            x: element.x,
            y: element.y
          },
          width: element.width,
          height: element.height,
          connectedTo: withNetId([element.pcb_smtpad_id])
        });
      } else if (element.shape === "rotated_rect") {
        const rotatedRect = {
          center: { x: element.x, y: element.y },
          width: element.width,
          height: element.height,
          rotation: element.ccw_rotation
        };
        const approximatingRects = generateApproximatingRects(rotatedRect);
        for (const rect of approximatingRects) {
          obstacles.push({
            type: "rect",
            layers: [element.layer],
            center: rect.center,
            width: rect.width,
            height: rect.height,
            connectedTo: withNetId([element.pcb_smtpad_id])
          });
        }
      }
    } else if (element.type === "pcb_keepout") {
      if (element.shape === "circle") {
        obstacles.push({
          // @ts-ignore
          type: "oval",
          layers: element.layers,
          center: {
            x: element.center.x,
            y: element.center.y
          },
          width: element.radius * 2,
          height: element.radius * 2,
          connectedTo: []
        });
      } else if (element.shape === "rect") {
        obstacles.push({
          type: "rect",
          layers: element.layers,
          center: {
            x: element.center.x,
            y: element.center.y
          },
          width: element.width,
          height: element.height,
          connectedTo: []
        });
      }
    } else if (element.type === "pcb_cutout") {
      if (element.shape === "rect") {
        obstacles.push({
          type: "rect",
          layers: EVERY_LAYER,
          center: {
            x: element.center.x,
            y: element.center.y
          },
          width: element.width,
          height: element.height,
          connectedTo: []
        });
      } else if (element.shape === "circle") {
        const approximatingRects = fillCircleWithRects(
          {
            center: element.center,
            radius: element.radius
          },
          { rectHeight: 0.6 }
        );
        for (const rect of approximatingRects) {
          obstacles.push({
            type: "rect",
            layers: EVERY_LAYER,
            center: rect.center,
            width: rect.width,
            height: rect.height,
            connectedTo: []
          });
        }
      } else if (element.shape === "polygon") {
        const approximatingRects = fillPolygonWithRects(element.points, {
          rectHeight: 0.6
        });
        for (const rect of approximatingRects) {
          obstacles.push({
            type: "rect",
            layers: EVERY_LAYER,
            center: rect.center,
            width: rect.width,
            height: rect.height,
            connectedTo: []
          });
        }
      }
    } else if (element.type === "pcb_hole") {
      if (element.hole_shape === "oval") {
        obstacles.push({
          // @ts-ignore
          type: "oval",
          center: {
            x: element.x,
            y: element.y
          },
          width: element.hole_width,
          height: element.hole_height,
          connectedTo: []
        });
      } else if (element.hole_shape === "rect") {
        obstacles.push({
          type: "rect",
          layers: EVERY_LAYER,
          center: {
            x: element.x,
            y: element.y
          },
          width: element.hole_width,
          height: element.hole_height,
          connectedTo: []
        });
      } else if (element.hole_shape === "square") {
        obstacles.push({
          type: "rect",
          layers: EVERY_LAYER,
          center: {
            x: element.x,
            y: element.y
          },
          width: element.hole_diameter,
          height: element.hole_diameter,
          connectedTo: []
        });
      } else if (
        // @ts-ignore
        element.hole_shape === "round" || element.hole_shape === "circle"
      ) {
        obstacles.push({
          type: "rect",
          layers: EVERY_LAYER,
          center: {
            x: element.x,
            y: element.y
          },
          width: element.hole_diameter,
          height: element.hole_diameter,
          connectedTo: []
        });
      }
    } else if (element.type === "pcb_plated_hole") {
      if (element.shape === "circle") {
        obstacles.push({
          // @ts-ignore
          type: "oval",
          layers: EVERY_LAYER,
          center: {
            x: element.x,
            y: element.y
          },
          width: element.outer_diameter,
          height: element.outer_diameter,
          connectedTo: withNetId([element.pcb_plated_hole_id])
        });
      } else if (element.shape === "circular_hole_with_rect_pad") {
        obstacles.push({
          // @ts-ignore
          type: "rect",
          layers: EVERY_LAYER,
          center: {
            x: element.x,
            y: element.y
          },
          width: element.rect_pad_width,
          height: element.rect_pad_height,
          connectedTo: withNetId([element.pcb_plated_hole_id])
        });
      } else if (element.shape === "oval" || element.shape === "pill") {
        obstacles.push({
          // @ts-ignore
          type: "oval",
          layers: EVERY_LAYER,
          center: {
            x: element.x,
            y: element.y
          },
          width: element.outer_width,
          height: element.outer_height,
          connectedTo: withNetId([element.pcb_plated_hole_id])
        });
      } else if (element.shape === "hole_with_polygon_pad") {
        if ("pad_outline" in element && element.pad_outline && element.pad_outline.length > 0) {
          const xs = element.pad_outline.map((p) => element.x + p.x);
          const ys = element.pad_outline.map((p) => element.y + p.y);
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          obstacles.push({
            // @ts-ignore
            type: "rect",
            layers: EVERY_LAYER,
            center: {
              x: centerX,
              y: centerY
            },
            width: maxX - minX,
            height: maxY - minY,
            connectedTo: withNetId([element.pcb_plated_hole_id])
          });
        }
      }
    } else if (element.type === "pcb_trace") {
      const traceObstacles = getObstaclesFromRoute(
        element.route.map((rp) => ({
          x: rp.x,
          y: rp.y,
          layer: "layer" in rp ? rp.layer : rp.from_layer
        })),
        element.source_trace_id
      );
      obstacles.push(...traceObstacles);
    } else if (element.type === "pcb_via") {
      const netIsAssignable = Boolean(
        element.net_is_assignable ?? element.netIsAssignable
      );
      obstacles.push({
        type: "rect",
        layers: element.layers,
        center: {
          x: element.x,
          y: element.y
        },
        connectedTo: [],
        // TODO we can associate source_ports with this via
        width: element.outer_diameter,
        height: element.outer_diameter,
        netIsAssignable: netIsAssignable || void 0
      });
    }
  }
  return obstacles;
};

// lib/utils/schematic/computeSchematicNetLabelCenter.ts
var computeSchematicNetLabelCenter = ({
  anchor_position,
  anchor_side,
  text,
  font_size = 0.18
}) => {
  const charWidth = 0.1 * (font_size / 0.18);
  const width = text.length * charWidth;
  const height = font_size;
  const center = { ...anchor_position };
  switch (anchor_side) {
    case "right":
      center.x -= width / 2;
      break;
    case "left":
      center.x += width / 2;
      break;
    case "top":
      center.y -= height / 2;
      break;
    case "bottom":
      center.y += height / 2;
      break;
  }
  return center;
};

// lib/components/primitive-components/Trace/Trace_doInitialSchematicTraceRender.ts
import { MultilayerIjump } from "@tscircuit/infgrid-ijump-astar";
import "circuit-json";
import { calculateElbow } from "calculate-elbow";
import { doesLineIntersectLine as doesLineIntersectLine3 } from "@tscircuit/math-utils";

// lib/components/primitive-components/Trace/trace-utils/create-schematic-trace-crossing-segments.ts
import { distance as distance4, doesLineIntersectLine } from "@tscircuit/math-utils";

// lib/components/primitive-components/Trace/trace-utils/get-other-schematic-traces.ts
var getOtherSchematicTraces = ({
  db,
  source_trace_id,
  sameNetOnly,
  differentNetOnly
}) => {
  if (!sameNetOnly && !differentNetOnly) {
    differentNetOnly = true;
  }
  const mySourceTrace = db.source_trace.get(source_trace_id);
  const traces = [];
  for (const otherSchematicTrace of db.schematic_trace.list()) {
    if (otherSchematicTrace.source_trace_id === source_trace_id) continue;
    const otherSourceTrace = db.source_trace.get(
      otherSchematicTrace.source_trace_id
    );
    const isSameNet = otherSourceTrace?.subcircuit_connectivity_map_key === mySourceTrace.subcircuit_connectivity_map_key;
    if (differentNetOnly && isSameNet) {
      continue;
    }
    if (sameNetOnly && !isSameNet) {
      continue;
    }
    traces.push(otherSchematicTrace);
  }
  return traces;
};

// lib/components/primitive-components/Trace/trace-utils/create-schematic-trace-crossing-segments.ts
import { getUnitVectorFromPointAToB } from "@tscircuit/math-utils";
var createSchematicTraceCrossingSegments = ({
  edges: inputEdges,
  otherEdges
}) => {
  const edges = [...inputEdges];
  for (let i = 0; i < edges.length; i++) {
    if (i > 2e3) {
      throw new Error(
        "Over 2000 iterations spent inside createSchematicTraceCrossingSegments, you have triggered an infinite loop, please report this!"
      );
    }
    const edge = edges[i];
    const edgeOrientation = Math.abs(edge.from.x - edge.to.x) < 0.01 ? "vertical" : edge.from.y === edge.to.y ? "horizontal" : "not-orthogonal";
    if (edgeOrientation === "not-orthogonal") {
      continue;
    }
    const otherEdgesIntersections = [];
    for (const otherEdge of otherEdges) {
      const otherOrientation = otherEdge.from.x === otherEdge.to.x ? "vertical" : otherEdge.from.y === otherEdge.to.y ? "horizontal" : "not-orthogonal";
      if (otherOrientation === "not-orthogonal") continue;
      if (edgeOrientation === otherOrientation)
        continue;
      const hasIntersection = doesLineIntersectLine(
        [edge.from, edge.to],
        [otherEdge.from, otherEdge.to],
        { lineThickness: 0.01 }
      );
      if (hasIntersection) {
        const intersectX = edgeOrientation === "vertical" ? edge.from.x : otherEdge.from.x;
        const intersectY = edgeOrientation === "vertical" ? otherEdge.from.y : edge.from.y;
        const crossingPoint2 = { x: intersectX, y: intersectY };
        otherEdgesIntersections.push({
          otherEdge,
          crossingPoint: crossingPoint2,
          distanceFromEdgeFrom: distance4(edge.from, crossingPoint2)
        });
      }
    }
    if (otherEdgesIntersections.length === 0) continue;
    let closestIntersection = otherEdgesIntersections[0];
    for (const intersection of otherEdgesIntersections) {
      if (intersection.distanceFromEdgeFrom < closestIntersection.distanceFromEdgeFrom) {
        closestIntersection = intersection;
      }
    }
    const crossingPoint = closestIntersection.crossingPoint;
    const crossingSegmentLength = 0.075;
    if (crossingPoint.x === edge.from.x && crossingPoint.y === edge.from.y) {
      continue;
    }
    const crossingUnitVec = getUnitVectorFromPointAToB(edge.from, crossingPoint);
    const beforeCrossing = {
      x: crossingPoint.x - crossingUnitVec.x * crossingSegmentLength / 2,
      y: crossingPoint.y - crossingUnitVec.y * crossingSegmentLength / 2
    };
    const afterCrossing = {
      x: crossingPoint.x + crossingUnitVec.x * crossingSegmentLength / 2,
      y: crossingPoint.y + crossingUnitVec.y * crossingSegmentLength / 2
    };
    const overshot = distance4(afterCrossing, edge.to) < crossingSegmentLength;
    const newEdges = [
      { from: edge.from, to: beforeCrossing },
      { from: beforeCrossing, to: afterCrossing, is_crossing: true },
      { from: afterCrossing, to: edge.to }
    ];
    edges.splice(i, 1, ...newEdges);
    i += newEdges.length - 2;
    if (overshot) {
      i++;
    }
  }
  return edges;
};

// lib/components/primitive-components/Trace/trace-utils/create-schematic-trace-junctions.ts
var TOLERANCE = 1e-3;
var isPointWithinEdge = (point, edge) => {
  const minX = Math.min(edge.from.x, edge.to.x);
  const maxX = Math.max(edge.from.x, edge.to.x);
  const minY = Math.min(edge.from.y, edge.to.y);
  const maxY = Math.max(edge.from.y, edge.to.y);
  return point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY;
};
var getEdgeOrientation = (edge) => {
  const isVertical = Math.abs(edge.from.x - edge.to.x) < TOLERANCE;
  const isHorizontal = Math.abs(edge.from.y - edge.to.y) < TOLERANCE;
  if (isVertical) return "vertical";
  if (isHorizontal) return "horizontal";
  return "diagonal";
};
var getIntersectionPoint = (edge1, edge2) => {
  const orientation1 = getEdgeOrientation(edge1);
  const orientation2 = getEdgeOrientation(edge2);
  if (orientation1 === orientation2) {
    return null;
  }
  if (orientation1 === "vertical" && orientation2 === "horizontal" || orientation1 === "horizontal" && orientation2 === "vertical") {
    const verticalEdge = orientation1 === "vertical" ? edge1 : edge2;
    const horizontalEdge = orientation1 === "horizontal" ? edge1 : edge2;
    const x2 = verticalEdge.from.x;
    const y2 = horizontalEdge.from.y;
    const intersection2 = { x: x2, y: y2 };
    return isPointWithinEdge(intersection2, edge1) && isPointWithinEdge(intersection2, edge2) ? intersection2 : null;
  }
  if (orientation1 === "vertical" || orientation2 === "vertical") {
    const verticalEdge = orientation1 === "vertical" ? edge1 : edge2;
    const diagonalEdge = orientation1 === "vertical" ? edge2 : edge1;
    const x2 = verticalEdge.from.x;
    const m = (diagonalEdge.to.y - diagonalEdge.from.y) / (diagonalEdge.to.x - diagonalEdge.from.x);
    const b = diagonalEdge.from.y - m * diagonalEdge.from.x;
    const y2 = m * x2 + b;
    const intersection2 = { x: x2, y: y2 };
    return isPointWithinEdge(intersection2, edge1) && isPointWithinEdge(intersection2, edge2) ? intersection2 : null;
  }
  const m1 = (edge1.to.y - edge1.from.y) / (edge1.to.x - edge1.from.x);
  const b1 = edge1.from.y - m1 * edge1.from.x;
  const m2 = (edge2.to.y - edge2.from.y) / (edge2.to.x - edge2.from.x);
  const b2 = edge2.from.y - m2 * edge2.from.x;
  if (Math.abs(m1 - m2) < TOLERANCE) {
    return null;
  }
  const x = (b2 - b1) / (m1 - m2);
  const y = m1 * x + b1;
  const intersection = { x, y };
  return isPointWithinEdge(intersection, edge1) && isPointWithinEdge(intersection, edge2) ? intersection : null;
};
var createSchematicTraceJunctions = ({
  edges: myEdges,
  db,
  source_trace_id
}) => {
  const otherEdges = getOtherSchematicTraces({
    db,
    source_trace_id,
    sameNetOnly: true
  }).flatMap((t) => t.edges);
  const junctions = /* @__PURE__ */ new Map();
  for (const myEdge of myEdges) {
    for (const otherEdge of otherEdges) {
      const intersection = getIntersectionPoint(myEdge, otherEdge);
      if (intersection) {
        const key = `${intersection.x.toFixed(6)},${intersection.y.toFixed(6)}`;
        if (!junctions.has(key)) {
          junctions.set(key, intersection);
        }
      }
    }
  }
  return Array.from(junctions.values());
};

// lib/components/primitive-components/Trace/trace-utils/get-obstacles-for-trace.ts
import { getUnitVectorFromDirection } from "@tscircuit/math-utils";

// lib/utils/autorouting/getObstaclesFromBounds.ts
function getObstaclesFromBounds(bounds, opts = {}) {
  const { minX, maxX, minY, maxY } = bounds;
  const PADDING = opts.padding ?? 1;
  if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minY) || !isFinite(maxY))
    return [];
  const left = minX - PADDING;
  const right = maxX + PADDING;
  const top = maxY + PADDING;
  const bottom = minY - PADDING;
  const thickness = 0.01;
  return [
    // Top border (horizontal)
    {
      type: "rect",
      layers: ["top"],
      center: { x: (left + right) / 2, y: top },
      width: right - left,
      height: thickness,
      connectedTo: []
    },
    // Bottom border (horizontal)
    {
      type: "rect",
      layers: ["top"],
      center: { x: (left + right) / 2, y: bottom },
      width: right - left,
      height: thickness,
      connectedTo: []
    },
    // Left border (vertical)
    {
      type: "rect",
      layers: ["top"],
      center: { x: left, y: (top + bottom) / 2 },
      width: thickness,
      height: top - bottom,
      connectedTo: []
    },
    // Right border (vertical)
    {
      type: "rect",
      layers: ["top"],
      center: { x: right, y: (top + bottom) / 2 },
      width: thickness,
      height: top - bottom,
      connectedTo: []
    }
  ];
}

// lib/components/primitive-components/Trace/trace-utils/get-obstacles-for-trace.ts
var getSchematicObstaclesForTrace = (trace) => {
  const db = trace.root.db;
  const connectedPorts = trace._findConnectedPorts().ports ?? [];
  const connectedPortIds = new Set(
    connectedPorts.map((p) => p.schematic_port_id)
  );
  const obstacles = [];
  for (const elm of db.toArray()) {
    if (elm.type === "schematic_component") {
      const isSymbol = Boolean(elm.symbol_name);
      const dominateAxis = elm.size.width > elm.size.height ? "horz" : "vert";
      obstacles.push({
        type: "rect",
        layers: ["top"],
        center: elm.center,
        width: elm.size.width + (isSymbol && dominateAxis === "horz" ? -0.5 : 0),
        height: elm.size.height + (isSymbol && dominateAxis === "vert" ? -0.5 : 0),
        connectedTo: []
      });
    }
    if (elm.type === "schematic_port") {
      if (connectedPortIds.has(elm.schematic_port_id)) {
        continue;
      }
      const dirVec = elm.facing_direction ? getUnitVectorFromDirection(elm.facing_direction) : {
        x: 0,
        y: 0
      };
      obstacles.push({
        type: "rect",
        layers: ["top"],
        center: {
          x: elm.center.x - dirVec.x * 0.1,
          y: elm.center.y - dirVec.y * 0.1
        },
        width: 0.1 + Math.abs(dirVec.x) * 0.3,
        height: 0.1 + Math.abs(dirVec.y) * 0.3,
        connectedTo: []
      });
    }
    if (elm.type === "schematic_text") {
      obstacles.push({
        type: "rect",
        layers: ["top"],
        center: elm.position,
        width: (elm.text?.length ?? 0) * 0.1,
        height: 0.2,
        connectedTo: []
      });
    }
    if (elm.type === "schematic_box") {
      obstacles.push({
        type: "rect",
        layers: ["top"],
        center: { x: elm.x, y: elm.y },
        width: elm.width,
        height: elm.height,
        connectedTo: []
      });
    }
  }
  const bounds = getBoundsForSchematic(db.toArray());
  obstacles.push(...getObstaclesFromBounds(bounds, { padding: 1 }));
  return obstacles;
};

// lib/components/primitive-components/Trace/trace-utils/push-edges-of-schematic-trace-to-prevent-overlap.ts
import { doesLineIntersectLine as doesLineIntersectLine2 } from "@tscircuit/math-utils";
var pushEdgesOfSchematicTraceToPreventOverlap = ({
  edges,
  db,
  source_trace_id
}) => {
  const mySourceTrace = db.source_trace.get(source_trace_id);
  const otherEdges = getOtherSchematicTraces({
    db,
    source_trace_id,
    differentNetOnly: true
  }).flatMap((t) => t.edges);
  const edgeOrientation = (edge) => {
    const { from, to } = edge;
    return from.x === to.x ? "vertical" : "horizontal";
  };
  for (const mySegment of edges) {
    const mySegmentOrientation = edgeOrientation(mySegment);
    const findOverlappingParallelSegment = () => otherEdges.find(
      (otherEdge) => edgeOrientation(otherEdge) === mySegmentOrientation && doesLineIntersectLine2(
        [mySegment.from, mySegment.to],
        [otherEdge.from, otherEdge.to],
        {
          lineThickness: 0.05
        }
      )
    );
    let overlappingParallelSegmentFromOtherTrace = findOverlappingParallelSegment();
    while (overlappingParallelSegmentFromOtherTrace) {
      if (mySegmentOrientation === "horizontal") {
        mySegment.from.y += 0.1;
        mySegment.to.y += 0.1;
      } else {
        mySegment.from.x += 0.1;
        mySegment.to.x += 0.1;
      }
      overlappingParallelSegmentFromOtherTrace = findOverlappingParallelSegment();
    }
  }
};

// lib/utils/schematic/convertFacingDirectionToElbowDirection.ts
var convertFacingDirectionToElbowDirection = (facingDirection) => {
  switch (facingDirection) {
    case "up":
      return "y+";
    case "down":
      return "y-";
    case "left":
      return "x-";
    case "right":
      return "x+";
    default:
  }
};

// lib/errors/AutorouterError.ts
import packageJson from "@tscircuit/capacity-autorouter/package.json" with { type: "json" };
var autorouterVersion = packageJson.version ?? "unknown";
var AutorouterError = class extends Error {
  constructor(message) {
    super(`${message} (capacity-autorouter@${autorouterVersion})`);
    this.name = "AutorouterError";
  }
};

// lib/errors/TraceConnectionError.ts
var TraceConnectionError = class extends Error {
  constructor(errorData) {
    super(errorData.message);
    this.errorData = errorData;
    this.name = "TraceConnectionError";
  }
};

// lib/components/primitive-components/Trace/Trace_doInitialSchematicTraceRender.ts
var Trace_doInitialSchematicTraceRender = (trace) => {
  if (trace.root?._featureMspSchematicTraceRouting) return;
  if (trace._couldNotFindPort) return;
  if (trace.root?.schematicDisabled) return;
  const { db } = trace.root;
  const { _parsedProps: props, parent } = trace;
  if (!parent) throw new Error("Trace has no parent");
  let allPortsFound;
  let connectedPorts;
  try {
    const result = trace._findConnectedPorts();
    allPortsFound = result.allPortsFound;
    connectedPorts = result.portsWithSelectors ?? [];
  } catch (error) {
    if (error instanceof TraceConnectionError) {
      db.source_trace_not_connected_error.insert({
        ...error.errorData,
        error_type: "source_trace_not_connected_error"
      });
      return;
    }
    throw error;
  }
  const { netsWithSelectors } = trace._findConnectedNets();
  if (!allPortsFound) return;
  const portIds = connectedPorts.map((p) => p.port.schematic_port_id).sort();
  const portPairKey = portIds.join(",");
  const board = trace.root?._getBoard();
  if (board?._connectedSchematicPortPairs) {
    if (board._connectedSchematicPortPairs.has(portPairKey)) {
      return;
    }
  }
  const connection = {
    name: trace.source_trace_id,
    pointsToConnect: []
  };
  const obstacles = getSchematicObstaclesForTrace(trace);
  const portsWithPosition = connectedPorts.filter(({ port }) => port.schematic_port_id !== null).map(({ port }) => ({
    port,
    position: port._getGlobalSchematicPositionAfterLayout(),
    schematic_port_id: port.schematic_port_id ?? void 0,
    facingDirection: port.facingDirection
  }));
  const isPortAndNetConnection = portsWithPosition.length === 1 && netsWithSelectors.length === 1;
  if (isPortAndNetConnection) {
    const net = netsWithSelectors[0].net;
    const { port, position: anchorPos } = portsWithPosition[0];
    let connectedNetLabel = trace.getSubcircuit().selectAll("netlabel").find((nl) => {
      const conn = nl._parsedProps.connection ?? nl._parsedProps.connectsTo;
      if (!conn) return false;
      if (Array.isArray(conn)) {
        return conn.some((selector) => {
          const targetPort2 = trace.getSubcircuit().selectOne(selector, {
            port: true
          });
          return targetPort2 === port;
        });
      }
      const targetPort = trace.getSubcircuit().selectOne(conn, {
        port: true
      });
      return targetPort === port;
    });
    if (!connectedNetLabel) {
      const dbNetLabel = db.schematic_net_label.getWhere({
        source_trace_id: trace.source_trace_id
      });
      if (dbNetLabel) {
        connectedNetLabel = dbNetLabel;
      }
    }
    if (connectedNetLabel) {
      const labelPos = "_getGlobalSchematicPositionBeforeLayout" in connectedNetLabel ? connectedNetLabel._getGlobalSchematicPositionBeforeLayout() : connectedNetLabel.anchor_position;
      const edges2 = [];
      if (anchorPos.x === labelPos.x || anchorPos.y === labelPos.y) {
        edges2.push({ from: anchorPos, to: labelPos });
      } else {
        edges2.push({ from: anchorPos, to: { x: labelPos.x, y: anchorPos.y } });
        edges2.push({ from: { x: labelPos.x, y: anchorPos.y }, to: labelPos });
      }
      const dbTrace2 = db.schematic_trace.insert({
        source_trace_id: trace.source_trace_id,
        edges: edges2,
        junctions: [],
        subcircuit_connectivity_map_key: trace.subcircuit_connectivity_map_key ?? void 0
      });
      trace.schematic_trace_id = dbTrace2.schematic_trace_id;
      return;
    }
    if (trace.props.schDisplayLabel) {
      const side2 = getEnteringEdgeFromDirection(port.facingDirection) ?? "bottom";
      db.schematic_net_label.insert({
        text: trace.props.schDisplayLabel,
        source_net_id: net.source_net_id,
        anchor_position: anchorPos,
        center: computeSchematicNetLabelCenter({
          anchor_position: anchorPos,
          anchor_side: side2,
          text: trace.props.schDisplayLabel
        }),
        anchor_side: side2
      });
      return;
    }
    const side = getEnteringEdgeFromDirection(port.facingDirection) ?? "bottom";
    const netLabel = db.schematic_net_label.insert({
      text: net._parsedProps.name,
      source_net_id: net.source_net_id,
      anchor_position: anchorPos,
      center: computeSchematicNetLabelCenter({
        anchor_position: anchorPos,
        anchor_side: side,
        text: net._parsedProps.name
      }),
      anchor_side: side
    });
    return;
  }
  if (trace.props.schDisplayLabel) {
    if ("from" in trace.props && "to" in trace.props || "path" in trace.props) {
      trace._doInitialSchematicTraceRenderWithDisplayLabel();
      return;
    }
  }
  if (portsWithPosition.length < 2) {
    return;
  }
  const attemptElbowEdges = () => {
    const elbowEdges = [];
    for (let i = 0; i < portsWithPosition.length - 1; i++) {
      const start = portsWithPosition[i];
      const end = portsWithPosition[i + 1];
      const path = calculateElbow(
        {
          x: start.position.x,
          y: start.position.y,
          facingDirection: convertFacingDirectionToElbowDirection(
            start.facingDirection
          )
        },
        {
          x: end.position.x,
          y: end.position.y,
          facingDirection: convertFacingDirectionToElbowDirection(
            end.facingDirection
          )
        }
      );
      for (let j = 0; j < path.length - 1; j++) {
        elbowEdges.push({ from: path[j], to: path[j + 1] });
      }
    }
    const doesSegmentIntersectRect = (edge, rect) => {
      const halfW = rect.width / 2;
      const halfH = rect.height / 2;
      const left = rect.center.x - halfW;
      const right = rect.center.x + halfW;
      const top = rect.center.y - halfH;
      const bottom = rect.center.y + halfH;
      const inRect = (p) => p.x >= left && p.x <= right && p.y >= top && p.y <= bottom;
      if (inRect(edge.from) || inRect(edge.to)) return true;
      const rectEdges = [
        [
          { x: left, y: top },
          { x: right, y: top }
        ],
        [
          { x: right, y: top },
          { x: right, y: bottom }
        ],
        [
          { x: right, y: bottom },
          { x: left, y: bottom }
        ],
        [
          { x: left, y: bottom },
          { x: left, y: top }
        ]
      ];
      return rectEdges.some(
        (r) => doesLineIntersectLine3([edge.from, edge.to], r, { lineThickness: 0 })
      );
    };
    for (const edge of elbowEdges) {
      for (const obstacle of obstacles) {
        if (doesSegmentIntersectRect(edge, obstacle)) {
          return null;
        }
      }
    }
    return elbowEdges;
  };
  let edges = attemptElbowEdges();
  if (edges && edges.length === 0) {
    edges = null;
  }
  connection.pointsToConnect = portsWithPosition.map(({ position }) => ({
    ...position,
    layer: "top"
  }));
  const bounds = computeObstacleBounds(obstacles);
  const BOUNDS_MARGIN = 2;
  const simpleRouteJsonInput = {
    minTraceWidth: 0.1,
    obstacles,
    connections: [connection],
    bounds: {
      minX: bounds.minX - BOUNDS_MARGIN,
      maxX: bounds.maxX + BOUNDS_MARGIN,
      minY: bounds.minY - BOUNDS_MARGIN,
      maxY: bounds.maxY + BOUNDS_MARGIN
    },
    layerCount: 1
  };
  let Autorouter = MultilayerIjump;
  let skipOtherTraceInteraction = false;
  if (trace.getSubcircuit().props._schDirectLineRoutingEnabled) {
    Autorouter = DirectLineRouter;
    skipOtherTraceInteraction = true;
  }
  if (!edges) {
    const autorouter = new Autorouter({
      input: simpleRouteJsonInput,
      MAX_ITERATIONS: 100,
      OBSTACLE_MARGIN: 0.1,
      isRemovePathLoopsEnabled: true,
      isShortenPathWithShortcutsEnabled: true,
      marginsWithCosts: [
        {
          margin: 1,
          enterCost: 0,
          travelCostFactor: 1
        },
        {
          margin: 0.3,
          enterCost: 0,
          travelCostFactor: 1
        },
        {
          margin: 0.2,
          enterCost: 0,
          travelCostFactor: 2
        },
        {
          margin: 0.1,
          enterCost: 0,
          travelCostFactor: 3
        }
      ]
    });
    let results = autorouter.solveAndMapToTraces();
    if (results.length === 0) {
      if (trace._isSymbolToChipConnection() || trace._isSymbolToSymbolConnection() || trace._isChipToChipConnection()) {
        trace._doInitialSchematicTraceRenderWithDisplayLabel();
        return;
      }
      const directLineRouter = new DirectLineRouter({
        input: simpleRouteJsonInput
      });
      results = directLineRouter.solveAndMapToTraces();
      skipOtherTraceInteraction = true;
    }
    const [{ route }] = results;
    edges = [];
    for (let i = 0; i < route.length - 1; i++) {
      edges.push({
        from: route[i],
        to: route[i + 1]
      });
    }
  }
  const source_trace_id = trace.source_trace_id;
  let junctions = [];
  if (!skipOtherTraceInteraction) {
    pushEdgesOfSchematicTraceToPreventOverlap({ edges, db, source_trace_id });
    const otherEdges = getOtherSchematicTraces({
      db,
      source_trace_id,
      differentNetOnly: true
    }).flatMap((t) => t.edges);
    edges = createSchematicTraceCrossingSegments({ edges, otherEdges });
    junctions = createSchematicTraceJunctions({
      edges,
      db,
      source_trace_id: trace.source_trace_id
    });
  }
  if (!edges || edges.length === 0) {
    return;
  }
  const lastEdge = edges[edges.length - 1];
  const lastEdgePort = portsWithPosition[portsWithPosition.length - 1];
  const lastDominantDirection = getDominantDirection(lastEdge);
  edges.push(...getStubEdges({ lastEdge, lastEdgePort, lastDominantDirection }));
  const firstEdge = edges[0];
  const firstEdgePort = portsWithPosition[0];
  const firstDominantDirection = getDominantDirection(firstEdge);
  edges.unshift(
    ...getStubEdges({
      firstEdge,
      firstEdgePort,
      firstDominantDirection
    })
  );
  if (!trace.source_trace_id) {
    throw new Error("Missing source_trace_id for schematic trace insertion.");
  }
  if (trace.getSubcircuit()._parsedProps.schTraceAutoLabelEnabled && countComplexElements(junctions, edges) >= 5 && (trace._isSymbolToChipConnection() || trace._isSymbolToSymbolConnection() || trace._isChipToChipConnection())) {
    trace._doInitialSchematicTraceRenderWithDisplayLabel();
    return;
  }
  const dbTrace = db.schematic_trace.insert({
    source_trace_id: trace.source_trace_id,
    edges,
    junctions,
    subcircuit_connectivity_map_key: trace.subcircuit_connectivity_map_key ?? void 0
  });
  trace.schematic_trace_id = dbTrace.schematic_trace_id;
  for (const { port } of connectedPorts) {
    if (port.schematic_port_id) {
      db.schematic_port.update(port.schematic_port_id, { is_connected: true });
    }
  }
  if (board?._connectedSchematicPortPairs)
    board._connectedSchematicPortPairs.add(portPairKey);
};

// lib/components/primitive-components/Trace/Trace_doInitialPcbTraceRender.ts
import { MultilayerIjump as MultilayerIjump2 } from "@tscircuit/infgrid-ijump-astar";
import "circuit-json";
import { getFullConnectivityMapFromCircuitJson } from "circuit-json-to-connectivity-map";

// lib/components/primitive-components/Trace/trace-utils/compute-trace-length.ts
function getTraceLength(route) {
  let totalLength = 0;
  for (let i = 0; i < route.length; i++) {
    const point = route[i];
    if (point.route_type === "wire") {
      const nextPoint = route[i + 1];
      if (nextPoint) {
        const dx = nextPoint.x - point.x;
        const dy = nextPoint.y - point.y;
        totalLength += Math.sqrt(dx * dx + dy * dy);
      }
    } else if (point.route_type === "via") {
      totalLength += 1.6;
    }
  }
  return totalLength;
}

// lib/components/primitive-components/Trace/Trace_doInitialPcbTraceRender.ts
var portToObjective = (port) => {
  const portPosition = port._getGlobalPcbPositionAfterLayout();
  return {
    ...portPosition,
    layers: port.getAvailablePcbLayers()
  };
};
var SHOULD_USE_SINGLE_LAYER_ROUTING = false;
function Trace_doInitialPcbTraceRender(trace) {
  if (trace.root?.pcbDisabled) return;
  const { db } = trace.root;
  const { _parsedProps: props, parent } = trace;
  const subcircuit = trace.getSubcircuit();
  if (!parent) throw new Error("Trace has no parent");
  if (subcircuit._parsedProps.routingDisabled) {
    return;
  }
  const cachedRoute = subcircuit._parsedProps.pcbRouteCache?.pcbTraces;
  if (cachedRoute) {
    const pcb_trace2 = db.pcb_trace.insert({
      route: cachedRoute.flatMap((trace2) => trace2.route),
      source_trace_id: trace.source_trace_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: trace.getGroup()?.pcb_group_id ?? void 0
    });
    trace.pcb_trace_id = pcb_trace2.pcb_trace_id;
    return;
  }
  if (props.pcbPath && props.pcbPath.length > 0) {
    return;
  }
  if (!subcircuit._shouldUseTraceByTraceRouting()) {
    return;
  }
  const { allPortsFound, ports } = trace._findConnectedPorts();
  const portsConnectedOnPcbViaNet = [];
  if (!allPortsFound) return;
  const portsWithoutMatchedPcbPrimitive = [];
  for (const port of ports) {
    if (!port._hasMatchedPcbPrimitive()) {
      portsWithoutMatchedPcbPrimitive.push(port);
    }
  }
  if (portsWithoutMatchedPcbPrimitive.length > 0) {
    db.pcb_trace_error.insert({
      error_type: "pcb_trace_error",
      source_trace_id: trace.source_trace_id,
      message: `Some ports did not have a matching PCB primitive (e.g. a pad or plated hole), this can happen if a footprint is missing. As a result, ${trace} wasn't routed. Missing ports: ${portsWithoutMatchedPcbPrimitive.map((p) => p.getString()).join(", ")}`,
      pcb_trace_id: trace.pcb_trace_id,
      pcb_component_ids: [],
      pcb_port_ids: portsWithoutMatchedPcbPrimitive.map((p) => p.pcb_port_id).filter(Boolean)
    });
    return;
  }
  const nets = trace._findConnectedNets().netsWithSelectors;
  if (ports.length === 0 && nets.length === 2) {
    trace.renderError(
      `Trace connects two nets, we haven't implemented a way to route this yet`
    );
    return;
  } else if (ports.length === 1 && nets.length === 1) {
    const port = ports[0];
    const portsInNet = nets[0].net.getAllConnectedPorts();
    const otherPortsInNet = portsInNet.filter((p) => p !== port);
    if (otherPortsInNet.length === 0) {
      console.log(
        "Nothing to connect this port to, the net is empty. TODO should emit a warning!"
      );
      return;
    }
    const closestPortInNet = getClosest(port, otherPortsInNet);
    portsConnectedOnPcbViaNet.push(closestPortInNet);
    ports.push(closestPortInNet);
  } else if (ports.length > 1 && nets.length >= 1) {
    trace.renderError(
      `Trace has more than one port and one or more nets, we don't currently support this type of complex trace routing`
    );
    return;
  }
  const hints = ports.flatMap(
    (port) => port.matchedComponents.filter((c) => c.componentName === "TraceHint")
  );
  const pcbRouteHints = (trace._parsedProps.pcbRouteHints ?? []).concat(
    hints.flatMap((h) => h.getPcbRouteHints())
  );
  if (ports.length > 2) {
    trace.renderError(
      `Trace has more than two ports (${ports.map((p) => p.getString()).join(
        ", "
      )}), routing between more than two ports for a single trace is not implemented`
    );
    return;
  }
  const alreadyRoutedTraces = trace.getSubcircuit().selectAll("trace").filter(
    (trace2) => trace2.renderPhaseStates.PcbTraceRender.initialized
  );
  const isAlreadyRouted = alreadyRoutedTraces.some(
    (trace2) => trace2._portsRoutedOnPcb.length === ports.length && trace2._portsRoutedOnPcb.every(
      (portRoutedByOtherTrace) => ports.includes(portRoutedByOtherTrace)
    )
  );
  if (isAlreadyRouted) {
    return;
  }
  let orderedRouteObjectives = [];
  if (pcbRouteHints.length === 0) {
    orderedRouteObjectives = [
      portToObjective(ports[0]),
      portToObjective(ports[1])
    ];
  } else {
    orderedRouteObjectives = [
      portToObjective(ports[0]),
      ...pcbRouteHints,
      portToObjective(ports[1])
    ];
  }
  const candidateLayerCombinations = findPossibleTraceLayerCombinations(
    orderedRouteObjectives
  );
  if (SHOULD_USE_SINGLE_LAYER_ROUTING && candidateLayerCombinations.length === 0) {
    trace.renderError(
      `Could not find a common layer (using hints) for trace ${trace.getString()}`
    );
    return;
  }
  const connMap = getFullConnectivityMapFromCircuitJson(
    trace.root.db.toArray()
  );
  const [obstacles, errGettingObstacles] = tryNow(
    () => getObstaclesFromCircuitJson(trace.root.db.toArray())
    // Remove as any when autorouting-dataset gets updated
  );
  if (errGettingObstacles) {
    trace.renderError({
      type: "pcb_trace_error",
      error_type: "pcb_trace_error",
      pcb_trace_error_id: trace.pcb_trace_id,
      message: `Error getting obstacles for autorouting: ${errGettingObstacles.message}`,
      source_trace_id: trace.source_trace_id,
      center: { x: 0, y: 0 },
      pcb_port_ids: ports.map((p) => p.pcb_port_id),
      pcb_trace_id: trace.pcb_trace_id,
      pcb_component_ids: []
    });
    return;
  }
  for (const obstacle of obstacles) {
    const connectedTo = obstacle.connectedTo;
    if (connectedTo.length > 0) {
      const netId = connMap.getNetConnectedToId(obstacle.connectedTo[0]);
      if (netId) {
        obstacle.connectedTo.push(netId);
      }
    }
  }
  let orderedRoutePoints = [];
  if (candidateLayerCombinations.length === 0) {
    orderedRoutePoints = orderedRouteObjectives;
  } else {
    const candidateLayerSelections = candidateLayerCombinations[0].layer_path;
    orderedRoutePoints = orderedRouteObjectives.map((t, idx) => {
      if (t.via) {
        return {
          ...t,
          via_to_layer: candidateLayerSelections[idx]
        };
      }
      return { ...t, layers: [candidateLayerSelections[idx]] };
    });
  }
  ;
  orderedRoutePoints[0].pcb_port_id = ports[0].pcb_port_id;
  orderedRoutePoints[orderedRoutePoints.length - 1].pcb_port_id = ports[1].pcb_port_id;
  const routes = [];
  for (const [a, b] of pairs(orderedRoutePoints)) {
    const dominantLayer = "via_to_layer" in a ? a.via_to_layer : null;
    const BOUNDS_MARGIN = 2;
    const aLayer = "layers" in a && a.layers.length === 1 ? a.layers[0] : dominantLayer ?? "top";
    const bLayer = "layers" in b && b.layers.length === 1 ? b.layers[0] : dominantLayer ?? "top";
    const pcbPortA = "pcb_port_id" in a ? a.pcb_port_id : null;
    const pcbPortB = "pcb_port_id" in b ? b.pcb_port_id : null;
    const minTraceWidth = trace._getExplicitTraceThickness() ?? trace.getSubcircuit()._parsedProps.minTraceWidth ?? 0.16;
    const ijump = new MultilayerIjump2({
      OBSTACLE_MARGIN: minTraceWidth * 2,
      isRemovePathLoopsEnabled: true,
      optimizeWithGoalBoxes: Boolean(pcbPortA && pcbPortB),
      connMap,
      input: {
        obstacles,
        minTraceWidth,
        connections: [
          {
            name: trace.source_trace_id,
            pointsToConnect: [
              { ...a, layer: aLayer, pcb_port_id: pcbPortA },
              { ...b, layer: bLayer, pcb_port_id: pcbPortB }
            ]
          }
        ],
        layerCount: trace.getSubcircuit()._getSubcircuitLayerCount(),
        bounds: {
          minX: Math.min(a.x, b.x) - BOUNDS_MARGIN,
          maxX: Math.max(a.x, b.x) + BOUNDS_MARGIN,
          minY: Math.min(a.y, b.y) - BOUNDS_MARGIN,
          maxY: Math.max(a.y, b.y) + BOUNDS_MARGIN
        }
      }
    });
    let traces = null;
    try {
      traces = ijump.solveAndMapToTraces();
    } catch (e) {
      trace.renderError({
        type: "pcb_trace_error",
        pcb_trace_error_id: trace.source_trace_id,
        error_type: "pcb_trace_error",
        message: `error solving route: ${e.message}`,
        source_trace_id: trace.pcb_trace_id,
        center: { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 },
        pcb_port_ids: ports.map((p) => p.pcb_port_id),
        pcb_trace_id: trace.pcb_trace_id,
        pcb_component_ids: ports.map((p) => p.pcb_component_id)
      });
    }
    if (!traces) return;
    if (traces.length === 0) {
      trace.renderError({
        type: "pcb_trace_error",
        error_type: "pcb_trace_error",
        pcb_trace_error_id: trace.pcb_trace_id,
        message: `Could not find a route for ${trace}`,
        source_trace_id: trace.source_trace_id,
        center: { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 },
        pcb_port_ids: ports.map((p) => p.pcb_port_id),
        pcb_trace_id: trace.pcb_trace_id,
        pcb_component_ids: ports.map((p) => p.pcb_component_id)
      });
      return;
    }
    const [autoroutedTrace] = traces;
    if (dominantLayer) {
      autoroutedTrace.route = autoroutedTrace.route.map((p) => {
        if (p.route_type === "wire" && !p.layer) {
          p.layer = dominantLayer;
        }
        return p;
      });
    }
    if (pcbPortA && autoroutedTrace.route[0].route_type === "wire") {
      autoroutedTrace.route[0].start_pcb_port_id = pcbPortA;
    }
    const lastRoutePoint = autoroutedTrace.route[autoroutedTrace.route.length - 1];
    if (pcbPortB && lastRoutePoint.route_type === "wire") {
      lastRoutePoint.end_pcb_port_id = pcbPortB;
    }
    routes.push(autoroutedTrace.route);
  }
  const mergedRoute = mergeRoutes(routes);
  const traceLength = getTraceLength(mergedRoute);
  const pcb_trace = db.pcb_trace.insert({
    route: mergedRoute,
    source_trace_id: trace.source_trace_id,
    subcircuit_id: trace.getSubcircuit()?.subcircuit_id,
    trace_length: traceLength
  });
  trace._portsRoutedOnPcb = ports;
  trace.pcb_trace_id = pcb_trace.pcb_trace_id;
  for (const point of mergedRoute) {
    if (point.route_type === "via") {
      db.pcb_via.insert({
        pcb_trace_id: pcb_trace.pcb_trace_id,
        x: point.x,
        y: point.y,
        hole_diameter: 0.3,
        outer_diameter: 0.6,
        layers: [point.from_layer, point.to_layer],
        from_layer: point.from_layer,
        to_layer: point.to_layer
      });
    }
  }
  trace._insertErrorIfTraceIsOutsideBoard(mergedRoute, ports);
}

// lib/components/primitive-components/Trace/Trace_doInitialPcbManualTraceRender.ts
import { applyToPoint as applyToPoint7, identity as identity3 } from "transformation-matrix";
function Trace_doInitialPcbManualTraceRender(trace) {
  if (trace.root?.pcbDisabled) return;
  const { db } = trace.root;
  const { _parsedProps: props } = trace;
  const subcircuit = trace.getSubcircuit();
  if (!props.pcbPath) return;
  const { allPortsFound, ports, portsWithSelectors } = trace._findConnectedPorts();
  if (!allPortsFound) return;
  const portsWithoutMatchedPcbPrimitive = [];
  for (const port of ports) {
    if (!port._hasMatchedPcbPrimitive()) {
      portsWithoutMatchedPcbPrimitive.push(port);
    }
  }
  if (portsWithoutMatchedPcbPrimitive.length > 0) {
    db.pcb_trace_error.insert({
      error_type: "pcb_trace_error",
      source_trace_id: trace.source_trace_id,
      message: `Some ports did not have a matching PCB primitive (e.g. a pad or plated hole), this can happen if a footprint is missing. As a result, ${trace} wasn't routed. Missing ports: ${portsWithoutMatchedPcbPrimitive.map((p) => p.getString()).join(", ")}`,
      pcb_trace_id: trace.pcb_trace_id,
      pcb_component_ids: [],
      pcb_port_ids: portsWithoutMatchedPcbPrimitive.map((p) => p.pcb_port_id).filter(Boolean)
    });
    return;
  }
  let anchorPort;
  if (props.pcbPathRelativeTo) {
    anchorPort = portsWithSelectors.find(
      (p) => p.selector === props.pcbPathRelativeTo
    )?.port;
    if (!anchorPort) {
      anchorPort = trace.getSubcircuit().selectOne(props.pcbPathRelativeTo);
    }
  }
  if (!anchorPort) {
    anchorPort = ports[0];
  }
  const otherPort = ports.find((p) => p !== anchorPort) ?? ports[1];
  const layer = anchorPort.getAvailablePcbLayers()[0] || "top";
  const width = trace._getExplicitTraceThickness() ?? trace.getSubcircuit()._parsedProps.minTraceWidth ?? 0.16;
  const anchorPos = anchorPort._getGlobalPcbPositionAfterLayout();
  const otherPos = otherPort._getGlobalPcbPositionAfterLayout();
  const route = [];
  route.push({
    route_type: "wire",
    x: anchorPos.x,
    y: anchorPos.y,
    width,
    layer,
    start_pcb_port_id: anchorPort.pcb_port_id
  });
  const transform = anchorPort?._computePcbGlobalTransformBeforeLayout?.() || identity3();
  for (const pt of props.pcbPath) {
    let coordinates;
    let isGlobalPosition = false;
    if (typeof pt === "string") {
      const resolvedPort = trace.getSubcircuit().selectOne(pt, {
        type: "port"
      });
      if (!resolvedPort) {
        db.pcb_trace_error.insert({
          error_type: "pcb_trace_error",
          source_trace_id: trace.source_trace_id,
          message: `Could not resolve pcbPath selector "${pt}" for ${trace}`,
          pcb_trace_id: trace.pcb_trace_id,
          pcb_component_ids: [],
          pcb_port_ids: []
        });
        continue;
      }
      const portPos = resolvedPort._getGlobalPcbPositionAfterLayout();
      coordinates = { x: portPos.x, y: portPos.y };
      isGlobalPosition = true;
    } else {
      coordinates = { x: pt.x, y: pt.y };
      isGlobalPosition = false;
    }
    const finalCoordinates = isGlobalPosition ? coordinates : applyToPoint7(transform, coordinates);
    route.push({
      route_type: "wire",
      x: finalCoordinates.x,
      y: finalCoordinates.y,
      width,
      layer
    });
  }
  route.push({
    route_type: "wire",
    x: otherPos.x,
    y: otherPos.y,
    width,
    layer,
    end_pcb_port_id: otherPort.pcb_port_id
  });
  const traceLength = getTraceLength(route);
  const pcb_trace = db.pcb_trace.insert({
    route,
    source_trace_id: trace.source_trace_id,
    subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
    pcb_group_id: trace.getGroup()?.pcb_group_id ?? void 0,
    trace_length: traceLength
  });
  trace._portsRoutedOnPcb = ports;
  trace.pcb_trace_id = pcb_trace.pcb_trace_id;
  trace._insertErrorIfTraceIsOutsideBoard(route, ports);
}

// lib/components/primitive-components/Trace/Trace__doInitialSchematicTraceRenderWithDisplayLabel.ts
function Trace__doInitialSchematicTraceRenderWithDisplayLabel(trace) {
  if (trace.root?.schematicDisabled) return;
  const { db } = trace.root;
  const { _parsedProps: props, parent } = trace;
  if (!parent) throw new Error("Trace has no parent");
  const { allPortsFound, portsWithSelectors: connectedPorts } = trace._findConnectedPorts();
  if (!allPortsFound) return;
  const portsWithPosition = connectedPorts.map(({ port }) => ({
    port,
    position: port._getGlobalSchematicPositionAfterLayout(),
    schematic_port_id: port.schematic_port_id,
    facingDirection: port.facingDirection
  }));
  if (portsWithPosition.length < 2) {
    throw new Error("Expected at least two ports in portsWithPosition.");
  }
  let fromPortName;
  let toPortName;
  const fromAnchorPos = portsWithPosition[0].position;
  const fromPort = portsWithPosition[0].port;
  if ("path" in trace.props) {
    if (trace.props.path.length !== 2) {
      throw new Error("Invalid 'path': Must contain exactly two elements.");
    }
    ;
    [fromPortName, toPortName] = trace.props.path;
  } else {
    if (!("from" in trace.props && "to" in trace.props)) {
      throw new Error("Missing 'from' or 'to' properties in props.");
    }
    fromPortName = trace.props.from;
    toPortName = trace.props.to;
  }
  if (!fromPort.source_port_id) {
    throw new Error(
      `Missing source_port_id for the 'from' port (${fromPortName}).`
    );
  }
  const toAnchorPos = portsWithPosition[1].position;
  const toPort = portsWithPosition[1].port;
  if (!toPort.source_port_id) {
    throw new Error(`Missing source_port_id for the 'to' port (${toPortName}).`);
  }
  const existingFromNetLabel = db.schematic_net_label.list().find((label) => label.source_net_id === fromPort.source_port_id);
  const existingToNetLabel = db.schematic_net_label.list().find((label) => label.source_net_id === toPort.source_port_id);
  const [firstPort, secondPort] = connectedPorts.map(({ port }) => port);
  const isFirstPortSchematicBox = firstPort.parent?.config.shouldRenderAsSchematicBox;
  const pinFullName = isFirstPortSchematicBox ? `${firstPort?.parent?.props.name}_${firstPort?.props.name}` : `${secondPort?.parent?.props.name}_${secondPort?.props.name}`;
  const netLabelText = trace.props.schDisplayLabel ?? pinFullName;
  if (existingFromNetLabel && existingFromNetLabel.text !== netLabelText) {
    existingFromNetLabel.text = `${netLabelText} / ${existingFromNetLabel.text}`;
  }
  if (existingToNetLabel && existingToNetLabel?.text !== netLabelText) {
    existingToNetLabel.text = `${netLabelText} / ${existingToNetLabel.text}`;
  }
  if (!existingToNetLabel) {
    const toSide = getEnteringEdgeFromDirection(toPort.facingDirection) ?? "bottom";
    db.schematic_net_label.insert({
      text: trace.props.schDisplayLabel ?? pinFullName,
      source_net_id: toPort.source_port_id,
      anchor_position: toAnchorPos,
      center: computeSchematicNetLabelCenter({
        anchor_position: toAnchorPos,
        anchor_side: toSide,
        text: trace.props.schDisplayLabel ?? pinFullName
      }),
      anchor_side: toSide
    });
  }
  if (!existingFromNetLabel) {
    const fromSide = getEnteringEdgeFromDirection(fromPort.facingDirection) ?? "bottom";
    db.schematic_net_label.insert({
      text: trace.props.schDisplayLabel ?? pinFullName,
      source_net_id: fromPort.source_port_id,
      anchor_position: fromAnchorPos,
      center: computeSchematicNetLabelCenter({
        anchor_position: fromAnchorPos,
        anchor_side: fromSide,
        text: trace.props.schDisplayLabel ?? pinFullName
      }),
      anchor_side: fromSide
    });
  }
}

// lib/components/primitive-components/Trace/Trace__findConnectedPorts.ts
function Trace__findConnectedPorts(trace) {
  const { _parsedProps: props, parent } = trace;
  if (!parent) throw new Error("Trace has no parent");
  const portSelectors = trace.getTracePortPathSelectors();
  const portsWithSelectors = portSelectors.map((selector) => ({
    selector,
    port: trace.getSubcircuit().selectOne(selector, { type: "port" }) ?? null
  }));
  for (const { selector, port } of portsWithSelectors) {
    if (!port) {
      let parentSelector;
      let portToken;
      const dotIndex = selector.lastIndexOf(".");
      if (dotIndex !== -1 && dotIndex > selector.lastIndexOf(" ")) {
        parentSelector = selector.slice(0, dotIndex);
        portToken = selector.slice(dotIndex + 1);
      } else {
        const match = selector.match(/^(.*[ >])?([^ >]+)$/);
        parentSelector = match?.[1]?.trim() ?? "";
        portToken = match?.[2] ?? selector;
      }
      let targetComponent = parentSelector ? trace.getSubcircuit().selectOne(parentSelector) : null;
      if (!targetComponent && parentSelector && !/[.#\[]/.test(parentSelector)) {
        targetComponent = trace.getSubcircuit().selectOne(`.${parentSelector}`);
      }
      if (!targetComponent) {
        const errorMessage2 = parentSelector ? `Could not find port for selector "${selector}". Component "${parentSelector}" not found` : `Could not find port for selector "${selector}"`;
        const subcircuit2 = trace.getSubcircuit();
        const sourceGroup2 = subcircuit2.getGroup();
        throw new TraceConnectionError({
          error_type: "source_trace_not_connected_error",
          message: errorMessage2,
          subcircuit_id: subcircuit2.subcircuit_id ?? void 0,
          source_group_id: sourceGroup2?.source_group_id ?? void 0,
          source_trace_id: trace.source_trace_id ?? void 0,
          selectors_not_found: [selector]
        });
      }
      const ports = targetComponent.children.filter(
        (c) => c.componentName === "Port"
      );
      const portLabel = portToken.includes(".") ? portToken.split(".").pop() ?? "" : portToken;
      const portNames = ports.flatMap((c) => c.getNameAndAliases());
      const hasCustomLabels = portNames.some((n) => !/^(pin\d+|\d+)$/.test(n));
      const labelList = Array.from(new Set(portNames)).join(", ");
      let detail;
      if (ports.length === 0) {
        detail = "It has no ports";
      } else if (!hasCustomLabels) {
        detail = `It has ${ports.length} pins and no pinLabels (consider adding pinLabels)`;
      } else {
        detail = `It has [${labelList}]`;
      }
      const errorMessage = `Could not find port for selector "${selector}". Component "${targetComponent.props.name ?? parentSelector}" found, but does not have pin "${portLabel}". ${detail}`;
      const subcircuit = trace.getSubcircuit();
      const sourceGroup = subcircuit.getGroup();
      throw new TraceConnectionError({
        error_type: "source_trace_not_connected_error",
        message: errorMessage,
        subcircuit_id: subcircuit.subcircuit_id ?? void 0,
        source_group_id: sourceGroup?.source_group_id ?? void 0,
        source_trace_id: trace.source_trace_id ?? void 0,
        selectors_not_found: [selector]
      });
    }
  }
  if (portsWithSelectors.some((p) => !p.port)) {
    return { allPortsFound: false };
  }
  return {
    allPortsFound: true,
    portsWithSelectors,
    ports: portsWithSelectors.map(({ port }) => port)
  };
}

// lib/components/primitive-components/Trace/Trace.ts
var Trace3 = class extends PrimitiveComponent2 {
  source_trace_id = null;
  pcb_trace_id = null;
  schematic_trace_id = null;
  _portsRoutedOnPcb;
  subcircuit_connectivity_map_key = null;
  _traceConnectionHash = null;
  _couldNotFindPort;
  constructor(props) {
    super(props);
    this._portsRoutedOnPcb = [];
  }
  /**
   * Get the explicit trace thickness, supporting 'width' as an alias for 'thickness'
   */
  _getExplicitTraceThickness() {
    return this._parsedProps.thickness ?? this._parsedProps.width;
  }
  get config() {
    return {
      zodProps: traceProps,
      componentName: "Trace"
    };
  }
  _getTracePortOrNetSelectorListFromProps() {
    if ("from" in this.props && "to" in this.props) {
      return [
        typeof this.props.from === "string" ? this.props.from : this.props.from.getPortSelector(),
        typeof this.props.to === "string" ? this.props.to : this.props.to.getPortSelector()
      ];
    }
    if ("path" in this.props) {
      return this.props.path.map(
        (p) => typeof p === "string" ? p : p.getPortSelector()
      );
    }
    return [];
  }
  getTracePortPathSelectors() {
    return this._getTracePortOrNetSelectorListFromProps().filter(
      (selector) => !selector.includes("net.")
    );
  }
  getTracePathNetSelectors() {
    return this._getTracePortOrNetSelectorListFromProps().filter(
      (selector) => selector.includes("net.")
    );
  }
  _findConnectedPorts() {
    return Trace__findConnectedPorts(this);
  }
  _resolveNet(selector) {
    const direct = this.getSubcircuit().selectOne(selector, {
      type: "net"
    });
    if (direct) return direct;
    const match = selector.match(/^net\.(.+)$/);
    const netName = match ? match[1] : null;
    if (!netName) return null;
    const board = this.root?._getBoard();
    if (!board) {
      this.renderError(
        `Could not find a <board> ancestor for ${this}, so net "${selector}" cannot be resolved`
      );
      return null;
    }
    const allDescendants = board.getDescendants();
    return allDescendants.find(
      (d) => d.componentName === "Net" && d._parsedProps.name === netName
    ) || null;
  }
  _findConnectedNets() {
    const netsWithSelectors = this.getTracePathNetSelectors().map(
      (selector) => ({
        selector,
        net: this._resolveNet(selector)
      })
    );
    const undefinedNets = netsWithSelectors.filter((n) => !n.net);
    if (undefinedNets.length > 0) {
      this.renderError(
        `Could not find net for selector "${undefinedNets[0].selector}" inside ${this}`
      );
    }
    return { netsWithSelectors, nets: netsWithSelectors.map((n) => n.net) };
  }
  /**
   * Get all the traces that are connected in any degree to this trace, this is
   * used during autorouting to routes to pass through traces connected to the
   * same net.
   */
  _getAllTracesConnectedToSameNet() {
    const traces = this.getSubcircuit().selectAll("trace");
    const myNets = this._findConnectedNets().nets;
    const myPorts = this._findConnectedPorts().ports ?? [];
    return traces.filter((t) => {
      if (t === this) return false;
      const tNets = t._findConnectedNets().nets;
      const tPorts = t._findConnectedPorts().ports ?? [];
      return tNets.some((n) => myNets.includes(n)) || tPorts.some((p) => myPorts.includes(p));
    });
  }
  /**
   * Determine if a trace is explicitly connected to a port (not via a net)
   */
  _isExplicitlyConnectedToPort(port) {
    const { allPortsFound, portsWithSelectors: portsWithMetadata } = this._findConnectedPorts();
    if (!allPortsFound) return false;
    const ports = portsWithMetadata.map((p) => p.port);
    return ports.includes(port);
  }
  /**
   * Determine if a trace is explicitly connected to a net (not via a port)
   */
  _isExplicitlyConnectedToNet(net) {
    const nets = this._findConnectedNets().nets;
    return nets.includes(net);
  }
  doInitialCreateNetsFromProps() {
    createNetsFromProps(this, this.getTracePathNetSelectors());
  }
  _computeTraceConnectionHash() {
    const { allPortsFound, ports } = this._findConnectedPorts();
    if (!allPortsFound || !ports) return null;
    const sortedPorts = [...ports].sort(
      (a, b) => (a.pcb_port_id || "").localeCompare(b.pcb_port_id || "")
    );
    const allIds = sortedPorts.map((p) => p.pcb_port_id);
    return allIds.join(",");
  }
  doInitialSourceTraceRender() {
    const { db } = this.root;
    const { _parsedProps: props, parent } = this;
    if (!parent) {
      this.renderError("Trace has no parent");
      return;
    }
    let allPortsFound;
    let ports;
    try {
      const result = this._findConnectedPorts();
      allPortsFound = result.allPortsFound;
      ports = result.portsWithSelectors ?? [];
    } catch (error) {
      if (error instanceof TraceConnectionError) {
        db.source_trace_not_connected_error.insert({
          ...error.errorData,
          error_type: "source_trace_not_connected_error"
        });
        this._couldNotFindPort = true;
        return;
      }
      throw error;
    }
    if (!allPortsFound) return;
    this._traceConnectionHash = this._computeTraceConnectionHash();
    const existingTraces = db.source_trace.list();
    const existingTrace = existingTraces.find(
      (t) => t.subcircuit_connectivity_map_key === this.subcircuit_connectivity_map_key && t.connected_source_port_ids.sort().join(",") === this._traceConnectionHash
    );
    if (existingTrace) {
      this.source_trace_id = existingTrace.source_trace_id;
      return;
    }
    const nets = this._findConnectedNets().nets;
    const displayName = getTraceDisplayName({ ports, nets });
    const trace = db.source_trace.insert({
      connected_source_port_ids: ports.map((p) => p.port.source_port_id),
      connected_source_net_ids: nets.map((n) => n.source_net_id),
      subcircuit_id: this.getSubcircuit()?.subcircuit_id,
      max_length: getMaxLengthFromConnectedCapacitors(
        ports.map((p) => p.port),
        { db }
      ) ?? props.maxLength,
      display_name: displayName,
      min_trace_thickness: this._getExplicitTraceThickness()
    });
    this.source_trace_id = trace.source_trace_id;
  }
  _insertErrorIfTraceIsOutsideBoard(mergedRoute, ports) {
    const { db } = this.root;
    const isOutsideBoard = isRouteOutsideBoard(mergedRoute, { db });
    if (isOutsideBoard) {
      db.pcb_trace_error.insert({
        error_type: "pcb_trace_error",
        source_trace_id: this.source_trace_id,
        message: `Trace ${this.getString()} routed outside the board boundaries.`,
        pcb_trace_id: this.pcb_trace_id,
        pcb_component_ids: [],
        pcb_port_ids: ports.map((p) => p.pcb_port_id)
      });
    }
  }
  doInitialPcbManualTraceRender() {
    Trace_doInitialPcbManualTraceRender(this);
  }
  doInitialPcbTraceRender() {
    Trace_doInitialPcbTraceRender(this);
  }
  _doInitialSchematicTraceRenderWithDisplayLabel() {
    Trace__doInitialSchematicTraceRenderWithDisplayLabel(this);
  }
  _isSymbolToChipConnection() {
    const { allPortsFound, ports } = this._findConnectedPorts();
    if (!allPortsFound || ports.length !== 2) return false;
    const [port1, port2] = ports;
    if (!port1?.parent || !port2?.parent) return false;
    const isPort1Chip = port1.parent.config.shouldRenderAsSchematicBox;
    const isPort2Chip = port2.parent.config.shouldRenderAsSchematicBox;
    return isPort1Chip && !isPort2Chip || !isPort1Chip && isPort2Chip;
  }
  _isSymbolToSymbolConnection() {
    const { allPortsFound, ports } = this._findConnectedPorts();
    if (!allPortsFound || ports.length !== 2) return false;
    const [port1, port2] = ports;
    if (!port1?.parent || !port2?.parent) return false;
    const isPort1Symbol = !port1.parent.config.shouldRenderAsSchematicBox;
    const isPort2Symbol = !port2.parent.config.shouldRenderAsSchematicBox;
    return isPort1Symbol && isPort2Symbol;
  }
  _isChipToChipConnection() {
    const { allPortsFound, ports } = this._findConnectedPorts();
    if (!allPortsFound || ports.length !== 2) return false;
    const [port1, port2] = ports;
    if (!port1?.parent || !port2?.parent) return false;
    const isPort1Chip = port1.parent.config.shouldRenderAsSchematicBox;
    const isPort2Chip = port2.parent.config.shouldRenderAsSchematicBox;
    return isPort1Chip && isPort2Chip;
  }
  doInitialSchematicTraceRender() {
    Trace_doInitialSchematicTraceRender(this);
  }
};

// lib/components/base-components/NormalComponent/NormalComponent__getMinimumFlexContainerSize.ts
import { getBoundsFromPoints } from "@tscircuit/math-utils";
var NormalComponent__getMinimumFlexContainerSize = (component) => {
  const { db } = component.root;
  if (component.pcb_component_id) {
    const pcbComponent = db.pcb_component.get(component.pcb_component_id);
    if (!pcbComponent) return null;
    return {
      width: pcbComponent.width,
      height: pcbComponent.height
    };
  }
  if (component.pcb_group_id) {
    const pcbGroup = db.pcb_group.get(
      component.pcb_group_id
    );
    if (!pcbGroup) return null;
    if (pcbGroup.outline && pcbGroup.outline.length > 0) {
      const bounds = getBoundsFromPoints(pcbGroup.outline);
      if (!bounds) return null;
      return {
        width: bounds.maxX - bounds.minX,
        height: bounds.maxY - bounds.minY
      };
    }
    return {
      width: pcbGroup.width ?? 0,
      height: pcbGroup.height ?? 0
    };
  }
  return null;
};

// lib/components/base-components/NormalComponent/NormalComponent__repositionOnPcb.ts
import {
  repositionPcbComponentTo,
  repositionPcbGroupTo
} from "@tscircuit/circuit-json-util";
var NormalComponent__repositionOnPcb = (component, position) => {
  const { db } = component.root;
  const allCircuitJson = db.toArray();
  if (component.pcb_component_id) {
    repositionPcbComponentTo(
      allCircuitJson,
      component.pcb_component_id,
      position
    );
    return;
  }
  if (component.source_group_id) {
    repositionPcbGroupTo(
      allCircuitJson,
      component.source_group_id,
      position
    );
    return;
  }
  throw new Error(
    `Cannot reposition component ${component.getString()}: no pcb_component_id or source_group_id`
  );
};

// lib/components/base-components/NormalComponent/NormalComponent_doInitialSourceDesignRuleChecks.ts
var NormalComponent_doInitialSourceDesignRuleChecks = (component) => {
  const { db } = component.root;
  if (!component.source_component_id) return;
  const ports = component.selectAll("port");
  const traces = db.source_trace.list();
  const connected = /* @__PURE__ */ new Set();
  for (const trace of traces) {
    for (const id of trace.connected_source_port_ids) {
      connected.add(id);
    }
  }
  const internalGroups = component._getInternallyConnectedPins();
  for (const group of internalGroups) {
    if (group.some((p) => p.source_port_id && connected.has(p.source_port_id))) {
      for (const p of group) {
        if (p.source_port_id) connected.add(p.source_port_id);
      }
    }
  }
  for (const port of ports) {
    if (!port.source_port_id) continue;
    if (!shouldCheckPortForMissingTrace(component, port)) continue;
    if (connected.has(port.source_port_id)) continue;
    db.source_pin_missing_trace_warning.insert({
      message: `Port ${port.getNameAndAliases()[0]} on ${component.props.name} is missing a trace`,
      source_component_id: component.source_component_id,
      source_port_id: port.source_port_id,
      subcircuit_id: component.getSubcircuit().subcircuit_id ?? void 0,
      warning_type: "source_pin_missing_trace_warning"
    });
  }
};
var shouldCheckPortForMissingTrace = (component, port) => {
  if (component.config.componentName === "Chip") {
    const pinAttributes = component.props.pinAttributes;
    if (!pinAttributes) return false;
    for (const alias of port.getNameAndAliases()) {
      const attrs = pinAttributes[alias];
      if (attrs?.requiresPower || attrs?.requiresGround || attrs?.requiresVoltage !== void 0) {
        return true;
      }
    }
    return false;
  }
  return true;
};

// lib/components/base-components/NormalComponent/utils/getPcbTextBounds.ts
function getPcbTextBounds(text) {
  const fontSize = text.font_size;
  const textWidth = text.text.length * fontSize * 0.6;
  const textHeight = fontSize;
  const anchorAlignment = text.anchor_alignment || "center";
  let centerX = text.anchor_position.x;
  let centerY = text.anchor_position.y;
  switch (anchorAlignment) {
    case "top_left":
      centerX = text.anchor_position.x + textWidth / 2;
      centerY = text.anchor_position.y + textHeight / 2;
      break;
    case "top_center":
      centerX = text.anchor_position.x;
      centerY = text.anchor_position.y + textHeight / 2;
      break;
    case "top_right":
      centerX = text.anchor_position.x - textWidth / 2;
      centerY = text.anchor_position.y + textHeight / 2;
      break;
    case "center_left":
      centerX = text.anchor_position.x + textWidth / 2;
      centerY = text.anchor_position.y;
      break;
    case "center":
      centerX = text.anchor_position.x;
      centerY = text.anchor_position.y;
      break;
    case "center_right":
      centerX = text.anchor_position.x - textWidth / 2;
      centerY = text.anchor_position.y;
      break;
    case "bottom_left":
      centerX = text.anchor_position.x + textWidth / 2;
      centerY = text.anchor_position.y - textHeight / 2;
      break;
    case "bottom_center":
      centerX = text.anchor_position.x;
      centerY = text.anchor_position.y - textHeight / 2;
      break;
    case "bottom_right":
      centerX = text.anchor_position.x - textWidth / 2;
      centerY = text.anchor_position.y - textHeight / 2;
      break;
    default:
      centerX = text.anchor_position.x;
      centerY = text.anchor_position.y;
      break;
  }
  return {
    x: centerX - textWidth / 2,
    y: centerY - textHeight / 2,
    width: textWidth,
    height: textHeight
  };
}

// lib/components/base-components/NormalComponent/NormalComponent_doInitialSilkscreenOverlapAdjustment.ts
import {
  getBoundingBox,
  doBoundsOverlap
} from "@tscircuit/math-utils";
function NormalComponent_doInitialSilkscreenOverlapAdjustment(component) {
  if (!component._adjustSilkscreenTextAutomatically) {
    return;
  }
  if (component.root?.pcbDisabled || !component.pcb_component_id) {
    return;
  }
  const { db } = component.root;
  const componentBounds = component._getPcbCircuitJsonBounds();
  const componentCenter = componentBounds.center;
  let silkscreenTexts = db.pcb_silkscreen_text.list({
    pcb_component_id: component.pcb_component_id
  }).filter((text) => text.text === component.name);
  if (silkscreenTexts.length === 0) {
    return;
  }
  const subcircuit = component.getSubcircuit();
  const allNormalComponents = subcircuit.selectAll("[_isNormalComponent=true]").filter((comp) => comp !== component && comp.pcb_component_id);
  const obstacleBounds = allNormalComponents.map((comp) => {
    const bounds = comp._getPcbCircuitJsonBounds();
    const box = {
      center: bounds.center,
      width: bounds.width,
      height: bounds.height
    };
    return getBoundingBox(box);
  });
  for (const silkscreenText of silkscreenTexts) {
    const currentPosition = silkscreenText.anchor_position;
    const textBounds = getPcbTextBounds(silkscreenText);
    const textBox = {
      center: {
        x: textBounds.x + textBounds.width / 2,
        y: textBounds.y + textBounds.height / 2
      },
      width: textBounds.width,
      height: textBounds.height
    };
    const textBoundsBox = getBoundingBox(textBox);
    const hasOverlap = obstacleBounds.some(
      (obstacle) => doBoundsOverlap(textBoundsBox, obstacle)
    );
    if (!hasOverlap) {
      continue;
    }
    const flippedX = 2 * componentCenter.x - currentPosition.x;
    const flippedY = 2 * componentCenter.y - currentPosition.y;
    const flippedTextBox = {
      center: { x: flippedX, y: flippedY },
      width: textBounds.width,
      height: textBounds.height
    };
    const flippedTextBounds = getBoundingBox(flippedTextBox);
    const flippedHasOverlap = obstacleBounds.some(
      (obstacle) => doBoundsOverlap(flippedTextBounds, obstacle)
    );
    if (!flippedHasOverlap) {
      db.pcb_silkscreen_text.update(silkscreenText.pcb_silkscreen_text_id, {
        anchor_position: {
          x: flippedX,
          y: flippedY
        }
      });
    }
  }
}

// lib/utils/filterPinLabels.ts
import { chipProps } from "@tscircuit/props";
function filterPinLabels(pinLabels) {
  if (!pinLabels)
    return {
      validPinLabels: pinLabels,
      invalidPinLabelsMessages: []
    };
  const validPinLabels = {};
  const invalidPinLabelsMessages = [];
  for (const [pin, labelOrLabels] of Object.entries(pinLabels)) {
    const labels = Array.isArray(labelOrLabels) ? labelOrLabels.slice() : [labelOrLabels];
    const validLabels = [];
    for (const label of labels) {
      if (isValidPinLabel(pin, label)) {
        validLabels.push(label);
      } else {
        invalidPinLabelsMessages.push(
          `Invalid pin label: ${pin} = '${label}' - excluding from component. Please use a valid pin label.`
        );
      }
    }
    if (validLabels.length > 0) {
      validPinLabels[pin] = Array.isArray(labelOrLabels) ? validLabels : validLabels[0];
    }
  }
  return {
    validPinLabels: Object.keys(validPinLabels).length > 0 ? validPinLabels : void 0,
    invalidPinLabelsMessages
  };
}
function isValidPinLabel(pin, label) {
  try {
    const testProps = {
      name: "test",
      footprint: "test",
      pinLabels: { [pin]: label }
    };
    const result = chipProps.safeParse(testProps);
    return result.success;
  } catch (error) {
    return false;
  }
}

// lib/components/base-components/NormalComponent/NormalComponent_doInitialPcbFootprintStringRender.ts
import { isValidElement as isReactElement } from "react";

// lib/components/base-components/NormalComponent/utils/isHttpUrl.ts
var isHttpUrl = (s) => s.startsWith("http://") || s.startsWith("https://");

// lib/components/base-components/NormalComponent/utils/parseLibraryFootprintRef.ts
var parseLibraryFootprintRef = (s) => {
  if (isHttpUrl(s)) return null;
  const idx = s.indexOf(":");
  if (idx <= 0) return null;
  const footprintLib = s.slice(0, idx);
  const footprintName = s.slice(idx + 1);
  if (!footprintLib || !footprintName) return null;
  return { footprintLib, footprintName };
};

// lib/components/base-components/NormalComponent/NormalComponent_doInitialPcbFootprintStringRender.ts
import {
  circuit_json_footprint_load_error,
  external_footprint_load_error
} from "circuit-json";

// lib/components/base-components/NormalComponent/utils/isStaticAssetPath.ts
var isStaticAssetPath = (s) => s.startsWith("/");

// lib/utils/resolveStaticFileImport.ts
import Debug4 from "debug";
var resolveStaticFileImportDebug = Debug4(
  "tscircuit:core:resolveStaticFileImport"
);
async function resolveStaticFileImport(path, platform) {
  if (!path) return path;
  const resolver = platform?.resolveProjectStaticFileImportUrl;
  if (resolver && path.startsWith("/")) {
    try {
      const resolved = await resolver(path);
      if (resolved) return resolved;
    } catch (error) {
      resolveStaticFileImportDebug(
        "failed to resolve static file via platform resolver",
        error
      );
    }
  }
  return constructAssetUrl(path, platform?.projectBaseUrl);
}

// lib/components/base-components/NormalComponent/NormalComponent_doInitialPcbFootprintStringRender.ts
function NormalComponent_doInitialPcbFootprintStringRender(component, queueAsyncEffect) {
  let { footprint } = component.props;
  footprint ??= component._getImpliedFootprintString?.();
  if (!footprint) return;
  const { pcbRotation, pinLabels, pcbPinLabels } = component.props;
  const fileExtension = getFileExtension(String(footprint));
  const footprintParser = fileExtension ? component.root?.platform?.footprintFileParserMap?.[fileExtension] : null;
  if (typeof footprint === "string" && (isHttpUrl(footprint) || isStaticAssetPath(footprint)) && footprintParser) {
    if (component._hasStartedFootprintUrlLoad) return;
    component._hasStartedFootprintUrlLoad = true;
    queueAsyncEffect("load-footprint-from-platform-file-parser", async () => {
      const footprintUrl = isHttpUrl(footprint) ? footprint : await resolveStaticFileImport(footprint, component.root?.platform);
      try {
        const result = await footprintParser.loadFromUrl(footprintUrl);
        const fpComponents = createComponentsFromCircuitJson(
          {
            componentName: component.name,
            componentRotation: pcbRotation,
            footprinterString: footprintUrl,
            pinLabels,
            pcbPinLabels
          },
          result.footprintCircuitJson
        );
        component.addAll(fpComponents);
        component._markDirty("InitializePortsFromChildren");
      } catch (err) {
        const db = component.root?.db;
        if (db && component.source_component_id && component.pcb_component_id) {
          const subcircuit = component.getSubcircuit();
          const errorMsg = `${component.getString()} failed to load footprint "${footprintUrl}": ` + (err instanceof Error ? err.message : String(err));
          const errorObj = external_footprint_load_error.parse({
            type: "external_footprint_load_error",
            message: errorMsg,
            pcb_component_id: component.pcb_component_id,
            source_component_id: component.source_component_id,
            subcircuit_id: subcircuit.subcircuit_id ?? void 0,
            pcb_group_id: component.getGroup()?.pcb_group_id ?? void 0,
            footprinter_string: footprintUrl
          });
          db.external_footprint_load_error.insert(errorObj);
        }
        throw err;
      }
    });
    return;
  }
  if (typeof footprint === "string" && isHttpUrl(footprint)) {
    if (component._hasStartedFootprintUrlLoad) return;
    component._hasStartedFootprintUrlLoad = true;
    const url = footprint;
    queueAsyncEffect("load-footprint-url", async () => {
      try {
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`Failed to fetch footprint: ${res.status}`);
        }
        const soup = await res.json();
        const fpComponents = createComponentsFromCircuitJson(
          {
            componentName: component.name,
            componentRotation: pcbRotation,
            footprinterString: url,
            pinLabels,
            pcbPinLabels
          },
          soup
        );
        component.addAll(fpComponents);
        component._markDirty("InitializePortsFromChildren");
      } catch (err) {
        const db = component.root?.db;
        if (db && component.source_component_id && component.pcb_component_id) {
          const subcircuit = component.getSubcircuit();
          const errorMsg = `${component.getString()} failed to load external footprint "${url}": ` + (err instanceof Error ? err.message : String(err));
          const errorObj = external_footprint_load_error.parse({
            type: "external_footprint_load_error",
            message: errorMsg,
            pcb_component_id: component.pcb_component_id,
            source_component_id: component.source_component_id,
            subcircuit_id: subcircuit.subcircuit_id ?? void 0,
            pcb_group_id: component.getGroup()?.pcb_group_id ?? void 0,
            footprinter_string: url
          });
          db.external_footprint_load_error.insert(errorObj);
        }
        throw err;
      }
    });
    return;
  }
  if (typeof footprint === "string") {
    const libRef = parseLibraryFootprintRef(footprint);
    if (!libRef) return;
    if (component._hasStartedFootprintUrlLoad) return;
    component._hasStartedFootprintUrlLoad = true;
    const platform = component.root?.platform;
    const libMap = platform?.footprintLibraryMap?.[libRef.footprintLib];
    let resolverFn;
    if (typeof libMap === "function") {
      resolverFn = libMap;
    }
    if (!resolverFn) return;
    const resolvedPcbStyle = component.getInheritedMergedProperty("pcbStyle");
    queueAsyncEffect("load-lib-footprint", async () => {
      try {
        const result = await resolverFn(libRef.footprintName, {
          resolvedPcbStyle
        });
        let circuitJson = null;
        if (Array.isArray(result)) {
          circuitJson = result;
        } else if (Array.isArray(result.footprintCircuitJson)) {
          circuitJson = result.footprintCircuitJson;
        }
        if (!circuitJson) return;
        const fpComponents = createComponentsFromCircuitJson(
          {
            componentName: component.name,
            componentRotation: pcbRotation,
            footprinterString: footprint,
            pinLabels,
            pcbPinLabels
          },
          circuitJson
        );
        component.addAll(fpComponents);
        if (!Array.isArray(result) && result.cadModel) {
          component._asyncFootprintCadModel = result.cadModel;
        }
        for (const child of component.children) {
          if (child.componentName === "Port") {
            child._markDirty?.("PcbPortRender");
          }
        }
        component._markDirty("InitializePortsFromChildren");
      } catch (err) {
        const db = component.root?.db;
        if (db && component.source_component_id && component.pcb_component_id) {
          const subcircuit = component.getSubcircuit();
          const errorMsg = `${component.getString()} failed to load external footprint "${footprint}": ` + (err instanceof Error ? err.message : String(err));
          const errorObj = external_footprint_load_error.parse({
            type: "external_footprint_load_error",
            message: errorMsg,
            pcb_component_id: component.pcb_component_id,
            source_component_id: component.source_component_id,
            subcircuit_id: subcircuit.subcircuit_id ?? void 0,
            pcb_group_id: component.getGroup()?.pcb_group_id ?? void 0,
            footprinter_string: footprint
          });
          db.external_footprint_load_error.insert(errorObj);
        }
        throw err;
      }
    });
    return;
  }
  if (!isReactElement(footprint) && footprint.componentName === "Footprint") {
    component.add(footprint);
  }
  if (Array.isArray(footprint) && !isReactElement(footprint) && footprint.length > 0) {
    try {
      const fpComponents = createComponentsFromCircuitJson(
        {
          componentName: component.name,
          componentRotation: pcbRotation,
          footprinterString: "",
          pinLabels,
          pcbPinLabels
        },
        footprint
      );
      component.addAll(fpComponents);
    } catch (err) {
      const db = component.root?.db;
      if (db && component.source_component_id && component.pcb_component_id) {
        const subcircuit = component.getSubcircuit();
        const errorMsg = `${component.getString()} failed to load json footprint: ` + (err instanceof Error ? err.message : String(err));
        const errorObj = circuit_json_footprint_load_error.parse({
          type: "circuit_json_footprint_load_error",
          message: errorMsg,
          pcb_component_id: component.pcb_component_id,
          source_component_id: component.source_component_id,
          subcircuit_id: subcircuit.subcircuit_id ?? void 0,
          pcb_group_id: component.getGroup()?.pcb_group_id ?? void 0
        });
        db.circuit_json_footprint_load_error.insert(errorObj);
      }
      throw err;
    }
    return;
  }
}

// lib/components/base-components/NormalComponent/NormalComponent_doInitialPcbComponentAnchorAlignment.ts
function NormalComponent_doInitialPcbComponentAnchorAlignment(component) {
  if (component.root?.pcbDisabled) return;
  if (!component.pcb_component_id) return;
  const { pcbX, pcbY } = component._parsedProps;
  const pcbPositionAnchor = component.props?.pcbPositionAnchor;
  if (!pcbPositionAnchor) return;
  if (pcbX === void 0 && pcbY === void 0) return;
  const bounds = getBoundsOfPcbComponents(component.children);
  if (bounds.width === 0 || bounds.height === 0) return;
  const center = {
    x: (bounds.minX + bounds.maxX) / 2,
    y: (bounds.minY + bounds.maxY) / 2
  };
  const currentCenter = { ...center };
  let anchorPos = null;
  const ninePointAnchors = /* @__PURE__ */ new Set([
    "center",
    "top_left",
    "top_center",
    "top_right",
    "center_left",
    "center_right",
    "bottom_left",
    "bottom_center",
    "bottom_right"
  ]);
  if (ninePointAnchors.has(pcbPositionAnchor)) {
    const b = {
      left: bounds.minX,
      right: bounds.maxX,
      top: bounds.minY,
      bottom: bounds.maxY
    };
    switch (pcbPositionAnchor) {
      case "center":
        anchorPos = currentCenter;
        break;
      case "top_left":
        anchorPos = { x: b.left, y: b.top };
        break;
      case "top_center":
        anchorPos = { x: currentCenter.x, y: b.top };
        break;
      case "top_right":
        anchorPos = { x: b.right, y: b.top };
        break;
      case "center_left":
        anchorPos = { x: b.left, y: currentCenter.y };
        break;
      case "center_right":
        anchorPos = { x: b.right, y: currentCenter.y };
        break;
      case "bottom_left":
        anchorPos = { x: b.left, y: b.bottom };
        break;
      case "bottom_center":
        anchorPos = { x: currentCenter.x, y: b.bottom };
        break;
      case "bottom_right":
        anchorPos = { x: b.right, y: b.bottom };
        break;
    }
  } else {
    try {
      const port = component.portMap[pcbPositionAnchor];
      if (port) {
        anchorPos = port._getGlobalPcbPositionBeforeLayout();
      }
    } catch {
    }
  }
  if (!anchorPos) return;
  const newCenter = { ...currentCenter };
  if (pcbX !== void 0) newCenter.x += pcbX - anchorPos.x;
  if (pcbY !== void 0) newCenter.y += pcbY - anchorPos.y;
  if (Math.abs(newCenter.x - currentCenter.x) > 1e-6 || Math.abs(newCenter.y - currentCenter.y) > 1e-6) {
    component._repositionOnPcb(newCenter);
  }
}

// lib/components/base-components/NormalComponent/NormalComponent.ts
import { normalizeDegrees } from "@tscircuit/math-utils";
var debug3 = Debug5("tscircuit:core");
var rotation32 = z9.object({
  x: rotation2,
  y: rotation2,
  z: rotation2
});
var NormalComponent3 = class extends PrimitiveComponent2 {
  reactSubtrees = [];
  _impliedFootprint;
  isPrimitiveContainer = true;
  _isNormalComponent = true;
  // Mapping from camelCase attribute names to their lowercase equivalents
  // This is used by the CSS selector adapter for fast attribute lookups
  // Reverse mapping from lowercase to camelCase for O(1) lookups
  _attributeLowerToCamelNameMap = {
    _isnormalcomponent: "_isNormalComponent"
  };
  _asyncSupplierPartNumbers;
  _asyncFootprintCadModel;
  _isCadModelChild;
  pcb_missing_footprint_error_id;
  _hasStartedFootprintUrlLoad = false;
  _invalidPinLabelMessages = [];
  /**
   * Set to true to enable automatic silkscreen text adjustment when it overlaps with other components
   */
  _adjustSilkscreenTextAutomatically = false;
  /**
   * Override this property for component defaults
   */
  get defaultInternallyConnectedPinNames() {
    return [];
  }
  get internallyConnectedPinNames() {
    const rawPins = this._parsedProps.internallyConnectedPins ?? this.defaultInternallyConnectedPinNames;
    return rawPins.map(
      (pinGroup) => pinGroup.map(
        (pin) => typeof pin === "number" ? `pin${pin}` : pin
      )
    );
  }
  constructor(props) {
    const filteredProps = { ...props };
    let invalidPinLabelsMessages = [];
    if (filteredProps.pinLabels && !Array.isArray(filteredProps.pinLabels)) {
      const { validPinLabels, invalidPinLabelsMessages: messages } = filterPinLabels(filteredProps.pinLabels);
      filteredProps.pinLabels = validPinLabels;
      invalidPinLabelsMessages = messages;
    }
    super(filteredProps);
    this._invalidPinLabelMessages = invalidPinLabelsMessages;
    this._addChildrenFromStringFootprint();
    this.initPorts();
  }
  doInitialSourceNameDuplicateComponentRemoval() {
    if (!this.name) return;
    const root = this.root;
    const componentsWithSameName = this.getSubcircuit().selectAll(
      `.${this.name}`
    );
    const conflictingComponents = componentsWithSameName.filter(
      (component) => component !== this && component._isNormalComponent && component.renderPhaseStates?.SourceNameDuplicateComponentRemoval?.initialized
    );
    if (conflictingComponents.length > 0) {
      const pcbPosition = this._getGlobalPcbPositionBeforeLayout();
      const schematicPosition = this._getGlobalSchematicPositionBeforeLayout();
      root.db.source_failed_to_create_component_error.insert({
        component_name: this.name,
        error_type: "source_failed_to_create_component_error",
        message: `Cannot create component "${this.name}": A component with the same name already exists`,
        pcb_center: pcbPosition,
        schematic_center: schematicPosition
      });
      this.shouldBeRemoved = true;
      const childrenToRemove = [...this.children];
      for (const child of childrenToRemove) {
        this.remove(child);
      }
    }
  }
  /**
   * Override this method for better control over the auto-discovery of ports.
   *
   * If you override this method just do something like:
   * initPorts() {
   *   this.add(new Port({ pinNumber: 1, aliases: ["anode", "pos"] }))
   *   this.add(new Port({ pinNumber: 2, aliases: ["cathode", "neg"] }))
   * }
   *
   * By default, we'll pull the ports from the first place we find them:
   * 1. `config.schematicSymbolName`
   * 2. `props.footprint`
   *
   */
  initPorts(opts = {}) {
    if (this.root?.schematicDisabled) return;
    const { config } = this;
    const portsToCreate = [];
    const schPortArrangement = this._getSchematicPortArrangement();
    if (schPortArrangement && !this._parsedProps.pinLabels) {
      for (const side in schPortArrangement) {
        const pins = schPortArrangement[side].pins;
        if (Array.isArray(pins)) {
          for (const pinNumberOrLabel of pins) {
            const pinNumber = parsePinNumberFromLabelsOrThrow(
              pinNumberOrLabel,
              this._parsedProps.pinLabels
            );
            portsToCreate.push(
              new Port(
                {
                  pinNumber,
                  aliases: opts.additionalAliases?.[`pin${pinNumber}`] ?? []
                },
                {
                  originDescription: `schPortArrangement:${side}`
                }
              )
            );
          }
        }
      }
      const sides = ["left", "right", "top", "bottom"];
      let pinNum = 1;
      for (const side of sides) {
        const size = schPortArrangement[`${side}Size`];
        for (let i = 0; i < size; i++) {
          portsToCreate.push(
            new Port(
              {
                pinNumber: pinNum++,
                aliases: opts.additionalAliases?.[`pin${pinNum}`] ?? []
              },
              {
                originDescription: `schPortArrangement:${side}`
              }
            )
          );
        }
      }
    }
    const pinLabels = this._parsedProps.pinLabels;
    if (pinLabels) {
      for (let [pinNumber, label] of Object.entries(pinLabels)) {
        pinNumber = pinNumber.replace("pin", "");
        let existingPort = portsToCreate.find(
          (p) => p._parsedProps.pinNumber === Number(pinNumber)
        );
        const primaryLabel = Array.isArray(label) ? label[0] : label;
        const otherLabels = Array.isArray(label) ? label.slice(1) : [];
        if (!existingPort) {
          existingPort = new Port(
            {
              pinNumber: parseInt(pinNumber),
              name: primaryLabel,
              aliases: [
                ...otherLabels,
                ...opts.additionalAliases?.[`pin${parseInt(pinNumber)}`] ?? []
              ]
            },
            {
              originDescription: `pinLabels:pin${pinNumber}`
            }
          );
          portsToCreate.push(existingPort);
        } else {
          existingPort.externallyAddedAliases.push(primaryLabel, ...otherLabels);
          existingPort.props.name = primaryLabel;
        }
      }
    }
    if (config.schematicSymbolName && !opts.ignoreSymbolPorts) {
      const sym = symbols2[this._getSchematicSymbolNameOrThrow()];
      if (!sym) return;
      for (const symPort of sym.ports) {
        const pinNumber = getPinNumberFromLabels(symPort.labels);
        if (!pinNumber) continue;
        const existingPort = portsToCreate.find(
          (p) => p._parsedProps.pinNumber === Number(pinNumber)
        );
        if (existingPort) {
          existingPort.schematicSymbolPortDef = symPort;
        } else {
          const port = getPortFromHints(
            symPort.labels.concat(
              opts.additionalAliases?.[`pin${pinNumber}`] ?? []
            )
          );
          if (port) {
            port.originDescription = `schematicSymbol:labels[0]:${symPort.labels[0]}`;
            port.schematicSymbolPortDef = symPort;
            portsToCreate.push(port);
          }
        }
      }
      this.addAll(portsToCreate);
    }
    if (!this._getSchematicPortArrangement()) {
      const portsFromFootprint = this.getPortsFromFootprint(opts);
      for (const port of portsFromFootprint) {
        if (!portsToCreate.some(
          (p) => p.isMatchingAnyOf(port.getNameAndAliases())
        )) {
          portsToCreate.push(port);
        }
      }
    }
    const requiredPinCount = opts.pinCount ?? this._getPinCount() ?? 0;
    for (let pn = 1; pn <= requiredPinCount; pn++) {
      if (portsToCreate.find((p) => p._parsedProps.pinNumber === pn)) continue;
      if (!schPortArrangement) {
        portsToCreate.push(
          new Port({
            pinNumber: pn,
            aliases: opts.additionalAliases?.[`pin${pn}`] ?? []
          })
        );
        continue;
      }
      let explicitlyListedPinNumbersInSchPortArrangement = [
        ...schPortArrangement.leftSide?.pins ?? [],
        ...schPortArrangement.rightSide?.pins ?? [],
        ...schPortArrangement.topSide?.pins ?? [],
        ...schPortArrangement.bottomSide?.pins ?? []
      ].map(
        (pn2) => parsePinNumberFromLabelsOrThrow(pn2, this._parsedProps.pinLabels)
      );
      if ([
        "leftSize",
        "rightSize",
        "topSize",
        "bottomSize",
        "leftPinCount",
        "rightPinCount",
        "topPinCount",
        "bottomPinCount"
      ].some((key) => key in schPortArrangement)) {
        explicitlyListedPinNumbersInSchPortArrangement = Array.from(
          { length: this._getPinCount() },
          (_, i) => i + 1
        );
      }
      if (!explicitlyListedPinNumbersInSchPortArrangement.includes(pn)) {
        continue;
      }
      portsToCreate.push(
        new Port(
          {
            pinNumber: pn,
            aliases: opts.additionalAliases?.[`pin${pn}`] ?? []
          },
          {
            originDescription: `notOtherwiseAddedButDeducedFromPinCount:${pn}`
          }
        )
      );
    }
    if (portsToCreate.length > 0) {
      this.addAll(portsToCreate);
    }
  }
  _getImpliedFootprintString() {
    return null;
  }
  _addChildrenFromStringFootprint() {
    const { pcbRotation, pinLabels, pcbPinLabels } = this.props;
    let { footprint } = this.props;
    footprint ??= this._getImpliedFootprintString?.();
    if (!footprint) return;
    if (typeof footprint === "string") {
      if (isHttpUrl(footprint)) return;
      if (isStaticAssetPath(footprint)) return;
      if (parseLibraryFootprintRef(footprint)) return;
      const fpSoup = fp.string(footprint).soup();
      const fpComponents = createComponentsFromCircuitJson(
        {
          componentName: this.name ?? this.componentName,
          componentRotation: pcbRotation,
          footprinterString: footprint,
          pinLabels,
          pcbPinLabels
        },
        fpSoup
      );
      this.addAll(fpComponents);
    }
  }
  get portMap() {
    return new Proxy(
      {},
      {
        get: (target, prop) => {
          const port = this.children.find(
            (c) => c.componentName === "Port" && c.isMatchingNameOrAlias(prop)
          );
          if (!port) {
            throw new Error(
              `There was an issue finding the port "${prop.toString()}" inside of a ${this.componentName} component with name: "${this.props.name}". This is a bug in @tscircuit/core`
            );
          }
          return port;
        }
      }
    );
  }
  getInstanceForReactElement(element) {
    for (const subtree of this.reactSubtrees) {
      if (subtree.element === element) return subtree.component;
    }
    return null;
  }
  doInitialSourceRender() {
    const ftype = this.config.sourceFtype;
    if (!ftype) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype,
      name: this.name,
      manufacturer_part_number: props.manufacturerPartNumber ?? props.mfn,
      supplier_part_numbers: props.supplierPartNumbers
    });
    this.source_component_id = source_component.source_component_id;
  }
  /**
   * Render the schematic component for this NormalComponent using the
   * config.schematicSymbolName if it exists, or create a generic box if
   * no symbol is defined.
   *
   * You can override this method to do more complicated things.
   */
  doInitialSchematicComponentRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    if (this._invalidPinLabelMessages?.length && this.root?.db) {
      for (const message of this._invalidPinLabelMessages) {
        let property_name = "pinLabels";
        const match = message.match(
          /^Invalid pin label:\s*([^=]+)=\s*'([^']+)'/
        );
        if (match) {
          const label = match[2];
          property_name = `pinLabels['${label}']`;
        }
        this.root.db.source_property_ignored_warning.insert({
          source_component_id: this.source_component_id,
          property_name,
          message,
          error_type: "source_property_ignored_warning"
        });
      }
    }
    const { schematicSymbolName } = this.config;
    const { _parsedProps: props } = this;
    if (props.symbol && isReactElement2(props.symbol)) {
      this._doInitialSchematicComponentRenderWithReactSymbol(props.symbol);
    } else if (schematicSymbolName) {
      this._doInitialSchematicComponentRenderWithSymbol();
    } else {
      const dimensions = this._getSchematicBoxDimensions();
      if (dimensions) {
        this._doInitialSchematicComponentRenderWithSchematicBoxDimensions();
      }
    }
    const manualPlacement = this.getSubcircuit()?._getSchematicManualPlacementForComponent(this);
    if (this.schematic_component_id && (this.props.schX !== void 0 || this.props.schY !== void 0) && !!manualPlacement) {
      if (!this.schematic_component_id) {
        return;
      }
      const warning = schematic_manual_edit_conflict_warning.parse({
        type: "schematic_manual_edit_conflict_warning",
        schematic_manual_edit_conflict_warning_id: `schematic_manual_edit_conflict_${this.source_component_id}`,
        message: `${this.getString()} has both manual placement and prop coordinates. schX and schY will be used. Remove schX/schY or clear the manual placement.`,
        schematic_component_id: this.schematic_component_id,
        source_component_id: this.source_component_id,
        subcircuit_id: this.getSubcircuit()?.subcircuit_id
      });
      db.schematic_manual_edit_conflict_warning.insert(warning);
    }
  }
  _getSchematicSymbolDisplayValue() {
    return void 0;
  }
  _getInternallyConnectedPins() {
    if (this.internallyConnectedPinNames.length === 0) return [];
    const internallyConnectedPorts = [];
    for (const netPortNames of this.internallyConnectedPinNames) {
      const ports = [];
      for (const portName of netPortNames) {
        ports.push(this.portMap[portName]);
      }
      internallyConnectedPorts.push(ports);
    }
    return internallyConnectedPorts;
  }
  _doInitialSchematicComponentRenderWithSymbol() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const symbol_name = this._getSchematicSymbolNameOrThrow();
    const symbol = symbols2[symbol_name];
    const center = this._getGlobalSchematicPositionBeforeLayout();
    if (symbol) {
      const schematic_component2 = db.schematic_component.insert({
        center,
        size: symbol.size,
        source_component_id: this.source_component_id,
        is_box_with_pins: true,
        symbol_name,
        symbol_display_value: this._getSchematicSymbolDisplayValue()
      });
      this.schematic_component_id = schematic_component2.schematic_component_id;
    }
  }
  _doInitialSchematicComponentRenderWithReactSymbol(symbolElement) {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const center = this._getGlobalSchematicPositionBeforeLayout();
    const schematic_component2 = db.schematic_component.insert({
      center,
      // width/height are computed in the SchematicComponentSizeCalculation phase
      size: { width: 0, height: 0 },
      source_component_id: this.source_component_id,
      symbol_display_value: this._getSchematicSymbolDisplayValue(),
      is_box_with_pins: false
    });
    this.schematic_component_id = schematic_component2.schematic_component_id;
  }
  _doInitialSchematicComponentRenderWithSchematicBoxDimensions() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const dimensions = this._getSchematicBoxDimensions();
    const primaryPortLabels = {};
    if (Array.isArray(props.pinLabels)) {
      props.pinLabels.forEach((label, index) => {
        primaryPortLabels[String(index + 1)] = label;
      });
    } else {
      for (const [port, label] of Object.entries(props.pinLabels ?? {})) {
        primaryPortLabels[port] = Array.isArray(label) ? label[0] : label;
      }
    }
    const center = this._getGlobalSchematicPositionBeforeLayout();
    const schPortArrangement = this._getSchematicPortArrangement();
    const schematic_component2 = db.schematic_component.insert({
      center,
      rotation: props.schRotation ?? 0,
      size: dimensions.getSize(),
      // We should be using the full size, but circuit-to-svg incorrectly
      // uses the schematic_component size to draw boxes instead of the
      // schematic_box size
      // size: dimensions.getSizeIncludingPins(),
      port_arrangement: underscorifyPortArrangement(schPortArrangement),
      pin_spacing: props.schPinSpacing ?? 0.2,
      // @ts-ignore soup needs to support distance for pin_styles
      pin_styles: underscorifyPinStyles(props.schPinStyle, props.pinLabels),
      port_labels: primaryPortLabels,
      source_component_id: this.source_component_id
    });
    const hasTopOrBottomPins = schPortArrangement?.topSide !== void 0 || schPortArrangement?.bottomSide !== void 0;
    const schematic_box_width = dimensions?.getSize().width;
    const schematic_box_height = dimensions?.getSize().height;
    const manufacturer_part_number_schematic_text = db.schematic_text.insert({
      text: props.manufacturerPartNumber ?? "",
      schematic_component_id: schematic_component2.schematic_component_id,
      anchor: "left",
      rotation: 0,
      position: {
        x: hasTopOrBottomPins ? center.x + (schematic_box_width ?? 0) / 2 + 0.1 : center.x - (schematic_box_width ?? 0) / 2,
        y: hasTopOrBottomPins ? center.y + (schematic_box_height ?? 0) / 2 + 0.35 : center.y - (schematic_box_height ?? 0) / 2 - 0.13
      },
      color: "#006464",
      font_size: 0.18
    });
    const component_name_text = db.schematic_text.insert({
      text: props.name ?? "",
      schematic_component_id: schematic_component2.schematic_component_id,
      anchor: "left",
      rotation: 0,
      position: {
        x: hasTopOrBottomPins ? center.x + (schematic_box_width ?? 0) / 2 + 0.1 : center.x - (schematic_box_width ?? 0) / 2,
        y: hasTopOrBottomPins ? center.y + (schematic_box_height ?? 0) / 2 + 0.55 : center.y + (schematic_box_height ?? 0) / 2 + 0.13
      },
      color: "#006464",
      font_size: 0.18
    });
    this.schematic_component_id = schematic_component2.schematic_component_id;
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const subcircuit = this.getSubcircuit();
    const componentLayer = props.layer ?? "top";
    if (componentLayer !== "top" && componentLayer !== "bottom") {
      const error = pcb_component_invalid_layer_error.parse({
        type: "pcb_component_invalid_layer_error",
        message: `Component cannot be placed on layer '${componentLayer}'. Components can only be placed on 'top' or 'bottom' layers.`,
        source_component_id: this.source_component_id,
        layer: componentLayer,
        subcircuit_id: subcircuit.subcircuit_id ?? void 0
      });
      db.pcb_component_invalid_layer_error.insert(error);
    }
    const globalTransform = this._computePcbGlobalTransformBeforeLayout();
    const decomposedTransform = decomposeTSR5(globalTransform);
    const accumulatedRotation = decomposedTransform.rotation.angle * 180 / Math.PI;
    const pcb_component = db.pcb_component.insert({
      center: this._getGlobalPcbPositionBeforeLayout(),
      // width/height are computed in the PcbComponentSizeCalculation phase
      width: 0,
      height: 0,
      layer: componentLayer === "top" || componentLayer === "bottom" ? componentLayer : "top",
      rotation: props.pcbRotation ?? accumulatedRotation,
      source_component_id: this.source_component_id,
      subcircuit_id: subcircuit.subcircuit_id ?? void 0,
      do_not_place: props.doNotPlace ?? false,
      obstructs_within_bounds: props.obstructsWithinBounds ?? true
    });
    const footprint = props.footprint ?? this._getImpliedFootprintString();
    if (!footprint && !this.isGroup) {
      const footprint_error = db.pcb_missing_footprint_error.insert({
        message: `No footprint found for component: ${this.getString()}`,
        source_component_id: `${this.source_component_id}`,
        error_type: "pcb_missing_footprint_error"
      });
      this.pcb_missing_footprint_error_id = footprint_error.pcb_missing_footprint_error_id;
    }
    this.pcb_component_id = pcb_component.pcb_component_id;
    const manualPlacement = this.getSubcircuit()._getPcbManualPlacementForComponent(this);
    if ((this.props.pcbX !== void 0 || this.props.pcbY !== void 0) && !!manualPlacement) {
      const warning = pcb_manual_edit_conflict_warning.parse({
        type: "pcb_manual_edit_conflict_warning",
        pcb_manual_edit_conflict_warning_id: `pcb_manual_edit_conflict_${this.source_component_id}`,
        message: `${this.getString()} has both manual placement and prop coordinates. pcbX and pcbY will be used. Remove pcbX/pcbY or clear the manual placement.`,
        pcb_component_id: this.pcb_component_id,
        source_component_id: this.source_component_id,
        subcircuit_id: subcircuit.subcircuit_id ?? void 0
      });
      db.pcb_manual_edit_conflict_warning.insert(warning);
    }
  }
  /**
   * At this stage, the smtpads/pcb primitives are placed, so we can compute
   * the width/height of the component
   */
  doInitialPcbComponentSizeCalculation() {
    if (this.root?.pcbDisabled) return;
    if (!this.pcb_component_id) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const bounds = getBoundsOfPcbComponents(this.children);
    if (bounds.width === 0 || bounds.height === 0) return;
    const center = {
      x: (bounds.minX + bounds.maxX) / 2,
      y: (bounds.minY + bounds.maxY) / 2
    };
    db.pcb_component.update(this.pcb_component_id, {
      center,
      width: bounds.width,
      height: bounds.height
    });
  }
  updatePcbComponentSizeCalculation() {
    this.doInitialPcbComponentSizeCalculation();
  }
  /**
   * Calculate and update the size of a custom schematic symbol based on its children
   */
  doInitialSchematicComponentSizeCalculation() {
    if (this.root?.schematicDisabled) return;
    if (!this.schematic_component_id) return;
    const { db } = this.root;
    const schematic_component2 = db.schematic_component.get(
      this.schematic_component_id
    );
    if (!schematic_component2) return;
    const schematicElements = [];
    const collectSchematicPrimitives = (children) => {
      for (const child of children) {
        if (child.isSchematicPrimitive && child.componentName === "SchematicLine") {
          const line = db.schematic_line.get(child.schematic_line_id);
          if (line) schematicElements.push(line);
        }
        if (child.isSchematicPrimitive && child.componentName === "SchematicRect") {
          const rect = db.schematic_rect.get(child.schematic_rect_id);
          if (rect) schematicElements.push(rect);
        }
        if (child.isSchematicPrimitive && child.componentName === "SchematicCircle") {
          const circle = db.schematic_circle.get(
            child.schematic_circle_id
          );
          if (circle) schematicElements.push(circle);
        }
        if (child.isSchematicPrimitive && child.componentName === "SchematicArc") {
          const arc = db.schematic_arc.get(child.schematic_arc_id);
          if (arc) schematicElements.push(arc);
        }
        if (child.isSchematicPrimitive && child.componentName === "SchematicText") {
          const text = db.schematic_text.get(child.schematic_text_id);
          if (text) schematicElements.push(text);
        }
        if (child.children && child.children.length > 0) {
          collectSchematicPrimitives(child.children);
        }
      }
    };
    collectSchematicPrimitives(this.children);
    if (schematicElements.length === 0) return;
    const bounds = getBoundsForSchematic(schematicElements);
    const width = Math.abs(bounds.maxX - bounds.minX);
    const height = Math.abs(bounds.maxY - bounds.minY);
    if (width === 0 && height === 0) return;
    const centerX = (bounds.minX + bounds.maxX) / 2;
    const centerY = (bounds.minY + bounds.maxY) / 2;
    db.schematic_component.update(this.schematic_component_id, {
      center: {
        x: centerX,
        y: centerY
      },
      size: {
        width,
        height
      }
    });
  }
  updateSchematicComponentSizeCalculation() {
    this.doInitialSchematicComponentSizeCalculation();
  }
  doInitialPcbComponentAnchorAlignment() {
    NormalComponent_doInitialPcbComponentAnchorAlignment(this);
  }
  updatePcbComponentAnchorAlignment() {
    this.doInitialPcbComponentAnchorAlignment();
  }
  _renderReactSubtree(element) {
    const component = createInstanceFromReactElement(element);
    return {
      element,
      component
    };
  }
  doInitialInitializePortsFromChildren() {
    this.initPorts();
  }
  doInitialReactSubtreesRender() {
    const fpElm = this.props.footprint;
    if (isValidElement(fpElm)) {
      const hasFootprintChild = this.children.some(
        (c) => c.componentName === "Footprint"
      );
      if (!hasFootprintChild) {
        this.add(fpElm);
      }
    }
    const symElm = this.props.symbol;
    if (isValidElement(symElm)) {
      const hasSymbolChild = this.children.some(
        (c) => c.componentName === "Symbol"
      );
      if (!hasSymbolChild) {
        this.add(symElm);
      }
    }
    const cmElm = this.props.cadModel;
    if (isValidElement(cmElm)) {
      this._isCadModelChild = true;
      const hasCadAssemblyChild = this.children.some(
        (c) => c.componentName === "CadAssembly"
      );
      const hasCadModelChild = this.children.some(
        (c) => c.componentName === "CadModel"
      );
      if (!hasCadAssemblyChild && !hasCadModelChild) {
        this.add(cmElm);
      }
    }
  }
  doInitialPcbFootprintStringRender() {
    NormalComponent_doInitialPcbFootprintStringRender(
      this,
      (name, effect) => this._queueAsyncEffect(name, effect)
    );
  }
  _hasExistingPortExactly(port1) {
    const existingPorts = this.children.filter(
      (c) => c.componentName === "Port"
    );
    return existingPorts.some((port2) => {
      const aliases1 = port1.getNameAndAliases();
      const aliases2 = port2.getNameAndAliases();
      return aliases1.length === aliases2.length && aliases1.every((alias) => aliases2.includes(alias));
    });
  }
  add(componentOrElm) {
    let component;
    if (isReactElement2(componentOrElm)) {
      const subtree = this._renderReactSubtree(componentOrElm);
      this.reactSubtrees.push(subtree);
      component = subtree.component;
    } else {
      component = componentOrElm;
    }
    if (component.componentName === "Port") {
      if (this._hasExistingPortExactly(component)) return;
      const existingPorts = this.children.filter(
        (c) => c.componentName === "Port"
      );
      const conflictingPort = existingPorts.find(
        (p) => p.isMatchingAnyOf(component.getNameAndAliases())
      );
      if (conflictingPort) {
        debug3(
          `Similar ports added. Port 1: ${conflictingPort}, Port 2: ${component}`
        );
      }
    }
    super.add(component);
  }
  getPortsFromFootprint(opts) {
    let { footprint } = this.props;
    if (!footprint || isValidElement(footprint)) {
      footprint = this.children.find((c) => c.componentName === "Footprint");
    }
    if (typeof footprint === "string") {
      if (isHttpUrl(footprint)) return [];
      if (isStaticAssetPath(footprint)) return [];
      if (parseLibraryFootprintRef(footprint)) return [];
      const fpSoup = fp.string(footprint).soup();
      const newPorts2 = [];
      for (const elm of fpSoup) {
        if ("port_hints" in elm && elm.port_hints) {
          const newPort = getPortFromHints(elm.port_hints, opts);
          if (!newPort) continue;
          newPort.originDescription = `footprint:string:${footprint}:port_hints[0]:${elm.port_hints[0]}`;
          newPorts2.push(newPort);
        }
      }
      return newPorts2;
    }
    if (!isValidElement(footprint) && footprint && footprint.componentName === "Footprint") {
      const fp2 = footprint;
      let pinNumber = 1;
      const newPorts2 = [];
      for (const fpChild of fp2.children) {
        if (!fpChild.props.portHints) continue;
        let portHintsList = fpChild.props.portHints;
        const hasPinPrefix = portHintsList.some(
          (hint) => hint.startsWith("pin")
        );
        if (!hasPinPrefix) {
          portHintsList = [...portHintsList, `pin${pinNumber}`];
        }
        pinNumber++;
        const newPort = getPortFromHints(portHintsList);
        if (!newPort) continue;
        newPort.originDescription = `footprint:${footprint}`;
        newPorts2.push(newPort);
      }
      return newPorts2;
    }
    const newPorts = [];
    if (!footprint) {
      for (const child of this.children) {
        if (child.props.portHints && child.isPcbPrimitive) {
          const port = getPortFromHints(child.props.portHints);
          if (port) newPorts.push(port);
        }
      }
    }
    return newPorts;
  }
  getPortsFromSchematicSymbol() {
    if (this.root?.schematicDisabled) return [];
    const { config } = this;
    if (!config.schematicSymbolName) return [];
    const symbol = symbols2[config.schematicSymbolName];
    if (!symbol) return [];
    const newPorts = [];
    for (const symbolPort of symbol.ports) {
      const port = getPortFromHints(symbolPort.labels);
      if (port) {
        port.schematicSymbolPortDef = symbolPort;
        newPorts.push(port);
      }
    }
    return newPorts;
  }
  doInitialCreateNetsFromProps() {
    this._createNetsFromProps(this._getNetsFromConnectionsProp());
  }
  _getNetsFromConnectionsProp() {
    const { _parsedProps: props } = this;
    const propsWithConnections = [];
    if (props.connections) {
      for (const [pinName, target] of Object.entries(props.connections)) {
        const targets = Array.isArray(target) ? target : [target];
        for (const targetPath of targets) {
          propsWithConnections.push(String(targetPath));
        }
      }
    }
    return propsWithConnections;
  }
  _createNetsFromProps(propsWithConnections) {
    createNetsFromProps(this, propsWithConnections);
  }
  _getPcbCircuitJsonBounds() {
    const { db } = this.root;
    if (!this.pcb_component_id) return super._getPcbCircuitJsonBounds();
    const pcb_component = db.pcb_component.get(this.pcb_component_id);
    return {
      center: { x: pcb_component.center.x, y: pcb_component.center.y },
      bounds: {
        left: pcb_component.center.x - pcb_component.width / 2,
        top: pcb_component.center.y - pcb_component.height / 2,
        right: pcb_component.center.x + pcb_component.width / 2,
        bottom: pcb_component.center.y + pcb_component.height / 2
      },
      width: pcb_component.width,
      height: pcb_component.height
    };
  }
  _getPinCountFromSchematicPortArrangement() {
    const schPortArrangement = this._getSchematicPortArrangement();
    if (!schPortArrangement) return 0;
    const isExplicitPinMapping = isExplicitPinMappingArrangement(schPortArrangement);
    if (!isExplicitPinMapping) {
      return (schPortArrangement.leftSize ?? schPortArrangement.leftPinCount ?? 0) + (schPortArrangement.rightSize ?? schPortArrangement.rightPinCount ?? 0) + (schPortArrangement.topSize ?? schPortArrangement.topPinCount ?? 0) + (schPortArrangement.bottomSize ?? schPortArrangement.bottomPinCount ?? 0);
    }
    const { leftSide, rightSide, topSide, bottomSide } = schPortArrangement;
    return Math.max(
      ...leftSide?.pins ?? [],
      ...rightSide?.pins ?? [],
      ...topSide?.pins ?? [],
      ...bottomSide?.pins ?? []
    );
  }
  _getPinCount() {
    const schPortArrangement = this._getSchematicPortArrangement();
    if (schPortArrangement) {
      const pinCountFromSchematicPortArrangement = this._getPinCountFromSchematicPortArrangement();
      return pinCountFromSchematicPortArrangement;
    }
    const portsFromFootprint = this.getPortsFromFootprint();
    if (portsFromFootprint.length > 0) {
      return portsFromFootprint.length;
    }
    const { pinLabels } = this._parsedProps;
    if (pinLabels) {
      if (Array.isArray(pinLabels)) {
        return pinLabels.length;
      }
      const pinNumbers = Object.keys(pinLabels).map((k) => k.startsWith("pin") ? parseInt(k.slice(3)) : parseInt(k)).filter((n) => !Number.isNaN(n));
      if (pinNumbers.length > 0) {
        return Math.max(...pinNumbers);
      }
      return Object.keys(pinLabels).length;
    }
    return 0;
  }
  /**
   * Override the schematic port arrangement if you want to customize where pins
   * appear on a schematic box, e.g. for a pin header
   */
  _getSchematicPortArrangement() {
    return this._parsedProps.schPinArrangement ?? this._parsedProps.schPortArrangement;
  }
  /**
   * Extract pin labels from ports using existing Port logic
   */
  _getPinLabelsFromPorts() {
    const ports = this.selectAll("port");
    const pinLabels = {};
    for (const port of ports) {
      const pinNumber = port.props.pinNumber;
      if (pinNumber !== void 0) {
        const bestLabel = port._getBestDisplayPinLabel();
        if (bestLabel) {
          pinLabels[`pin${pinNumber}`] = bestLabel;
        }
      }
    }
    return pinLabels;
  }
  _getSchematicBoxDimensions() {
    if (this.getSchematicSymbol()) return null;
    if (!this.config.shouldRenderAsSchematicBox) return null;
    const { _parsedProps: props } = this;
    const pinCount = this._getPinCount();
    const pinSpacing = props.schPinSpacing ?? 0.2;
    const pinLabelsFromPorts = this._getPinLabelsFromPorts();
    const allPinLabels = {
      ...pinLabelsFromPorts,
      ...props.pinLabels
    };
    const dimensions = getAllDimensionsForSchematicBox({
      schWidth: props.schWidth,
      schHeight: props.schHeight,
      schPinSpacing: pinSpacing,
      numericSchPinStyle: getNumericSchPinStyle(
        props.schPinStyle,
        allPinLabels
      ),
      pinCount,
      schPortArrangement: this._getSchematicPortArrangement(),
      pinLabels: allPinLabels
    });
    return dimensions;
  }
  getFootprinterString() {
    if (typeof this._parsedProps.footprint === "string") {
      return this._parsedProps.footprint;
    }
    return null;
  }
  doInitialCadModelRender() {
    if (this._isCadModelChild) return;
    if (this.props.doNotPlace) return;
    const { db } = this.root;
    const { boardThickness = 0 } = this.root?._getBoard() ?? {};
    const cadModelProp = this._parsedProps.cadModel;
    const cadModel = cadModelProp === void 0 ? this._asyncFootprintCadModel : cadModelProp;
    const footprint = this.getFootprinterString() ?? this._getImpliedFootprintString();
    if (!this.pcb_component_id) return;
    if (!cadModel && !footprint) return;
    if (cadModel === null) return;
    const bounds = this._getPcbCircuitJsonBounds();
    if (typeof cadModel === "string") {
      throw new Error("String cadModel not yet implemented");
    }
    const rotationOffset = rotation32.parse({
      x: 0,
      y: 0,
      z: typeof cadModel?.rotationOffset === "number" ? cadModel.rotationOffset : 0,
      ...typeof cadModel?.rotationOffset === "object" ? cadModel.rotationOffset ?? {} : {}
    });
    const positionOffset = point32.parse({
      x: 0,
      y: 0,
      z: 0,
      ...typeof cadModel?.positionOffset === "object" ? cadModel.positionOffset : {}
    });
    const zOffsetFromSurface = cadModel && typeof cadModel === "object" && "zOffsetFromSurface" in cadModel ? cadModel.zOffsetFromSurface !== void 0 ? distance5.parse(
      cadModel.zOffsetFromSurface
    ) : 0 : 0;
    const computedLayer = this.props.layer === "bottom" ? "bottom" : "top";
    const globalTransform = this._computePcbGlobalTransformBeforeLayout();
    const decomposedTransform = decomposeTSR5(globalTransform);
    const totalRotation = decomposedTransform.rotation.angle * 180 / Math.PI;
    const isBottomLayer = computedLayer === "bottom";
    const rotationWithOffset = totalRotation + (rotationOffset.z ?? 0);
    const cadRotationZ = normalizeDegrees(rotationWithOffset);
    const cad_model = db.cad_component.insert({
      // TODO z maybe depends on layer
      position: {
        x: bounds.center.x + positionOffset.x,
        y: bounds.center.y + positionOffset.y,
        z: (computedLayer === "bottom" ? -boardThickness / 2 : boardThickness / 2) + (computedLayer === "bottom" ? -zOffsetFromSurface : zOffsetFromSurface) + positionOffset.z
      },
      rotation: {
        x: rotationOffset.x,
        y: rotationOffset.y + (isBottomLayer ? 180 : 0),
        z: normalizeDegrees(isBottomLayer ? -cadRotationZ : cadRotationZ)
      },
      pcb_component_id: this.pcb_component_id,
      source_component_id: this.source_component_id,
      model_stl_url: "stlUrl" in (cadModel ?? {}) ? this._addCachebustToModelUrl(cadModel.stlUrl) : void 0,
      model_obj_url: "objUrl" in (cadModel ?? {}) ? this._addCachebustToModelUrl(cadModel.objUrl) : void 0,
      model_mtl_url: "mtlUrl" in (cadModel ?? {}) ? this._addCachebustToModelUrl(cadModel.mtlUrl) : void 0,
      model_gltf_url: "gltfUrl" in (cadModel ?? {}) ? this._addCachebustToModelUrl(cadModel.gltfUrl) : void 0,
      model_glb_url: "glbUrl" in (cadModel ?? {}) ? this._addCachebustToModelUrl(cadModel.glbUrl) : void 0,
      model_step_url: "stepUrl" in (cadModel ?? {}) ? this._addCachebustToModelUrl(cadModel.stepUrl) : void 0,
      model_wrl_url: "wrlUrl" in (cadModel ?? {}) ? this._addCachebustToModelUrl(cadModel.wrlUrl) : void 0,
      model_jscad: "jscad" in (cadModel ?? {}) ? cadModel.jscad : void 0,
      model_unit_to_mm_scale_factor: typeof cadModel?.modelUnitToMmScale === "number" ? cadModel.modelUnitToMmScale : void 0,
      footprinter_string: typeof footprint === "string" && !cadModel ? footprint : void 0
    });
    this.cad_component_id = cad_model.cad_component_id;
  }
  _addCachebustToModelUrl(url) {
    if (!url || !url.includes("modelcdn.tscircuit.com")) return url;
    const origin = this.root?.getClientOrigin() ?? "";
    return `${url}${url.includes("?") ? "&" : "?"}cachebust_origin=${encodeURIComponent(origin)}`;
  }
  _getPartsEngineCacheKey(source_component, footprinterString) {
    return JSON.stringify({
      ftype: source_component.ftype,
      name: source_component.name,
      manufacturer_part_number: source_component.manufacturer_part_number,
      footprinterString
    });
  }
  async _getSupplierPartNumbers(partsEngine, source_component, footprinterString) {
    if (this.props.doNotPlace) return {};
    const cacheEngine = this.root?.platform?.localCacheEngine;
    const cacheKey = this._getPartsEngineCacheKey(
      source_component,
      footprinterString
    );
    if (cacheEngine) {
      const cached = await cacheEngine.getItem(cacheKey);
      if (cached) {
        try {
          return JSON.parse(cached);
        } catch {
        }
      }
    }
    const result = await Promise.resolve(
      partsEngine.findPart({
        sourceComponent: source_component,
        footprinterString
      })
    );
    if (typeof result === "string") {
      if (result.includes("<!DOCTYPE") || result.includes("<html")) {
        throw new Error(
          `Failed to fetch supplier part numbers: Received HTML response instead of JSON. Response starts with: ${result.substring(0, 100)}`
        );
      }
      if (result === "Not found") {
        return {};
      }
      throw new Error(
        `Invalid supplier part numbers format: Expected object but got string: "${result}"`
      );
    }
    if (!result || Array.isArray(result) || typeof result !== "object") {
      const actualType = result === null ? "null" : Array.isArray(result) ? "array" : typeof result;
      throw new Error(
        `Invalid supplier part numbers format: Expected object but got ${actualType}`
      );
    }
    const supplierPartNumbers = result;
    if (cacheEngine) {
      try {
        await cacheEngine.setItem(cacheKey, JSON.stringify(supplierPartNumbers));
      } catch {
      }
    }
    return supplierPartNumbers;
  }
  doInitialPartsEngineRender() {
    if (this.props.doNotPlace) return;
    const partsEngine = this.getInheritedProperty("partsEngine");
    if (!partsEngine) return;
    const { db } = this.root;
    const source_component = db.source_component.get(this.source_component_id);
    if (!source_component) return;
    if (source_component.supplier_part_numbers) return;
    let footprinterString;
    if (this.props.footprint && typeof this.props.footprint === "string") {
      footprinterString = this.props.footprint;
    }
    const supplierPartNumbersMaybePromise = this._getSupplierPartNumbers(
      partsEngine,
      source_component,
      footprinterString
    );
    if (!(supplierPartNumbersMaybePromise instanceof Promise)) {
      db.source_component.update(this.source_component_id, {
        supplier_part_numbers: supplierPartNumbersMaybePromise
      });
      return;
    }
    this._queueAsyncEffect("get-supplier-part-numbers", async () => {
      await supplierPartNumbersMaybePromise.then((supplierPartNumbers) => {
        this._asyncSupplierPartNumbers = supplierPartNumbers;
        this._markDirty("PartsEngineRender");
      }).catch((error) => {
        this._asyncSupplierPartNumbers = {};
        const errorObj = unknown_error_finding_part.parse({
          type: "unknown_error_finding_part",
          message: `Failed to fetch supplier part numbers for ${this.getString()}: ${error.message}`,
          source_component_id: this.source_component_id,
          subcircuit_id: this.getSubcircuit()?.subcircuit_id
        });
        db.unknown_error_finding_part.insert(errorObj);
        this._markDirty("PartsEngineRender");
      });
    });
  }
  updatePartsEngineRender() {
    if (this.props.doNotPlace) return;
    const { db } = this.root;
    const source_component = db.source_component.get(this.source_component_id);
    if (!source_component) return;
    if (source_component.supplier_part_numbers) return;
    if (this._asyncSupplierPartNumbers) {
      db.source_component.update(this.source_component_id, {
        supplier_part_numbers: this._asyncSupplierPartNumbers
      });
      return;
    }
  }
  doInitialAssignFallbackProps() {
    const { _parsedProps: props } = this;
    if (props.connections && !this.name) {
      this.fallbackUnassignedName = this.getSubcircuit().getNextAvailableName(this);
    }
  }
  doInitialCreateTracesFromProps() {
    this._createTracesFromConnectionsProp();
  }
  _createTracesFromConnectionsProp() {
    const { _parsedProps: props } = this;
    if (props.connections) {
      for (const [pinName, target] of Object.entries(props.connections)) {
        const targets = Array.isArray(target) ? target : [target];
        for (const targetPath of targets) {
          this.add(
            new Trace3({
              from: `.${this.name} > .${pinName}`,
              to: String(targetPath)
            })
          );
        }
      }
    }
  }
  doInitialSourceDesignRuleChecks() {
    NormalComponent_doInitialSourceDesignRuleChecks(this);
  }
  /**
   * Get the minimum flex container size for this component on PCB
   */
  _getMinimumFlexContainerSize() {
    return NormalComponent__getMinimumFlexContainerSize(this);
  }
  /**
   * Reposition this component on the PCB to the specified coordinates
   */
  _repositionOnPcb(position) {
    return NormalComponent__repositionOnPcb(this, position);
  }
  doInitialSilkscreenOverlapAdjustment() {
    return NormalComponent_doInitialSilkscreenOverlapAdjustment(this);
  }
  /**
   * Returns true if this component has explicit PCB positioning (pcbX or pcbY)
   * and should not be moved by automatic packing/layout algorithms
   */
  isRelativelyPositioned() {
    return this._parsedProps.pcbX !== void 0 || this._parsedProps.pcbY !== void 0;
  }
};

// lib/utils/boards/get-board-center-from-anchor.ts
var getBoardCenterFromAnchor = ({
  boardAnchorPosition,
  boardAnchorAlignment,
  width,
  height
}) => {
  const { x: ax, y: ay } = boardAnchorPosition;
  let cx = ax;
  let cy = ay;
  switch (boardAnchorAlignment) {
    case "top_left":
      cx = ax + width / 2;
      cy = ay - height / 2;
      break;
    case "top_right":
      cx = ax - width / 2;
      cy = ay - height / 2;
      break;
    case "bottom_left":
      cx = ax + width / 2;
      cy = ay + height / 2;
      break;
    case "bottom_right":
      cx = ax - width / 2;
      cy = ay + height / 2;
      break;
    case "top":
      cx = ax;
      cy = ay - height / 2;
      break;
    case "bottom":
      cx = ax;
      cy = ay + height / 2;
      break;
    case "left":
      cx = ax + width / 2;
      cy = ay;
      break;
    case "right":
      cx = ax - width / 2;
      cy = ay;
      break;
    case "center":
    default:
      break;
  }
  return { x: cx, y: cy };
};

// lib/components/normal-components/Board.ts
import { boardProps } from "@tscircuit/props";
import { identity as identity4 } from "transformation-matrix";

// lib/components/primitive-components/Group/Group.ts
import {
  groupProps
} from "@tscircuit/props";

// lib/utils/autorouting/CapacityMeshAutorouter.ts
import * as CapacityAutorouter from "@tscircuit/capacity-autorouter";
var CapacityMeshAutorouter = class {
  input;
  isRouting = false;
  solver;
  eventHandlers = {
    complete: [],
    error: [],
    progress: []
  };
  cycleCount = 0;
  stepDelay;
  timeoutId;
  constructor(input, options = {}) {
    this.input = input;
    const {
      capacityDepth,
      targetMinCapacity,
      stepDelay = 0,
      useAssignableViaSolver = false
    } = options;
    const {
      AutoroutingPipelineSolver,
      AssignableViaAutoroutingPipelineSolver
    } = CapacityAutorouter;
    const SolverClass = useAssignableViaSolver ? AssignableViaAutoroutingPipelineSolver : AutoroutingPipelineSolver;
    this.solver = new SolverClass(input, {
      capacityDepth,
      targetMinCapacity,
      cacheProvider: null
    });
    this.stepDelay = stepDelay;
  }
  /**
   * Start the autorouting process asynchronously
   * This will emit progress events during routing and a complete event when done
   */
  start() {
    if (this.isRouting) return;
    this.isRouting = true;
    this.cycleCount = 0;
    this.runCycleAndQueueNextCycle();
  }
  /**
   * Execute the next routing step and schedule the following one if needed
   */
  runCycleAndQueueNextCycle() {
    if (!this.isRouting) return;
    try {
      if (this.solver.solved || this.solver.failed) {
        if (this.solver.failed) {
          this.emitEvent({
            type: "error",
            error: new AutorouterError(this.solver.error || "Routing failed")
          });
        } else {
          this.emitEvent({
            type: "complete",
            traces: this.solver.getOutputSimpleRouteJson().traces || []
          });
        }
        this.isRouting = false;
        return;
      }
      const startTime = Date.now();
      const startIterations = this.solver.iterations;
      while (Date.now() - startTime < 250 && !this.solver.failed && !this.solver.solved) {
        this.solver.step();
      }
      const iterationsPerSecond = (this.solver.iterations - startIterations) / (Date.now() - startTime) * 1e3;
      this.cycleCount++;
      const debugGraphics = this.solver?.preview() || void 0;
      const progress = this.solver.progress;
      this.emitEvent({
        type: "progress",
        steps: this.cycleCount,
        iterationsPerSecond,
        progress,
        phase: this.solver.getCurrentPhase(),
        debugGraphics
      });
      if (this.stepDelay > 0) {
        this.timeoutId = setTimeout(
          () => this.runCycleAndQueueNextCycle(),
          this.stepDelay
        );
      } else {
        this.timeoutId = setTimeout(
          () => this.runCycleAndQueueNextCycle(),
          0
        );
      }
    } catch (error) {
      this.emitEvent({
        type: "error",
        error: error instanceof Error ? new AutorouterError(error.message) : new AutorouterError(String(error))
      });
      this.isRouting = false;
    }
  }
  /**
   * Stop the routing process if it's in progress
   */
  stop() {
    if (!this.isRouting) return;
    this.isRouting = false;
    if (this.timeoutId !== void 0) {
      clearTimeout(this.timeoutId);
      this.timeoutId = void 0;
    }
  }
  on(event, callback) {
    if (event === "complete") {
      this.eventHandlers.complete.push(
        callback
      );
    } else if (event === "error") {
      this.eventHandlers.error.push(
        callback
      );
    } else if (event === "progress") {
      this.eventHandlers.progress.push(
        callback
      );
    }
  }
  /**
   * Emit an event to all registered handlers
   */
  emitEvent(event) {
    if (event.type === "complete") {
      for (const handler of this.eventHandlers.complete) {
        handler(event);
      }
    } else if (event.type === "error") {
      for (const handler of this.eventHandlers.error) {
        handler(event);
      }
    } else if (event.type === "progress") {
      for (const handler of this.eventHandlers.progress) {
        handler(event);
      }
    }
  }
  /**
   * Solve the routing problem synchronously
   * @returns Array of routed traces
   */
  solveSync() {
    this.solver.solve();
    if (this.solver.failed) {
      throw new AutorouterError(this.solver.error || "Routing failed");
    }
    return this.solver.getOutputSimpleRouteJson().traces || [];
  }
};

// lib/components/primitive-components/Group/Group.ts
import {
  distance as distance6
} from "circuit-json";
import Debug13 from "debug";
import "zod";

// lib/components/primitive-components/TraceHint.ts
import { traceHintProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint8 } from "transformation-matrix";
var TraceHint = class extends PrimitiveComponent2 {
  matchedPort = null;
  get config() {
    return {
      componentName: "TraceHint",
      zodProps: traceHintProps
    };
  }
  doInitialPortMatching() {
    const { db } = this.root;
    const { _parsedProps: props, parent } = this;
    if (!parent) return;
    if (parent.componentName === "Trace") {
      this.renderError(
        `Port inference inside trace is not yet supported (${this})`
      );
      return;
    }
    if (!parent) throw new Error("TraceHint has no parent");
    if (!props.for) {
      this.renderError(`TraceHint has no for property (${this})`);
      return;
    }
    const port = parent.selectOne(props.for, { type: "port" });
    if (!port) {
      this.renderError(
        `${this} could not find port for selector "${props.for}"`
      );
    }
    this.matchedPort = port;
    port.registerMatch(this);
  }
  getPcbRouteHints() {
    const { _parsedProps: props } = this;
    const offsets = props.offset ? [props.offset] : props.offsets;
    if (!offsets) return [];
    const globalTransform = this._computePcbGlobalTransformBeforeLayout();
    return offsets.map(
      (offset) => ({
        ...applyToPoint8(globalTransform, offset),
        via: offset.via,
        to_layer: offset.to_layer,
        trace_width: offset.trace_width
      })
    );
  }
  doInitialPcbTraceHintRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    db.pcb_trace_hint.insert({
      pcb_component_id: this.matchedPort?.pcb_component_id,
      pcb_port_id: this.matchedPort?.pcb_port_id,
      route: this.getPcbRouteHints()
    });
  }
};

// lib/utils/edit-events/apply-pcb-edit-events-to-manual-edits-file.ts
import "zod";
import { su } from "@tscircuit/circuit-json-util";
var applyPcbEditEventsToManualEditsFile = ({
  circuitJson,
  editEvents,
  manualEditsFile
}) => {
  const updatedManualEditsFile = {
    ...manualEditsFile,
    pcb_placements: [...manualEditsFile.pcb_placements ?? []]
  };
  for (const editEvent of editEvents) {
    if (editEvent.edit_event_type === "edit_pcb_component_location") {
      const { pcb_component_id, new_center } = editEvent;
      const pcb_component = su(circuitJson).pcb_component.get(pcb_component_id);
      if (!pcb_component) continue;
      const source_component = su(circuitJson).source_component.get(
        pcb_component.source_component_id
      );
      if (!source_component) continue;
      const existingPlacementIndex = updatedManualEditsFile.pcb_placements?.findIndex(
        (p) => p.selector === source_component.name
      );
      const newPlacement = {
        selector: source_component.name,
        center: new_center,
        relative_to: "group_center"
      };
      if (existingPlacementIndex >= 0) {
        updatedManualEditsFile.pcb_placements[existingPlacementIndex] = newPlacement;
      } else {
        updatedManualEditsFile.pcb_placements.push(newPlacement);
      }
    }
  }
  return updatedManualEditsFile;
};

// lib/utils/edit-events/apply-schematic-edit-events-to-manual-edits-file.ts
import { su as su2 } from "@tscircuit/circuit-json-util";
import "zod";
var applySchematicEditEventsToManualEditsFile = ({
  circuitJson,
  editEvents,
  manualEditsFile
}) => {
  const updatedManualEditsFile = {
    ...manualEditsFile,
    schematic_placements: [...manualEditsFile.schematic_placements ?? []]
  };
  for (const editEvent of editEvents) {
    if (editEvent.edit_event_type === "edit_schematic_component_location") {
      const { schematic_component_id, new_center } = editEvent;
      const schematic_component2 = su2(circuitJson).schematic_component.get(
        schematic_component_id
      );
      if (!schematic_component2) continue;
      if (!schematic_component2.source_component_id) continue;
      const source_component = su2(circuitJson).source_component.get(
        schematic_component2.source_component_id
      );
      if (!source_component) continue;
      const existingPlacementIndex = updatedManualEditsFile.schematic_placements?.findIndex(
        (p) => p.selector === source_component.name
      );
      const newPlacement = {
        selector: source_component.name,
        center: new_center,
        relative_to: "group_center"
      };
      if (existingPlacementIndex >= 0) {
        updatedManualEditsFile.schematic_placements[existingPlacementIndex] = newPlacement;
      } else {
        updatedManualEditsFile.schematic_placements.push(newPlacement);
      }
    }
  }
  return updatedManualEditsFile;
};

// lib/utils/edit-events/apply-edit-events-to-manual-edits-file.ts
var applyEditEventsToManualEditsFile = ({
  circuitJson,
  editEvents,
  manualEditsFile
}) => {
  const schematicEditEvents = editEvents.filter(
    (event) => event.edit_event_type === "edit_schematic_component_location"
  );
  const pcbEditEvents = editEvents.filter(
    (event) => event.edit_event_type === "edit_pcb_component_location"
  );
  let updatedManualEditsFile = manualEditsFile;
  if (schematicEditEvents.length > 0) {
    updatedManualEditsFile = applySchematicEditEventsToManualEditsFile({
      circuitJson,
      editEvents: schematicEditEvents,
      manualEditsFile: updatedManualEditsFile
    });
  }
  if (pcbEditEvents.length > 0) {
    updatedManualEditsFile = applyPcbEditEventsToManualEditsFile({
      circuitJson,
      editEvents: pcbEditEvents,
      manualEditsFile: updatedManualEditsFile
    });
  }
  return updatedManualEditsFile;
};

// lib/utils/edit-events/apply-edit-events-to-circuit-json.ts
import { transformPCBElement } from "@tscircuit/circuit-json-util";
import { translate as translate4 } from "transformation-matrix";

// lib/utils/edit-events/apply-trace-hint-edit-event.ts
import { su as su3 } from "@tscircuit/circuit-json-util";
var applyTraceHintEditEvent = (circuitJson, edit_event) => {
  const existingTraceHint = su3(circuitJson).pcb_trace_hint.get(
    edit_event.pcb_trace_hint_id
  );
  if (existingTraceHint) {
    circuitJson = circuitJson.map(
      (e) => e.pcb_trace_hint_id === edit_event.pcb_trace_hint_id ? {
        ...e,
        route: edit_event.route
      } : e
    );
  } else {
    const pcbPort = su3(circuitJson).pcb_port.get(edit_event.pcb_port_id);
    circuitJson = circuitJson.filter(
      (e) => !(e.type === "pcb_trace_hint" && e.pcb_port_id === edit_event.pcb_port_id)
    ).concat([
      {
        type: "pcb_trace_hint",
        pcb_trace_hint_id: edit_event.pcb_trace_hint_id,
        route: edit_event.route,
        pcb_port_id: edit_event.pcb_port_id,
        pcb_component_id: pcbPort?.pcb_component_id
      }
    ]);
  }
  return circuitJson;
};

// lib/utils/edit-events/apply-edit-events-to-circuit-json.ts
var applyEditEvents = ({
  circuitJson,
  editEvents
}) => {
  circuitJson = JSON.parse(JSON.stringify(circuitJson));
  for (const editEvent of editEvents) {
    if (editEvent.edit_event_type === "edit_pcb_component_location") {
      const component = circuitJson.find(
        (e) => e.type === "pcb_component" && e.pcb_component_id === editEvent.pcb_component_id
      );
      const needsMovement = !component || component.center.x !== editEvent.new_center.x || component.center.y !== editEvent.new_center.y;
      if (needsMovement && editEvent.original_center) {
        const mat = translate4(
          editEvent.new_center.x - editEvent.original_center.x,
          editEvent.new_center.y - editEvent.original_center.y
        );
        circuitJson = circuitJson.map(
          (e) => e.pcb_component_id !== editEvent.pcb_component_id ? e : transformPCBElement(e, mat)
        );
      }
    } else if (editEvent.edit_event_type === "edit_schematic_component_location") {
      circuitJson = circuitJson.map((e) => {
        if (e.type === "schematic_component" && e.schematic_component_id === editEvent.schematic_component_id) {
          return {
            ...e,
            center: editEvent.new_center
          };
        }
        return e;
      });
    } else if (editEvent.edit_event_type === "edit_pcb_trace_hint") {
      circuitJson = applyTraceHintEditEvent(circuitJson, editEvent);
    }
  }
  return circuitJson;
};

// lib/utils/autorouting/getSimpleRouteJsonFromCircuitJson.ts
import { su as su4 } from "@tscircuit/circuit-json-util";
import {
  getFullConnectivityMapFromCircuitJson as getFullConnectivityMapFromCircuitJson3
} from "circuit-json-to-connectivity-map";

// lib/utils/autorouting/getAncestorSubcircuitIds.ts
var getDescendantSubcircuitIds = (db, root_subcircuit_id) => {
  const groups = db.source_group.list();
  const result = [];
  const findDescendants = (parentId) => {
    const children = groups.filter(
      (group) => group.parent_subcircuit_id === parentId
    );
    for (const child of children) {
      if (child.subcircuit_id) {
        result.push(child.subcircuit_id);
        findDescendants(child.subcircuit_id);
      }
    }
  };
  findDescendants(root_subcircuit_id);
  return result;
};

// lib/utils/autorouting/getSimpleRouteJsonFromCircuitJson.ts
var getSimpleRouteJsonFromCircuitJson = ({
  db,
  circuitJson,
  subcircuit_id,
  minTraceWidth = 0.1
}) => {
  if (!db && circuitJson) {
    db = su4(circuitJson);
  }
  if (!db) {
    throw new Error("db or circuitJson is required");
  }
  const traceHints = db.pcb_trace_hint.list();
  const relevantSubcircuitIds = subcircuit_id ? /* @__PURE__ */ new Set([subcircuit_id]) : null;
  if (subcircuit_id) {
    const descendantSubcircuitIds = getDescendantSubcircuitIds(
      db,
      subcircuit_id
    );
    for (const id of descendantSubcircuitIds) {
      relevantSubcircuitIds.add(id);
    }
  }
  const subcircuitElements = (circuitJson ?? db.toArray()).filter(
    (e) => !subcircuit_id || "subcircuit_id" in e && relevantSubcircuitIds.has(e.subcircuit_id)
  );
  const board = db.pcb_board.list()[0];
  db = su4(subcircuitElements);
  const connMap = getFullConnectivityMapFromCircuitJson3(subcircuitElements);
  const obstacles = getObstaclesFromCircuitJson(
    [
      ...db.pcb_component.list(),
      ...db.pcb_smtpad.list(),
      ...db.pcb_plated_hole.list(),
      ...db.pcb_hole.list(),
      ...db.pcb_via.list(),
      ...db.pcb_cutout.list()
      // getObstaclesFromSoup is old and doesn't support diagonal traces
      // ...db.pcb_trace.list(),
    ].filter(
      (e) => !subcircuit_id || relevantSubcircuitIds?.has(e.subcircuit_id)
    ),
    connMap
  );
  for (const obstacle of obstacles) {
    const additionalIds = obstacle.connectedTo.flatMap(
      (id) => connMap.getIdsConnectedToNet(id)
    );
    obstacle.connectedTo.push(...additionalIds);
  }
  const allPoints = obstacles.flatMap((o) => [
    {
      x: o.center.x - o.width / 2,
      y: o.center.y - o.height / 2
    },
    {
      x: o.center.x + o.width / 2,
      y: o.center.y + o.height / 2
    }
  ]).concat(board?.outline ?? []);
  let bounds;
  if (board && !board.outline) {
    bounds = {
      minX: board.center.x - board.width / 2,
      maxX: board.center.x + board.width / 2,
      minY: board.center.y - board.height / 2,
      maxY: board.center.y + board.height / 2
    };
  } else {
    bounds = {
      minX: Math.min(...allPoints.map((p) => p.x)) - 1,
      maxX: Math.max(...allPoints.map((p) => p.x)) + 1,
      minY: Math.min(...allPoints.map((p) => p.y)) - 1,
      maxY: Math.max(...allPoints.map((p) => p.y)) + 1
    };
  }
  if (subcircuit_id) {
    const group = db.pcb_group.getWhere({ subcircuit_id });
    if (group?.width && group.height) {
      const groupBounds = {
        minX: group.center.x - group.width / 2,
        maxX: group.center.x + group.width / 2,
        minY: group.center.y - group.height / 2,
        maxY: group.center.y + group.height / 2
      };
      bounds = {
        minX: Math.min(bounds.minX, groupBounds.minX),
        maxX: Math.max(bounds.maxX, groupBounds.maxX),
        minY: Math.min(bounds.minY, groupBounds.minY),
        maxY: Math.max(bounds.maxY, groupBounds.maxY)
      };
    }
  }
  const routedTraceIds = new Set(
    db.pcb_trace.list().map((t) => t.source_trace_id).filter((id) => Boolean(id))
  );
  const directTraceConnections = db.source_trace.list().filter((trace) => !routedTraceIds.has(trace.source_trace_id)).map((trace) => {
    const connectedPorts = trace.connected_source_port_ids.map((id) => {
      const source_port = db.source_port.get(id);
      const pcb_port = db.pcb_port.getWhere({ source_port_id: id });
      return {
        ...source_port,
        ...pcb_port
      };
    });
    if (connectedPorts.length < 2) return null;
    const [portA, portB] = connectedPorts;
    const layerA = portA.layers?.[0] ?? "top";
    const layerB = portB.layers?.[0] ?? "top";
    const matchingHints = traceHints.filter(
      (hint) => hint.pcb_port_id === portA.pcb_port_id || hint.pcb_port_id === portB.pcb_port_id
    );
    const hintPoints = [];
    for (const hint of matchingHints) {
      const port = db.pcb_port.get(hint.pcb_port_id);
      const layer = port?.layers?.[0] ?? "top";
      for (const pt of hint.route) {
        hintPoints.push({
          x: pt.x,
          y: pt.y,
          layer
        });
      }
    }
    return {
      name: trace.source_trace_id ?? connMap.getNetConnectedToId(trace.source_trace_id) ?? "",
      source_trace_id: trace.source_trace_id,
      width: trace.min_trace_thickness,
      pointsToConnect: [
        {
          x: portA.x,
          y: portA.y,
          layer: layerA,
          pointId: portA.pcb_port_id,
          pcb_port_id: portA.pcb_port_id
        },
        ...hintPoints,
        {
          x: portB.x,
          y: portB.y,
          layer: layerB,
          pointId: portB.pcb_port_id,
          pcb_port_id: portB.pcb_port_id
        }
      ]
    };
  }).filter((c) => c !== null);
  const directTraceConnectionsById = new Map(
    directTraceConnections.map((c) => [c.source_trace_id, c])
  );
  const source_nets = db.source_net.list().filter(
    (e) => !subcircuit_id || relevantSubcircuitIds?.has(e.subcircuit_id)
  );
  const connectionsFromNets = [];
  for (const net of source_nets) {
    const connectedSourceTraces = db.source_trace.list().filter((st) => st.connected_source_net_ids?.includes(net.source_net_id));
    connectionsFromNets.push({
      name: net.source_net_id ?? connMap.getNetConnectedToId(net.source_net_id),
      pointsToConnect: connectedSourceTraces.flatMap((st) => {
        const pcb_ports = db.pcb_port.list().filter(
          (p) => st.connected_source_port_ids.includes(p.source_port_id)
        );
        return pcb_ports.map((p) => ({
          x: p.x,
          y: p.y,
          layer: p.layers?.[0] ?? "top",
          pointId: p.pcb_port_id,
          pcb_port_id: p.pcb_port_id
        }));
      })
    });
  }
  const breakoutPoints = db.pcb_breakout_point.list().filter(
    (bp) => !subcircuit_id || relevantSubcircuitIds?.has(bp.subcircuit_id)
  );
  const connectionsFromBreakoutPoints = [];
  const breakoutTraceConnectionsById = /* @__PURE__ */ new Map();
  for (const bp of breakoutPoints) {
    const pt = { x: bp.x, y: bp.y, layer: "top" };
    if (bp.source_trace_id) {
      const conn = directTraceConnectionsById.get(bp.source_trace_id) ?? breakoutTraceConnectionsById.get(bp.source_trace_id);
      if (conn) {
        conn.pointsToConnect.push(pt);
      } else {
        const newConn = {
          name: bp.source_trace_id,
          source_trace_id: bp.source_trace_id,
          pointsToConnect: [pt]
        };
        connectionsFromBreakoutPoints.push(newConn);
        breakoutTraceConnectionsById.set(bp.source_trace_id, newConn);
      }
    } else if (bp.source_net_id) {
      const conn = connectionsFromNets.find((c) => c.name === bp.source_net_id);
      if (conn) {
        conn.pointsToConnect.push(pt);
      } else {
        connectionsFromBreakoutPoints.push({
          name: bp.source_net_id,
          pointsToConnect: [pt]
        });
      }
    } else if (bp.source_port_id) {
      const pcb_port = db.pcb_port.getWhere({
        source_port_id: bp.source_port_id
      });
      if (pcb_port) {
        connectionsFromBreakoutPoints.push({
          name: bp.source_port_id,
          // direct connection from port to breakout point
          source_trace_id: void 0,
          pointsToConnect: [
            {
              x: pcb_port.x,
              y: pcb_port.y,
              layer: pcb_port.layers?.[0] ?? "top",
              pointId: pcb_port.pcb_port_id,
              // @ts-ignore
              pcb_port_id: pcb_port.pcb_port_id
            },
            pt
          ]
        });
      }
    }
  }
  const allConns = [
    ...directTraceConnections,
    ...connectionsFromNets,
    ...connectionsFromBreakoutPoints
  ];
  const pointIdToConn = /* @__PURE__ */ new Map();
  for (const conn of allConns) {
    for (const pt of conn.pointsToConnect) {
      if (pt.pointId) pointIdToConn.set(pt.pointId, conn);
    }
  }
  const existingTraces = db.pcb_trace.list().filter(
    (t) => !subcircuit_id || relevantSubcircuitIds?.has(t.subcircuit_id)
  );
  for (const tr of existingTraces) {
    const tracePortIds = /* @__PURE__ */ new Set();
    for (const seg of tr.route) {
      if (seg.start_pcb_port_id) tracePortIds.add(seg.start_pcb_port_id);
      if (seg.end_pcb_port_id) tracePortIds.add(seg.end_pcb_port_id);
    }
    if (tracePortIds.size < 2) continue;
    const firstId = tracePortIds.values().next().value;
    if (!firstId) continue;
    const conn = pointIdToConn.get(firstId);
    if (!conn) continue;
    if (![...tracePortIds].every((pid) => pointIdToConn.get(pid) === conn))
      continue;
    conn.externallyConnectedPointIds ??= [];
    conn.externallyConnectedPointIds.push([...tracePortIds]);
  }
  return {
    simpleRouteJson: {
      bounds,
      obstacles,
      connections: allConns,
      // TODO add traces so that we don't run into things routed by another
      // subcircuit
      layerCount: board?.num_layers ?? 2,
      minTraceWidth,
      outline: board?.outline?.map((point) => ({ ...point }))
    },
    connMap
  };
};

// lib/utils/render-events/getPhaseTimingsFromRenderEvents.ts
var getPhaseTimingsFromRenderEvents = (renderEvents) => {
  const phaseTimings = {};
  if (!renderEvents) return phaseTimings;
  for (const renderPhase of orderedRenderPhases) {
    phaseTimings[renderPhase] = 0;
  }
  const startEvents = /* @__PURE__ */ new Map();
  for (const event of renderEvents) {
    const [, , phase, eventType] = event.type.split(":");
    if (eventType === "start") {
      startEvents.set(`${phase}:${event.renderId}`, event);
      continue;
    }
    if (eventType === "end") {
      const startEvent = startEvents.get(`${phase}:${event.renderId}`);
      if (startEvent) {
        const duration = event.createdAt - startEvent.createdAt;
        phaseTimings[phase] = (phaseTimings[phase] || 0) + duration;
      }
    }
  }
  return phaseTimings;
};

// lib/utils/schematic/normalizePinLabels.ts
var normalizePinLabels = (inputPinLabels) => {
  const unqInputPinLabels = inputPinLabels.map((labels) => [...new Set(labels)]);
  const result = unqInputPinLabels.map(() => []);
  const desiredNumbers = unqInputPinLabels.map(() => null);
  for (let i = 0; i < unqInputPinLabels.length; i++) {
    for (const label of unqInputPinLabels[i]) {
      if (/^\d+$/.test(label)) {
        desiredNumbers[i] = Number.parseInt(label);
        break;
      }
    }
  }
  let highestPinNumber = 0;
  const alreadyAcceptedDesiredNumbers = /* @__PURE__ */ new Set();
  for (let i = 0; i < desiredNumbers.length; i++) {
    const desiredNumber = desiredNumbers[i];
    if (desiredNumber === null || desiredNumber < 1) {
      continue;
    }
    if (!alreadyAcceptedDesiredNumbers.has(desiredNumber)) {
      alreadyAcceptedDesiredNumbers.add(desiredNumber);
      result[i].push(`pin${desiredNumber}`);
      highestPinNumber = Math.max(highestPinNumber, desiredNumber);
      continue;
    }
    let existingAltsForPin = 0;
    for (const label of result[i]) {
      if (label.startsWith(`pin${desiredNumber}_alt`)) {
        existingAltsForPin++;
      }
    }
    result[i].push(`pin${desiredNumber}_alt${existingAltsForPin + 1}`);
  }
  for (let i = 0; i < result.length; i++) {
    const firstLabel = result[i][0];
    if (firstLabel?.includes("_alt")) {
      highestPinNumber++;
      result[i].unshift(`pin${highestPinNumber}`);
    }
  }
  for (let i = 0; i < result.length; i++) {
    if (result[i].length === 0) {
      highestPinNumber++;
      result[i].push(`pin${highestPinNumber}`);
    }
  }
  const totalLabelCounts = {};
  for (const inputLabels of unqInputPinLabels) {
    for (const label of inputLabels) {
      if (/^\d+$/.test(label)) {
        continue;
      }
      totalLabelCounts[label] = (totalLabelCounts[label] ?? 0) + 1;
    }
  }
  const incrementalLabelCounts = {};
  for (let i = 0; i < unqInputPinLabels.length; i++) {
    const inputLabels = unqInputPinLabels[i];
    for (const label of inputLabels) {
      if (/^\d+$/.test(label)) {
        continue;
      }
      if (totalLabelCounts[label] === 1) {
        result[i].push(label);
      } else {
        incrementalLabelCounts[label] = (incrementalLabelCounts[label] ?? 0) + 1;
        result[i].push(`${label}${incrementalLabelCounts[label]}`);
      }
    }
  }
  return result;
};

// lib/components/primitive-components/Group/Group.ts
import { getBoundsFromPoints as getBoundsFromPoints3 } from "@tscircuit/math-utils";

// lib/components/primitive-components/Group/Group_doInitialSchematicLayoutMatchAdapt.ts
import { convertCircuitJsonToBpc } from "circuit-json-to-bpc";
import { getGraphicsForBpcGraph, layoutSchematicGraphVariants } from "bpc-graph";
import Debug6 from "debug";
import { buildSubtree } from "@tscircuit/circuit-json-util";

// lib/components/primitive-components/Group/utils/updateSchematicPrimitivesForLayoutShift.ts
function updateSchematicPrimitivesForLayoutShift({
  db,
  schematicComponentId,
  deltaX,
  deltaY
}) {
  const rects = db.schematic_rect.list({
    schematic_component_id: schematicComponentId
  });
  for (const rect of rects) {
    rect.center.x += deltaX;
    rect.center.y += deltaY;
  }
  const lines = db.schematic_line.list({
    schematic_component_id: schematicComponentId
  });
  for (const line of lines) {
    line.x1 += deltaX;
    line.y1 += deltaY;
    line.x2 += deltaX;
    line.y2 += deltaY;
  }
  const circles = db.schematic_circle.list({
    schematic_component_id: schematicComponentId
  });
  for (const circle of circles) {
    circle.center.x += deltaX;
    circle.center.y += deltaY;
  }
  const arcs = db.schematic_arc.list({
    schematic_component_id: schematicComponentId
  });
  for (const arc of arcs) {
    arc.center.x += deltaX;
    arc.center.y += deltaY;
  }
}

// lib/components/primitive-components/Group/Group_doInitialSchematicLayoutMatchAdapt.ts
var debug4 = Debug6("Group_doInitialSchematicLayoutMatchAdapt");
function Group_doInitialSchematicLayoutMatchAdapt(group) {
  const { db } = group.root;
  const subtreeCircuitJson = buildSubtree(db.toArray(), {
    source_group_id: group.source_group_id
  });
  const bpcGraphBeforeGeneratedNetLabels = convertCircuitJsonToBpc(subtreeCircuitJson);
  if (debug4.enabled && global?.debugGraphics) {
    global.debugGraphics?.push(
      getGraphicsForBpcGraph(bpcGraphBeforeGeneratedNetLabels, {
        title: `floatingBpcGraph-${group.name}`
      })
    );
  }
  const floatingGraph = convertCircuitJsonToBpc(
    subtreeCircuitJson
    // .concat(implicitNetLabels),
  );
  const floatingGraphNoNotConnected = {
    boxes: floatingGraph.boxes,
    pins: floatingGraph.pins.map((p) => ({
      ...p,
      color: p.color.replace("not_connected", "normal")
    }))
  };
  const { result: laidOutBpcGraph } = layoutSchematicGraphVariants(
    [
      { variantName: "default", floatingGraph },
      {
        variantName: "noNotConnected",
        floatingGraph: floatingGraphNoNotConnected
      }
    ],
    {
      singletonKeys: ["vcc/2", "gnd/2"],
      centerPinColors: ["netlabel_center", "component_center"],
      floatingBoxIdsWithMutablePinOffsets: new Set(
        floatingGraph.boxes.filter((box) => {
          const boxPins = floatingGraph.pins.filter(
            (p) => p.boxId === box.boxId
          );
          const nonCenterBoxPins = boxPins.filter(
            (bp) => !bp.color.includes("center")
          );
          if (nonCenterBoxPins.length <= 2) {
            return true;
          }
          return false;
        }).map((b) => b.boxId)
      ),
      corpus: {}
    }
  );
  if (debug4.enabled && global?.debugGraphics) {
    global.debugGraphics?.push(
      getGraphicsForBpcGraph(laidOutBpcGraph, {
        title: `laidOutBpcGraph-${group.name}`
      })
    );
  }
  const groupOffset = group._getGlobalSchematicPositionBeforeLayout();
  for (const box of laidOutBpcGraph.boxes) {
    if (!box.center) continue;
    const schematic_component2 = db.schematic_component.get(box.boxId);
    if (schematic_component2) {
      const newCenter = {
        x: box.center.x + groupOffset.x,
        y: box.center.y + groupOffset.y
      };
      const ports = db.schematic_port.list({
        schematic_component_id: schematic_component2.schematic_component_id
      });
      const texts = db.schematic_text.list({
        schematic_component_id: schematic_component2.schematic_component_id
      });
      const positionDelta = {
        x: newCenter.x - schematic_component2.center.x,
        y: newCenter.y - schematic_component2.center.y
      };
      for (const port of ports) {
        port.center.x += positionDelta.x;
        port.center.y += positionDelta.y;
      }
      for (const text of texts) {
        text.position.x += positionDelta.x;
        text.position.y += positionDelta.y;
      }
      updateSchematicPrimitivesForLayoutShift({
        db,
        schematicComponentId: schematic_component2.schematic_component_id,
        deltaX: positionDelta.x,
        deltaY: positionDelta.y
      });
      schematic_component2.center = newCenter;
      continue;
    }
    const schematic_net_label = db.schematic_net_label.get(box.boxId);
    if (schematic_net_label) {
      const pin = laidOutBpcGraph.pins.find(
        (p) => p.boxId === box.boxId && p.color === "netlabel_center"
      );
      if (!pin) {
        throw new Error(`No pin found for net label: ${box.boxId}`);
      }
      const finalCenter = {
        x: box.center.x + groupOffset.x,
        y: box.center.y + groupOffset.y
      };
      schematic_net_label.center = finalCenter;
      schematic_net_label.anchor_position = {
        x: finalCenter.x + pin.offset.x,
        y: finalCenter.y + pin.offset.y
      };
      continue;
    }
    console.error(
      `No schematic element found for box: ${box.boxId}. This is a bug in the matchAdapt binding with @tscircuit/core`
    );
  }
}

// lib/components/primitive-components/Group/Group_doInitialSchematicLayoutMatchPack.ts
import {
  getCircuitJsonTree
} from "@tscircuit/circuit-json-util";
import { LayoutPipelineSolver } from "@tscircuit/matchpack";
import Debug7 from "debug";
var debug5 = Debug7("Group_doInitialSchematicLayoutMatchpack");
function facingDirectionToSide(facingDirection) {
  switch (facingDirection) {
    case "up":
      return "y+";
    case "down":
      return "y-";
    case "left":
      return "x-";
    case "right":
      return "x+";
    default:
      return "y+";
  }
}
function rotateDirection(direction, degrees) {
  const directions = [
    "right",
    "up",
    "left",
    "down"
  ];
  const currentIndex = directions.indexOf(direction);
  if (currentIndex === -1) return direction;
  const steps = Math.round(degrees / 90);
  const newIndex = (currentIndex + steps) % 4;
  return directions[newIndex < 0 ? newIndex + 4 : newIndex];
}
function convertTreeToInputProblem(tree, db, group) {
  const problem = {
    chipMap: {},
    chipPinMap: {},
    netMap: {},
    pinStrongConnMap: {},
    netConnMap: {},
    chipGap: 0.6,
    decouplingCapsGap: 0.4,
    partitionGap: 1.2
  };
  debug5(
    `[${group.name}] Processing ${tree.childNodes.length} child nodes for input problem`
  );
  tree.childNodes.forEach((child, index) => {
    debug5(
      `[${group.name}] Processing child ${index}: nodeType=${child.nodeType}`
    );
    if (child.nodeType === "component") {
      debug5(`[${group.name}] - Component: ${child.sourceComponent?.name}`);
    } else if (child.nodeType === "group") {
      debug5(`[${group.name}] - Group: ${child.sourceGroup?.name}`);
    }
    if (child.nodeType === "component" && child.sourceComponent) {
      const chipId = child.sourceComponent.name || `chip_${index}`;
      const schematicComponent = db.schematic_component.getWhere({
        source_component_id: child.sourceComponent.source_component_id
      });
      if (!schematicComponent) return;
      const component = group.children.find(
        (groupChild) => groupChild.source_component_id === child.sourceComponent?.source_component_id
      );
      let availableRotations = [0, 90, 180, 270];
      if (component?._parsedProps?.schOrientation) {
        availableRotations = [0];
      }
      if (component?._parsedProps?.schRotation !== void 0) {
        availableRotations = [0];
      }
      if (component?._parsedProps?.facingDirection) {
        availableRotations = [0];
      }
      if (component?._parsedProps?.schFacingDirection) {
        availableRotations = [0];
      }
      if (component?.componentName === "Chip") {
        availableRotations = [0];
      }
      const marginLeft = component?._parsedProps?.schMarginLeft ?? component?._parsedProps?.schMarginX ?? 0;
      const marginRight = component?._parsedProps?.schMarginRight ?? component?._parsedProps?.schMarginX ?? 0;
      let marginTop = component?._parsedProps?.schMarginTop ?? component?._parsedProps?.schMarginY ?? 0;
      let marginBottom = component?._parsedProps?.schMarginBottom ?? component?._parsedProps?.schMarginY ?? 0;
      if (component?.config.shouldRenderAsSchematicBox) {
        marginTop += 0.4;
        marginBottom += 0.4;
      }
      const marginXShift = (marginRight - marginLeft) / 2;
      const marginYShift = (marginTop - marginBottom) / 2;
      problem.chipMap[chipId] = {
        chipId,
        pins: [],
        size: {
          x: (schematicComponent.size?.width || 1) + marginLeft + marginRight,
          y: (schematicComponent.size?.height || 1) + marginTop + marginBottom
        },
        availableRotations
      };
      const ports = db.schematic_port.list({
        schematic_component_id: schematicComponent.schematic_component_id
      });
      for (const port of ports) {
        const sourcePort = db.source_port.get(port.source_port_id);
        if (!sourcePort) continue;
        const pinId = `${chipId}.${sourcePort.pin_number || sourcePort.name || port.schematic_port_id}`;
        problem.chipMap[chipId].pins.push(pinId);
        const side = facingDirectionToSide(port.facing_direction);
        problem.chipPinMap[pinId] = {
          pinId,
          offset: {
            x: (port.center?.x || 0) - (schematicComponent.center.x || 0) + marginXShift,
            y: (port.center?.y || 0) - (schematicComponent.center.y || 0) + marginYShift
          },
          side
        };
      }
    } else if (child.nodeType === "group" && child.sourceGroup) {
      const groupId = child.sourceGroup.name || `group_${index}`;
      debug5(`[${group.name}] Processing nested group: ${groupId}`);
      const schematicGroup = db.schematic_group?.getWhere?.({
        source_group_id: child.sourceGroup.source_group_id
      });
      const groupInstance = group.children.find(
        (groupChild) => groupChild.source_group_id === child.sourceGroup?.source_group_id
      );
      debug5(
        `[${group.name}] Found schematic_group for ${groupId}:`,
        schematicGroup
      );
      if (schematicGroup) {
        debug5(`[${group.name}] Treating group ${groupId} as composite chip`);
        const groupComponents = db.schematic_component.list({
          schematic_group_id: schematicGroup.schematic_group_id
        });
        debug5(
          `[${group.name}] Group ${groupId} has ${groupComponents.length} components:`,
          groupComponents.map((c) => c.source_component_id)
        );
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        let hasValidBounds = false;
        for (const comp of groupComponents) {
          if (comp.center && comp.size) {
            hasValidBounds = true;
            const halfWidth = comp.size.width / 2;
            const halfHeight = comp.size.height / 2;
            minX = Math.min(minX, comp.center.x - halfWidth);
            maxX = Math.max(maxX, comp.center.x + halfWidth);
            minY = Math.min(minY, comp.center.y - halfHeight);
            maxY = Math.max(maxY, comp.center.y + halfHeight);
          }
        }
        const marginLeft = groupInstance?._parsedProps?.schMarginLeft ?? groupInstance?._parsedProps?.schMarginX ?? 0;
        const marginRight = groupInstance?._parsedProps?.schMarginRight ?? groupInstance?._parsedProps?.schMarginX ?? 0;
        const marginTop = groupInstance?._parsedProps?.schMarginTop ?? groupInstance?._parsedProps?.schMarginY ?? 0;
        const marginBottom = groupInstance?._parsedProps?.schMarginBottom ?? groupInstance?._parsedProps?.schMarginY ?? 0;
        const marginXShift = (marginRight - marginLeft) / 2;
        const marginYShift = (marginTop - marginBottom) / 2;
        const groupWidth = (hasValidBounds ? maxX - minX : 2) + marginLeft + marginRight;
        const groupHeight = (hasValidBounds ? maxY - minY : 2) + marginTop + marginBottom;
        debug5(
          `[${group.name}] Group ${groupId} computed size: ${groupWidth} x ${groupHeight}`
        );
        const groupPins = [];
        for (const comp of groupComponents) {
          const ports = db.schematic_port.list({
            schematic_component_id: comp.schematic_component_id
          });
          for (const port of ports) {
            const sourcePort = db.source_port.get(port.source_port_id);
            if (!sourcePort) continue;
            const pinId = `${groupId}.${sourcePort.pin_number || sourcePort.name || port.schematic_port_id}`;
            groupPins.push(pinId);
            const groupCenter = schematicGroup.center || { x: 0, y: 0 };
            const side = facingDirectionToSide(port.facing_direction);
            problem.chipPinMap[pinId] = {
              pinId,
              offset: {
                x: (port.center?.x || 0) - groupCenter.x + marginXShift,
                y: (port.center?.y || 0) - groupCenter.y + marginYShift
              },
              side
            };
          }
        }
        debug5(
          `[${group.name}] Group ${groupId} has ${groupPins.length} pins:`,
          groupPins
        );
        problem.chipMap[groupId] = {
          chipId: groupId,
          pins: groupPins,
          size: {
            x: groupWidth,
            y: groupHeight
          }
        };
        debug5(`[${group.name}] Added group ${groupId} to chipMap`);
      } else {
        debug5(
          `[${group.name}] Warning: No schematic_group found for group ${groupId}`
        );
      }
    }
  });
  debug5(`[${group.name}] Creating connections using connectivity keys`);
  const connectivityGroups = /* @__PURE__ */ new Map();
  for (const [chipId, chip] of Object.entries(problem.chipMap)) {
    for (const pinId of chip.pins) {
      const pinNumber = pinId.split(".").pop();
      const treeNode = tree.childNodes.find((child) => {
        if (child.nodeType === "component" && child.sourceComponent) {
          return child.sourceComponent.name === chipId;
        }
        if (child.nodeType === "group" && child.sourceGroup) {
          const expectedChipId = `group_${tree.childNodes.indexOf(child)}`;
          return expectedChipId === chipId;
        }
        return false;
      });
      if (treeNode?.nodeType === "group" && treeNode.sourceGroup) {
        const schematicGroup = db.schematic_group?.getWhere?.({
          source_group_id: treeNode.sourceGroup.source_group_id
        });
        if (schematicGroup) {
          const groupComponents = db.schematic_component.list({
            schematic_group_id: schematicGroup.schematic_group_id
          });
          for (const comp of groupComponents) {
            const sourcePorts = db.source_port.list({
              source_component_id: comp.source_component_id
            });
            for (const sourcePort of sourcePorts) {
              const portNumber = sourcePort.pin_number || sourcePort.name;
              if (String(portNumber) === String(pinNumber)) {
                if (sourcePort.subcircuit_connectivity_map_key) {
                  const connectivityKey = sourcePort.subcircuit_connectivity_map_key;
                  if (!connectivityGroups.has(connectivityKey)) {
                    connectivityGroups.set(connectivityKey, []);
                  }
                  connectivityGroups.get(connectivityKey).push(pinId);
                  debug5(
                    `[${group.name}] \u2713 Pin ${pinId} has connectivity key: ${connectivityKey}`
                  );
                } else {
                  debug5(`[${group.name}] Pin ${pinId} has no connectivity key`);
                }
              }
            }
          }
        }
      } else if (treeNode?.nodeType === "component" && treeNode.sourceComponent) {
        const sourcePorts = db.source_port.list({
          source_component_id: treeNode.sourceComponent.source_component_id
        });
        for (const sourcePort of sourcePorts) {
          const portNumber = sourcePort.pin_number || sourcePort.name;
          if (String(portNumber) === String(pinNumber) && sourcePort.subcircuit_connectivity_map_key) {
            const connectivityKey = sourcePort.subcircuit_connectivity_map_key;
            if (!connectivityGroups.has(connectivityKey)) {
              connectivityGroups.set(connectivityKey, []);
            }
            connectivityGroups.get(connectivityKey).push(pinId);
            debug5(
              `[${group.name}] Pin ${pinId} has connectivity key: ${connectivityKey}`
            );
          }
        }
      }
    }
  }
  debug5(
    `[${group.name}] Found ${connectivityGroups.size} connectivity groups:`,
    Array.from(connectivityGroups.entries()).map(([key, pins]) => ({
      key,
      pins
    }))
  );
  for (const [connectivityKey, pins] of connectivityGroups) {
    if (pins.length >= 2) {
      const tracesWithThisKey = db.source_trace.list().filter(
        (trace) => trace.subcircuit_connectivity_map_key === connectivityKey
      );
      const hasNetConnections = tracesWithThisKey.some(
        (trace) => trace.connected_source_net_ids && trace.connected_source_net_ids.length > 0
      );
      const hasDirectConnections = tracesWithThisKey.some(
        (trace) => trace.connected_source_port_ids && trace.connected_source_port_ids.length >= 2
      );
      debug5(
        `[${group.name}] Connectivity ${connectivityKey}: hasNetConnections=${hasNetConnections}, hasDirectConnections=${hasDirectConnections}`
      );
      if (hasDirectConnections) {
        for (const trace of tracesWithThisKey) {
          if (trace.connected_source_port_ids && trace.connected_source_port_ids.length >= 2) {
            const directlyConnectedPins = [];
            for (const portId of trace.connected_source_port_ids) {
              for (const pinId of pins) {
                const pinNumber = pinId.split(".").pop();
                const sourcePort = db.source_port.get(portId);
                if (sourcePort && String(sourcePort.pin_number || sourcePort.name) === String(pinNumber)) {
                  const chipId = pinId.split(".")[0];
                  const treeNode = tree.childNodes.find((child) => {
                    if (child.nodeType === "component" && child.sourceComponent) {
                      return child.sourceComponent.name === chipId;
                    }
                    if (child.nodeType === "group" && child.sourceGroup) {
                      const expectedChipId = `group_${tree.childNodes.indexOf(child)}`;
                      return expectedChipId === chipId;
                    }
                    return false;
                  });
                  if (treeNode?.nodeType === "component" && treeNode.sourceComponent) {
                    const portBelongsToComponent = db.source_port.list({
                      source_component_id: treeNode.sourceComponent.source_component_id
                    }).some((p) => p.source_port_id === portId);
                    if (portBelongsToComponent) {
                      directlyConnectedPins.push(pinId);
                    }
                  }
                }
              }
            }
            for (let i = 0; i < directlyConnectedPins.length; i++) {
              for (let j = i + 1; j < directlyConnectedPins.length; j++) {
                const pin1 = directlyConnectedPins[i];
                const pin2 = directlyConnectedPins[j];
                problem.pinStrongConnMap[`${pin1}-${pin2}`] = true;
                problem.pinStrongConnMap[`${pin2}-${pin1}`] = true;
                debug5(
                  `[${group.name}] Created strong connection: ${pin1} <-> ${pin2}`
                );
              }
            }
          }
        }
      }
      if (hasNetConnections) {
        const source_net = db.source_net.getWhere({
          subcircuit_connectivity_map_key: connectivityKey
        });
        const isGround = source_net?.is_ground ?? false;
        const isPositiveVoltageSource = source_net?.is_power ?? false;
        problem.netMap[connectivityKey] = {
          netId: connectivityKey,
          isGround,
          isPositiveVoltageSource
        };
        for (const pinId of pins) {
          problem.netConnMap[`${pinId}-${connectivityKey}`] = true;
        }
        debug5(
          `[${group.name}] Created net ${connectivityKey} with ${pins.length} pins:`,
          pins
        );
      }
    }
  }
  return problem;
}
function Group_doInitialSchematicLayoutMatchPack(group) {
  const { db } = group.root;
  const tree = getCircuitJsonTree(db.toArray(), {
    source_group_id: group.source_group_id
  });
  debug5(
    `[${group.name}] Starting matchpack layout with ${tree.childNodes.length} children`
  );
  debug5(`[${group.name}] Tree structure:`, JSON.stringify(tree, null, 2));
  if (tree.childNodes.length <= 1) {
    debug5(
      `[${group.name}] Only ${tree.childNodes.length} children, skipping layout`
    );
    return;
  }
  debug5("Converting circuit tree to InputProblem...");
  const inputProblem = convertTreeToInputProblem(tree, db, group);
  if (debug5.enabled) {
    group.root?.emit("debug:logOutput", {
      type: "debug:logOutput",
      name: `matchpack-input-problem-${group.name}`,
      content: JSON.stringify(inputProblem, null, 2)
    });
  }
  const solver = new LayoutPipelineSolver(inputProblem);
  debug5("Starting LayoutPipelineSolver...");
  if (debug5.enabled && global?.debugGraphics) {
    const initialViz = solver.visualize();
    global.debugGraphics.push({
      ...initialViz,
      title: `matchpack-initial-${group.name}`
    });
  }
  solver.solve();
  debug5(`Solver completed in ${solver.iterations} iterations`);
  debug5(`Solved: ${solver.solved}, Failed: ${solver.failed}`);
  if (solver.failed) {
    debug5(`Solver failed with error: ${solver.error}`);
    throw new Error(`Matchpack layout solver failed: ${solver.error}`);
  }
  const outputLayout = solver.getOutputLayout();
  debug5("OutputLayout:", JSON.stringify(outputLayout, null, 2));
  debug5("Solver completed successfully:", !solver.failed);
  if (debug5.enabled && global?.debugGraphics) {
    const finalViz = solver.visualize();
    global.debugGraphics.push({
      ...finalViz,
      title: `matchpack-final-${group.name}`
    });
  }
  const overlaps = solver.checkForOverlaps(outputLayout);
  if (overlaps.length > 0) {
    debug5(`Warning: Found ${overlaps.length} overlapping components:`);
    for (const overlap of overlaps) {
      debug5(
        `  ${overlap.chip1} overlaps ${overlap.chip2} (area: ${overlap.overlapArea})`
      );
    }
  }
  const groupOffset = group._getGlobalSchematicPositionBeforeLayout();
  debug5(`Group offset: x=${groupOffset.x}, y=${groupOffset.y}`);
  debug5(
    `Applying layout results for ${Object.keys(outputLayout.chipPlacements).length} chip placements`
  );
  for (const [chipId, placement] of Object.entries(
    outputLayout.chipPlacements
  )) {
    debug5(
      `Processing placement for chip: ${chipId} at (${placement.x}, ${placement.y})`
    );
    const treeNode = tree.childNodes.find((child) => {
      if (child.nodeType === "component" && child.sourceComponent) {
        const matches = child.sourceComponent.name === chipId;
        debug5(
          `  Checking component ${child.sourceComponent.name}: matches=${matches}`
        );
        return matches;
      }
      if (child.nodeType === "group" && child.sourceGroup) {
        const groupName = child.sourceGroup.name;
        const expectedChipId = `group_${tree.childNodes.indexOf(child)}`;
        const matches = expectedChipId === chipId;
        debug5(
          `  Checking group ${groupName} (expected chipId: ${expectedChipId}): matches=${matches}`
        );
        return matches;
      }
      return false;
    });
    if (!treeNode) {
      debug5(`Warning: No tree node found for chip: ${chipId}`);
      debug5(
        "Available tree nodes:",
        tree.childNodes.map((child, idx) => ({
          type: child.nodeType,
          name: child.nodeType === "component" ? child.sourceComponent?.name : child.sourceGroup?.name,
          expectedChipId: child.nodeType === "group" ? `group_${idx}` : child.sourceComponent?.name
        }))
      );
      continue;
    }
    const newCenter = {
      x: placement.x + groupOffset.x,
      y: placement.y + groupOffset.y
    };
    if (treeNode.nodeType === "component" && treeNode.sourceComponent) {
      const schematicComponent = db.schematic_component.getWhere({
        source_component_id: treeNode.sourceComponent.source_component_id
      });
      if (schematicComponent) {
        debug5(`Moving component ${chipId} to (${newCenter.x}, ${newCenter.y})`);
        const ports = db.schematic_port.list({
          schematic_component_id: schematicComponent.schematic_component_id
        });
        const texts = db.schematic_text.list({
          schematic_component_id: schematicComponent.schematic_component_id
        });
        const positionDelta = {
          x: newCenter.x - schematicComponent.center.x,
          y: newCenter.y - schematicComponent.center.y
        };
        for (const port of ports) {
          port.center.x += positionDelta.x;
          port.center.y += positionDelta.y;
        }
        for (const text of texts) {
          text.position.x += positionDelta.x;
          text.position.y += positionDelta.y;
        }
        updateSchematicPrimitivesForLayoutShift({
          db,
          schematicComponentId: schematicComponent.schematic_component_id,
          deltaX: positionDelta.x,
          deltaY: positionDelta.y
        });
        schematicComponent.center = newCenter;
        if (placement.ccwRotationDegrees !== 0) {
          debug5(
            `Component ${chipId} has rotation: ${placement.ccwRotationDegrees}\xB0`
          );
          const angleRad = placement.ccwRotationDegrees * Math.PI / 180;
          const cos = Math.cos(angleRad);
          const sin = Math.sin(angleRad);
          for (const port of ports) {
            const dx = port.center.x - newCenter.x;
            const dy = port.center.y - newCenter.y;
            const rotatedDx = dx * cos - dy * sin;
            const rotatedDy = dx * sin + dy * cos;
            port.center.x = newCenter.x + rotatedDx;
            port.center.y = newCenter.y + rotatedDy;
            const originalDirection = port.facing_direction || "right";
            port.facing_direction = rotateDirection(
              originalDirection,
              placement.ccwRotationDegrees
            );
            port.side_of_component = (port.facing_direction === "up" ? "top" : port.facing_direction === "down" ? "bottom" : port.facing_direction) || port.side_of_component;
          }
          for (const text of texts) {
            const dx = text.position.x - newCenter.x;
            const dy = text.position.y - newCenter.y;
            const rotatedDx = dx * cos - dy * sin;
            const rotatedDy = dx * sin + dy * cos;
            text.position.x = newCenter.x + rotatedDx;
            text.position.y = newCenter.y + rotatedDy;
          }
          if (schematicComponent.symbol_name) {
            const schematicSymbolDirection = schematicComponent.symbol_name.match(/_(right|left|up|down)$/);
            if (schematicSymbolDirection) {
              schematicComponent.symbol_name = schematicComponent.symbol_name.replace(
                schematicSymbolDirection[0],
                `_${rotateDirection(schematicSymbolDirection[1], placement.ccwRotationDegrees)}`
              );
            }
          }
        }
      }
    } else if (treeNode.nodeType === "group" && treeNode.sourceGroup) {
      const schematicGroup = db.schematic_group?.getWhere?.({
        source_group_id: treeNode.sourceGroup.source_group_id
      });
      if (schematicGroup) {
        debug5(
          `Moving group ${chipId} to (${newCenter.x}, ${newCenter.y}) from (${schematicGroup.center?.x}, ${schematicGroup.center?.y})`
        );
        const groupComponents = db.schematic_component.list({
          schematic_group_id: schematicGroup.schematic_group_id
        });
        debug5(
          `Group ${chipId} has ${groupComponents.length} components to move`
        );
        const oldCenter = schematicGroup.center || { x: 0, y: 0 };
        const positionDelta = {
          x: newCenter.x - oldCenter.x,
          y: newCenter.y - oldCenter.y
        };
        debug5(
          `Position delta for group ${chipId}: (${positionDelta.x}, ${positionDelta.y})`
        );
        for (const component of groupComponents) {
          if (component.center) {
            const oldComponentCenter = { ...component.center };
            component.center.x += positionDelta.x;
            component.center.y += positionDelta.y;
            debug5(
              `Moved component ${component.source_component_id} from (${oldComponentCenter.x}, ${oldComponentCenter.y}) to (${component.center.x}, ${component.center.y})`
            );
            const ports = db.schematic_port.list({
              schematic_component_id: component.schematic_component_id
            });
            const texts = db.schematic_text.list({
              schematic_component_id: component.schematic_component_id
            });
            for (const port of ports) {
              if (port.center) {
                port.center.x += positionDelta.x;
                port.center.y += positionDelta.y;
              }
            }
            for (const text of texts) {
              if (text.position) {
                text.position.x += positionDelta.x;
                text.position.y += positionDelta.y;
              }
            }
          }
        }
        schematicGroup.center = newCenter;
        debug5(
          `Updated group ${chipId} center to (${newCenter.x}, ${newCenter.y})`
        );
      }
    }
  }
  debug5("Matchpack layout completed successfully");
}

// lib/components/primitive-components/Group/Group_doInitialSourceAddConnectivityMapKey.ts
import { ConnectivityMap as ConnectivityMap2 } from "circuit-json-to-connectivity-map";
function Group_doInitialSourceAddConnectivityMapKey(group) {
  if (!group.isSubcircuit) return;
  const { db } = group.root;
  const traces = group.selectAll("trace");
  const vias = group.selectAll("via");
  const nets = group.selectAll("net");
  const connMap = new ConnectivityMap2({});
  connMap.addConnections(
    traces.map((t) => {
      const source_trace = db.source_trace.get(
        t.source_trace_id
      );
      if (!source_trace) return null;
      return [
        source_trace.source_trace_id,
        ...source_trace.connected_source_port_ids,
        ...source_trace.connected_source_net_ids
      ];
    }).filter((c) => c !== null)
  );
  const sourceNets = db.source_net.list().filter((net) => net.subcircuit_id === group.subcircuit_id);
  for (const sourceNet of sourceNets) {
    connMap.addConnections([[sourceNet.source_net_id]]);
  }
  const { name: subcircuitName } = group._parsedProps;
  for (const trace of traces) {
    if (!trace.source_trace_id) continue;
    const connNetId = connMap.getNetConnectedToId(trace.source_trace_id);
    if (!connNetId) continue;
    trace.subcircuit_connectivity_map_key = `${subcircuitName ?? `unnamedsubcircuit${group._renderId}`}_${connNetId}`;
    db.source_trace.update(trace.source_trace_id, {
      subcircuit_connectivity_map_key: trace.subcircuit_connectivity_map_key
    });
  }
  const allSourcePortIds = /* @__PURE__ */ new Set();
  for (const trace of traces) {
    if (!trace.source_trace_id) continue;
    const source_trace = db.source_trace.get(
      trace.source_trace_id
    );
    if (!source_trace) continue;
    for (const id of source_trace.connected_source_port_ids) {
      allSourcePortIds.add(id);
    }
  }
  for (const portId of allSourcePortIds) {
    const connNetId = connMap.getNetConnectedToId(portId);
    if (!connNetId) continue;
    const connectivityMapKey = `${subcircuitName ?? `unnamedsubcircuit${group._renderId}`}_${connNetId}`;
    db.source_port.update(portId, {
      subcircuit_connectivity_map_key: connectivityMapKey
    });
  }
  const allSourceNetIds = /* @__PURE__ */ new Set();
  for (const trace of traces) {
    if (!trace.source_trace_id) continue;
    const source_trace = db.source_trace.get(
      trace.source_trace_id
    );
    if (!source_trace) continue;
    for (const source_net_id of source_trace.connected_source_net_ids) {
      allSourceNetIds.add(source_net_id);
    }
  }
  for (const sourceNet of sourceNets) {
    allSourceNetIds.add(sourceNet.source_net_id);
  }
  for (const netId of allSourceNetIds) {
    const connNetId = connMap.getNetConnectedToId(netId);
    if (!connNetId) continue;
    const connectivityMapKey = `${subcircuitName ?? `unnamedsubcircuit${group._renderId}`}_${connNetId}`;
    db.source_net.update(netId, {
      subcircuit_connectivity_map_key: connectivityMapKey
    });
    const netInstance = nets.find((n) => n.source_net_id === netId);
    if (netInstance) {
      netInstance.subcircuit_connectivity_map_key = connectivityMapKey;
    }
  }
  for (const via of vias) {
    const connectedNetOrTrace = via._getConnectedNetOrTrace();
    if (!connectedNetOrTrace) continue;
    if (connectedNetOrTrace.subcircuit_connectivity_map_key) {
      via.subcircuit_connectivity_map_key = connectedNetOrTrace.subcircuit_connectivity_map_key;
    }
  }
}

// lib/components/primitive-components/Group/Group_doInitialSchematicLayoutGrid.ts
import { length } from "circuit-json";
function Group_doInitialSchematicLayoutGrid(group) {
  const { db } = group.root;
  const props = group._parsedProps;
  const schematicChildren = group.children.filter((child) => {
    const isExplicitlyPositioned = child._parsedProps?.schX !== void 0 || child._parsedProps?.schY !== void 0;
    return child.schematic_component_id && !isExplicitlyPositioned;
  });
  if (schematicChildren.length === 0) return;
  let maxCellWidth = 0;
  let maxCellHeight = 0;
  for (const child of schematicChildren) {
    const schComp = db.schematic_component.get(child.schematic_component_id);
    if (schComp?.size) {
      maxCellWidth = Math.max(maxCellWidth, schComp.size.width);
      maxCellHeight = Math.max(maxCellHeight, schComp.size.height);
    }
  }
  if (maxCellWidth === 0 && schematicChildren.length > 0) maxCellWidth = 1;
  if (maxCellHeight === 0 && schematicChildren.length > 0) maxCellHeight = 1;
  let gridColsOption = props.gridCols;
  let gridRowsOption = void 0;
  let gridGapOption = props.gridGap;
  let gridRowGapOption = props.gridRowGap;
  let gridColumnGapOption = props.gridColumnGap;
  if (props.schLayout?.grid) {
    gridColsOption = props.schLayout.grid.cols ?? gridColsOption;
    gridRowsOption = props.schLayout.grid.rows;
    gridGapOption = props.schLayout.gridGap ?? gridGapOption;
    gridRowGapOption = props.schLayout.gridRowGap ?? gridRowGapOption;
    gridColumnGapOption = props.schLayout.gridColumnGap ?? gridColumnGapOption;
  }
  let numCols;
  let numRows;
  if (gridColsOption !== void 0 && gridRowsOption !== void 0) {
    numCols = gridColsOption;
    numRows = gridRowsOption;
  } else if (gridColsOption !== void 0) {
    numCols = gridColsOption;
    numRows = Math.ceil(schematicChildren.length / numCols);
  } else if (gridRowsOption !== void 0) {
    numRows = gridRowsOption;
    numCols = Math.ceil(schematicChildren.length / numRows);
  } else {
    numCols = Math.ceil(Math.sqrt(schematicChildren.length));
    numRows = Math.ceil(schematicChildren.length / numCols);
  }
  if (numCols === 0 && schematicChildren.length > 0) numCols = 1;
  if (numRows === 0 && schematicChildren.length > 0)
    numRows = schematicChildren.length;
  let gridGapX;
  let gridGapY;
  const parseGap = (val) => {
    if (val === void 0) return void 0;
    return typeof val === "number" ? val : length.parse(val);
  };
  if (gridRowGapOption !== void 0 || gridColumnGapOption !== void 0) {
    const fallbackX = typeof gridGapOption === "object" && gridGapOption !== null ? gridGapOption.x : gridGapOption;
    const fallbackY = typeof gridGapOption === "object" && gridGapOption !== null ? gridGapOption.y : gridGapOption;
    gridGapX = parseGap(gridColumnGapOption ?? fallbackX) ?? 1;
    gridGapY = parseGap(gridRowGapOption ?? fallbackY) ?? 1;
  } else if (typeof gridGapOption === "number") {
    gridGapX = gridGapOption;
    gridGapY = gridGapOption;
  } else if (typeof gridGapOption === "string") {
    const parsed = length.parse(gridGapOption);
    gridGapX = parsed;
    gridGapY = parsed;
  } else if (typeof gridGapOption === "object" && gridGapOption !== null) {
    const xRaw = gridGapOption.x;
    const yRaw = gridGapOption.y;
    gridGapX = typeof xRaw === "number" ? xRaw : length.parse(xRaw ?? "0mm");
    gridGapY = typeof yRaw === "number" ? yRaw : length.parse(yRaw ?? "0mm");
  } else {
    gridGapX = 1;
    gridGapY = 1;
  }
  const totalGridWidth = numCols * maxCellWidth + Math.max(0, numCols - 1) * gridGapX;
  const totalGridHeight = numRows * maxCellHeight + Math.max(0, numRows - 1) * gridGapY;
  const groupCenter = group._getGlobalSchematicPositionBeforeLayout();
  const firstCellCenterX = groupCenter.x - totalGridWidth / 2 + maxCellWidth / 2;
  const firstCellCenterY = groupCenter.y + totalGridHeight / 2 - maxCellHeight / 2;
  for (let i = 0; i < schematicChildren.length; i++) {
    const child = schematicChildren[i];
    if (!child.schematic_component_id) continue;
    const row = Math.floor(i / numCols);
    const col = i % numCols;
    if (row >= numRows || col >= numCols) {
      console.warn(
        `Schematic grid layout: Child ${child.getString()} at index ${i} (row ${row}, col ${col}) exceeds specified grid dimensions (${numRows}x${numCols}). Skipping placement.`
      );
      continue;
    }
    const targetCellCenterX = firstCellCenterX + col * (maxCellWidth + gridGapX);
    const targetCellCenterY = firstCellCenterY - row * (maxCellHeight + gridGapY);
    const schComp = db.schematic_component.get(child.schematic_component_id);
    if (schComp) {
      const oldChildCenter = schComp.center;
      const newChildCenter = { x: targetCellCenterX, y: targetCellCenterY };
      db.schematic_component.update(child.schematic_component_id, {
        center: newChildCenter
      });
      const deltaX = newChildCenter.x - oldChildCenter.x;
      const deltaY = newChildCenter.y - oldChildCenter.y;
      const schPorts = db.schematic_port.list({
        schematic_component_id: child.schematic_component_id
      });
      for (const port of schPorts) {
        db.schematic_port.update(port.schematic_port_id, {
          center: { x: port.center.x + deltaX, y: port.center.y + deltaY }
        });
      }
      const schTexts = db.schematic_text.list({
        schematic_component_id: child.schematic_component_id
      });
      for (const text of schTexts) {
        db.schematic_text.update(text.schematic_text_id, {
          position: {
            x: text.position.x + deltaX,
            y: text.position.y + deltaY
          }
        });
      }
      updateSchematicPrimitivesForLayoutShift({
        db,
        schematicComponentId: child.schematic_component_id,
        deltaX,
        deltaY
      });
    }
  }
  if (group.schematic_group_id) {
    db.schematic_group.update(group.schematic_group_id, {
      width: totalGridWidth,
      height: totalGridHeight,
      center: groupCenter
    });
  }
}

// lib/components/primitive-components/Group/Group_doInitialSchematicLayoutFlex.ts
import {
  getCircuitJsonTree as getCircuitJsonTree2,
  getMinimumFlexContainer,
  repositionSchematicComponentTo,
  repositionSchematicGroupTo
} from "@tscircuit/circuit-json-util";
import { RootFlexBox } from "@tscircuit/miniflex";
import { length as length2 } from "circuit-json";
var getSizeOfTreeNodeChild = (db, child) => {
  const { sourceComponent, sourceGroup } = child;
  if (child.nodeType === "component") {
    const schComponent = db.schematic_component.getWhere({
      source_component_id: sourceComponent?.source_component_id
    });
    if (!schComponent?.size) return null;
    return {
      width: schComponent.size.width,
      height: schComponent.size.height
    };
  }
  if (child.nodeType === "group") {
    const schGroup = db.schematic_group.getWhere({
      source_group_id: sourceGroup?.source_group_id
    });
    if (schGroup?.width && schGroup?.height) {
      return {
        width: schGroup.width,
        height: schGroup.height
      };
    }
    const groupComponents = db.schematic_component.list({
      schematic_group_id: schGroup?.schematic_group_id
    });
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (const comp of groupComponents) {
      if (comp.center && comp.size) {
        const halfWidth = comp.size.width / 2;
        const halfHeight = comp.size.height / 2;
        minX = Math.min(minX, comp.center.x - halfWidth);
        maxX = Math.max(maxX, comp.center.x + halfWidth);
        minY = Math.min(minY, comp.center.y - halfHeight);
        maxY = Math.max(maxY, comp.center.y + halfHeight);
      }
    }
    const groupWidth = maxX - minX;
    const groupHeight = maxY - minY;
    return {
      width: groupWidth,
      height: groupHeight
    };
  }
  return null;
};
var Group_doInitialSchematicLayoutFlex = (group) => {
  const { db } = group.root;
  const props = group._parsedProps;
  const tree = getCircuitJsonTree2(db.toArray(), {
    source_group_id: group.source_group_id
  });
  const rawJustify = props.schJustifyContent ?? props.justifyContent;
  const rawAlign = props.schAlignItems ?? props.alignItems;
  const rawGap = props.schFlexGap ?? props.schGap ?? props.gap;
  const direction = props.schFlexDirection ?? "row";
  const justifyContent = {
    start: "flex-start",
    end: "flex-end",
    "flex-start": "flex-start",
    "flex-end": "flex-end",
    stretch: "space-between",
    "space-between": "space-between",
    "space-around": "space-around",
    "space-evenly": "space-evenly",
    center: "center"
  }[rawJustify ?? "space-between"];
  const alignItems = {
    start: "flex-start",
    end: "flex-end",
    "flex-start": "flex-start",
    "flex-end": "flex-end",
    stretch: "stretch",
    center: "center"
  }[rawAlign ?? "center"];
  if (!justifyContent) {
    throw new Error(`Invalid justifyContent value: "${rawJustify}"`);
  }
  if (!alignItems) {
    throw new Error(`Invalid alignItems value: "${rawAlign}"`);
  }
  let rowGap = 0;
  let columnGap = 0;
  if (typeof rawGap === "object") {
    rowGap = rawGap.y ?? 0;
    columnGap = rawGap.x ?? 0;
  } else if (typeof rawGap === "number") {
    rowGap = rawGap;
    columnGap = rawGap;
  } else if (typeof rawGap === "string") {
    rowGap = length2.parse(rawGap);
    columnGap = length2.parse(rawGap);
  }
  let minFlexContainer;
  let width = props.width ?? props.schWidth ?? void 0;
  let height = props.height ?? props.schHeight ?? void 0;
  const isInline = Boolean(width === void 0 || height === void 0);
  if (isInline) {
    minFlexContainer = getMinimumFlexContainer(
      tree.childNodes.map((child) => getSizeOfTreeNodeChild(db, child)).filter((size) => size !== null),
      {
        alignItems,
        justifyContent,
        direction,
        rowGap,
        columnGap
      }
    );
    width = minFlexContainer.width;
    height = minFlexContainer.height;
  }
  const flexBox = new RootFlexBox(width, height, {
    alignItems,
    justifyContent,
    direction,
    rowGap,
    columnGap
  });
  for (const child of tree.childNodes) {
    const size = getSizeOfTreeNodeChild(db, child);
    flexBox.addChild({
      metadata: child,
      width: size?.width ?? 0,
      height: size?.height ?? 0,
      flexBasis: !size ? void 0 : direction === "row" ? size.width : size.height
    });
  }
  flexBox.build();
  const bounds = {
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity,
    width: 0,
    height: 0
  };
  for (const child of flexBox.children) {
    bounds.minX = Math.min(bounds.minX, child.position.x);
    bounds.minY = Math.min(bounds.minY, child.position.y);
    bounds.maxX = Math.max(bounds.maxX, child.position.x + child.size.width);
    bounds.maxY = Math.max(bounds.maxY, child.position.y + child.size.height);
  }
  bounds.width = bounds.maxX - bounds.minX;
  bounds.height = bounds.maxY - bounds.minY;
  const offset = {
    x: -(bounds.maxX + bounds.minX) / 2,
    y: -(bounds.maxY + bounds.minY) / 2
  };
  const allCircuitJson = db.toArray();
  for (const child of flexBox.children) {
    const { sourceComponent, sourceGroup } = child.metadata;
    if (sourceComponent) {
      const schComponent = db.schematic_component.getWhere({
        source_component_id: sourceComponent.source_component_id
      });
      if (!schComponent) continue;
      repositionSchematicComponentTo(
        allCircuitJson,
        schComponent.schematic_component_id,
        {
          x: child.position.x + child.size.width / 2 + offset.x,
          y: child.position.y + child.size.height / 2 + offset.y
        }
      );
    }
    if (sourceGroup) {
      const schGroup = db.schematic_group.getWhere({
        source_group_id: sourceGroup.source_group_id
      });
      if (!schGroup) continue;
      repositionSchematicGroupTo(allCircuitJson, sourceGroup.source_group_id, {
        x: child.position.x + child.size.width / 2 + offset.x,
        y: child.position.y + child.size.height / 2 + offset.y
      });
    }
  }
  if (group.schematic_group_id) {
    db.schematic_group.update(group.schematic_group_id, {
      width: bounds.width,
      height: bounds.height
    });
  }
};

// lib/components/primitive-components/Group/Group_doInitialPcbLayoutGrid.ts
import {
  repositionPcbComponentTo as repositionPcbComponentTo2,
  repositionPcbGroupTo as repositionPcbGroupTo2
} from "@tscircuit/circuit-json-util";
import { length as length3 } from "circuit-json";
import { CssGrid } from "minicssgrid";
var MIN_GAP = 1;
function Group_doInitialPcbLayoutGrid(group) {
  const { db } = group.root;
  const props = group._parsedProps;
  const pcbChildren = getPcbChildren(group);
  if (pcbChildren.length === 0) return;
  const childDimensions = calculateChildDimensions({ db, pcbChildren });
  const gridConfig = parseGridConfiguration(props);
  const gridLayout = createGridLayout({
    props,
    pcbChildren,
    childDimensions,
    gridConfig
  });
  const cssGrid = createCssGrid({
    pcbChildren,
    childDimensions,
    gridLayout,
    gridConfig
  });
  const { itemCoordinates } = cssGrid.layout();
  positionChildren({ db, group, pcbChildren, itemCoordinates, gridLayout });
  updateGroupDimensions({ db, group, props, gridLayout });
}
function getPcbChildren(group) {
  return group.children.filter(
    (child) => child.pcb_component_id || child.pcb_group_id
  );
}
function calculateChildDimensions(params) {
  const { db, pcbChildren } = params;
  let maxWidth = 0;
  let maxHeight = 0;
  for (const child of pcbChildren) {
    let width = 0;
    let height = 0;
    if (child.pcb_group_id) {
      const pcbGroup = db.pcb_group.get(child.pcb_group_id);
      width = pcbGroup?.width ?? 0;
      height = pcbGroup?.height ?? 0;
    } else if (child.pcb_component_id) {
      const pcbComp = db.pcb_component.get(child.pcb_component_id);
      width = pcbComp?.width ?? 0;
      height = pcbComp?.height ?? 0;
    }
    maxWidth = Math.max(maxWidth, width);
    maxHeight = Math.max(maxHeight, height);
  }
  return {
    width: maxWidth,
    height: maxHeight
  };
}
function parseGridConfiguration(props) {
  const cols = props.pcbGridCols ?? props.gridCols ?? props.pcbLayout?.grid?.cols;
  const rows = props.pcbGridRows ?? props.pcbLayout?.grid?.rows;
  const templateColumns = props.pcbGridTemplateColumns;
  const templateRows = props.pcbGridTemplateRows;
  const parseGap = (gapValue) => {
    if (gapValue === void 0) return MIN_GAP;
    return typeof gapValue === "number" ? gapValue : length3.parse(gapValue);
  };
  const gridGapOption = props.pcbGridGap ?? props.gridGap ?? props.pcbLayout?.gridGap;
  const rowGapOption = props.pcbGridRowGap ?? props.gridRowGap ?? props.pcbLayout?.gridRowGap;
  const colGapOption = props.pcbGridColumnGap ?? props.gridColumnGap ?? props.pcbLayout?.gridColumnGap;
  let gapX = MIN_GAP;
  let gapY = MIN_GAP;
  if (rowGapOption !== void 0 || colGapOption !== void 0) {
    const fallbackX = typeof gridGapOption === "object" ? gridGapOption?.x : gridGapOption;
    const fallbackY = typeof gridGapOption === "object" ? gridGapOption?.y : gridGapOption;
    gapX = parseGap(colGapOption ?? fallbackX);
    gapY = parseGap(rowGapOption ?? fallbackY);
  } else if (typeof gridGapOption === "object" && gridGapOption !== null) {
    gapX = parseGap(gridGapOption.x);
    gapY = parseGap(gridGapOption.y);
  } else {
    const gap = parseGap(gridGapOption);
    gapX = gap;
    gapY = gap;
  }
  return { cols, rows, gapX, gapY, templateColumns, templateRows };
}
function createGridLayout(params) {
  const { props, pcbChildren, childDimensions, gridConfig } = params;
  if (props.pcbGridTemplateColumns || props.pcbGridTemplateRows) {
    return createTemplateBasedLayout({
      props,
      gridConfig,
      pcbChildren,
      childDimensions
    });
  }
  return createDefaultLayout({ gridConfig, pcbChildren, childDimensions });
}
function createTemplateBasedLayout(params) {
  const { props, gridConfig, pcbChildren, childDimensions } = params;
  const gridTemplateColumns = props.pcbGridTemplateColumns ?? "";
  const gridTemplateRows = props.pcbGridTemplateRows ?? "";
  const extractRepeatCount = (template) => {
    const match = template.match(/repeat\((\d+),/);
    return match ? parseInt(match[1]) : Math.ceil(Math.sqrt(pcbChildren.length));
  };
  const numCols = props.pcbGridTemplateColumns ? extractRepeatCount(gridTemplateColumns) : Math.ceil(Math.sqrt(pcbChildren.length));
  const numRows = props.pcbGridTemplateRows ? extractRepeatCount(gridTemplateRows) : Math.ceil(pcbChildren.length / numCols);
  const containerWidth = numCols * childDimensions.width + Math.max(0, numCols - 1) * gridConfig.gapX;
  const containerHeight = numRows * childDimensions.height + Math.max(0, numRows - 1) * gridConfig.gapY;
  return {
    gridTemplateColumns,
    gridTemplateRows,
    containerWidth,
    containerHeight
  };
}
function createDefaultLayout(params) {
  const { gridConfig, pcbChildren, childDimensions } = params;
  let numCols;
  let numRows;
  if (gridConfig.cols !== void 0 && gridConfig.rows !== void 0) {
    numCols = gridConfig.cols;
    numRows = gridConfig.rows;
  } else if (gridConfig.cols !== void 0) {
    numCols = gridConfig.cols;
    numRows = Math.ceil(pcbChildren.length / numCols);
  } else if (gridConfig.rows !== void 0) {
    numRows = gridConfig.rows;
    numCols = Math.ceil(pcbChildren.length / numRows);
  } else {
    numCols = Math.ceil(Math.sqrt(pcbChildren.length));
    numRows = Math.ceil(pcbChildren.length / numCols);
  }
  numCols = Math.max(1, numCols);
  numRows = Math.max(1, numRows);
  const containerWidth = numCols * childDimensions.width + Math.max(0, numCols - 1) * gridConfig.gapX;
  const containerHeight = numRows * childDimensions.height + Math.max(0, numRows - 1) * gridConfig.gapY;
  const gridTemplateColumns = `repeat(${numCols}, ${childDimensions.width}px)`;
  const gridTemplateRows = `repeat(${numRows}, ${childDimensions.height}px)`;
  return {
    gridTemplateColumns,
    gridTemplateRows,
    containerWidth,
    containerHeight
  };
}
function createCssGrid(params) {
  const { pcbChildren, childDimensions, gridLayout, gridConfig } = params;
  const gridChildren = pcbChildren.map((child, index) => ({
    key: child.getString() || `child-${index}`,
    contentWidth: childDimensions.width,
    contentHeight: childDimensions.height
  }));
  return new CssGrid({
    containerWidth: gridLayout.containerWidth,
    containerHeight: gridLayout.containerHeight,
    gridTemplateColumns: gridLayout.gridTemplateColumns,
    gridTemplateRows: gridLayout.gridTemplateRows,
    gap: [gridConfig.gapY, gridConfig.gapX],
    // [rowGap, columnGap]
    children: gridChildren
  });
}
function positionChildren(params) {
  const { db, group, pcbChildren, itemCoordinates, gridLayout } = params;
  const groupCenter = group._getGlobalPcbPositionBeforeLayout();
  const allCircuitJson = db.toArray();
  for (let i = 0; i < pcbChildren.length; i++) {
    const child = pcbChildren[i];
    const childKey = child.getString() || `child-${i}`;
    const coordinates = itemCoordinates[childKey];
    if (!coordinates) {
      console.warn(
        `PCB grid layout: No coordinates found for child ${childKey}`
      );
      continue;
    }
    const targetX = groupCenter.x - gridLayout.containerWidth / 2 + coordinates.x + coordinates.width / 2;
    const targetY = groupCenter.y + gridLayout.containerHeight / 2 - coordinates.y - coordinates.height / 2;
    if (child.pcb_component_id) {
      repositionPcbComponentTo2(allCircuitJson, child.pcb_component_id, {
        x: targetX,
        y: targetY
      });
    } else {
      const groupChild = child;
      if (groupChild.pcb_group_id && groupChild.source_group_id) {
        repositionPcbGroupTo2(allCircuitJson, groupChild.source_group_id, {
          x: targetX,
          y: targetY
        });
      }
    }
  }
}
function updateGroupDimensions(params) {
  const { db, group, props, gridLayout } = params;
  if (group.pcb_group_id) {
    const groupCenter = group._getGlobalPcbPositionBeforeLayout();
    db.pcb_group.update(group.pcb_group_id, {
      width: props.width ?? gridLayout.containerWidth,
      height: props.height ?? gridLayout.containerHeight,
      center: groupCenter
    });
  }
}

// lib/utils/autorouting/getPresetAutoroutingConfig.ts
function getPresetAutoroutingConfig(autorouterConfig) {
  const defaults = {
    serverUrl: "https://registry-api.tscircuit.com",
    serverMode: "job",
    serverCacheEnabled: true
  };
  if (typeof autorouterConfig === "object" && !autorouterConfig.preset) {
    return {
      local: !(autorouterConfig.serverUrl || autorouterConfig.serverMode || autorouterConfig.serverCacheEnabled),
      ...defaults,
      ...autorouterConfig
    };
  }
  const preset = typeof autorouterConfig === "object" ? autorouterConfig.preset : autorouterConfig;
  const providedConfig = typeof autorouterConfig === "object" ? autorouterConfig : {};
  const normalizedPreset = typeof preset === "string" ? preset.replace(/_/g, "-") : preset;
  switch (normalizedPreset) {
    case "auto-local":
      return {
        local: true,
        groupMode: "subcircuit"
      };
    case "sequential-trace":
      return {
        local: true,
        groupMode: "sequential-trace"
      };
    case "subcircuit":
      return {
        local: true,
        groupMode: "subcircuit"
      };
    case "auto-cloud": {
      const {
        preset: _preset,
        local: _local,
        groupMode: _groupMode,
        ...rest
      } = providedConfig;
      return {
        local: false,
        groupMode: "subcircuit",
        ...defaults,
        ...rest
      };
    }
    case "laser-prefab": {
      const {
        preset: _preset,
        local: _local,
        groupMode: _groupMode,
        ...rest
      } = providedConfig;
      return {
        local: true,
        groupMode: "subcircuit",
        preset: "laser_prefab",
        ...rest
      };
    }
    default:
      return {
        local: true,
        groupMode: "subcircuit"
      };
  }
}

// lib/components/primitive-components/Group/Group_doInitialPcbLayoutPack/Group_doInitialPcbLayoutPack.ts
import {
  pack,
  convertCircuitJsonToPackOutput,
  convertPackOutputToPackInput,
  getGraphicsFromPackOutput
} from "calculate-packing";
import {
  length as length4
} from "circuit-json";
import Debug8 from "debug";

// lib/components/primitive-components/Group/Group_doInitialPcbLayoutPack/applyComponentConstraintClusters.ts
import * as kiwi2 from "@lume/kiwi";
var applyComponentConstraintClusters = (group, packInput) => {
  const constraints = group.children.filter(
    (c) => c.componentName === "Constraint" && c._parsedProps.pcb
  );
  const clusterByRoot = /* @__PURE__ */ new Map();
  const parent = {};
  const find = (x) => {
    if (parent[x] !== x) parent[x] = find(parent[x]);
    return parent[x];
  };
  const union = (a, b) => {
    const ra = find(a);
    const rb = find(b);
    if (ra !== rb) parent[rb] = ra;
  };
  const makeSet = (x) => {
    if (!(x in parent)) parent[x] = x;
  };
  const getIdFromSelector = (sel2) => {
    const name = sel2.startsWith(".") ? sel2.slice(1) : sel2;
    const child = group.children.find((c) => c.name === name);
    return child?.pcb_component_id ?? void 0;
  };
  for (const constraint of constraints) {
    const props = constraint._parsedProps;
    if ("left" in props && "right" in props) {
      const a = getIdFromSelector(props.left);
      const b = getIdFromSelector(props.right);
      if (a && b) {
        makeSet(a);
        makeSet(b);
        union(a, b);
      }
    } else if ("top" in props && "bottom" in props) {
      const a = getIdFromSelector(props.top);
      const b = getIdFromSelector(props.bottom);
      if (a && b) {
        makeSet(a);
        makeSet(b);
        union(a, b);
      }
    } else if ("for" in props && Array.isArray(props.for)) {
      const ids = props.for.map((s) => getIdFromSelector(s)).filter((s) => !!s);
      for (const id of ids) makeSet(id);
      for (let i = 1; i < ids.length; i++) union(ids[0], ids[i]);
    }
  }
  for (const id of Object.keys(parent)) {
    const rootId = find(id);
    if (!clusterByRoot.has(rootId))
      clusterByRoot.set(rootId, { componentIds: [], constraints: [] });
    clusterByRoot.get(rootId).componentIds.push(id);
  }
  for (const constraint of constraints) {
    const props = constraint._parsedProps;
    let compId;
    if ("left" in props) compId = getIdFromSelector(props.left);
    else if ("top" in props) compId = getIdFromSelector(props.top);
    else if ("for" in props) compId = getIdFromSelector(props.for[0]);
    if (!compId) continue;
    const root = find(compId);
    clusterByRoot.get(root)?.constraints.push(constraint);
  }
  const clusterMap = {};
  const packCompById = Object.fromEntries(
    packInput.components.map((c) => [c.componentId, c])
  );
  for (const [rootId, info] of clusterByRoot.entries()) {
    if (info.componentIds.length <= 1) continue;
    const solver = new kiwi2.Solver();
    const kVars = {};
    const getVar = (id, axis) => {
      const key = `${id}_${axis}`;
      if (!kVars[key]) kVars[key] = new kiwi2.Variable(key);
      return kVars[key];
    };
    const anchor = info.componentIds[0];
    solver.addConstraint(
      new kiwi2.Constraint(
        getVar(anchor, "x"),
        kiwi2.Operator.Eq,
        0,
        kiwi2.Strength.required
      )
    );
    solver.addConstraint(
      new kiwi2.Constraint(
        getVar(anchor, "y"),
        kiwi2.Operator.Eq,
        0,
        kiwi2.Strength.required
      )
    );
    for (const constraint of info.constraints) {
      const props = constraint._parsedProps;
      if ("xDist" in props) {
        const left = getIdFromSelector(props.left);
        const right = getIdFromSelector(props.right);
        if (left && right) {
          solver.addConstraint(
            new kiwi2.Constraint(
              new kiwi2.Expression(getVar(right, "x"), [-1, getVar(left, "x")]),
              kiwi2.Operator.Eq,
              props.xDist,
              kiwi2.Strength.required
            )
          );
        }
      } else if ("yDist" in props) {
        const top = getIdFromSelector(props.top);
        const bottom = getIdFromSelector(props.bottom);
        if (top && bottom) {
          solver.addConstraint(
            new kiwi2.Constraint(
              new kiwi2.Expression(getVar(top, "y"), [-1, getVar(bottom, "y")]),
              kiwi2.Operator.Eq,
              props.yDist,
              kiwi2.Strength.required
            )
          );
        }
      } else if ("sameX" in props && Array.isArray(props.for)) {
        const ids = props.for.map((s) => getIdFromSelector(s)).filter((s) => !!s);
        if (ids.length > 1) {
          const base = getVar(ids[0], "x");
          for (let i = 1; i < ids.length; i++) {
            solver.addConstraint(
              new kiwi2.Constraint(
                new kiwi2.Expression(getVar(ids[i], "x"), [-1, base]),
                kiwi2.Operator.Eq,
                0,
                kiwi2.Strength.required
              )
            );
          }
        }
      } else if ("sameY" in props && Array.isArray(props.for)) {
        const ids = props.for.map((s) => getIdFromSelector(s)).filter((s) => !!s);
        if (ids.length > 1) {
          const base = getVar(ids[0], "y");
          for (let i = 1; i < ids.length; i++) {
            solver.addConstraint(
              new kiwi2.Constraint(
                new kiwi2.Expression(getVar(ids[i], "y"), [-1, base]),
                kiwi2.Operator.Eq,
                0,
                kiwi2.Strength.required
              )
            );
          }
        }
      }
    }
    solver.updateVariables();
    const positions = {};
    for (const id of info.componentIds) {
      positions[id] = {
        x: getVar(id, "x").value(),
        y: getVar(id, "y").value()
      };
    }
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const id of info.componentIds) {
      const comp = packCompById[id];
      const pos = positions[id];
      if (!comp) continue;
      for (const pad of comp.pads) {
        const ax = pos.x + pad.offset.x;
        const ay = pos.y + pad.offset.y;
        minX = Math.min(minX, ax - pad.size.x / 2);
        maxX = Math.max(maxX, ax + pad.size.x / 2);
        minY = Math.min(minY, ay - pad.size.y / 2);
        maxY = Math.max(maxY, ay + pad.size.y / 2);
      }
    }
    const clusterCenter = { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
    const mergedPads = [];
    const relCenters = {};
    for (const id of info.componentIds) {
      const comp = packCompById[id];
      const pos = positions[id];
      if (!comp) continue;
      relCenters[id] = {
        x: pos.x - clusterCenter.x,
        y: pos.y - clusterCenter.y
      };
      for (const pad of comp.pads) {
        mergedPads.push({
          padId: pad.padId,
          networkId: pad.networkId,
          type: pad.type,
          size: pad.size,
          offset: {
            x: pos.x + pad.offset.x - clusterCenter.x,
            y: pos.y + pad.offset.y - clusterCenter.y
          }
        });
      }
    }
    packInput.components = packInput.components.filter(
      (c) => !info.componentIds.includes(c.componentId)
    );
    packInput.components.push({
      componentId: info.componentIds[0],
      pads: mergedPads,
      availableRotationDegrees: [0]
    });
    info.relativeCenters = relCenters;
    clusterMap[info.componentIds[0]] = info;
  }
  return clusterMap;
};

// lib/components/primitive-components/Group/Group_doInitialPcbLayoutPack/applyPackOutput.ts
import { translate as translate5, rotate as rotate2, compose as compose4 } from "transformation-matrix";
import {
  transformPCBElements
} from "@tscircuit/circuit-json-util";
import { normalizeDegrees as normalizeDegrees2 } from "@tscircuit/math-utils";
var updateCadRotation = ({
  db,
  pcbComponentId,
  rotationDegrees,
  layer
}) => {
  if (rotationDegrees == null) return;
  if (!db?.cad_component?.list) return;
  const cadComponent = db.cad_component.getWhere({
    pcb_component_id: pcbComponentId
  });
  if (!cadComponent) return;
  const delta = layer?.toLowerCase?.() === "bottom" ? -rotationDegrees : rotationDegrees;
  const currentRotationZ = cadComponent.rotation?.z ?? 0;
  const nextRotation = {
    ...cadComponent.rotation ?? { x: 0, y: 0, z: 0 },
    z: normalizeDegrees2(currentRotationZ + delta)
  };
  db.cad_component.update(cadComponent.cad_component_id, {
    rotation: nextRotation
  });
  cadComponent.rotation = nextRotation;
};
var isDescendantGroup = (db, groupId, ancestorId) => {
  if (groupId === ancestorId) return true;
  const group = db.source_group.get(groupId);
  if (!group || !group.parent_source_group_id) return false;
  return isDescendantGroup(db, group.parent_source_group_id, ancestorId);
};
var applyPackOutput = (group, packOutput, clusterMap) => {
  const { db } = group.root;
  for (const packedComponent of packOutput.components) {
    const { center, componentId, ccwRotationOffset, ccwRotationDegrees } = packedComponent;
    const cluster = clusterMap[componentId];
    if (cluster) {
      const rotationDegrees2 = ccwRotationDegrees ?? ccwRotationOffset ?? 0;
      const angleRad = rotationDegrees2 * Math.PI / 180;
      for (const memberId of cluster.componentIds) {
        const rel = cluster.relativeCenters[memberId];
        if (!rel) continue;
        const rotatedRel = {
          x: rel.x * Math.cos(angleRad) - rel.y * Math.sin(angleRad),
          y: rel.x * Math.sin(angleRad) + rel.y * Math.cos(angleRad)
        };
        const member = db.pcb_component.get(memberId);
        if (!member) continue;
        const originalCenter2 = member.center;
        const transformMatrix2 = compose4(
          group._computePcbGlobalTransformBeforeLayout(),
          translate5(center.x + rotatedRel.x, center.y + rotatedRel.y),
          rotate2(angleRad),
          translate5(-originalCenter2.x, -originalCenter2.y)
        );
        const related = db.toArray().filter(
          (elm) => "pcb_component_id" in elm && elm.pcb_component_id === memberId
        );
        transformPCBElements(related, transformMatrix2);
        updateCadRotation({
          db,
          pcbComponentId: memberId,
          rotationDegrees: rotationDegrees2,
          layer: member.layer
        });
      }
      continue;
    }
    const pcbComponent = db.pcb_component.get(componentId);
    if (pcbComponent) {
      const currentGroupId = group.source_group_id;
      const sourceComponent = db.source_component.get(
        pcbComponent.source_component_id
      );
      const componentGroupId = sourceComponent?.source_group_id;
      if (componentGroupId !== void 0 && !isDescendantGroup(db, componentGroupId, currentGroupId)) {
        continue;
      }
      const originalCenter2 = pcbComponent.center;
      const rotationDegrees2 = ccwRotationDegrees ?? ccwRotationOffset ?? 0;
      const transformMatrix2 = compose4(
        group._computePcbGlobalTransformBeforeLayout(),
        translate5(center.x, center.y),
        rotate2(rotationDegrees2 * Math.PI / 180),
        translate5(-originalCenter2.x, -originalCenter2.y)
      );
      const related = db.toArray().filter(
        (elm) => "pcb_component_id" in elm && elm.pcb_component_id === componentId
      );
      transformPCBElements(related, transformMatrix2);
      updateCadRotation({
        db,
        pcbComponentId: componentId,
        rotationDegrees: rotationDegrees2,
        layer: pcbComponent.layer
      });
      continue;
    }
    const pcbGroup = db.pcb_group.list().find((g) => g.source_group_id === componentId);
    if (!pcbGroup) continue;
    const originalCenter = pcbGroup.center;
    const rotationDegrees = ccwRotationDegrees ?? ccwRotationOffset ?? 0;
    const transformMatrix = compose4(
      group._computePcbGlobalTransformBeforeLayout(),
      translate5(center.x, center.y),
      rotate2(rotationDegrees * Math.PI / 180),
      translate5(-originalCenter.x, -originalCenter.y)
    );
    const relatedElements = db.toArray().filter((elm) => {
      if ("source_group_id" in elm && elm.source_group_id) {
        if (elm.source_group_id === componentId) {
          return true;
        }
        if (isDescendantGroup(db, elm.source_group_id, componentId)) {
          return true;
        }
      }
      if ("source_component_id" in elm && elm.source_component_id) {
        const sourceComponent = db.source_component.get(elm.source_component_id);
        if (sourceComponent?.source_group_id) {
          if (sourceComponent.source_group_id === componentId) {
            return true;
          }
          if (isDescendantGroup(db, sourceComponent.source_group_id, componentId)) {
            return true;
          }
        }
      }
      if ("pcb_component_id" in elm && elm.pcb_component_id) {
        const pcbComp = db.pcb_component.get(elm.pcb_component_id);
        if (pcbComp?.source_component_id) {
          const sourceComp = db.source_component.get(
            pcbComp.source_component_id
          );
          if (sourceComp?.source_group_id) {
            if (sourceComp.source_group_id === componentId) {
              return true;
            }
            if (isDescendantGroup(db, sourceComp.source_group_id, componentId)) {
              return true;
            }
          }
        }
      }
      return false;
    });
    transformPCBElements(relatedElements, transformMatrix);
    db.pcb_group.update(pcbGroup.pcb_group_id, { center });
  }
};

// lib/utils/packing/getObstacleDimensionsFromElement.ts
function getObstacleDimensionsFromSmtPad(pad) {
  switch (pad.shape) {
    case "rect":
    case "rotated_rect":
    case "pill":
    case "rotated_pill":
      return {
        width: pad.width,
        height: pad.height
      };
    case "circle":
      return {
        width: pad.radius * 2,
        height: pad.radius * 2
      };
    case "polygon":
      if (!pad.points || pad.points.length === 0) {
        return null;
      }
      const xs = pad.points.map((p) => p.x);
      const ys = pad.points.map((p) => p.y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      return {
        width: maxX - minX,
        height: maxY - minY
      };
    default:
      return null;
  }
}
function getObstacleDimensionsFromPlatedHole(hole) {
  switch (hole.shape) {
    case "circular_hole_with_rect_pad":
    case "pill_hole_with_rect_pad":
    case "rotated_pill_hole_with_rect_pad":
      return {
        width: hole.rect_pad_width,
        height: hole.rect_pad_height
      };
    case "circle":
      return {
        width: hole.outer_diameter,
        height: hole.outer_diameter
      };
    case "oval":
      return {
        width: hole.outer_width,
        height: hole.outer_height
      };
    case "pill":
      return {
        width: hole.outer_width,
        height: hole.outer_height
      };
    case "hole_with_polygon_pad":
      if (!("pad_outline" in hole) || !hole.pad_outline || hole.pad_outline.length === 0) {
        return null;
      }
      const xs = hole.pad_outline.map((p) => p.x);
      const ys = hole.pad_outline.map((p) => p.y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      return {
        width: maxX - minX,
        height: maxY - minY
      };
    default:
      return null;
  }
}

// lib/components/primitive-components/Group/Group_doInitialPcbLayoutPack/Group_doInitialPcbLayoutPack.ts
var DEFAULT_MIN_GAP = "1mm";
var debug6 = Debug8("Group_doInitialPcbLayoutPack");
var Group_doInitialPcbLayoutPack = (group) => {
  const { db } = group.root;
  const { _parsedProps: props } = group;
  const {
    packOrderStrategy,
    packPlacementStrategy,
    gap: gapProp,
    pcbGap,
    pcbPackGap
  } = props;
  const gap = pcbPackGap ?? pcbGap ?? gapProp;
  const gapMm = length4.parse(gap ?? DEFAULT_MIN_GAP);
  const chipMarginsMap = {};
  const excludedPcbComponentIds = /* @__PURE__ */ new Set();
  const collectMargins = (comp) => {
    if (comp?.pcb_component_id && comp?._parsedProps) {
      const props2 = comp._parsedProps;
      const left = length4.parse(props2.pcbMarginLeft ?? props2.pcbMarginX ?? 0);
      const right = length4.parse(props2.pcbMarginRight ?? props2.pcbMarginX ?? 0);
      const top = length4.parse(props2.pcbMarginTop ?? props2.pcbMarginY ?? 0);
      const bottom = length4.parse(
        props2.pcbMarginBottom ?? props2.pcbMarginY ?? 0
      );
      if (left || right || top || bottom) {
        chipMarginsMap[comp.pcb_component_id] = { left, right, top, bottom };
      }
    }
    if (comp?.children) comp.children.forEach(collectMargins);
  };
  collectMargins(group);
  const excludedPcbGroupIds = /* @__PURE__ */ new Set();
  for (const child of group.children) {
    const childIsGroupOrNormalComponent = child;
    if (childIsGroupOrNormalComponent._isNormalComponent && childIsGroupOrNormalComponent.isRelativelyPositioned?.()) {
      if (childIsGroupOrNormalComponent.pcb_component_id) {
        excludedPcbComponentIds.add(
          childIsGroupOrNormalComponent.pcb_component_id
        );
      }
      if (childIsGroupOrNormalComponent.pcb_group_id) {
        excludedPcbGroupIds.add(
          childIsGroupOrNormalComponent.pcb_group_id
        );
      }
    }
  }
  const filteredCircuitJson = db.toArray().filter((element) => {
    if (element.type === "pcb_component") {
      return !excludedPcbComponentIds.has(element.pcb_component_id);
    }
    if (element.type === "pcb_group") {
      return !excludedPcbGroupIds.has(element.pcb_group_id);
    }
    return true;
  });
  const obstaclesFromRelativelyPositionedComponents = [];
  for (const pcb_component_id of excludedPcbComponentIds) {
    const component = db.toArray().find(
      (el) => el.type === "pcb_component" && el.pcb_component_id === pcb_component_id
    );
    if (!component) continue;
    const componentX = component.center.x;
    const componentY = component.center.y;
    const smtpads = db.toArray().filter(
      (el) => el.type === "pcb_smtpad" && el.pcb_component_id === pcb_component_id
    );
    for (const pad of smtpads) {
      const dimensions = getObstacleDimensionsFromSmtPad(pad);
      if (!dimensions || dimensions.width === 0 || dimensions.height === 0) {
        continue;
      }
      let centerX;
      let centerY;
      if (pad.shape === "polygon") {
        const xs = pad.points.map((p) => p.x);
        const ys = pad.points.map((p) => p.y);
        centerX = componentX + (Math.min(...xs) + Math.max(...xs)) / 2;
        centerY = componentY + (Math.min(...ys) + Math.max(...ys)) / 2;
      } else {
        centerX = componentX + pad.x;
        centerY = componentY + pad.y;
      }
      obstaclesFromRelativelyPositionedComponents.push({
        obstacleId: pad.pcb_smtpad_id,
        absoluteCenter: { x: centerX, y: centerY },
        width: dimensions.width,
        height: dimensions.height
      });
    }
    const platedHoles = db.toArray().filter(
      (el) => el.type === "pcb_plated_hole" && el.pcb_component_id === pcb_component_id
    );
    for (const hole of platedHoles) {
      const dimensions = getObstacleDimensionsFromPlatedHole(hole);
      if (!dimensions || dimensions.width === 0 || dimensions.height === 0) {
        continue;
      }
      const centerX = componentX + hole.x;
      const centerY = componentY + hole.y;
      obstaclesFromRelativelyPositionedComponents.push({
        obstacleId: hole.pcb_plated_hole_id,
        absoluteCenter: { x: centerX, y: centerY },
        width: dimensions.width,
        height: dimensions.height
      });
    }
  }
  let bounds;
  if (props.width !== void 0 && props.height !== void 0) {
    const widthMm = length4.parse(props.width);
    const heightMm = length4.parse(props.height);
    bounds = {
      minX: -widthMm / 2,
      maxX: widthMm / 2,
      minY: -heightMm / 2,
      maxY: heightMm / 2
    };
  }
  const packInput = {
    ...convertPackOutputToPackInput(
      convertCircuitJsonToPackOutput(filteredCircuitJson, {
        source_group_id: group.source_group_id,
        shouldAddInnerObstacles: true,
        chipMarginsMap
      })
    ),
    // @ts-expect-error we're missing some pack order strategies
    orderStrategy: packOrderStrategy ?? "largest_to_smallest",
    placementStrategy: packPlacementStrategy ?? "minimum_sum_squared_distance_to_network",
    minGap: gapMm,
    obstacles: obstaclesFromRelativelyPositionedComponents,
    bounds
  };
  const clusterMap = applyComponentConstraintClusters(group, packInput);
  if (debug6.enabled) {
    group.root?.emit("debug:logOutput", {
      type: "debug:logOutput",
      name: `packInput-circuitjson-${group.name}`,
      content: JSON.stringify(db.toArray())
    });
    group.root?.emit("debug:logOutput", {
      type: "debug:logOutput",
      name: `packInput-${group.name}`,
      content: packInput
    });
  }
  const packOutput = pack(packInput);
  if (debug6.enabled && global?.debugGraphics) {
    const graphics = getGraphicsFromPackOutput(packOutput);
    graphics.title = `packOutput-${group.name}`;
    global.debugGraphics?.push(graphics);
  }
  applyPackOutput(group, packOutput, clusterMap);
};

// lib/components/primitive-components/Group/Group_doInitialPcbLayoutFlex.ts
import { getMinimumFlexContainer as getMinimumFlexContainer2 } from "@tscircuit/circuit-json-util";
import { RootFlexBox as RootFlexBox2 } from "@tscircuit/miniflex";
import { length as length5 } from "circuit-json";
var Group_doInitialPcbLayoutFlex = (group) => {
  const { db } = group.root;
  const { _parsedProps: props } = group;
  const pcbChildren = group.children.filter(
    (c) => c.pcb_component_id || c.pcb_group_id
  );
  const anyChildHasExplicitPcbPosition = pcbChildren.some((child) => {
    const childProps = child._parsedProps;
    return childProps?.pcbX !== void 0 || childProps?.pcbY !== void 0;
  });
  if (anyChildHasExplicitPcbPosition) {
    return;
  }
  const rawJustify = props.pcbJustifyContent ?? props.justifyContent;
  const rawAlign = props.pcbAlignItems ?? props.alignItems;
  const rawGap = props.pcbFlexGap ?? props.pcbGap ?? props.gap;
  const direction = props.pcbFlexDirection ?? "row";
  const justifyContent = {
    start: "flex-start",
    end: "flex-end",
    "flex-start": "flex-start",
    "flex-end": "flex-end",
    stretch: "space-between",
    "space-between": "space-between",
    "space-around": "space-around",
    "space-evenly": "space-evenly",
    center: "center"
  }[rawJustify ?? "space-between"];
  const alignItems = {
    start: "flex-start",
    end: "flex-end",
    "flex-start": "flex-start",
    "flex-end": "flex-end",
    stretch: "stretch",
    center: "center"
  }[rawAlign ?? "center"];
  if (!justifyContent) {
    throw new Error(`Invalid justifyContent value: "${rawJustify}"`);
  }
  if (!alignItems) {
    throw new Error(`Invalid alignItems value: "${rawAlign}"`);
  }
  let rowGap = 0;
  let columnGap = 0;
  if (typeof rawGap === "object") {
    rowGap = rawGap.y ?? 0;
    columnGap = rawGap.x ?? 0;
  } else if (typeof rawGap === "number") {
    rowGap = rawGap;
    columnGap = rawGap;
  } else if (typeof rawGap === "string") {
    rowGap = length5.parse(rawGap);
    columnGap = length5.parse(rawGap);
  }
  let minFlexContainer;
  let width = props.width ?? props.pcbWidth ?? void 0;
  let height = props.height ?? props.pcbHeight ?? void 0;
  const isInline = Boolean(width === void 0 || height === void 0);
  if (isInline) {
    minFlexContainer = getMinimumFlexContainer2(
      pcbChildren.map((child) => child._getMinimumFlexContainerSize()).filter((size) => size !== null),
      {
        alignItems,
        justifyContent,
        direction,
        rowGap,
        columnGap
      }
    );
    width = minFlexContainer.width;
    height = minFlexContainer.height;
  }
  const flexBox = new RootFlexBox2(width, height, {
    alignItems,
    justifyContent,
    direction,
    rowGap,
    columnGap
  });
  for (const child of pcbChildren) {
    const size = child._getMinimumFlexContainerSize();
    flexBox.addChild({
      metadata: child,
      // TODO these should be minWidth/minHeight
      width: size?.width ?? 0,
      height: size?.height ?? 0,
      // TODO allow overriding flexBasis
      flexBasis: !size ? void 0 : direction === "row" ? size.width : size.height
      // TODO alignSelf, flexGrow, flexShrink etc.
    });
  }
  flexBox.build();
  const bounds = {
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity,
    width: 0,
    height: 0
  };
  for (const child of flexBox.children) {
    bounds.minX = Math.min(bounds.minX, child.position.x);
    bounds.minY = Math.min(bounds.minY, child.position.y);
    bounds.maxX = Math.max(bounds.maxX, child.position.x + child.size.width);
    bounds.maxY = Math.max(bounds.maxY, child.position.y + child.size.height);
  }
  bounds.width = bounds.maxX - bounds.minX;
  bounds.height = bounds.maxY - bounds.minY;
  const groupCenter = group._getGlobalPcbPositionBeforeLayout();
  const offset = {
    x: groupCenter.x - (bounds.maxX + bounds.minX) / 2,
    y: groupCenter.y - (bounds.maxY + bounds.minY) / 2
  };
  for (const child of flexBox.children) {
    const childMetadata = child.metadata;
    childMetadata._repositionOnPcb({
      x: child.position.x + child.size.width / 2 + offset.x,
      y: child.position.y + child.size.height / 2 + offset.y
    });
  }
  db.pcb_group.update(group.pcb_group_id, {
    width: bounds.width,
    height: bounds.height,
    center: groupCenter
  });
};

// lib/components/primitive-components/Group/Group.ts
import { convertSrjToGraphicsObject } from "@tscircuit/capacity-autorouter";

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/Group_doInitialSchematicTraceRender.ts
import { SchematicTracePipelineSolver as SchematicTracePipelineSolver4 } from "@tscircuit/schematic-trace-solver";
import Debug11 from "debug";

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/createSchematicTraceSolverInputProblem.ts
import "@tscircuit/schematic-trace-solver";
function createSchematicTraceSolverInputProblem(group) {
  const { db } = group.root;
  const sckToSourceNet = /* @__PURE__ */ new Map();
  const sckToUserNetId = /* @__PURE__ */ new Map();
  const allScks = /* @__PURE__ */ new Set();
  const traces = group.selectAll("trace");
  const displayLabelTraces = traces.filter(
    (t) => t._parsedProps?.schDisplayLabel
  );
  const childGroups = group.selectAll("group");
  const allSchematicGroupIds = [
    group.schematic_group_id,
    ...childGroups.map((a) => a.schematic_group_id)
  ];
  const schematicComponents = db.schematic_component.list().filter((a) => allSchematicGroupIds.includes(a.schematic_group_id));
  const chips = [];
  const pinIdToSchematicPortId = /* @__PURE__ */ new Map();
  const schematicPortIdToPinId = /* @__PURE__ */ new Map();
  for (const schematicComponent of schematicComponents) {
    const chipId = schematicComponent.schematic_component_id;
    const pins = [];
    const sourceComponent = db.source_component.getWhere({
      source_component_id: schematicComponent.source_component_id
    });
    const schematicPorts = db.schematic_port.list({
      schematic_component_id: schematicComponent.schematic_component_id
    });
    for (const schematicPort of schematicPorts) {
      const pinId = `${sourceComponent?.name ?? schematicComponent.schematic_component_id}.${schematicPort.pin_number}`;
      pinIdToSchematicPortId.set(pinId, schematicPort.schematic_port_id);
      schematicPortIdToPinId.set(schematicPort.schematic_port_id, pinId);
    }
    for (const schematicPort of schematicPorts) {
      const pinId = schematicPortIdToPinId.get(schematicPort.schematic_port_id);
      pins.push({
        pinId,
        x: schematicPort.center.x,
        y: schematicPort.center.y
      });
    }
    chips.push({
      chipId,
      center: schematicComponent.center,
      width: schematicComponent.size.width,
      height: schematicComponent.size.height,
      pins
    });
  }
  const allSourceAndSchematicPortIdsInScope = /* @__PURE__ */ new Set();
  const schPortIdToSourcePortId = /* @__PURE__ */ new Map();
  const sourcePortIdToSchPortId = /* @__PURE__ */ new Map();
  const userNetIdToSck = /* @__PURE__ */ new Map();
  for (const sc of schematicComponents) {
    const ports = db.schematic_port.list({
      schematic_component_id: sc.schematic_component_id
    });
    for (const sp of ports) {
      allSourceAndSchematicPortIdsInScope.add(sp.schematic_port_id);
      if (sp.source_port_id) {
        schPortIdToSourcePortId.set(sp.schematic_port_id, sp.source_port_id);
        sourcePortIdToSchPortId.set(sp.source_port_id, sp.schematic_port_id);
      }
    }
  }
  const allowedSubcircuitIds = /* @__PURE__ */ new Set();
  if (group.subcircuit_id) allowedSubcircuitIds.add(group.subcircuit_id);
  for (const cg of childGroups) {
    if (cg.subcircuit_id) allowedSubcircuitIds.add(cg.subcircuit_id);
  }
  const tracesInScope = db.source_trace.list().filter((st) => {
    if (st.subcircuit_id === group.subcircuit_id) return true;
    for (const source_port_id of st.connected_source_port_ids) {
      if (sourcePortIdToSchPortId.has(source_port_id)) return true;
    }
    return false;
  });
  const externalNetIds = tracesInScope.flatMap(
    (st) => st.connected_source_net_ids
  );
  for (const netId of externalNetIds) {
    const net = db.source_net.get(netId);
    if (net?.subcircuit_id) {
      allowedSubcircuitIds.add(net.subcircuit_id);
    }
  }
  const directConnections = [];
  const pairKeyToSourceTraceId = /* @__PURE__ */ new Map();
  for (const st of db.source_trace.list()) {
    if (st.subcircuit_id && !allowedSubcircuitIds.has(st.subcircuit_id)) {
      continue;
    }
    const connected = (st.connected_source_port_ids ?? []).map((srcId) => sourcePortIdToSchPortId.get(srcId)).filter(
      (sourcePortId) => Boolean(sourcePortId) && allSourceAndSchematicPortIdsInScope.has(sourcePortId)
    );
    if (connected.length >= 2) {
      const [a, b] = connected.slice(0, 2);
      const pairKey = [a, b].sort().join("::");
      if (!pairKeyToSourceTraceId.has(pairKey)) {
        pairKeyToSourceTraceId.set(pairKey, st.source_trace_id);
        const userNetId = st.display_name ?? st.source_trace_id;
        if (st.subcircuit_connectivity_map_key) {
          allScks.add(st.subcircuit_connectivity_map_key);
          userNetIdToSck.set(userNetId, st.subcircuit_connectivity_map_key);
          sckToUserNetId.set(st.subcircuit_connectivity_map_key, userNetId);
        }
        directConnections.push({
          pinIds: [a, b].map((id) => schematicPortIdToPinId.get(id)),
          netId: userNetId
        });
      }
    }
  }
  const netConnections = [];
  for (const net of db.source_net.list().filter(
    (n) => !n.subcircuit_id || allowedSubcircuitIds.has(n.subcircuit_id)
  )) {
    if (net.subcircuit_connectivity_map_key) {
      allScks.add(net.subcircuit_connectivity_map_key);
      sckToSourceNet.set(net.subcircuit_connectivity_map_key, net);
    }
  }
  const sckToPinIds = /* @__PURE__ */ new Map();
  for (const [schId, srcPortId] of schPortIdToSourcePortId) {
    const sp = db.source_port.get(srcPortId);
    if (!sp?.subcircuit_connectivity_map_key) continue;
    const sck = sp.subcircuit_connectivity_map_key;
    allScks.add(sck);
    if (!sckToPinIds.has(sck)) sckToPinIds.set(sck, []);
    sckToPinIds.get(sck).push(schId);
  }
  for (const [subcircuitConnectivityKey, schematicPortIds] of sckToPinIds) {
    const sourceNet = sckToSourceNet.get(subcircuitConnectivityKey);
    if (sourceNet && schematicPortIds.length >= 2) {
      const userNetId = String(
        sourceNet.name || sourceNet.source_net_id || subcircuitConnectivityKey
      );
      userNetIdToSck.set(userNetId, subcircuitConnectivityKey);
      sckToUserNetId.set(subcircuitConnectivityKey, userNetId);
      const fontSize = 0.18;
      const charWidth = 0.1 * (fontSize / 0.18);
      const netLabelWidth = Number(
        (String(userNetId).length * charWidth).toFixed(2)
      );
      netConnections.push({
        netId: userNetId,
        pinIds: schematicPortIds.map(
          (portId) => schematicPortIdToPinId.get(portId)
        ),
        netLabelWidth
      });
    }
  }
  const availableNetLabelOrientations = (() => {
    const netToAllowedOrientations = {};
    const presentNetIds = new Set(netConnections.map((nc) => nc.netId));
    for (const net of db.source_net.list().filter(
      (n) => !n.subcircuit_id || allowedSubcircuitIds.has(n.subcircuit_id)
    )) {
      if (!net.name) continue;
      if (!presentNetIds.has(net.name)) continue;
      if (net.is_ground || net.name.toLowerCase().startsWith("gnd")) {
        netToAllowedOrientations[net.name] = ["y-"];
      } else if (net.is_power || net.name.toLowerCase().startsWith("v")) {
        netToAllowedOrientations[net.name] = ["y+"];
      } else {
        netToAllowedOrientations[net.name] = ["x-", "x+"];
      }
    }
    return netToAllowedOrientations;
  })();
  const inputProblem = {
    chips,
    directConnections,
    netConnections,
    availableNetLabelOrientations,
    maxMspPairDistance: group._parsedProps.schMaxTraceDistance ?? 2.4
  };
  return {
    inputProblem,
    pinIdToSchematicPortId,
    pairKeyToSourceTraceId,
    sckToSourceNet,
    sckToUserNetId,
    userNetIdToSck,
    allSourceAndSchematicPortIdsInScope,
    schPortIdToSourcePortId,
    displayLabelTraces,
    allScks
  };
}

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/applyTracesFromSolverOutput.ts
import "@tscircuit/schematic-trace-solver";

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/compute-crossings.ts
var TOL = 1e-6;
function isHorizontalEdge(edge) {
  const dx = Math.abs(edge.to.x - edge.from.x);
  const dy = Math.abs(edge.to.y - edge.from.y);
  return dx >= dy;
}
function length6(a, b) {
  return Math.hypot(b.x - a.x, b.y - a.y);
}
function pointAt(a, b, t) {
  return { x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t };
}
function paramAlong(a, b, p) {
  const L = length6(a, b);
  if (L < TOL) return 0;
  const t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / ((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));
  return Math.max(0, Math.min(1, t)) * L;
}
function cross(ax, ay, bx, by) {
  return ax * by - ay * bx;
}
function segmentIntersection(p1, p2, q1, q2) {
  const r = { x: p2.x - p1.x, y: p2.y - p1.y };
  const s = { x: q2.x - q1.x, y: q2.y - q1.y };
  const rxs = cross(r.x, r.y, s.x, s.y);
  const q_p = { x: q1.x - p1.x, y: q1.y - p1.y };
  const q_pxr = cross(q_p.x, q_p.y, r.x, r.y);
  if (Math.abs(rxs) < TOL && Math.abs(q_pxr) < TOL) {
    return null;
  }
  if (Math.abs(rxs) < TOL && Math.abs(q_pxr) >= TOL) {
    return null;
  }
  const t = cross(q_p.x, q_p.y, s.x, s.y) / rxs;
  const u = cross(q_p.x, q_p.y, r.x, r.y) / rxs;
  if (t < -TOL || t > 1 + TOL || u < -TOL || u > 1 + TOL) return null;
  const pt = { x: p1.x + t * r.x, y: p1.y + t * r.y };
  return pt;
}
function mergeIntervals(intervals, tol = TOL) {
  if (intervals.length === 0) return intervals;
  intervals.sort((a, b) => a.start - b.start);
  const merged = [];
  let cur = { ...intervals[0] };
  for (let i = 1; i < intervals.length; i++) {
    const nxt = intervals[i];
    if (nxt.start <= cur.end + tol) {
      cur.end = Math.max(cur.end, nxt.end);
    } else {
      merged.push(cur);
      cur = { ...nxt };
    }
  }
  merged.push(cur);
  return merged;
}
function splitEdgeByCrossings(edge, crossingDistances, crossLen) {
  const L = length6(edge.from, edge.to);
  if (L < TOL || crossingDistances.length === 0) return [edge];
  const half = crossLen / 2;
  const rawIntervals = crossingDistances.map((d) => ({
    start: Math.max(0, d - half),
    end: Math.min(L, d + half)
  })).filter((iv) => iv.end - iv.start > TOL);
  const intervals = mergeIntervals(rawIntervals);
  const result = [];
  let cursor = 0;
  const dir = { x: edge.to.x - edge.from.x, y: edge.to.y - edge.from.y };
  const addSeg = (d0, d1, isCrossing) => {
    if (d1 - d0 <= TOL) return;
    const t0 = d0 / L;
    const t1 = d1 / L;
    result.push({
      from: pointAt(edge.from, edge.to, t0),
      to: pointAt(edge.from, edge.to, t1),
      ...isCrossing ? { is_crossing: true } : {}
    });
  };
  for (const iv of intervals) {
    if (iv.start - cursor > TOL) {
      addSeg(cursor, iv.start, false);
    }
    addSeg(iv.start, iv.end, true);
    cursor = iv.end;
  }
  if (L - cursor > TOL) {
    addSeg(cursor, L, false);
  }
  return result.length > 0 ? result : [edge];
}
function computeCrossings(traces, opts = {}) {
  const crossLen = opts.crossSegmentLength ?? 0.075;
  const tol = opts.tolerance ?? TOL;
  const crossingsByEdge = /* @__PURE__ */ new Map();
  const keyOf = (ref) => `${ref.traceIdx}:${ref.edgeIdx}`;
  const getEdge = (ref) => traces[ref.traceIdx].edges[ref.edgeIdx];
  for (let ti = 0; ti < traces.length; ti++) {
    const A = traces[ti];
    for (let ei = 0; ei < A.edges.length; ei++) {
      const eA = A.edges[ei];
      for (let tj = ti; tj < traces.length; tj++) {
        const B = traces[tj];
        for (let ej = tj === ti ? ei + 1 : 0; ej < B.edges.length; ej++) {
          const eB = B.edges[ej];
          const P = segmentIntersection(eA.from, eA.to, eB.from, eB.to);
          if (!P) continue;
          const LA = length6(eA.from, eA.to);
          const LB = length6(eB.from, eB.to);
          if (LA < tol || LB < tol) continue;
          const dA = paramAlong(eA.from, eA.to, P);
          const dB = paramAlong(eB.from, eB.to, P);
          const nearEndpointA = dA <= tol || Math.abs(LA - dA) <= tol || Number.isNaN(dA);
          const nearEndpointB = dB <= tol || Math.abs(LB - dB) <= tol || Number.isNaN(dB);
          if (!nearEndpointA && !nearEndpointB) {
            const aIsHorizontal = isHorizontalEdge(eA);
            const bIsHorizontal = isHorizontalEdge(eB);
            let assignToA;
            if (aIsHorizontal !== bIsHorizontal) {
              assignToA = aIsHorizontal;
            } else {
              const ax = Math.abs(eA.to.x - eA.from.x);
              const ay = Math.abs(eA.to.y - eA.from.y);
              const bx = Math.abs(eB.to.x - eB.from.x);
              const by = Math.abs(eB.to.y - eB.from.y);
              const aScore = ax - ay;
              const bScore = bx - by;
              assignToA = aScore === bScore ? true : aScore > bScore;
            }
            const chosenKey = keyOf({
              traceIdx: assignToA ? ti : tj,
              edgeIdx: assignToA ? ei : ej
            });
            const chosenList = crossingsByEdge.get(chosenKey) ?? [];
            chosenList.push(assignToA ? dA : dB);
            crossingsByEdge.set(chosenKey, chosenList);
          }
        }
      }
    }
  }
  const out = traces.map((t) => ({
    source_trace_id: t.source_trace_id,
    edges: []
  }));
  for (let ti = 0; ti < traces.length; ti++) {
    const trace = traces[ti];
    for (let ei = 0; ei < trace.edges.length; ei++) {
      const eRefKey = keyOf({ traceIdx: ti, edgeIdx: ei });
      const splittingDistances = crossingsByEdge.get(eRefKey) ?? [];
      if (splittingDistances.length === 0) {
        out[ti].edges.push(trace.edges[ei]);
        continue;
      }
      const uniqueSorted = Array.from(
        new Set(splittingDistances.map((d) => Number(d.toFixed(6))))
      ).sort((a, b) => a - b);
      const split = splitEdgeByCrossings(
        trace.edges[ei],
        uniqueSorted,
        crossLen
      );
      out[ti].edges.push(...split);
    }
  }
  return out;
}

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/compute-junctions.ts
var TOL2 = 1e-6;
function nearlyEqual(a, b, tol = TOL2) {
  return Math.abs(a - b) <= tol;
}
function pointEq(a, b, tol = TOL2) {
  return nearlyEqual(a.x, b.x, tol) && nearlyEqual(a.y, b.y, tol);
}
function onSegment(p, a, b, tol = TOL2) {
  const minX = Math.min(a.x, b.x) - tol;
  const maxX = Math.max(a.x, b.x) + tol;
  const minY = Math.min(a.y, b.y) - tol;
  const maxY = Math.max(a.y, b.y) + tol;
  if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) return false;
  const area = Math.abs((b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x));
  return area <= tol;
}
function dedupePoints(points, tol = TOL2) {
  const map = /* @__PURE__ */ new Map();
  for (const p of points) {
    const key = `${p.x.toFixed(6)},${p.y.toFixed(6)}`;
    if (!map.has(key)) map.set(key, p);
  }
  return Array.from(map.values());
}
function edgeVec(e) {
  return { x: e.to.x - e.from.x, y: e.to.y - e.from.y };
}
function isParallel(e1, e2, tol = TOL2) {
  const v1 = edgeVec(e1);
  const v2 = edgeVec(e2);
  const L1 = Math.hypot(v1.x, v1.y);
  const L2 = Math.hypot(v2.x, v2.y);
  if (L1 < tol || L2 < tol) return true;
  const cross2 = v1.x * v2.y - v1.y * v2.x;
  return Math.abs(cross2) <= tol * L1 * L2;
}
function incidentEdgesAtPoint(trace, p, tol = TOL2) {
  return trace.edges.filter(
    (e) => pointEq(e.from, p, tol) || pointEq(e.to, p, tol)
  );
}
function nearestEndpointOnTrace(trace, p, tol = TOL2) {
  for (const e of trace.edges) {
    if (pointEq(e.from, p, tol)) return e.from;
    if (pointEq(e.to, p, tol)) return e.to;
  }
  return null;
}
function edgeDirectionFromPoint(e, p, tol = TOL2) {
  const other = pointEq(e.from, p, tol) || nearlyEqual(e.from.x, p.x, tol) && nearlyEqual(e.from.y, p.y, tol) ? e.to : e.from;
  const dx = other.x - p.x;
  const dy = other.y - p.y;
  if (Math.abs(dx) < tol && Math.abs(dy) < tol) return null;
  if (Math.abs(dx) >= Math.abs(dy)) {
    return dx >= 0 ? "right" : "left";
  }
  return dy >= 0 ? "up" : "down";
}
function getCornerOrientationAtPoint(trace, p, tol = TOL2) {
  const incident = incidentEdgesAtPoint(trace, p, tol);
  if (incident.length < 2) return null;
  const dirs = incident.map((e) => edgeDirectionFromPoint(e, p, tol));
  const hasUp = dirs.includes("up");
  const hasDown = dirs.includes("down");
  const hasLeft = dirs.includes("left");
  const hasRight = dirs.includes("right");
  const vertical = hasUp ? "up" : hasDown ? "down" : null;
  const horizontal = hasRight ? "right" : hasLeft ? "left" : null;
  if (vertical && horizontal) {
    return `${vertical}-${horizontal}`;
  }
  return null;
}
function computeJunctions(traces, opts = {}) {
  const tol = opts.tolerance ?? TOL2;
  const result = {};
  for (const t of traces) result[t.source_trace_id] = [];
  const endpointsByTrace = traces.map((t) => {
    const pts = [];
    for (const e of t.edges) {
      pts.push(e.from, e.to);
    }
    return dedupePoints(pts, tol);
  });
  for (let i = 0; i < traces.length; i++) {
    const A = traces[i];
    const AEnds = endpointsByTrace[i];
    for (let j = i + 1; j < traces.length; j++) {
      const B = traces[j];
      const BEnds = endpointsByTrace[j];
      for (const pa of AEnds) {
        for (const pb of BEnds) {
          if (pointEq(pa, pb, tol)) {
            const aEdgesAtP = incidentEdgesAtPoint(A, pa, tol);
            const bEdgesAtP = incidentEdgesAtPoint(B, pb, tol);
            const hasCorner = aEdgesAtP.some(
              (eA) => bEdgesAtP.some((eB) => !isParallel(eA, eB, tol))
            );
            const aCorner = getCornerOrientationAtPoint(A, pa, tol);
            const bCorner = getCornerOrientationAtPoint(B, pb, tol);
            const sameCornerOrientation = aCorner !== null && bCorner !== null && aCorner === bCorner;
            if (hasCorner && !sameCornerOrientation) {
              result[A.source_trace_id].push(pa);
              if (A.source_trace_id !== B.source_trace_id)
                result[B.source_trace_id].push(pb);
            }
          }
        }
      }
      for (const pa of AEnds) {
        for (const eB of B.edges) {
          if (onSegment(pa, eB.from, eB.to, tol)) {
            const aEdgesAtP = incidentEdgesAtPoint(A, pa, tol);
            const hasCorner = aEdgesAtP.some((eA) => !isParallel(eA, eB, tol));
            const aCorner = getCornerOrientationAtPoint(A, pa, tol);
            const bEndpointNearPa = nearestEndpointOnTrace(B, pa, tol * 1e3);
            const bCorner = bEndpointNearPa ? getCornerOrientationAtPoint(B, bEndpointNearPa, tol) : null;
            const sameCornerOrientation = aCorner !== null && bCorner !== null && aCorner === bCorner;
            if (hasCorner && !sameCornerOrientation) {
              result[A.source_trace_id].push(pa);
              if (A.source_trace_id !== B.source_trace_id)
                result[B.source_trace_id].push(pa);
            }
          }
        }
      }
      for (const pb of BEnds) {
        for (const eA of A.edges) {
          if (onSegment(pb, eA.from, eA.to, tol)) {
            const bEdgesAtP = incidentEdgesAtPoint(B, pb, tol);
            const hasCorner = bEdgesAtP.some((eB) => !isParallel(eA, eB, tol));
            const bCorner = getCornerOrientationAtPoint(B, pb, tol);
            const aEndpointNearPb = nearestEndpointOnTrace(A, pb, tol * 1e3);
            const aCorner = aEndpointNearPb ? getCornerOrientationAtPoint(A, aEndpointNearPb, tol) : null;
            const sameCornerOrientation = aCorner !== null && bCorner !== null && aCorner === bCorner;
            if (hasCorner && !sameCornerOrientation) {
              result[B.source_trace_id].push(pb);
              if (A.source_trace_id !== B.source_trace_id)
                result[A.source_trace_id].push(pb);
            }
          }
        }
      }
    }
  }
  for (const id of Object.keys(result)) {
    result[id] = dedupePoints(result[id], tol);
  }
  return result;
}

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/applyTracesFromSolverOutput.ts
import Debug9 from "debug";
var debug7 = Debug9("Group_doInitialSchematicTraceRender");
function applyTracesFromSolverOutput(args) {
  const { group, solver, pinIdToSchematicPortId, userNetIdToSck } = args;
  const { db } = group.root;
  const traces = solver.traceCleanupSolver?.getOutput().traces ?? solver.traceLabelOverlapAvoidanceSolver?.getOutput().traces ?? solver.schematicTraceLinesSolver?.solvedTracePaths;
  const pendingTraces = [];
  debug7(`Traces inside SchematicTraceSolver output: ${(traces ?? []).length}`);
  for (const solvedTracePath of traces ?? []) {
    const points = solvedTracePath?.tracePath;
    if (!Array.isArray(points) || points.length < 2) {
      debug7(
        `Skipping trace ${solvedTracePath?.pinIds.join(",")} because it has less than 2 points`
      );
      continue;
    }
    const edges = [];
    for (let i = 0; i < points.length - 1; i++) {
      edges.push({
        from: { x: points[i].x, y: points[i].y },
        to: { x: points[i + 1].x, y: points[i + 1].y }
      });
    }
    let source_trace_id = null;
    let subcircuit_connectivity_map_key;
    if (Array.isArray(solvedTracePath?.pins) && solvedTracePath.pins.length === 2) {
      const pA = pinIdToSchematicPortId.get(solvedTracePath.pins[0]?.pinId);
      const pB = pinIdToSchematicPortId.get(solvedTracePath.pins[1]?.pinId);
      if (pA && pB) {
        for (const schPid of [pA, pB]) {
          const existing = db.schematic_port.get(schPid);
          if (existing) db.schematic_port.update(schPid, { is_connected: true });
        }
        subcircuit_connectivity_map_key = userNetIdToSck.get(
          String(solvedTracePath.userNetId)
        );
      }
    }
    if (!source_trace_id) {
      source_trace_id = `solver_${solvedTracePath?.mspPairId}`;
      subcircuit_connectivity_map_key = userNetIdToSck.get(
        String(solvedTracePath.userNetId)
      );
    }
    pendingTraces.push({
      source_trace_id,
      edges,
      subcircuit_connectivity_map_key
    });
  }
  debug7(
    `Applying ${pendingTraces.length} traces from SchematicTraceSolver output`
  );
  const withCrossings = computeCrossings(
    pendingTraces.map((t) => ({
      source_trace_id: t.source_trace_id,
      edges: t.edges
    }))
  );
  const junctionsById = computeJunctions(withCrossings);
  for (const t of withCrossings) {
    db.schematic_trace.insert({
      source_trace_id: t.source_trace_id,
      edges: t.edges,
      junctions: junctionsById[t.source_trace_id] ?? [],
      subcircuit_connectivity_map_key: pendingTraces.find(
        (p) => p.source_trace_id === t.source_trace_id
      )?.subcircuit_connectivity_map_key
    });
  }
}

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/applyNetLabelPlacements.ts
import "@tscircuit/schematic-trace-solver";

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/oppositeSide.ts
var oppositeSide = (input) => {
  switch (input) {
    case "x+":
      return "left";
    case "x-":
      return "right";
    case "y+":
      return "bottom";
    case "y-":
      return "top";
    case "left":
      return "right";
    case "top":
      return "bottom";
    case "right":
      return "left";
    case "bottom":
      return "top";
  }
};

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/getNetNameFromPorts.ts
var getNetNameFromPorts = (ports) => {
  for (const port of ports) {
    const traces = port._getDirectlyConnectedTraces();
    for (const trace of traces) {
      const displayLabel = trace._parsedProps.schDisplayLabel;
      if (displayLabel) {
        return { name: displayLabel, wasAssignedDisplayLabel: true };
      }
    }
  }
  const netName = ports.map((p) => p._getNetLabelText()).join("/");
  return { name: netName, wasAssignedDisplayLabel: false };
};

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/applyNetLabelPlacements.ts
import Debug10 from "debug";
var debug8 = Debug10("Group_doInitialSchematicTraceRender");
function applyNetLabelPlacements(args) {
  const {
    group,
    solver,
    sckToSourceNet,
    allScks,
    allSourceAndSchematicPortIdsInScope,
    schPortIdToSourcePortId,
    userNetIdToSck,
    pinIdToSchematicPortId,
    schematicPortIdsWithPreExistingNetLabels,
    schematicPortIdsWithRoutedTraces
  } = args;
  const { db } = group.root;
  const netLabelPlacements = solver.netLabelPlacementSolver?.netLabelPlacements ?? solver.traceLabelOverlapAvoidanceSolver?.getOutput().netLabelPlacements ?? [];
  const globalConnMap = solver.mspConnectionPairSolver.globalConnMap;
  for (const placement of netLabelPlacements) {
    debug8(`processing placement: ${placement.netId}`);
    const placementUserNetId = globalConnMap.getIdsConnectedToNet(placement.globalConnNetId).find((id) => userNetIdToSck.get(id));
    const placementSck = userNetIdToSck.get(placementUserNetId);
    const anchor_position = placement.anchorPoint;
    const orientation = placement.orientation;
    const anchor_side = oppositeSide(orientation);
    const sourceNet = placementSck ? sckToSourceNet.get(placementSck) : void 0;
    const schPortIds = placement.pinIds.map(
      (pinId) => pinIdToSchematicPortId.get(pinId)
    );
    if (schPortIds.some(
      (schPortId) => schematicPortIdsWithPreExistingNetLabels.has(schPortId)
    )) {
      debug8(
        `skipping net label placement for "${placement.netId}" REASON:schematic port has pre-existing net label`
      );
      continue;
    }
    if (sourceNet) {
      const text2 = sourceNet.name;
      const center2 = computeSchematicNetLabelCenter({
        anchor_position,
        anchor_side,
        text: text2
      });
      db.schematic_net_label.insert({
        text: text2,
        anchor_position,
        center: center2,
        anchor_side,
        ...sourceNet?.source_net_id ? { source_net_id: sourceNet.source_net_id } : {}
      });
      continue;
    }
    const ports = group.selectAll("port").filter((p) => p._getSubcircuitConnectivityKey() === placementSck);
    const { name: text, wasAssignedDisplayLabel } = getNetNameFromPorts(ports);
    if (!wasAssignedDisplayLabel && schPortIds.some(
      (schPortId) => schematicPortIdsWithRoutedTraces.has(schPortId)
    )) {
      debug8(
        `skipping net label placement for "${placement.netId}" REASON:schematic port has routed traces and no display label`
      );
      continue;
    }
    const center = computeSchematicNetLabelCenter({
      anchor_position,
      anchor_side,
      text
    });
    db.schematic_net_label.insert({
      text,
      anchor_position,
      center,
      anchor_side
    });
  }
}

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/insertNetLabelsForTracesExcludedFromRouting.ts
import "@tscircuit/schematic-trace-solver";

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/insertNetLabelsForPortsMissingTrace.ts
var insertNetLabelsForPortsMissingTrace = ({
  allSourceAndSchematicPortIdsInScope,
  group,
  schPortIdToSourcePortId,
  sckToSourceNet: connKeyToNet,
  pinIdToSchematicPortId,
  schematicPortIdsWithPreExistingNetLabels
}) => {
  const { db } = group.root;
  for (const schOrSrcPortId of Array.from(
    allSourceAndSchematicPortIdsInScope
  )) {
    const schPort = db.schematic_port.get(schOrSrcPortId);
    if (!schPort) continue;
    if (schPort.is_connected) continue;
    const srcPortId = schPortIdToSourcePortId.get(schOrSrcPortId);
    if (!srcPortId) continue;
    const sourcePort = db.source_port.get(srcPortId);
    const key = sourcePort?.subcircuit_connectivity_map_key;
    if (!key) continue;
    const sourceNet = connKeyToNet.get(key);
    if (!sourceNet) {
      continue;
    }
    const existingAtPort = db.schematic_net_label.list().some((nl) => {
      const samePos = Math.abs(nl.anchor_position.x - schPort.center.x) < 0.1 && Math.abs(nl.anchor_position.y - schPort.center.y) < 0.1;
      if (!samePos) return false;
      if (sourceNet.source_net_id && nl.source_net_id) {
        return nl.source_net_id === sourceNet.source_net_id;
      }
      return nl.text === (sourceNet.name || key);
    });
    if (existingAtPort) continue;
    const text = sourceNet.name || sourceNet.source_net_id || key;
    const side = getEnteringEdgeFromDirection(
      schPort.facing_direction || "right"
    ) || "right";
    const center = computeSchematicNetLabelCenter({
      anchor_position: schPort.center,
      anchor_side: side,
      text
    });
    db.schematic_net_label.insert({
      text,
      anchor_position: schPort.center,
      center,
      anchor_side: side,
      ...sourceNet.source_net_id ? { source_net_id: sourceNet.source_net_id } : {}
    });
  }
};

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/getSchematicPortIdsWithAssignedNetLabels.ts
var getSchematicPortIdsWithAssignedNetLabels = (group) => {
  const schematicPortIdsWithNetLabels = /* @__PURE__ */ new Set();
  const netLabels = group.selectAll("netlabel");
  for (const netLabel of netLabels) {
    const netLabelPorts = netLabel._getConnectedPorts();
    for (const port of netLabelPorts) {
      if (!port.schematic_port_id) continue;
      schematicPortIdsWithNetLabels.add(port.schematic_port_id);
    }
  }
  return schematicPortIdsWithNetLabels;
};

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/getSchematicPortIdsWithRoutedTraces.ts
var getSchematicPortIdsWithRoutedTraces = ({
  solver,
  pinIdToSchematicPortId
}) => {
  const solvedTraces = solver.schematicTraceLinesSolver.solvedTracePaths;
  const schematicPortIdsWithRoutedTraces = /* @__PURE__ */ new Set();
  for (const solvedTrace of solvedTraces) {
    for (const pinId of solvedTrace.pinIds) {
      const schPortId = pinIdToSchematicPortId.get(pinId);
      if (schPortId) {
        schematicPortIdsWithRoutedTraces.add(schPortId);
      }
    }
  }
  return schematicPortIdsWithRoutedTraces;
};

// lib/components/primitive-components/Group/Group_doInitialSchematicTraceRender/Group_doInitialSchematicTraceRender.ts
var debug9 = Debug11("Group_doInitialSchematicTraceRender");
var Group_doInitialSchematicTraceRender = (group) => {
  if (!group.root?._featureMspSchematicTraceRouting) return;
  if (!group.isSubcircuit) return;
  if (group.root?.schematicDisabled) return;
  const {
    inputProblem,
    pinIdToSchematicPortId,
    pairKeyToSourceTraceId,
    sckToSourceNet,
    allSourceAndSchematicPortIdsInScope,
    schPortIdToSourcePortId,
    displayLabelTraces,
    allScks,
    userNetIdToSck
  } = createSchematicTraceSolverInputProblem(group);
  const schematicPortIdsWithPreExistingNetLabels = getSchematicPortIdsWithAssignedNetLabels(group);
  if (debug9.enabled) {
    group.root?.emit("debug:logOutput", {
      type: "debug:logOutput",
      name: "group-trace-render-input-problem",
      content: JSON.stringify(inputProblem, null, 2)
    });
  }
  const solver = new SchematicTracePipelineSolver4(inputProblem);
  solver.solve();
  const schematicPortIdsWithRoutedTraces = getSchematicPortIdsWithRoutedTraces({
    solver,
    pinIdToSchematicPortId
  });
  applyTracesFromSolverOutput({
    group,
    solver,
    pinIdToSchematicPortId,
    userNetIdToSck
  });
  applyNetLabelPlacements({
    group,
    solver,
    sckToSourceNet,
    allSourceAndSchematicPortIdsInScope,
    schPortIdToSourcePortId,
    pinIdToSchematicPortId,
    allScks,
    userNetIdToSck,
    schematicPortIdsWithPreExistingNetLabels,
    schematicPortIdsWithRoutedTraces
  });
  insertNetLabelsForPortsMissingTrace({
    group,
    allSourceAndSchematicPortIdsInScope,
    schPortIdToSourcePortId,
    sckToSourceNet,
    pinIdToSchematicPortId,
    schematicPortIdsWithPreExistingNetLabels
  });
};

// lib/components/primitive-components/Group/Group_doInitialSimulationSpiceEngineRender.ts
import { circuitJsonToSpice } from "circuit-json-to-spice";
import Debug12 from "debug";

// lib/spice/get-spicey-engine.ts
import { simulate, spiceyTranToVGraphs } from "spicey";
var getSpiceyEngine = () => {
  return {
    async simulate(spiceString) {
      const simulation_experiment_id = "spice-experiment-1";
      const { circuit: parsedCircuit, tran } = simulate(spiceString);
      const voltageGraphs = spiceyTranToVGraphs(
        tran,
        parsedCircuit,
        simulation_experiment_id
      );
      return {
        simulationResultCircuitJson: voltageGraphs
      };
    }
  };
};

// lib/utils/simulation/getSimulationColorForId.ts
var SIMULATION_COLOR_PALETTE = [
  "rgb(132, 0, 0)",
  "rgb(194, 194, 0)",
  "rgb(194, 0, 194)",
  "rgb(194, 0, 0)",
  "rgb(0, 132, 132)",
  "rgb(0, 132, 0)",
  "rgb(0, 0, 132)",
  "rgb(132, 132, 132)",
  "rgb(132, 0, 132)",
  "rgb(194, 194, 194)",
  "rgb(132, 0, 132)",
  "rgb(132, 0, 0)",
  "rgb(132, 132, 0)",
  "rgb(194, 194, 194)",
  "rgb(0, 0, 132)",
  "rgb(0, 132, 0)"
];
var idToColorMap = /* @__PURE__ */ new Map();
var colorIndex = 0;
function getSimulationColorForId(id) {
  if (idToColorMap.has(id)) {
    const color2 = idToColorMap.get(id);
    return color2;
  }
  const color = SIMULATION_COLOR_PALETTE[colorIndex];
  colorIndex = (colorIndex + 1) % SIMULATION_COLOR_PALETTE.length;
  idToColorMap.set(id, color);
  return color;
}
function resetSimulationColorState() {
  idToColorMap.clear();
  colorIndex = 0;
}

// lib/components/primitive-components/Group/Group_doInitialSimulationSpiceEngineRender.ts
var debug10 = Debug12("tscircuit:core:Group_doInitialSimulationSpiceEngineRender");
function Group_doInitialSimulationSpiceEngineRender(group) {
  if (!group.isSubcircuit) return;
  const { root } = group;
  if (!root) return;
  const analogSims = group.selectAll("analogsimulation");
  if (analogSims.length === 0) return;
  const voltageProbes = group.selectAll("voltageprobe");
  resetSimulationColorState();
  const spiceEngineMap = { ...root.platform?.spiceEngineMap };
  if (!spiceEngineMap.spicey) {
    spiceEngineMap.spicey = getSpiceyEngine();
  }
  const circuitJson = root.db.toArray();
  let spiceString;
  let spiceNetlist;
  try {
    spiceNetlist = circuitJsonToSpice(circuitJson);
    spiceString = spiceNetlist.toSpiceString();
    debug10(`Generated SPICE string:
${spiceString}`);
  } catch (error) {
    debug10(`Failed to convert circuit JSON to SPICE: ${error}`);
    return;
  }
  for (const analogSim of analogSims) {
    const engineName = analogSim._parsedProps.spiceEngine ?? "spicey";
    const spiceEngine = spiceEngineMap[engineName];
    if (!spiceEngine) {
      throw new Error(
        `SPICE engine "${engineName}" not found in platform config. Available engines: ${JSON.stringify(
          Object.keys(spiceEngineMap).filter((k) => k !== "spicey")
        )}`
      );
    }
    const effectId = `spice-simulation-${engineName}-${analogSim.source_component_id}`;
    debug10(
      `Queueing simulation for spice engine: ${engineName} (id: ${effectId})`
    );
    group._queueAsyncEffect(effectId, async () => {
      try {
        debug10(`Running simulation with engine: ${engineName}`);
        const result = await spiceEngine.simulate(spiceString);
        debug10(
          `Simulation completed, received ${result.simulationResultCircuitJson.length} elements`
        );
        const simulationExperiment = root.db.simulation_experiment.list()[0];
        if (!simulationExperiment) {
          debug10("No simulation experiment found, skipping result insertion");
          return;
        }
        for (const element of result.simulationResultCircuitJson) {
          if (element.type === "simulation_transient_voltage_graph") {
            element.simulation_experiment_id = simulationExperiment.simulation_experiment_id;
            const probeMatch = voltageProbes.find(
              (p) => p.finalProbeName === element.name
            );
            if (probeMatch) element.color = probeMatch.color;
          }
          const elementType = element.type;
          if (elementType && root.db[elementType]) {
            ;
            root.db[elementType].insert(element);
            debug10(`Inserted ${elementType} into database`);
          } else {
            debug10(
              `Warning: Unknown element type ${elementType}, adding to raw db`
            );
            root.db._addElement(element);
          }
        }
        group._markDirty("SimulationSpiceEngineRender");
      } catch (error) {
        debug10(`Simulation failed for engine ${engineName}: ${error}`);
        const simulationExperiment = root.db.simulation_experiment.list()[0];
        root.db.simulation_unknown_experiment_error.insert({
          simulation_experiment_id: simulationExperiment?.simulation_experiment_id,
          error_type: "simulation_unknown_experiment_error",
          message: error instanceof Error ? error.message : String(error)
        });
      }
    });
  }
}

// lib/components/primitive-components/Group/Group_doInitialPcbComponentAnchorAlignment.ts
import { getBoundsFromPoints as getBoundsFromPoints2 } from "@tscircuit/math-utils";
function Group_doInitialPcbComponentAnchorAlignment(group) {
  if (group.root?.pcbDisabled) return;
  if (!group.pcb_group_id) return;
  const pcbPositionAnchor = group._parsedProps?.pcbPositionAnchor;
  if (!pcbPositionAnchor) return;
  const targetPosition = group._getGlobalPcbPositionBeforeLayout();
  const { pcbX, pcbY } = group._parsedProps;
  if (pcbX === void 0 && pcbY === void 0) return;
  const { db } = group.root;
  const pcbGroup = db.pcb_group.get(group.pcb_group_id);
  if (!pcbGroup) return;
  let width = pcbGroup.width;
  let height = pcbGroup.height;
  const { center } = pcbGroup;
  if (pcbGroup.outline && pcbGroup.outline.length > 0) {
    const bounds2 = getBoundsFromPoints2(pcbGroup.outline);
    if (bounds2) {
      width = bounds2.maxX - bounds2.minX;
      height = bounds2.maxY - bounds2.minY;
    }
  }
  if (!width || !height) return;
  const bounds = {
    left: center.x - width / 2,
    right: center.x + width / 2,
    top: center.y + height / 2,
    // Y-up: top is at higher Y
    bottom: center.y - height / 2
    // Y-up: bottom is at lower Y
  };
  const currentCenter = { ...center };
  let anchorPos = null;
  const ninePointAnchors = /* @__PURE__ */ new Set([
    "center",
    "top_left",
    "top_center",
    "top_right",
    "center_left",
    "center_right",
    "bottom_left",
    "bottom_center",
    "bottom_right"
  ]);
  if (ninePointAnchors.has(pcbPositionAnchor)) {
    switch (pcbPositionAnchor) {
      case "center":
        anchorPos = currentCenter;
        break;
      case "top_left":
        anchorPos = { x: bounds.left, y: bounds.top };
        break;
      case "top_center":
        anchorPos = { x: currentCenter.x, y: bounds.top };
        break;
      case "top_right":
        anchorPos = { x: bounds.right, y: bounds.top };
        break;
      case "center_left":
        anchorPos = { x: bounds.left, y: currentCenter.y };
        break;
      case "center_right":
        anchorPos = { x: bounds.right, y: currentCenter.y };
        break;
      case "bottom_left":
        anchorPos = { x: bounds.left, y: bounds.bottom };
        break;
      case "bottom_center":
        anchorPos = { x: currentCenter.x, y: bounds.bottom };
        break;
      case "bottom_right":
        anchorPos = { x: bounds.right, y: bounds.bottom };
        break;
    }
  }
  if (!anchorPos) return;
  const newCenter = { ...currentCenter };
  if (targetPosition.x !== void 0)
    newCenter.x += targetPosition.x - anchorPos.x;
  if (targetPosition.y !== void 0)
    newCenter.y += targetPosition.y - anchorPos.y;
  if (Math.abs(newCenter.x - currentCenter.x) > 1e-6 || Math.abs(newCenter.y - currentCenter.y) > 1e-6) {
    group._repositionOnPcb(newCenter);
    db.pcb_group.update(group.pcb_group_id, {
      center: newCenter
    });
  }
  db.pcb_group.update(group.pcb_group_id, {
    anchor_position: targetPosition,
    anchor_alignment: pcbPositionAnchor
  });
}

// lib/components/primitive-components/Group/Group.ts
var Group6 = class extends NormalComponent3 {
  pcb_group_id = null;
  schematic_group_id = null;
  subcircuit_id = null;
  _hasStartedAsyncAutorouting = false;
  _asyncAutoroutingResult = null;
  get config() {
    return {
      zodProps: groupProps,
      componentName: "Group"
    };
  }
  doInitialSourceGroupRender() {
    const { db } = this.root;
    const hasExplicitName = typeof this._parsedProps.name === "string" && this._parsedProps.name.length > 0;
    const source_group = db.source_group.insert({
      name: this.name,
      is_subcircuit: this.isSubcircuit,
      was_automatically_named: !hasExplicitName
    });
    this.source_group_id = source_group.source_group_id;
    if (this.isSubcircuit) {
      this.subcircuit_id = `subcircuit_${source_group.source_group_id}`;
      db.source_group.update(source_group.source_group_id, {
        subcircuit_id: this.subcircuit_id
      });
    }
  }
  doInitialSourceRender() {
    const { db } = this.root;
    for (const child of this.children) {
      db.source_component.update(child.source_component_id, {
        source_group_id: this.source_group_id
      });
    }
  }
  doInitialSourceParentAttachment() {
    const { db } = this.root;
    const parentGroup = this.parent?.getGroup?.();
    if (parentGroup?.source_group_id) {
      db.source_group.update(this.source_group_id, {
        parent_source_group_id: parentGroup.source_group_id
      });
    }
    if (!this.isSubcircuit) return;
    const parent_subcircuit_id = this.parent?.getSubcircuit?.()?.subcircuit_id;
    if (!parent_subcircuit_id) return;
    db.source_group.update(this.source_group_id, {
      parent_subcircuit_id
    });
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const groupProps2 = props;
    const hasOutline = groupProps2.outline && groupProps2.outline.length > 0;
    const numericOutline = hasOutline ? groupProps2.outline.map((point) => ({
      x: distance6.parse(point.x),
      y: distance6.parse(point.y)
    })) : void 0;
    const pcb_group = db.pcb_group.insert({
      is_subcircuit: this.isSubcircuit,
      subcircuit_id: this.subcircuit_id ?? this.getSubcircuit()?.subcircuit_id,
      name: this.name,
      center: this._getGlobalPcbPositionBeforeLayout(),
      ...hasOutline ? { outline: numericOutline } : { width: 0, height: 0 },
      pcb_component_ids: [],
      source_group_id: this.source_group_id,
      autorouter_configuration: props.autorouter ? {
        trace_clearance: props.autorouter.traceClearance
      } : void 0
    });
    this.pcb_group_id = pcb_group.pcb_group_id;
    for (const child of this.children) {
      db.pcb_component.update(child.pcb_component_id, {
        pcb_group_id: pcb_group.pcb_group_id
      });
    }
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const props = this._parsedProps;
    const hasOutline = props.outline && props.outline.length > 0;
    if (this.pcb_group_id) {
      const hasExplicitPositioning = this._parsedProps.pcbX !== void 0 || this._parsedProps.pcbY !== void 0;
      if (hasOutline) {
        const numericOutline = props.outline.map((point) => ({
          x: distance6.parse(point.x),
          y: distance6.parse(point.y)
        }));
        const outlineBounds = getBoundsFromPoints3(numericOutline);
        if (!outlineBounds) return;
        const centerX2 = (outlineBounds.minX + outlineBounds.maxX) / 2;
        const centerY2 = (outlineBounds.minY + outlineBounds.maxY) / 2;
        const center2 = hasExplicitPositioning ? db.pcb_group.get(this.pcb_group_id)?.center ?? {
          x: centerX2,
          y: centerY2
        } : { x: centerX2, y: centerY2 };
        db.pcb_group.update(this.pcb_group_id, {
          center: center2
        });
        return;
      }
      const bounds = getBoundsOfPcbComponents(this.children);
      let width = bounds.width;
      let height = bounds.height;
      let centerX = (bounds.minX + bounds.maxX) / 2;
      let centerY = (bounds.minY + bounds.maxY) / 2;
      if (this.isSubcircuit) {
        const { padLeft, padRight, padTop, padBottom } = this._resolvePcbPadding();
        width += padLeft + padRight;
        height += padTop + padBottom;
        centerX += (padRight - padLeft) / 2;
        centerY += (padTop - padBottom) / 2;
      }
      const center = hasExplicitPositioning ? db.pcb_group.get(this.pcb_group_id)?.center ?? {
        x: centerX,
        y: centerY
      } : { x: centerX, y: centerY };
      db.pcb_group.update(this.pcb_group_id, {
        width: Number(props.width ?? width),
        height: Number(props.height ?? height),
        center
      });
    }
  }
  unnamedElementCounter = {};
  getNextAvailableName(elm) {
    this.unnamedElementCounter[elm.lowercaseComponentName] ??= 1;
    return `unnamed_${elm.lowercaseComponentName}${this.unnamedElementCounter[elm.lowercaseComponentName]++}`;
  }
  _resolvePcbPadding() {
    const props = this._parsedProps;
    const layout = props.pcbLayout;
    const getPaddingValue = (key) => {
      const layoutValue = layout?.[key];
      const propsValue = props[key];
      if (typeof layoutValue === "number") return layoutValue;
      if (typeof propsValue === "number") return propsValue;
      return void 0;
    };
    const generalPadding = getPaddingValue("padding") ?? 0;
    const paddingX = getPaddingValue("paddingX");
    const paddingY = getPaddingValue("paddingY");
    const padLeft = getPaddingValue("paddingLeft") ?? paddingX ?? generalPadding;
    const padRight = getPaddingValue("paddingRight") ?? paddingX ?? generalPadding;
    const padTop = getPaddingValue("paddingTop") ?? paddingY ?? generalPadding;
    const padBottom = getPaddingValue("paddingBottom") ?? paddingY ?? generalPadding;
    return { padLeft, padRight, padTop, padBottom };
  }
  doInitialCreateTraceHintsFromProps() {
    const { _parsedProps: props } = this;
    const { db } = this.root;
    const groupProps2 = props;
    if (!this.isSubcircuit) return;
    const manualTraceHints = groupProps2.manualEdits?.manual_trace_hints;
    if (!manualTraceHints) return;
    for (const manualTraceHint of manualTraceHints) {
      this.add(
        new TraceHint({
          for: manualTraceHint.pcb_port_selector,
          offsets: manualTraceHint.offsets
        })
      );
    }
  }
  doInitialSourceAddConnectivityMapKey() {
    Group_doInitialSourceAddConnectivityMapKey(this);
  }
  _areChildSubcircuitsRouted() {
    const subcircuitChildren = this.selectAll("group").filter(
      (g) => g.isSubcircuit
    );
    for (const subcircuitChild of subcircuitChildren) {
      if (subcircuitChild._shouldRouteAsync() && !subcircuitChild._asyncAutoroutingResult) {
        return false;
      }
    }
    return true;
  }
  _shouldRouteAsync() {
    const autorouter = this._getAutorouterConfig();
    if (autorouter.groupMode === "sequential-trace") return false;
    if (autorouter.local && autorouter.groupMode === "subcircuit") return true;
    if (!autorouter.local) return true;
    return false;
  }
  _hasTracesToRoute() {
    const debug11 = Debug13("tscircuit:core:_hasTracesToRoute");
    const traces = this.selectAll("trace");
    debug11(`[${this.getString()}] has ${traces.length} traces to route`);
    return traces.length > 0;
  }
  async _runEffectMakeHttpAutoroutingRequest() {
    const { db } = this.root;
    const debug11 = Debug13("tscircuit:core:_runEffectMakeHttpAutoroutingRequest");
    const props = this._parsedProps;
    const autorouterConfig = this._getAutorouterConfig();
    const serverUrl = autorouterConfig.serverUrl;
    const serverMode = autorouterConfig.serverMode;
    const fetchWithDebug = (url, options) => {
      debug11("fetching", url);
      if (options.headers) {
        options.headers["Tscircuit-Core-Version"] = this.root?.getCoreVersion();
      }
      return fetch(url, options);
    };
    const pcbAndSourceCircuitJson = this.root.db.toArray().filter(
      (element) => {
        return element.type.startsWith("source_") || element.type.startsWith("pcb_");
      }
    );
    if (serverMode === "solve-endpoint") {
      if (this.props.autorouter?.inputFormat === "simplified") {
        const { autorouting_result: autorouting_result2 } = await fetchWithDebug(
          `${serverUrl}/autorouting/solve`,
          {
            method: "POST",
            body: JSON.stringify({
              input_simple_route_json: getSimpleRouteJsonFromCircuitJson({
                db,
                minTraceWidth: this.props.autorouter?.minTraceWidth ?? 0.15,
                subcircuit_id: this.subcircuit_id
              }).simpleRouteJson,
              subcircuit_id: this.subcircuit_id
            }),
            headers: {
              "Content-Type": "application/json"
            }
          }
        ).then((r) => r.json());
        this._asyncAutoroutingResult = autorouting_result2;
        this._markDirty("PcbTraceRender");
        return;
      }
      const { autorouting_result } = await fetchWithDebug(
        `${serverUrl}/autorouting/solve`,
        {
          method: "POST",
          body: JSON.stringify({
            input_circuit_json: pcbAndSourceCircuitJson,
            subcircuit_id: this.subcircuit_id
          }),
          headers: {
            "Content-Type": "application/json"
          }
        }
      ).then((r) => r.json());
      this._asyncAutoroutingResult = autorouting_result;
      this._markDirty("PcbTraceRender");
      return;
    }
    const { autorouting_job } = await fetchWithDebug(
      `${serverUrl}/autorouting/jobs/create`,
      {
        method: "POST",
        body: JSON.stringify({
          input_circuit_json: pcbAndSourceCircuitJson,
          provider: "freerouting",
          autostart: true,
          display_name: this.root?.name,
          subcircuit_id: this.subcircuit_id,
          server_cache_enabled: autorouterConfig.serverCacheEnabled
        }),
        headers: {
          "Content-Type": "application/json"
        }
      }
    ).then((r) => r.json());
    while (true) {
      const { autorouting_job: job } = await fetchWithDebug(
        `${serverUrl}/autorouting/jobs/get`,
        {
          method: "POST",
          body: JSON.stringify({
            autorouting_job_id: autorouting_job.autorouting_job_id
          }),
          headers: { "Content-Type": "application/json" }
        }
      ).then((r) => r.json());
      if (job.is_finished) {
        const { autorouting_job_output } = await fetchWithDebug(
          `${serverUrl}/autorouting/jobs/get_output`,
          {
            method: "POST",
            body: JSON.stringify({
              autorouting_job_id: autorouting_job.autorouting_job_id
            }),
            headers: { "Content-Type": "application/json" }
          }
        ).then((r) => r.json());
        this._asyncAutoroutingResult = {
          output_pcb_traces: autorouting_job_output.output_pcb_traces
        };
        this._markDirty("PcbTraceRender");
        break;
      }
      if (job.has_error) {
        const err = new AutorouterError(
          `Autorouting job failed: ${JSON.stringify(job.error)}`
        );
        db.pcb_autorouting_error.insert({
          pcb_error_id: autorouting_job.autorouting_job_id,
          error_type: "pcb_autorouting_error",
          message: err.message
        });
        throw err;
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  /**
   * Run local autorouting using the CapacityMeshAutorouter
   */
  async _runLocalAutorouting() {
    const { db } = this.root;
    const props = this._parsedProps;
    const debug11 = Debug13("tscircuit:core:_runLocalAutorouting");
    debug11(`[${this.getString()}] starting local autorouting`);
    const autorouterConfig = this._getAutorouterConfig();
    const isLaserPrefabPreset = this._isLaserPrefabAutorouter(autorouterConfig);
    const { simpleRouteJson } = getSimpleRouteJsonFromCircuitJson({
      db,
      minTraceWidth: this.props.autorouter?.minTraceWidth ?? 0.15,
      subcircuit_id: this.subcircuit_id
    });
    if (debug11.enabled) {
      ;
      global.debugOutputArray?.push({
        name: `simpleroutejson-${this.props.name}.json`,
        obj: simpleRouteJson
      });
    }
    if (debug11.enabled) {
      const graphicsObject = convertSrjToGraphicsObject(
        simpleRouteJson
      );
      graphicsObject.title = `autorouting-${this.props.name}`;
      global.debugGraphics?.push(graphicsObject);
    }
    this.root?.emit("autorouting:start", {
      subcircuit_id: this.subcircuit_id,
      componentDisplayName: this.getString(),
      simpleRouteJson
    });
    let autorouter;
    if (autorouterConfig.algorithmFn) {
      autorouter = await autorouterConfig.algorithmFn(simpleRouteJson);
    } else {
      autorouter = new CapacityMeshAutorouter(simpleRouteJson, {
        // Optional configuration parameters
        capacityDepth: this.props.autorouter?.capacityDepth,
        targetMinCapacity: this.props.autorouter?.targetMinCapacity,
        useAssignableViaSolver: isLaserPrefabPreset
      });
    }
    const routingPromise = new Promise(
      (resolve, reject) => {
        autorouter.on("complete", (event) => {
          debug11(`[${this.getString()}] local autorouting complete`);
          resolve(event.traces);
        });
        autorouter.on("error", (event) => {
          debug11(
            `[${this.getString()}] local autorouting error: ${event.error.message}`
          );
          reject(event.error);
        });
      }
    );
    autorouter.on("progress", (event) => {
      this.root?.emit("autorouting:progress", {
        subcircuit_id: this.subcircuit_id,
        componentDisplayName: this.getString(),
        ...event
      });
    });
    autorouter.start();
    try {
      const traces = await routingPromise;
      this._asyncAutoroutingResult = {
        output_pcb_traces: traces
      };
      this._markDirty("PcbTraceRender");
    } catch (error) {
      const { db: db2 } = this.root;
      db2.pcb_autorouting_error.insert({
        pcb_error_id: `pcb_autorouter_error_subcircuit_${this.subcircuit_id}`,
        error_type: "pcb_autorouting_error",
        message: error instanceof Error ? error.message : String(error)
      });
      this.root?.emit("autorouting:error", {
        subcircuit_id: this.subcircuit_id,
        componentDisplayName: this.getString(),
        error: {
          message: error instanceof Error ? error.message : String(error)
        },
        simpleRouteJson
      });
      throw error;
    } finally {
      autorouter.stop();
    }
  }
  _startAsyncAutorouting() {
    if (this._hasStartedAsyncAutorouting) return;
    this._hasStartedAsyncAutorouting = true;
    if (this._getAutorouterConfig().local) {
      this._queueAsyncEffect(
        "capacity-mesh-autorouting",
        async () => this._runLocalAutorouting()
      );
    } else {
      this._queueAsyncEffect(
        "make-http-autorouting-request",
        async () => this._runEffectMakeHttpAutoroutingRequest()
      );
    }
  }
  doInitialPcbTraceRender() {
    const debug11 = Debug13("tscircuit:core:doInitialPcbTraceRender");
    if (!this.isSubcircuit) return;
    if (this.root?.pcbDisabled) return;
    if (this.getInheritedProperty("routingDisabled")) return;
    if (this._shouldUseTraceByTraceRouting()) return;
    if (!this._areChildSubcircuitsRouted()) {
      debug11(
        `[${this.getString()}] child subcircuits are not routed, skipping async autorouting until subcircuits routed`
      );
      return;
    }
    debug11(
      `[${this.getString()}] no child subcircuits to wait for, initiating async routing`
    );
    if (!this._hasTracesToRoute()) return;
    this._startAsyncAutorouting();
  }
  doInitialSchematicTraceRender() {
    Group_doInitialSchematicTraceRender(this);
  }
  updatePcbTraceRender() {
    const debug11 = Debug13("tscircuit:core:updatePcbTraceRender");
    debug11(`[${this.getString()}] updating...`);
    if (!this.isSubcircuit) return;
    if (this._shouldRouteAsync() && this._hasTracesToRoute() && !this._hasStartedAsyncAutorouting) {
      if (this._areChildSubcircuitsRouted()) {
        debug11(
          `[${this.getString()}] child subcircuits are now routed, starting async autorouting`
        );
        this._startAsyncAutorouting();
      }
      return;
    }
    if (!this._asyncAutoroutingResult) return;
    if (this._shouldUseTraceByTraceRouting()) return;
    const { db } = this.root;
    if (this._asyncAutoroutingResult.output_simple_route_json) {
      debug11(
        `[${this.getString()}] updating PCB traces from simple route json (${this._asyncAutoroutingResult.output_simple_route_json.traces?.length} traces)`
      );
      this._updatePcbTraceRenderFromSimpleRouteJson();
      return;
    }
    if (this._asyncAutoroutingResult.output_pcb_traces) {
      debug11(
        `[${this.getString()}] updating PCB traces from ${this._asyncAutoroutingResult.output_pcb_traces.length} traces`
      );
      this._updatePcbTraceRenderFromPcbTraces();
      return;
    }
  }
  _updatePcbTraceRenderFromSimpleRouteJson() {
    const { db } = this.root;
    const { traces: routedTraces } = this._asyncAutoroutingResult.output_simple_route_json;
    if (!routedTraces) return;
    for (const routedTrace of routedTraces) {
      const pcb_trace = db.pcb_trace.insert({
        subcircuit_id: this.subcircuit_id,
        route: routedTrace.route
        // source_trace_id: circuitTrace.source_trace_id!,
      });
    }
  }
  _updatePcbTraceRenderFromPcbTraces() {
    const { output_pcb_traces } = this._asyncAutoroutingResult;
    if (!output_pcb_traces) return;
    const { db } = this.root;
    for (const pcb_trace of output_pcb_traces) {
      if (pcb_trace.type !== "pcb_trace") continue;
      pcb_trace.subcircuit_id = this.subcircuit_id;
      if (pcb_trace.connection_name) {
        const sourceTraceId = pcb_trace.connection_name;
        pcb_trace.source_trace_id = sourceTraceId;
      }
      db.pcb_trace.insert(pcb_trace);
    }
    for (const pcb_trace of output_pcb_traces) {
      if (pcb_trace.type === "pcb_via") {
        continue;
      }
      if (pcb_trace.type === "pcb_trace") {
        for (const point of pcb_trace.route) {
          if (point.route_type === "via") {
            db.pcb_via.insert({
              pcb_trace_id: pcb_trace.pcb_trace_id,
              x: point.x,
              y: point.y,
              hole_diameter: 0.3,
              outer_diameter: 0.6,
              layers: [
                point.from_layer,
                point.to_layer
              ],
              from_layer: point.from_layer,
              to_layer: point.to_layer
            });
          }
        }
      }
    }
  }
  doInitialSchematicComponentRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const schematic_group = db.schematic_group.insert({
      is_subcircuit: this.isSubcircuit,
      subcircuit_id: this.subcircuit_id,
      name: this.name,
      center: this._getGlobalSchematicPositionBeforeLayout(),
      width: 0,
      height: 0,
      schematic_component_ids: [],
      source_group_id: this.source_group_id
    });
    this.schematic_group_id = schematic_group.schematic_group_id;
    for (const child of this.children) {
      if (child.schematic_component_id) {
        db.schematic_component.update(child.schematic_component_id, {
          schematic_group_id: schematic_group.schematic_group_id
        });
      }
    }
  }
  _getSchematicLayoutMode() {
    const props = this._parsedProps;
    if (props.schLayout?.layoutMode === "none") return "relative";
    if (props.schLayout?.layoutMode === "relative") return "relative";
    if (props.schLayout?.matchAdapt) return "match-adapt";
    if (props.schLayout?.flex) return "flex";
    if (props.schLayout?.grid) return "grid";
    if (props.schMatchAdapt) return "match-adapt";
    if (props.schFlex) return "flex";
    if (props.schGrid) return "grid";
    if (props.matchAdapt) return "match-adapt";
    if (props.flex) return "flex";
    if (props.grid) return "grid";
    if (props.relative) return "relative";
    if (props.schRelative) return "relative";
    const anyChildHasSchCoords = this.children.some((child) => {
      const cProps = child._parsedProps;
      return cProps?.schX !== void 0 || cProps?.schY !== void 0;
    });
    const hasManualEdits = (props.manualEdits?.schematic_placements?.length ?? 0) > 0;
    if (!anyChildHasSchCoords && !hasManualEdits) return "match-adapt";
    return "relative";
  }
  doInitialSchematicLayout() {
    const schematicLayoutMode = this._getSchematicLayoutMode();
    if (schematicLayoutMode === "match-adapt") {
      this._doInitialSchematicLayoutMatchpack();
    }
    if (schematicLayoutMode === "grid") {
      this._doInitialSchematicLayoutGrid();
    }
    if (schematicLayoutMode === "flex") {
      this._doInitialSchematicLayoutFlex();
    }
    this._insertSchematicBorder();
  }
  _doInitialSchematicLayoutMatchAdapt() {
    Group_doInitialSchematicLayoutMatchAdapt(this);
  }
  _doInitialSchematicLayoutMatchpack() {
    Group_doInitialSchematicLayoutMatchPack(this);
  }
  _doInitialSchematicLayoutGrid() {
    Group_doInitialSchematicLayoutGrid(this);
  }
  _doInitialSchematicLayoutFlex() {
    Group_doInitialSchematicLayoutFlex(this);
  }
  _getPcbLayoutMode() {
    const props = this._parsedProps;
    if (props.pcbRelative) return "none";
    if (props.pcbLayout?.matchAdapt) return "match-adapt";
    if (props.pcbLayout?.flex) return "flex";
    if (props.pcbLayout?.grid) return "grid";
    if (props.pcbLayout?.pack) return "pack";
    if (props.pcbFlex) return "flex";
    if (props.pcbGrid) return "grid";
    if (props.pcbPack) return "pack";
    if (props.pack) return "pack";
    if (props.matchAdapt) return "match-adapt";
    if (props.flex) return "flex";
    if (props.grid) return "grid";
    const groupHasCoords = props.pcbX !== void 0 || props.pcbY !== void 0;
    const hasManualEdits = (props.manualEdits?.pcb_placements?.length ?? 0) > 0;
    const unpositionedDirectChildrenCount = this.children.reduce(
      (count, child) => {
        if (!child.pcb_component_id && !child.pcb_group_id) {
          return count;
        }
        const childProps = child._parsedProps;
        const hasCoords = childProps?.pcbX !== void 0 || childProps?.pcbY !== void 0;
        return count + (hasCoords ? 0 : 1);
      },
      0
    );
    if (!groupHasCoords && !hasManualEdits && unpositionedDirectChildrenCount > 1)
      return "pack";
    return "none";
  }
  doInitialPcbLayout() {
    const pcbLayoutMode = this._getPcbLayoutMode();
    if (pcbLayoutMode === "grid") {
      this._doInitialPcbLayoutGrid();
    } else if (pcbLayoutMode === "pack") {
      this._doInitialPcbLayoutPack();
    } else if (pcbLayoutMode === "flex") {
      this._doInitialPcbLayoutFlex();
    }
  }
  _doInitialPcbLayoutGrid() {
    Group_doInitialPcbLayoutGrid(this);
  }
  _doInitialPcbLayoutPack() {
    Group_doInitialPcbLayoutPack(this);
  }
  _doInitialPcbLayoutFlex() {
    Group_doInitialPcbLayoutFlex(this);
  }
  _insertSchematicBorder() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const props = this._parsedProps;
    if (!props.border) return;
    let width = typeof props.schWidth === "number" ? props.schWidth : void 0;
    let height = typeof props.schHeight === "number" ? props.schHeight : void 0;
    const paddingGeneral = typeof props.schPadding === "number" ? props.schPadding : 0;
    const paddingLeft = typeof props.schPaddingLeft === "number" ? props.schPaddingLeft : paddingGeneral;
    const paddingRight = typeof props.schPaddingRight === "number" ? props.schPaddingRight : paddingGeneral;
    const paddingTop = typeof props.schPaddingTop === "number" ? props.schPaddingTop : paddingGeneral;
    const paddingBottom = typeof props.schPaddingBottom === "number" ? props.schPaddingBottom : paddingGeneral;
    const schematicGroup = this.schematic_group_id ? db.schematic_group.get(this.schematic_group_id) : null;
    if (schematicGroup) {
      if (width === void 0 && typeof schematicGroup.width === "number") {
        width = schematicGroup.width;
      }
      if (height === void 0 && typeof schematicGroup.height === "number") {
        height = schematicGroup.height;
      }
    }
    if (width === void 0 || height === void 0) return;
    const center = schematicGroup?.center ?? this._getGlobalSchematicPositionBeforeLayout();
    const left = center.x - width / 2 - paddingLeft;
    const bottom = center.y - height / 2 - paddingBottom;
    const finalWidth = width + paddingLeft + paddingRight;
    const finalHeight = height + paddingTop + paddingBottom;
    db.schematic_box.insert({
      width: finalWidth,
      height: finalHeight,
      x: left,
      y: bottom,
      is_dashed: props.border?.dashed ?? false
    });
  }
  _determineSideFromPosition(port, component) {
    if (!port.center || !component.center) return "left";
    const dx = port.center.x - component.center.x;
    const dy = port.center.y - component.center.y;
    if (Math.abs(dx) > Math.abs(dy)) {
      return dx > 0 ? "right" : "left";
    }
    return dy > 0 ? "bottom" : "top";
  }
  _calculateSchematicBounds(boxes) {
    if (boxes.length === 0) {
      return { minX: 0, maxX: 0, minY: 0, maxY: 0 };
    }
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (const box of boxes) {
      minX = Math.min(minX, box.centerX);
      maxX = Math.max(maxX, box.centerX);
      minY = Math.min(minY, box.centerY);
      maxY = Math.max(maxY, box.centerY);
    }
    const padding = 2;
    return {
      minX: minX - padding,
      maxX: maxX + padding,
      minY: minY - padding,
      maxY: maxY + padding
    };
  }
  _getAutorouterConfig() {
    const autorouter = this._parsedProps.autorouter || this.getInheritedProperty("autorouter");
    return getPresetAutoroutingConfig(autorouter);
  }
  _isLaserPrefabAutorouter(autorouterConfig = this._getAutorouterConfig()) {
    const autorouterProp = this.props.autorouter;
    const normalize = (value) => value?.replace(/-/g, "_") ?? value;
    if (autorouterConfig.preset === "laser_prefab") return true;
    if (typeof autorouterProp === "string") {
      return normalize(autorouterProp) === "laser_prefab";
    }
    if (typeof autorouterProp === "object" && autorouterProp) {
      return normalize(autorouterProp.preset) === "laser_prefab";
    }
    return false;
  }
  _getSubcircuitLayerCount() {
    const layers = this.getInheritedProperty("layers");
    return typeof layers === "number" ? layers : 2;
  }
  /**
   * Trace-by-trace autorouting is where each trace routes itself in a well-known
   * order. It's the most deterministic way to autoroute, because a new trace
   * is generally ordered last.
   *
   * This method will return false if using an external service for autorouting
   * or if using a "fullview" or "rip and replace" autorouting mode
   */
  _shouldUseTraceByTraceRouting() {
    const autorouter = this._getAutorouterConfig();
    return autorouter.groupMode === "sequential-trace";
  }
  doInitialPcbDesignRuleChecks() {
    if (this.root?.pcbDisabled) return;
    if (this.getInheritedProperty("routingDisabled")) return;
    const { db } = this.root;
    if (this.isSubcircuit) {
      const subcircuitComponentsByName = /* @__PURE__ */ new Map();
      for (const child of this.children) {
        if (child.isSubcircuit) continue;
        if (child._parsedProps.name) {
          const components = subcircuitComponentsByName.get(child._parsedProps.name) || [];
          components.push(child);
          subcircuitComponentsByName.set(child._parsedProps.name, components);
        }
      }
      for (const [name, components] of subcircuitComponentsByName.entries()) {
        if (components.length > 1) {
          db.pcb_trace_error.insert({
            error_type: "pcb_trace_error",
            message: `Multiple components found with name "${name}" in subcircuit "${this.name || "unnamed"}". Component names must be unique within a subcircuit.`,
            source_trace_id: "",
            pcb_trace_id: "",
            pcb_component_ids: components.map((c) => c.pcb_component_id).filter(Boolean),
            pcb_port_ids: []
          });
        }
      }
    }
  }
  doInitialSchematicReplaceNetLabelsWithSymbols() {
    if (this.root?.schematicDisabled) return;
    if (!this.isSubcircuit) return;
    const { db } = this.root;
    const subtree = db;
    for (const nl of subtree.schematic_net_label.list()) {
      const net = subtree.source_net.get(nl.source_net_id);
      const text = nl.text || net?.name || "";
      if (nl.anchor_side === "top" && /^gnd/i.test(text)) {
        subtree.schematic_net_label.update(nl.schematic_net_label_id, {
          symbol_name: "rail_down"
        });
        continue;
      }
      if (nl.anchor_side === "bottom" && /^v/i.test(text)) {
        subtree.schematic_net_label.update(nl.schematic_net_label_id, {
          symbol_name: "rail_up"
        });
      }
    }
  }
  doInitialSimulationSpiceEngineRender() {
    Group_doInitialSimulationSpiceEngineRender(this);
  }
  /**
   * Override anchor alignment to handle group-specific logic
   */
  doInitialPcbComponentAnchorAlignment() {
    Group_doInitialPcbComponentAnchorAlignment(this);
  }
  updatePcbComponentAnchorAlignment() {
    this.doInitialPcbComponentAnchorAlignment();
  }
  /**
   * Get the minimum flex container size for this group on PCB
   */
  _getMinimumFlexContainerSize() {
    return super._getMinimumFlexContainerSize();
  }
  /**
   * Reposition this group on the PCB to the specified coordinates
   */
  _repositionOnPcb(position) {
    return super._repositionOnPcb(position);
  }
};

// lib/components/normal-components/Board.ts
import {
  checkEachPcbPortConnectedToPcbTraces,
  checkEachPcbTraceNonOverlapping,
  checkPcbComponentsOutOfBoard,
  checkPcbTracesOutOfBoard,
  checkDifferentNetViaSpacing,
  checkSameNetViaSpacing,
  checkPcbComponentOverlap
} from "@tscircuit/checks";
import { getBoundsFromPoints as getBoundsFromPoints4 } from "@tscircuit/math-utils";
var MIN_EFFECTIVE_BORDER_RADIUS_MM = 0.01;
var getRoundedRectOutline = (width, height, radius) => {
  const w2 = width / 2;
  const h2 = height / 2;
  const r = Math.min(radius, w2, h2);
  if (r < MIN_EFFECTIVE_BORDER_RADIUS_MM) {
    return [
      { x: -w2, y: -h2 },
      { x: w2, y: -h2 },
      { x: w2, y: h2 },
      { x: -w2, y: h2 }
    ];
  }
  const maxArcLengthPerSegment = 0.1;
  const segments = Math.max(
    1,
    Math.ceil(Math.PI / 2 * r / maxArcLengthPerSegment)
  );
  const step = Math.PI / 2 / segments;
  const outline = [];
  outline.push({ x: -w2 + r, y: -h2 });
  outline.push({ x: w2 - r, y: -h2 });
  for (let i = 1; i <= segments; i++) {
    const theta = -Math.PI / 2 + i * step;
    outline.push({
      x: w2 - r + r * Math.cos(theta),
      y: -h2 + r + r * Math.sin(theta)
    });
  }
  outline.push({ x: w2, y: h2 - r });
  for (let i = 1; i <= segments; i++) {
    const theta = 0 + i * step;
    outline.push({
      x: w2 - r + r * Math.cos(theta),
      y: h2 - r + r * Math.sin(theta)
    });
  }
  outline.push({ x: -w2 + r, y: h2 });
  for (let i = 1; i <= segments; i++) {
    const theta = Math.PI / 2 + i * step;
    outline.push({
      x: -w2 + r + r * Math.cos(theta),
      y: h2 - r + r * Math.sin(theta)
    });
  }
  outline.push({ x: -w2, y: -h2 + r });
  for (let i = 1; i <= segments; i++) {
    const theta = Math.PI + i * step;
    outline.push({
      x: -w2 + r + r * Math.cos(theta),
      y: -h2 + r + r * Math.sin(theta)
    });
  }
  return outline;
};
var Board = class extends Group6 {
  pcb_board_id = null;
  source_board_id = null;
  _drcChecksComplete = false;
  _connectedSchematicPortPairs = /* @__PURE__ */ new Set();
  get isSubcircuit() {
    return true;
  }
  get isGroup() {
    return true;
  }
  get config() {
    return {
      componentName: "Board",
      zodProps: boardProps
    };
  }
  get boardThickness() {
    const { _parsedProps: props } = this;
    return props.thickness ?? 1.4;
  }
  /**
   * Get all available layers for the board
   */
  get allLayers() {
    const layerCount = this._parsedProps.layers ?? 2;
    if (layerCount === 4) {
      return ["top", "bottom", "inner1", "inner2"];
    }
    return ["top", "bottom"];
  }
  _getSubcircuitLayerCount() {
    return this._parsedProps.layers ?? 2;
  }
  doInitialPcbBoardAutoSize() {
    if (this.root?.pcbDisabled) return;
    if (!this.pcb_board_id) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    if (props.width && props.height || props.outline) return;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    const descendantIds = getDescendantSubcircuitIds(db, this.subcircuit_id);
    const allowedSubcircuitIds = /* @__PURE__ */ new Set([this.subcircuit_id, ...descendantIds]);
    const allPcbComponents = db.pcb_component.list().filter(
      (c) => c.subcircuit_id && allowedSubcircuitIds.has(c.subcircuit_id)
    );
    const allPcbGroups = db.pcb_group.list().filter(
      (g) => g.subcircuit_id && allowedSubcircuitIds.has(g.subcircuit_id)
    );
    let hasComponents = false;
    const updateBounds = (center2, width, height) => {
      if (width === 0 || height === 0) return;
      hasComponents = true;
      minX = Math.min(minX, center2.x - width / 2);
      minY = Math.min(minY, center2.y - height / 2);
      maxX = Math.max(maxX, center2.x + width / 2);
      maxY = Math.max(maxY, center2.y + height / 2);
    };
    for (const pcbComponent of allPcbComponents) {
      updateBounds(pcbComponent.center, pcbComponent.width, pcbComponent.height);
    }
    for (const pcbGroup of allPcbGroups) {
      let width = pcbGroup.width ?? 0;
      let height = pcbGroup.height ?? 0;
      if (pcbGroup.outline && pcbGroup.outline.length > 0) {
        const bounds = getBoundsFromPoints4(pcbGroup.outline);
        if (bounds) {
          width = bounds.maxX - bounds.minX;
          height = bounds.maxY - bounds.minY;
        }
      }
      updateBounds(pcbGroup.center, width, height);
    }
    if (props.boardAnchorPosition) {
      const { x, y } = props.boardAnchorPosition;
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
    }
    const padding = 2;
    const computedWidth = hasComponents ? maxX - minX + padding * 2 : 0;
    const computedHeight = hasComponents ? maxY - minY + padding * 2 : 0;
    const center = {
      x: hasComponents ? (minX + maxX) / 2 + (props.outlineOffsetX ?? 0) : props.outlineOffsetX ?? 0,
      y: hasComponents ? (minY + maxY) / 2 + (props.outlineOffsetY ?? 0) : props.outlineOffsetY ?? 0
    };
    const finalWidth = props.width ?? computedWidth;
    const finalHeight = props.height ?? computedHeight;
    let outline = props.outline;
    if (!outline && props.borderRadius != null && finalWidth > 0 && finalHeight > 0) {
      outline = getRoundedRectOutline(
        finalWidth,
        finalHeight,
        props.borderRadius
      );
    }
    const update = {
      width: finalWidth,
      height: finalHeight,
      center
    };
    if (outline) {
      update.outline = outline.map((point) => ({
        x: point.x + (props.outlineOffsetX ?? 0),
        y: point.y + (props.outlineOffsetY ?? 0)
      }));
    }
    db.pcb_board.update(this.pcb_board_id, update);
  }
  // Recompute autosize after child components update (e.g., async footprints)
  updatePcbBoardAutoSize() {
    this.doInitialPcbBoardAutoSize();
  }
  /**
   * Update the board information silkscreen text if platform config is set and
   * the project name, version, or url is set.
   */
  _addBoardInformationToSilkscreen() {
    const platform = this.root?.platform;
    if (!platform?.printBoardInformationToSilkscreen) return;
    const pcbBoard = this.root.db.pcb_board.get(this.pcb_board_id);
    if (!pcbBoard) return;
    const boardInformation = [];
    if (platform.projectName) boardInformation.push(platform.projectName);
    if (platform.version) boardInformation.push(`v${platform.version}`);
    if (platform.url) boardInformation.push(platform.url);
    if (boardInformation.length === 0) return;
    const text = boardInformation.join("\n");
    const marginX = 0.25;
    const marginY = 1;
    const position = {
      x: pcbBoard.center.x + pcbBoard.width / 2 - marginX,
      y: pcbBoard.center.y - pcbBoard.height / 2 + marginY
    };
    this.root.db.pcb_silkscreen_text.insert({
      pcb_component_id: this.pcb_board_id,
      layer: "top",
      font: "tscircuit2024",
      font_size: 0.45,
      text,
      ccw_rotation: 0,
      anchor_alignment: "bottom_right",
      anchor_position: position
    });
  }
  doInitialSourceRender() {
    super.doInitialSourceRender();
    const { db } = this.root;
    const source_board = db.source_board.insert({
      source_group_id: this.source_group_id,
      title: this.props.title || this.props.name
    });
    this.source_board_id = source_board.source_board_id;
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    let computedWidth = props.width ?? 0;
    let computedHeight = props.height ?? 0;
    let center = {
      x: (props.pcbX ?? 0) + (props.outlineOffsetX ?? 0),
      y: (props.pcbY ?? 0) + (props.outlineOffsetY ?? 0)
    };
    const { boardAnchorPosition, boardAnchorAlignment } = props;
    if (boardAnchorPosition) {
      center = getBoardCenterFromAnchor({
        boardAnchorPosition,
        boardAnchorAlignment: boardAnchorAlignment ?? "center",
        width: computedWidth,
        height: computedHeight
      });
    }
    if (props.outline) {
      const xValues = props.outline.map((point) => point.x);
      const yValues = props.outline.map((point) => point.y);
      const minX = Math.min(...xValues);
      const maxX = Math.max(...xValues);
      const minY = Math.min(...yValues);
      const maxY = Math.max(...yValues);
      computedWidth = maxX - minX;
      computedHeight = maxY - minY;
      center = {
        x: (minX + maxX) / 2 + (props.outlineOffsetX ?? 0),
        y: (minY + maxY) / 2 + (props.outlineOffsetY ?? 0)
      };
    }
    let outline = props.outline;
    if (!outline && props.borderRadius != null && computedWidth > 0 && computedHeight > 0) {
      outline = getRoundedRectOutline(
        computedWidth,
        computedHeight,
        props.borderRadius
      );
    }
    const pcb_board = db.pcb_board.insert({
      center,
      thickness: this.boardThickness,
      num_layers: this.allLayers.length,
      width: computedWidth,
      height: computedHeight,
      outline: outline?.map((point) => ({
        x: point.x + (props.outlineOffsetX ?? 0),
        y: point.y + (props.outlineOffsetY ?? 0)
      })),
      material: props.material
    });
    this.pcb_board_id = pcb_board.pcb_board_id;
    this._addBoardInformationToSilkscreen();
  }
  removePcbComponentRender() {
    const { db } = this.root;
    if (!this.pcb_board_id) return;
    db.pcb_board.delete(this.pcb_board_id);
    this.pcb_board_id = null;
  }
  _computePcbGlobalTransformBeforeLayout() {
    return identity4();
  }
  doInitialPcbDesignRuleChecks() {
    if (this.root?.pcbDisabled) return;
    if (this.getInheritedProperty("routingDisabled")) return;
    super.doInitialPcbDesignRuleChecks();
  }
  updatePcbDesignRuleChecks() {
    if (this.root?.pcbDisabled) return;
    if (this.getInheritedProperty("routingDisabled")) return;
    const { db } = this.root;
    if (!this._areChildSubcircuitsRouted()) return;
    if (this._drcChecksComplete) return;
    this._drcChecksComplete = true;
    const errors = checkEachPcbTraceNonOverlapping(db.toArray());
    for (const error of errors) {
      db.pcb_trace_error.insert(error);
    }
    const pcbPortNotConnectedErrors = checkEachPcbPortConnectedToPcbTraces(
      db.toArray()
    );
    for (const error of pcbPortNotConnectedErrors) {
      db.pcb_port_not_connected_error.insert(error);
    }
    const pcbComponentOutsideErrors = checkPcbComponentsOutOfBoard(db.toArray());
    for (const error of pcbComponentOutsideErrors) {
      db.pcb_component_outside_board_error.insert(error);
    }
    const pcbTracesOutOfBoardErrors = checkPcbTracesOutOfBoard(db.toArray());
    for (const error of pcbTracesOutOfBoardErrors) {
      db.pcb_trace_error.insert(error);
    }
    const differentNetViaErrors = checkDifferentNetViaSpacing(db.toArray());
    for (const error of differentNetViaErrors) {
      db.pcb_via_clearance_error.insert(error);
    }
    const sameNetViaErrors = checkSameNetViaSpacing(db.toArray());
    for (const error of sameNetViaErrors) {
      db.pcb_via_clearance_error.insert(error);
    }
    const pcbComponentOverlapErrors = checkPcbComponentOverlap(db.toArray());
    for (const error of pcbComponentOverlapErrors) {
      db.pcb_footprint_overlap_error.insert(error);
    }
  }
  _emitRenderLifecycleEvent(phase, startOrEnd) {
    super._emitRenderLifecycleEvent(phase, startOrEnd);
    if (startOrEnd === "start") {
      this.root?.emit("board:renderPhaseStarted", {
        renderId: this._renderId,
        phase
      });
    }
  }
};

// lib/components/normal-components/Panel.ts
import { panelProps } from "@tscircuit/props";
import { distance as distance7 } from "circuit-json";

// lib/utils/panels/generate-panel-tabs-and-mouse-bites.ts
var TAB_CONFIG = {
  TAB_WIDTH: 4,
  TAB_DEPTH: 0.5,
  TAB_TO_SPACE_RATIO: 5,
  MOUSE_BITE_DIAMETER: 0.2,
  MOUSE_BITE_SPACING: 0.1,
  MOUSE_BITES_PER_GAP: 5
};
function rectanglesOverlap(rect1, rect2) {
  const r1Left = rect1.center.x - rect1.width / 2;
  const r1Right = rect1.center.x + rect1.width / 2;
  const r1Bottom = rect1.center.y - rect1.height / 2;
  const r1Top = rect1.center.y + rect1.height / 2;
  const r2Left = rect2.center.x - rect2.width / 2;
  const r2Right = rect2.center.x + rect2.width / 2;
  const r2Bottom = rect2.center.y - rect2.height / 2;
  const r2Top = rect2.center.y + rect2.height / 2;
  return !(r1Right <= r2Left || r1Left >= r2Right || r1Top <= r2Bottom || r1Bottom >= r2Top);
}
function pointOverlapsRectangle(point, radius, rect) {
  const rectLeft = rect.center.x - rect.width / 2;
  const rectRight = rect.center.x + rect.width / 2;
  const rectBottom = rect.center.y - rect.height / 2;
  const rectTop = rect.center.y + rect.height / 2;
  const closestX = Math.max(rectLeft, Math.min(point.x, rectRight));
  const closestY = Math.max(rectBottom, Math.min(point.y, rectTop));
  const distanceX = point.x - closestX;
  const distanceY = point.y - closestY;
  return distanceX * distanceX + distanceY * distanceY <= radius * radius;
}
function generateTabsForEdge(board, edge, existingTabs, otherBoards) {
  const tabs = [];
  if (!board.width || !board.height) return tabs;
  const boardLeft = board.center.x - board.width / 2;
  const boardRight = board.center.x + board.width / 2;
  const boardBottom = board.center.y - board.height / 2;
  const boardTop = board.center.y + board.height / 2;
  let edgeLength;
  let isHorizontal;
  let edgeCenter;
  if (edge === "top" || edge === "bottom") {
    edgeLength = board.width;
    isHorizontal = true;
    edgeCenter = edge === "top" ? boardTop : boardBottom;
  } else {
    edgeLength = board.height;
    isHorizontal = false;
    edgeCenter = edge === "right" ? boardRight : boardLeft;
  }
  const totalTabWidth = TAB_CONFIG.TAB_WIDTH;
  const minSpacingForMouseBites = TAB_CONFIG.MOUSE_BITES_PER_GAP * TAB_CONFIG.MOUSE_BITE_DIAMETER + (TAB_CONFIG.MOUSE_BITES_PER_GAP - 1) * TAB_CONFIG.MOUSE_BITE_SPACING;
  const fixedSpacing = minSpacingForMouseBites * 1.1;
  let numTabs = Math.floor(
    (edgeLength - fixedSpacing) / (totalTabWidth + fixedSpacing)
  );
  if (numTabs < 1 && edgeLength >= totalTabWidth) {
    numTabs = 1;
  }
  if (numTabs === 0) return tabs;
  const actualSpacing = fixedSpacing;
  const boardStart = -edgeLength / 2;
  const boardEnd = edgeLength / 2;
  for (let i = 0; i < numTabs; i++) {
    const offsetAlongEdge = boardStart + actualSpacing + i * (totalTabWidth + actualSpacing) + totalTabWidth / 2;
    const isFirstTab = i === 0;
    const isLastTab = i === numTabs - 1;
    const isCornerTab = isFirstTab || isLastTab;
    let axisStart = offsetAlongEdge - totalTabWidth / 2;
    let axisEnd = offsetAlongEdge + totalTabWidth / 2;
    if (isCornerTab) {
      if (isFirstTab) axisStart = boardStart;
      if (isLastTab) axisEnd = boardEnd;
    }
    axisStart = Math.max(axisStart, boardStart);
    axisEnd = Math.min(axisEnd, boardEnd);
    if (isCornerTab) {
      if (isFirstTab) axisStart -= TAB_CONFIG.TAB_DEPTH;
      if (isLastTab) axisEnd += TAB_CONFIG.TAB_DEPTH;
    }
    if (axisEnd <= axisStart) continue;
    const axisCenterOffset = (axisStart + axisEnd) / 2;
    const axisLength = axisEnd - axisStart;
    const crossAxisOffset = edge === "top" || edge === "right" ? TAB_CONFIG.TAB_DEPTH / 2 : -TAB_CONFIG.TAB_DEPTH / 2;
    const tabCenter = isHorizontal ? {
      x: board.center.x + axisCenterOffset,
      y: edgeCenter + crossAxisOffset
    } : {
      x: edgeCenter + crossAxisOffset,
      y: board.center.y + axisCenterOffset
    };
    const tabWidth = isHorizontal ? axisLength : TAB_CONFIG.TAB_DEPTH;
    const tabHeight = isHorizontal ? TAB_CONFIG.TAB_DEPTH : axisLength;
    const newTab = {
      center: tabCenter,
      width: tabWidth,
      height: tabHeight,
      boardId: `${board.center.x}_${board.center.y}`
    };
    let overlapsBoard = false;
    for (const otherBoard of otherBoards) {
      if (!otherBoard.width || !otherBoard.height) continue;
      const boardRect = {
        center: otherBoard.center,
        width: otherBoard.width,
        height: otherBoard.height
      };
      if (rectanglesOverlap(newTab, boardRect)) {
        overlapsBoard = true;
        break;
      }
    }
    if (overlapsBoard && !isCornerTab) continue;
    tabs.push(newTab);
  }
  return tabs;
}
function generateMouseBitesForEdge(board, edge, edgeTabs, allTabs, allBoards, existingMouseBites) {
  const mouseBites = [];
  if (edgeTabs.length === 0) return mouseBites;
  if (!board.width || !board.height) return mouseBites;
  const boardLeft = board.center.x - board.width / 2;
  const boardRight = board.center.x + board.width / 2;
  const boardBottom = board.center.y - board.height / 2;
  const boardTop = board.center.y + board.height / 2;
  const isHorizontal = edge === "top" || edge === "bottom";
  let mouseBitePosition;
  const radius = TAB_CONFIG.MOUSE_BITE_DIAMETER / 2;
  if (edge === "top") {
    mouseBitePosition = boardTop;
  } else if (edge === "bottom") {
    mouseBitePosition = boardBottom;
  } else if (edge === "right") {
    mouseBitePosition = boardRight;
  } else {
    mouseBitePosition = boardLeft;
  }
  const sortedTabs = [...edgeTabs].sort((a, b) => {
    if (isHorizontal) {
      return a.center.x - b.center.x;
    } else {
      return a.center.y - b.center.y;
    }
  });
  for (let i = 0; i < sortedTabs.length - 1; i++) {
    const tab1 = sortedTabs[i];
    const tab2 = sortedTabs[i + 1];
    let gapStart;
    let gapEnd;
    if (isHorizontal) {
      gapStart = tab1.center.x + tab1.width / 2;
      gapEnd = tab2.center.x - tab2.width / 2;
    } else {
      gapStart = tab1.center.y + tab1.height / 2;
      gapEnd = tab2.center.y - tab2.height / 2;
    }
    const gapLength = gapEnd - gapStart;
    const totalMouseBiteWidth = TAB_CONFIG.MOUSE_BITES_PER_GAP * TAB_CONFIG.MOUSE_BITE_DIAMETER;
    const totalSpacing = (TAB_CONFIG.MOUSE_BITES_PER_GAP - 1) * TAB_CONFIG.MOUSE_BITE_SPACING;
    if (gapLength < totalMouseBiteWidth + totalSpacing) continue;
    const gapCenter = (gapStart + gapEnd) / 2;
    for (let j = 0; j < TAB_CONFIG.MOUSE_BITES_PER_GAP; j++) {
      const posOffset = (j - (TAB_CONFIG.MOUSE_BITES_PER_GAP - 1) / 2) * (TAB_CONFIG.MOUSE_BITE_DIAMETER + TAB_CONFIG.MOUSE_BITE_SPACING);
      const newMouseBite = isHorizontal ? { x: gapCenter + posOffset, y: mouseBitePosition } : { x: mouseBitePosition, y: gapCenter + posOffset };
      const radius2 = TAB_CONFIG.MOUSE_BITE_DIAMETER / 2;
      let overlapsBoard = false;
      for (const otherBoard of allBoards) {
        if (!otherBoard.width || !otherBoard.height) continue;
        const boardRect = {
          center: otherBoard.center,
          width: otherBoard.width,
          height: otherBoard.height
        };
        if (pointOverlapsRectangle(newMouseBite, radius2, boardRect)) {
          overlapsBoard = true;
          break;
        }
      }
      if (overlapsBoard) continue;
      mouseBites.push(newMouseBite);
    }
  }
  return mouseBites;
}
function generatePanelTabsAndMouseBites(boards) {
  const allTabCutouts = [];
  const allMouseBites = [];
  for (let boardIndex = 0; boardIndex < boards.length; boardIndex++) {
    const board = boards[boardIndex];
    const otherBoards = boards.filter((_, i) => i !== boardIndex);
    for (const edge of ["top", "bottom", "left", "right"]) {
      const edgeTabs = generateTabsForEdge(
        board,
        edge,
        allTabCutouts,
        otherBoards
      );
      allTabCutouts.push(...edgeTabs);
      const edgeMouseBites = generateMouseBitesForEdge(
        board,
        edge,
        edgeTabs,
        allTabCutouts,
        otherBoards,
        allMouseBites
      );
      allMouseBites.push(...edgeMouseBites);
    }
  }
  const tabCutouts = allTabCutouts.map((tab, index) => ({
    type: "pcb_cutout",
    pcb_cutout_id: `panel_tab_${index}`,
    shape: "rect",
    center: tab.center,
    width: tab.width,
    height: tab.height,
    corner_radius: 0.25
  }));
  const mouseBiteHoles = allMouseBites.map((bite, index) => ({
    type: "pcb_hole",
    pcb_hole_id: `panel_mouse_bite_${index}`,
    hole_shape: "circle",
    hole_diameter: TAB_CONFIG.MOUSE_BITE_DIAMETER,
    x: bite.x,
    y: bite.y
  }));
  return {
    tabCutouts,
    mouseBiteHoles
  };
}

// lib/components/normal-components/Panel.ts
var Panel = class extends Group6 {
  pcb_panel_id = null;
  _tabsAndMouseBitesGenerated = false;
  get config() {
    return {
      componentName: "Panel",
      zodProps: panelProps
    };
  }
  get isGroup() {
    return true;
  }
  get isSubcircuit() {
    return true;
  }
  add(component) {
    if (component.lowercaseComponentName !== "board") {
      throw new Error("<panel> can only contain <board> elements");
    }
    super.add(component);
  }
  doInitialPcbComponentAnchorAlignment() {
    if (this.root?.pcbDisabled) return;
    super.doInitialPcbComponentAnchorAlignment();
    const { db } = this.root;
    const childBoardInstances = this.children.filter(
      (c) => c instanceof Board
    );
    const unpositionedBoards = childBoardInstances.filter(
      (b) => b.props.pcbX === void 0 && b.props.pcbY === void 0
    );
    if (unpositionedBoards.length > 0) {
      const gridCols = Math.ceil(Math.sqrt(unpositionedBoards.length));
      const gridRows = Math.ceil(unpositionedBoards.length / gridCols);
      const colWidths = Array(gridCols).fill(0);
      const rowHeights = Array(gridRows).fill(0);
      unpositionedBoards.forEach((board, i) => {
        const col = i % gridCols;
        const row = Math.floor(i / gridCols);
        const pcbBoard = db.pcb_board.get(board.pcb_board_id);
        if (!pcbBoard || pcbBoard.width === void 0 || pcbBoard.height === void 0)
          return;
        colWidths[col] = Math.max(colWidths[col], pcbBoard.width);
        rowHeights[row] = Math.max(rowHeights[row], pcbBoard.height);
      });
      const totalGridWidth = colWidths.reduce((a, b) => a + b, 0) + (gridCols > 1 ? (gridCols - 1) * TAB_CONFIG.TAB_DEPTH : 0);
      const totalGridHeight = rowHeights.reduce((a, b) => a + b, 0) + (gridRows > 1 ? (gridRows - 1) * TAB_CONFIG.TAB_DEPTH : 0);
      const startX = -totalGridWidth / 2;
      const startY = -totalGridHeight / 2;
      const rowYOffsets = [startY];
      for (let i = 0; i < gridRows - 1; i++) {
        rowYOffsets.push(rowYOffsets[i] + rowHeights[i] + TAB_CONFIG.TAB_DEPTH);
      }
      const colXOffsets = [startX];
      for (let i = 0; i < gridCols - 1; i++) {
        colXOffsets.push(colXOffsets[i] + colWidths[i] + TAB_CONFIG.TAB_DEPTH);
      }
      unpositionedBoards.forEach((board, i) => {
        const col = i % gridCols;
        const row = Math.floor(i / gridCols);
        const pcbBoard = db.pcb_board.get(board.pcb_board_id);
        if (!pcbBoard || !pcbBoard.width || !pcbBoard.height) return;
        const xPos = colXOffsets[col] + colWidths[col] / 2;
        const yPos = rowYOffsets[row] + rowHeights[row] / 2;
        db.pcb_board.update(board.pcb_board_id, {
          center: { x: xPos, y: yPos }
        });
      });
      const allBoardPcbIds = childBoardInstances.map((b) => b.pcb_board_id).filter((id) => !!id);
      const allBoardsInPanel = db.pcb_board.list().filter((b) => allBoardPcbIds.includes(b.pcb_board_id));
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      for (const board of allBoardsInPanel) {
        if (board.width === void 0 || board.height === void 0 || !isFinite(board.width) || !isFinite(board.height))
          continue;
        const left = board.center.x - board.width / 2;
        const right = board.center.x + board.width / 2;
        const bottom = board.center.y - board.height / 2;
        const top = board.center.y + board.height / 2;
        minX = Math.min(minX, left);
        maxX = Math.max(maxX, right);
        minY = Math.min(minY, bottom);
        maxY = Math.max(maxY, top);
      }
      if (isFinite(minX)) {
        const boundsWidth = maxX - minX;
        const boundsHeight = maxY - minY;
        const margin = TAB_CONFIG.TAB_DEPTH * 3;
        const newPanelWidth = boundsWidth + 2 * margin;
        const newPanelHeight = boundsHeight + 2 * margin;
        db.pcb_panel.update(this.pcb_panel_id, {
          width: newPanelWidth,
          height: newPanelHeight
        });
      }
    }
    if (this._tabsAndMouseBitesGenerated) return;
    const childBoardIds = childBoardInstances.map((c) => c.pcb_board_id).filter((id) => !!id);
    const boardsInPanel = db.pcb_board.list().filter((b) => childBoardIds.includes(b.pcb_board_id));
    if (boardsInPanel.length === 0) return;
    const { tabCutouts, mouseBiteHoles } = generatePanelTabsAndMouseBites(boardsInPanel);
    for (const tabCutout of tabCutouts) {
      db.pcb_cutout.insert(tabCutout);
    }
    for (const mouseBiteHole of mouseBiteHoles) {
      db.pcb_hole.insert(mouseBiteHole);
    }
    this._tabsAndMouseBitesGenerated = true;
  }
  runRenderCycle() {
    if (!this.children.some((child) => child.componentName === "Board")) {
      throw new Error("<panel> must contain at least one <board>");
    }
    super.runRenderCycle();
  }
  doInitialPcbComponentRender() {
    super.doInitialPcbComponentRender();
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const props = this._parsedProps;
    const inserted = db.pcb_panel.insert({
      width: distance7.parse(props.width),
      height: distance7.parse(props.height),
      center: this._getGlobalPcbPositionBeforeLayout(),
      covered_with_solder_mask: !(props.noSolderMask ?? false)
    });
    this.pcb_panel_id = inserted.pcb_panel_id;
  }
  updatePcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    if (!this.pcb_panel_id) return;
    const { db } = this.root;
    const props = this._parsedProps;
    db.pcb_panel.update(this.pcb_panel_id, {
      width: distance7.parse(props.width),
      height: distance7.parse(props.height),
      center: this._getGlobalPcbPositionBeforeLayout(),
      covered_with_solder_mask: !(props.noSolderMask ?? false)
    });
  }
  removePcbComponentRender() {
    if (!this.pcb_panel_id) return;
    this.root?.db.pcb_panel.delete(this.pcb_panel_id);
    this.pcb_panel_id = null;
  }
};

// lib/components/normal-components/Capacitor.ts
import { capacitorProps } from "@tscircuit/props";

// lib/utils/constants.ts
var stringProxy = new Proxy(
  {},
  {
    get: (target, prop) => prop
  }
);
var FTYPE = stringProxy;
var SCHEMATIC_COMPONENT_OUTLINE_COLOR = "rgba(132, 0, 0)";
var SCHEMATIC_COMPONENT_OUTLINE_STROKE_WIDTH = 0.12;

// lib/components/normal-components/Capacitor.ts
import { formatSiUnit } from "format-si-unit";
var Capacitor = class extends NormalComponent3 {
  _adjustSilkscreenTextAutomatically = true;
  // @ts-ignore (cause the symbolName is string and not fixed)
  get config() {
    return {
      componentName: "Capacitor",
      schematicSymbolName: this.props.polarized ? "capacitor_polarized" : this.props.symbolName ?? "capacitor",
      zodProps: capacitorProps,
      sourceFtype: FTYPE.simple_capacitor
    };
  }
  initPorts() {
    if (typeof this.props.footprint === "string") {
      super.initPorts({
        additionalAliases: {
          pin1: ["anode", "pos"],
          pin2: ["cathode", "neg"]
        }
      });
    } else {
      super.initPorts();
    }
  }
  _getSchematicSymbolDisplayValue() {
    const inputCapacitance = this.props.capacitance;
    const capacitanceDisplay = typeof inputCapacitance === "string" ? inputCapacitance : `${formatSiUnit(this._parsedProps.capacitance)}F`;
    if (this._parsedProps.schShowRatings && this._parsedProps.maxVoltageRating) {
      return `${capacitanceDisplay}/${formatSiUnit(this._parsedProps.maxVoltageRating)}V`;
    }
    return capacitanceDisplay;
  }
  doInitialCreateNetsFromProps() {
    this._createNetsFromProps([
      this.props.decouplingFor,
      this.props.decouplingTo,
      ...this._getNetsFromConnectionsProp()
    ]);
  }
  doInitialCreateTracesFromProps() {
    if (this.props.decouplingFor && this.props.decouplingTo) {
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.1`,
          to: this.props.decouplingFor
        })
      );
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.2`,
          to: this.props.decouplingTo
        })
      );
    }
    this._createTracesFromConnectionsProp();
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_capacitor",
      name: this.name,
      // @ts-ignore
      manufacturer_part_number: props.manufacturerPartNumber ?? props.mfn,
      supplier_part_numbers: props.supplierPartNumbers,
      capacitance: props.capacitance,
      max_voltage_rating: props.maxVoltageRating,
      max_decoupling_trace_length: props.maxDecouplingTraceLength,
      display_capacitance: this._getSchematicSymbolDisplayValue(),
      are_pins_interchangeable: !props.polarized
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Chip.ts
import { chipProps as chipProps2 } from "@tscircuit/props";
import { pcb_component_invalid_layer_error as pcb_component_invalid_layer_error2 } from "circuit-json";
var Chip = class extends NormalComponent3 {
  schematicBoxDimensions = null;
  constructor(props) {
    super(props);
  }
  get config() {
    return {
      componentName: "Chip",
      zodProps: chipProps2,
      shouldRenderAsSchematicBox: true
    };
  }
  initPorts(opts = {}) {
    super.initPorts(opts);
    const { _parsedProps: props } = this;
    if (props.externallyConnectedPins) {
      const requiredPorts = /* @__PURE__ */ new Set();
      for (const [pin1, pin2] of props.externallyConnectedPins) {
        requiredPorts.add(pin1);
        requiredPorts.add(pin2);
      }
      for (const pinIdentifier of requiredPorts) {
        const existingPort = this.children.find(
          (child) => child instanceof Port && child.isMatchingAnyOf([pinIdentifier])
        );
        if (!existingPort) {
          const pinMatch = pinIdentifier.match(/^pin(\d+)$/);
          if (pinMatch) {
            const pinNumber = parseInt(pinMatch[1]);
            this.add(
              new Port({
                pinNumber,
                aliases: [pinIdentifier]
              })
            );
          } else {
            this.add(
              new Port({
                name: pinIdentifier,
                aliases: [pinIdentifier]
              })
            );
          }
        }
      }
    }
  }
  doInitialSchematicComponentRender() {
    const { _parsedProps: props } = this;
    if (props?.noSchematicRepresentation === true) return;
    super.doInitialSchematicComponentRender();
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_chip",
      name: this.name,
      manufacturer_part_number: props.manufacturerPartNumber,
      supplier_part_numbers: props.supplierPartNumbers
    });
    this.source_component_id = source_component.source_component_id;
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const componentLayer = props.layer ?? "top";
    if (componentLayer !== "top" && componentLayer !== "bottom") {
      const subcircuit = this.getSubcircuit();
      const error = pcb_component_invalid_layer_error2.parse({
        type: "pcb_component_invalid_layer_error",
        message: `Component cannot be placed on layer '${componentLayer}'. Components can only be placed on 'top' or 'bottom' layers.`,
        source_component_id: this.source_component_id,
        layer: componentLayer,
        subcircuit_id: subcircuit.subcircuit_id ?? void 0
      });
      db.pcb_component_invalid_layer_error.insert(error);
    }
    const pcb_component = db.pcb_component.insert({
      center: { x: props.pcbX ?? 0, y: props.pcbY ?? 0 },
      width: 2,
      // Default width, adjust as needed
      height: 3,
      // Default height, adjust as needed
      layer: componentLayer === "top" || componentLayer === "bottom" ? componentLayer : "top",
      rotation: props.pcbRotation ?? 0,
      source_component_id: this.source_component_id,
      subcircuit_id: this.getSubcircuit().subcircuit_id ?? void 0,
      do_not_place: props.doNotPlace ?? false,
      obstructs_within_bounds: props.obstructsWithinBounds ?? true
    });
    this.pcb_component_id = pcb_component.pcb_component_id;
  }
  doInitialCreateTracesFromProps() {
    const { _parsedProps: props } = this;
    if (props.externallyConnectedPins) {
      for (const [pin1, pin2] of props.externallyConnectedPins) {
        this.add(
          new Trace3({
            from: `${this.getSubcircuitSelector()} > port.${pin1}`,
            to: `${this.getSubcircuitSelector()} > port.${pin2}`
          })
        );
      }
    }
    this._createTracesFromConnectionsProp();
  }
  doInitialSimulationRender() {
    const { db } = this.root;
    const { pinAttributes } = this.props;
    if (!pinAttributes) return;
    let powerPort = null;
    let groundPort = null;
    let voltage2;
    const ports = this.selectAll("port");
    for (const port of ports) {
      for (const alias of port.getNameAndAliases()) {
        if (pinAttributes[alias]) {
          const attributes = pinAttributes[alias];
          if (attributes.providesPower) {
            powerPort = port;
            voltage2 = attributes.providesVoltage;
          }
          if (attributes.providesGround) {
            groundPort = port;
          }
        }
      }
    }
    if (!powerPort || !groundPort || voltage2 === void 0) {
      return;
    }
    const powerSourcePort = db.source_port.get(powerPort.source_port_id);
    if (!powerSourcePort?.subcircuit_connectivity_map_key) return;
    const groundSourcePort = db.source_port.get(groundPort.source_port_id);
    if (!groundSourcePort?.subcircuit_connectivity_map_key) return;
    const powerNet = db.source_net.getWhere({
      subcircuit_connectivity_map_key: powerSourcePort.subcircuit_connectivity_map_key
    });
    const groundNet = db.source_net.getWhere({
      subcircuit_connectivity_map_key: groundSourcePort.subcircuit_connectivity_map_key
    });
    if (!powerNet || !groundNet) {
      return;
    }
    ;
    db.simulation_voltage_source.insert({
      type: "simulation_voltage_source",
      positive_source_port_id: powerPort.source_port_id,
      positive_source_net_id: powerNet.source_net_id,
      negative_source_port_id: groundPort.source_port_id,
      negative_source_net_id: groundNet.source_net_id,
      voltage: voltage2
    });
  }
};

// lib/components/normal-components/Pinout.ts
import { pinoutProps } from "@tscircuit/props";
var Pinout = class extends Chip {
  constructor(props) {
    super(props);
  }
  get config() {
    return {
      ...super.config,
      componentName: "Pinout",
      zodProps: pinoutProps
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_pinout",
      name: this.name,
      manufacturer_part_number: props.manufacturerPartNumber,
      supplier_part_numbers: props.supplierPartNumbers
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Diode.ts
import { diodeProps } from "@tscircuit/props";
var Diode = class extends NormalComponent3 {
  // @ts-ignore
  get config() {
    const symbolMap = {
      schottky: "schottky_diode",
      avalanche: "avalanche_diode",
      zener: "zener_diode",
      photodiode: "photodiode"
    };
    const variantSymbol = this.props.schottky ? "schottky" : this.props.avalanche ? "avalanche" : this.props.zener ? "zener" : this.props.photo ? "photodiode" : null;
    return {
      schematicSymbolName: variantSymbol ? symbolMap[variantSymbol] : this.props.symbolName ?? "diode",
      componentName: "Diode",
      zodProps: diodeProps,
      sourceFtype: "simple_diode"
    };
  }
  initPorts() {
    super.initPorts({
      additionalAliases: {
        pin1: ["anode", "pos", "left"],
        pin2: ["cathode", "neg", "right"]
      }
    });
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_diode",
      name: this.name,
      // @ts-ignore
      manufacturer_part_number: props.manufacturerPartNumber ?? props.mfn,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: false
    });
    this.source_component_id = source_component.source_component_id;
  }
  pos = this.portMap.pin1;
  anode = this.portMap.pin1;
  neg = this.portMap.pin2;
  cathode = this.portMap.pin2;
};

// lib/components/normal-components/Fuse.ts
import { fuseProps } from "@tscircuit/props";
import { formatSiUnit as formatSiUnit2 } from "format-si-unit";
var Fuse = class extends NormalComponent3 {
  get config() {
    return {
      componentName: "fuse",
      schematicSymbolName: this.props.symbolName ?? "fuse",
      zodProps: fuseProps,
      sourceFtype: FTYPE.simple_fuse
    };
  }
  _getSchematicSymbolDisplayValue() {
    const rawCurrent = this._parsedProps.currentRating;
    const rawVoltage = this._parsedProps.voltageRating;
    const current = typeof rawCurrent === "string" ? parseFloat(rawCurrent) : rawCurrent;
    const voltage2 = typeof rawVoltage === "string" ? parseFloat(rawVoltage) : rawVoltage;
    return `${formatSiUnit2(current)}A / ${formatSiUnit2(voltage2)}V`;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const currentRating = typeof props.currentRating === "string" ? parseFloat(props.currentRating) : props.currentRating;
    const voltageRating = typeof props.voltageRating === "string" ? parseFloat(props.voltageRating) : props.voltageRating;
    const source_component = db.source_component.insert({
      name: this.name,
      ftype: FTYPE.simple_fuse,
      current_rating_amps: currentRating,
      voltage_rating_volts: voltageRating,
      display_current_rating: `${formatSiUnit2(currentRating)}A`,
      display_voltage_rating: `${formatSiUnit2(voltageRating)}V`
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Jumper.ts
import { jumperProps } from "@tscircuit/props";
var Jumper = class extends NormalComponent3 {
  schematicDimensions = null;
  get config() {
    return {
      schematicSymbolName: void 0,
      componentName: "Jumper",
      zodProps: jumperProps,
      shouldRenderAsSchematicBox: true
    };
  }
  _getSchematicPortArrangement() {
    const arrangement = super._getSchematicPortArrangement();
    if (arrangement && Object.keys(arrangement).length > 0) return arrangement;
    const pinCount = this._parsedProps.pinCount ?? (Array.isArray(this._parsedProps.pinLabels) ? this._parsedProps.pinLabels.length : this._parsedProps.pinLabels ? Object.keys(this._parsedProps.pinLabels).length : this.getPortsFromFootprint().length);
    const direction = this._parsedProps.schDirection ?? "right";
    return {
      leftSize: direction === "left" ? pinCount : 0,
      rightSize: direction === "right" ? pinCount : 0
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_chip",
      // TODO unknown or jumper
      name: this.name,
      manufacturer_part_number: props.manufacturerPartNumber,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const pcb_component = db.pcb_component.insert({
      center: { x: props.pcbX ?? 0, y: props.pcbY ?? 0 },
      width: 2,
      // Default width, adjust as needed
      height: 3,
      // Default height, adjust as needed
      layer: props.layer ?? "top",
      rotation: props.pcbRotation ?? 0,
      source_component_id: this.source_component_id,
      subcircuit_id: this.getSubcircuit().subcircuit_id ?? void 0,
      do_not_place: props.doNotPlace ?? false,
      obstructs_within_bounds: props.obstructsWithinBounds ?? true
    });
    this.pcb_component_id = pcb_component.pcb_component_id;
  }
  doInitialPcbTraceRender() {
    const { db } = this.root;
    const pcb_ports = db.pcb_port.list({
      pcb_component_id: this.pcb_component_id
    });
    const pinLabelToPortId = {};
    for (let i = 0; i < pcb_ports.length; i++) {
      const port = pcb_ports[i];
      const sourcePort = db.source_port.get(port.source_port_id);
      let pinLabel = "";
      if (typeof sourcePort?.pin_number === "number") {
        pinLabel = sourcePort.pin_number.toString();
      } else if (Array.isArray(sourcePort?.port_hints)) {
        let matchedHint = sourcePort.port_hints.find(
          (h) => /^(pin)?\d+$/.test(h)
        );
        if (matchedHint) {
          if (/^pin\d+$/.test(matchedHint)) {
            pinLabel = matchedHint.replace(/^pin/, "");
          } else {
            pinLabel = matchedHint;
          }
        }
      }
      pinLabelToPortId[pinLabel] = port.pcb_port_id;
    }
    const traces = db.pcb_trace.list({
      pcb_component_id: this.pcb_component_id
    });
    const updatePortId = (portId) => {
      if (portId && typeof portId === "string" && portId.startsWith("{PIN")) {
        const pin = portId.replace("{PIN", "").replace("}", "");
        return pinLabelToPortId[pin] || portId;
      }
      return portId;
    };
    for (const trace of traces) {
      if (!trace.route) continue;
      for (const segment of trace.route) {
        if (segment.route_type !== "wire") continue;
        segment.start_pcb_port_id = updatePortId(segment.start_pcb_port_id);
        segment.end_pcb_port_id = updatePortId(segment.end_pcb_port_id);
      }
    }
  }
};

// lib/components/normal-components/SolderJumper.ts
import { solderjumperProps } from "@tscircuit/props";
var SolderJumper = class extends NormalComponent3 {
  schematicDimensions = null;
  _getPinNumberFromBridgedPinName(pinName) {
    const port = this.selectOne(`port.${pinName}`, {
      type: "port"
    });
    return port?._parsedProps.pinNumber ?? null;
  }
  get defaultInternallyConnectedPinNames() {
    if (this._parsedProps.bridged) {
      const pins = this.children.filter((c) => c.componentName === "Port").map((p) => p.name);
      return pins.length > 0 ? [pins] : [];
    }
    return this._parsedProps.bridgedPins ?? [];
  }
  get config() {
    const props = this._parsedProps ?? this.props;
    let resolvedPinCount = props.pinCount;
    if (props.pinCount == null && !props.footprint) {
      resolvedPinCount = 2;
    }
    if (props.pinCount == null) {
      const nums = (props.bridgedPins ?? []).flat().map((p_str) => this._getPinNumberFromBridgedPinName(p_str)).filter((n) => n !== null);
      const maxPinFromBridged = nums.length > 0 ? Math.max(...nums) : 0;
      const pinCountFromLabels = props.pinLabels ? Object.keys(props.pinLabels).length : 0;
      const finalPinCount = Math.max(maxPinFromBridged, pinCountFromLabels);
      if (finalPinCount === 2 || finalPinCount === 3) {
        resolvedPinCount = finalPinCount;
      }
      if (resolvedPinCount == null && props.footprint && [2, 3].includes(this.getPortsFromFootprint().length)) {
        resolvedPinCount = this.getPortsFromFootprint().length;
      }
    }
    let symbolName = "";
    if (resolvedPinCount) {
      symbolName += `solderjumper${resolvedPinCount}`;
    } else {
      symbolName = "solderjumper";
    }
    let bridgedPinNumbers = [];
    if (Array.isArray(props.bridgedPins) && props.bridgedPins.length > 0) {
      bridgedPinNumbers = Array.from(
        new Set(
          props.bridgedPins.flat().map((pinName) => this._getPinNumberFromBridgedPinName(pinName)).filter((n) => n !== null)
        )
      ).sort((a, b) => a - b);
    } else if (props.bridged && resolvedPinCount) {
      bridgedPinNumbers = Array.from(
        { length: resolvedPinCount },
        (_, i) => i + 1
      );
    }
    if (bridgedPinNumbers.length > 0) {
      symbolName += `_bridged${bridgedPinNumbers.join("")}`;
    }
    return {
      schematicSymbolName: props.symbolName ?? symbolName,
      componentName: "SolderJumper",
      zodProps: solderjumperProps,
      shouldRenderAsSchematicBox: true
    };
  }
  _getSchematicPortArrangement() {
    const arrangement = super._getSchematicPortArrangement();
    if (arrangement && Object.keys(arrangement).length > 0) return arrangement;
    let pinCount = this._parsedProps.pinCount ?? (Array.isArray(this._parsedProps.pinLabels) ? this._parsedProps.pinLabels.length : this._parsedProps.pinLabels ? Object.keys(this._parsedProps.pinLabels).length : this.getPortsFromFootprint().length);
    if (pinCount == null && !this._parsedProps.footprint) {
      pinCount = 2;
    }
    const direction = this._parsedProps.schDirection ?? "right";
    return {
      leftSize: direction === "left" ? pinCount : 0,
      rightSize: direction === "right" ? pinCount : 0
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_chip",
      // TODO unknown or jumper
      name: this.name,
      manufacturer_part_number: props.manufacturerPartNumber,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const pcb_component = db.pcb_component.insert({
      center: { x: props.pcbX ?? 0, y: props.pcbY ?? 0 },
      width: 2,
      // Default width, adjust as needed
      height: 3,
      // Default height, adjust as needed
      layer: props.layer ?? "top",
      rotation: props.pcbRotation ?? 0,
      source_component_id: this.source_component_id,
      subcircuit_id: this.getSubcircuit().subcircuit_id ?? void 0,
      do_not_place: props.doNotPlace ?? false,
      obstructs_within_bounds: props.obstructsWithinBounds ?? true
    });
    this.pcb_component_id = pcb_component.pcb_component_id;
  }
  doInitialPcbTraceRender() {
    const { db } = this.root;
    const pcb_ports = db.pcb_port.list({
      pcb_component_id: this.pcb_component_id
    });
    const pinLabelToPortId = {};
    for (let i = 0; i < pcb_ports.length; i++) {
      const port = pcb_ports[i];
      const sourcePort = db.source_port.get(port.source_port_id);
      let pinLabel = "";
      if (typeof sourcePort?.pin_number === "number") {
        pinLabel = sourcePort.pin_number.toString();
      } else if (Array.isArray(sourcePort?.port_hints)) {
        let matchedHint = sourcePort.port_hints.find(
          (h) => /^(pin)?\d+$/.test(h)
        );
        if (matchedHint) {
          if (/^pin\d+$/.test(matchedHint)) {
            pinLabel = matchedHint.replace(/^pin/, "");
          } else {
            pinLabel = matchedHint;
          }
        }
      }
      pinLabelToPortId[pinLabel] = port.pcb_port_id;
    }
    const traces = db.pcb_trace.list({
      pcb_component_id: this.pcb_component_id
    });
    const updatePortId = (portId) => {
      if (portId && typeof portId === "string" && portId.startsWith("{PIN")) {
        const pin = portId.replace("{PIN", "").replace("}", "");
        return pinLabelToPortId[pin] || portId;
      }
      return portId;
    };
    for (const trace of traces) {
      if (!trace.route) continue;
      for (const segment of trace.route) {
        if (segment.route_type !== "wire") continue;
        segment.start_pcb_port_id = updatePortId(segment.start_pcb_port_id);
        segment.end_pcb_port_id = updatePortId(segment.end_pcb_port_id);
      }
    }
  }
};

// lib/components/normal-components/Led.ts
import { ledProps } from "@tscircuit/props";
var Led = class extends NormalComponent3 {
  get config() {
    const symbolMap = {
      laser: "laser_diode"
    };
    const variantSymbol = this.props.laser ? "laser" : null;
    return {
      schematicSymbolName: variantSymbol ? symbolMap[variantSymbol] : this.props.symbolName ?? "led",
      componentName: "Led",
      zodProps: ledProps,
      sourceFtype: "simple_led"
    };
  }
  initPorts() {
    super.initPorts({
      additionalAliases: {
        pin1: ["anode", "pos", "left"],
        pin2: ["cathode", "neg", "right"]
      }
    });
  }
  _getSchematicSymbolDisplayValue() {
    return this._parsedProps.schDisplayValue || this._parsedProps.color || void 0;
  }
  getFootprinterString() {
    const baseFootprint = super.getFootprinterString();
    if (baseFootprint && this.props.color) {
      return `${baseFootprint}_color(${this.props.color})`;
    }
    return baseFootprint;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_led",
      name: this.name,
      wave_length: props.wavelength,
      color: props.color,
      symbol_display_value: this._getSchematicSymbolDisplayValue(),
      // @ts-ignore
      manufacturer_part_number: props.manufacturerPartNumber ?? props.mfn,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: false
    });
    this.source_component_id = source_component.source_component_id;
  }
  pos = this.portMap.pin1;
  anode = this.portMap.pin1;
  neg = this.portMap.pin2;
  cathode = this.portMap.pin2;
};

// lib/components/normal-components/PowerSource.ts
import { powerSourceProps } from "@tscircuit/props";
var PowerSource = class extends NormalComponent3 {
  // @ts-ignore
  get config() {
    return {
      // TBD in schematic_symbol and replace then
      schematicSymbolName: this.props.symbolName ?? "power_factor_meter_horz",
      componentName: "PowerSource",
      zodProps: powerSourceProps,
      sourceFtype: "simple_power_source"
    };
  }
  initPorts() {
    this.add(
      new Port({ name: "pin1", pinNumber: 1, aliases: ["positive", "pos"] })
    );
    this.add(
      new Port({ name: "pin2", pinNumber: 2, aliases: ["negative", "neg"] })
    );
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_power_source",
      name: this.name,
      voltage: props.voltage,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: false
    });
    this.source_component_id = source_component.source_component_id;
  }
  pos = this.portMap.pin1;
  positive = this.portMap.pin1;
  neg = this.portMap.pin2;
  negative = this.portMap.pin2;
};

// lib/components/normal-components/VoltageSource.ts
import { frequency, rotation as rotation4, voltage } from "circuit-json";
import {
  commonComponentProps
} from "@tscircuit/props";
import { z as z13 } from "zod";
var voltageSourceProps = commonComponentProps.extend({
  voltage: voltage.optional(),
  frequency: frequency.optional(),
  peakToPeakVoltage: voltage.optional(),
  waveShape: z13.enum(["sinewave", "square", "triangle", "sawtooth"]).optional(),
  phase: rotation4.optional(),
  dutyCycle: z13.number().optional()
});
var VoltageSource = class extends NormalComponent3 {
  get config() {
    const isSquare = this.props.waveShape === "square";
    return {
      componentName: "VoltageSource",
      schematicSymbolName: isSquare ? "square_wave" : "ac_voltmeter",
      zodProps: voltageSourceProps,
      sourceFtype: "simple_voltage_source"
    };
  }
  runRenderPhaseForChildren(phase) {
    if (phase.startsWith("Pcb")) {
      return;
    }
    for (const child of this.children) {
      child.runRenderPhaseForChildren(phase);
      child.runRenderPhase(phase);
    }
  }
  doInitialPcbComponentRender() {
  }
  initPorts() {
    super.initPorts({
      additionalAliases: {
        pin1: ["terminal1"],
        pin2: ["terminal2"]
      }
    });
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_voltage_source",
      name: this.name,
      voltage: props.voltage,
      frequency: props.frequency,
      peak_to_peak_voltage: props.peakToPeakVoltage,
      wave_shape: props.waveShape,
      phase: props.phase,
      duty_cycle: props.dutyCycle,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
  doInitialSimulationRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const terminal1Port = this.portMap.terminal1;
    const terminal2Port = this.portMap.terminal2;
    db.simulation_voltage_source.insert({
      type: "simulation_voltage_source",
      is_dc_source: false,
      terminal1_source_port_id: terminal1Port.source_port_id,
      terminal2_source_port_id: terminal2Port.source_port_id,
      voltage: props.voltage,
      frequency: props.frequency,
      peak_to_peak_voltage: props.peakToPeakVoltage,
      wave_shape: props.waveShape,
      phase: props.phase,
      duty_cycle: props.dutyCycle
    });
  }
  terminal1 = this.portMap.terminal1;
  terminal2 = this.portMap.terminal2;
};

// lib/components/normal-components/Resistor.ts
import { resistorProps } from "@tscircuit/props";
import { formatSiUnit as formatSiUnit3 } from "format-si-unit";
var Resistor = class extends NormalComponent3 {
  _adjustSilkscreenTextAutomatically = true;
  get config() {
    return {
      componentName: "Resistor",
      schematicSymbolName: this.props.symbolName ?? "boxresistor",
      zodProps: resistorProps,
      sourceFtype: "simple_resistor"
    };
  }
  initPorts() {
    super.initPorts({
      additionalAliases: {
        pin1: ["anode", "pos", "left"],
        pin2: ["cathode", "neg", "right"]
      }
    });
  }
  _getSchematicSymbolDisplayValue() {
    return `${formatSiUnit3(this._parsedProps.resistance)}\u03A9`;
  }
  doInitialCreateNetsFromProps() {
    this._createNetsFromProps([
      this.props.pullupFor,
      this.props.pullupTo,
      this.props.pulldownFor,
      this.props.pulldownTo,
      ...this._getNetsFromConnectionsProp()
    ]);
  }
  doInitialCreateTracesFromProps() {
    if (this.props.pullupFor && this.props.pullupTo) {
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.1`,
          to: this.props.pullupFor
        })
      );
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.2`,
          to: this.props.pullupTo
        })
      );
    }
    if (this.props.pulldownFor && this.props.pulldownTo) {
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.1`,
          to: this.props.pulldownFor
        })
      );
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.2`,
          to: this.props.pulldownTo
        })
      );
    }
    this._createTracesFromConnectionsProp();
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_resistor",
      name: this.name,
      // @ts-ignore
      manufacturer_part_number: props.manufacturerPartNumber ?? props.mfn,
      supplier_part_numbers: props.supplierPartNumbers,
      resistance: props.resistance,
      display_resistance: this._getSchematicSymbolDisplayValue(),
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/primitive-components/Constraint.ts
import { constraintProps } from "@tscircuit/props";
import "zod";
var edgeSpecifiers = [
  "leftedge",
  "rightedge",
  "topedge",
  "bottomedge",
  "center"
];
var Constraint3 = class extends PrimitiveComponent2 {
  get config() {
    return {
      componentName: "Constraint",
      zodProps: constraintProps
    };
  }
  constructor(props) {
    super(props);
    if ("xdist" in props || "ydist" in props) {
      if (!("edgeToEdge" in props) && !("centerToCenter" in props)) {
        throw new Error(
          `edgeToEdge, centerToCenter must be set for xDist or yDist for ${this}`
        );
      }
    }
    if ("for" in props && props.for.length < 2) {
      throw new Error(`"for" must have at least two selectors for ${this}`);
    }
  }
  _getAllReferencedComponents() {
    const componentsWithSelectors = [];
    const container = this.getPrimitiveContainer();
    function addComponentFromSelector(selector) {
      const maybeEdge = selector.split(" ").pop();
      const edge = edgeSpecifiers.includes(maybeEdge) ? maybeEdge : void 0;
      const componentSelector = edge ? selector.replace(` ${edge}`, "") : selector;
      const component = container.selectOne(componentSelector, {
        pcbPrimitive: true
      });
      if (component) {
        componentsWithSelectors.push({
          selector,
          component,
          componentSelector,
          edge
        });
      }
    }
    for (const key of ["left", "right", "top", "bottom"]) {
      if (key in this._parsedProps) {
        addComponentFromSelector(this._parsedProps[key]);
      }
    }
    if ("for" in this._parsedProps) {
      for (const selector of this._parsedProps.for) {
        addComponentFromSelector(selector);
      }
    }
    return { componentsWithSelectors };
  }
};

// lib/components/primitive-components/FabricationNoteRect.ts
import { fabricationNoteRectProps } from "@tscircuit/props";
import "transformation-matrix";
var FabricationNoteRect = class extends PrimitiveComponent2 {
  fabrication_note_rect_id = null;
  get config() {
    return {
      componentName: "FabricationNoteRect",
      zodProps: fabricationNoteRectProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const layer = maybeFlipLayer(props.layer ?? "top");
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for FabricationNoteRect. Must be "top" or "bottom".`
      );
    }
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id;
    const subcircuit = this.getSubcircuit();
    const hasStroke = props.hasStroke ?? (props.strokeWidth !== void 0 && props.strokeWidth !== null);
    const fabrication_note_rect = db.pcb_fabrication_note_rect.insert({
      pcb_component_id,
      layer,
      color: props.color,
      center: {
        x: props.pcbX ?? 0,
        y: props.pcbY ?? 0
      },
      width: props.width,
      height: props.height,
      stroke_width: props.strokeWidth ?? 1,
      is_filled: props.isFilled ?? false,
      has_stroke: hasStroke,
      is_stroke_dashed: props.isStrokeDashed ?? false,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
      corner_radius: props.cornerRadius ?? void 0
    });
    this.fabrication_note_rect_id = fabrication_note_rect.pcb_fabrication_note_rect_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    return { width: props.width, height: props.height };
  }
};

// lib/components/primitive-components/FabricationNotePath.ts
import { fabricationNotePathProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint10 } from "transformation-matrix";
var FabricationNotePath = class extends PrimitiveComponent2 {
  fabrication_note_path_id = null;
  get config() {
    return {
      componentName: "FabricationNotePath",
      zodProps: fabricationNotePathProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const subcircuit = this.getSubcircuit();
    const { _parsedProps: props } = this;
    const layer = props.layer ?? "top";
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for SilkscreenPath. Must be "top" or "bottom".`
      );
    }
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id;
    const fabrication_note_path = db.pcb_fabrication_note_path.insert({
      pcb_component_id,
      layer,
      color: props.color,
      route: props.route.map((p) => {
        const transformedPosition = applyToPoint10(transform, {
          x: p.x,
          y: p.y
        });
        return {
          ...p,
          x: transformedPosition.x,
          y: transformedPosition.y
        };
      }),
      stroke_width: props.strokeWidth ?? 0.1,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0
    });
    this.fabrication_note_path_id = fabrication_note_path.pcb_fabrication_note_path_id;
  }
};

// lib/components/primitive-components/FabricationNoteText.ts
import { fabricationNoteTextProps } from "@tscircuit/props";
var FabricationNoteText = class extends PrimitiveComponent2 {
  get config() {
    return {
      componentName: "FabricationNoteText",
      zodProps: fabricationNoteTextProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const container = this.getPrimitiveContainer();
    const subcircuit = this.getSubcircuit();
    db.pcb_fabrication_note_text.insert({
      anchor_alignment: props.anchorAlignment,
      anchor_position: {
        x: props.pcbX ?? 0,
        y: props.pcbY ?? 0
      },
      font: props.font ?? "tscircuit2024",
      font_size: props.fontSize ?? 1,
      layer: "top",
      color: props.color,
      text: props.text ?? "",
      pcb_component_id: container.pcb_component_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
    });
  }
};

// lib/components/primitive-components/FabricationNoteDimension.ts
import { fabricationNoteDimensionProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint11 } from "transformation-matrix";
var FabricationNoteDimension = class extends PrimitiveComponent2 {
  fabrication_note_dimension_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "FabricationNoteDimension",
      zodProps: fabricationNoteDimensionProps
    };
  }
  _resolvePoint(input, transform) {
    if (typeof input === "string") {
      const target = this.getSubcircuit().selectOne(
        input
      );
      if (!target) {
        this.renderError(
          `FabricationNoteDimension could not find selector "${input}"`
        );
        return applyToPoint11(transform, { x: 0, y: 0 });
      }
      return target._getGlobalPcbPositionBeforeLayout();
    }
    const numericX = typeof input.x === "string" ? parseFloat(input.x) : input.x;
    const numericY = typeof input.y === "string" ? parseFloat(input.y) : input.y;
    return applyToPoint11(transform, { x: numericX, y: numericY });
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const from = this._resolvePoint(props.from, transform);
    const to = this._resolvePoint(props.to, transform);
    const subcircuit = this.getSubcircuit();
    const group = this.getGroup();
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const layer = maybeFlipLayer(props.layer ?? "top");
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for FabricationNoteDimension. Must be "top" or "bottom".`
      );
    }
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id;
    const text = props.text ?? this._formatDistanceText({ from, to, units: props.units ?? "mm" });
    const fabrication_note_dimension = db.pcb_fabrication_note_dimension.insert(
      {
        pcb_component_id,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: group?.pcb_group_id ?? void 0,
        layer,
        from,
        to,
        text,
        offset: props.offset,
        font: props.font ?? "tscircuit2024",
        font_size: props.fontSize ?? 1,
        color: props.color,
        arrow_size: props.arrowSize ?? 1
      }
    );
    this.fabrication_note_dimension_id = fabrication_note_dimension.pcb_fabrication_note_dimension_id;
  }
  getPcbSize() {
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const from = this._resolvePoint(this._parsedProps.from, transform);
    const to = this._resolvePoint(this._parsedProps.to, transform);
    return {
      width: Math.abs(to.x - from.x),
      height: Math.abs(to.y - from.y)
    };
  }
  _formatDistanceText({
    from,
    to,
    units
  }) {
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const distanceInMillimeters = Math.sqrt(dx * dx + dy * dy);
    const distanceInUnits = units === "in" ? distanceInMillimeters / 25.4 : distanceInMillimeters;
    const roundedDistance = Math.round(distanceInUnits);
    const isWholeNumber = Math.abs(distanceInUnits - roundedDistance) < 1e-9;
    if (isWholeNumber) {
      return `${roundedDistance}${units}`;
    }
    const decimalPlaces = units === "in" ? 3 : 2;
    const valueText = units === "in" ? Number(distanceInUnits.toFixed(decimalPlaces)).toString() : distanceInUnits.toFixed(decimalPlaces);
    return `${valueText}${units}`;
  }
};

// lib/components/primitive-components/PcbNoteLine.ts
import { pcbNoteLineProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint12 } from "transformation-matrix";
var PcbNoteLine = class extends PrimitiveComponent2 {
  pcb_note_line_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "PcbNoteLine",
      zodProps: pcbNoteLineProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const subcircuit = this.getSubcircuit();
    const group = this.getGroup();
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const start = applyToPoint12(transform, { x: props.x1, y: props.y1 });
    const end = applyToPoint12(transform, { x: props.x2, y: props.y2 });
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id ?? void 0;
    const pcb_note_line = db.pcb_note_line.insert({
      pcb_component_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: group?.pcb_group_id ?? void 0,
      x1: start.x,
      y1: start.y,
      x2: end.x,
      y2: end.y,
      stroke_width: props.strokeWidth ?? 0.1,
      color: props.color,
      is_dashed: props.isDashed
    });
    this.pcb_note_line_id = pcb_note_line.pcb_note_line_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    return {
      width: Math.abs(props.x2 - props.x1),
      height: Math.abs(props.y2 - props.y1)
    };
  }
};

// lib/components/primitive-components/PcbNoteRect.ts
import { pcbNoteRectProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint13 } from "transformation-matrix";
var PcbNoteRect = class extends PrimitiveComponent2 {
  pcb_note_rect_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "PcbNoteRect",
      zodProps: pcbNoteRectProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const center = applyToPoint13(transform, { x: 0, y: 0 });
    const subcircuit = this.getSubcircuit();
    const group = this.getGroup();
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id ?? void 0;
    const pcb_note_rect = db.pcb_note_rect.insert({
      pcb_component_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: group?.pcb_group_id ?? void 0,
      center,
      width: props.width,
      height: props.height,
      stroke_width: props.strokeWidth ?? 0.1,
      is_filled: props.isFilled ?? false,
      has_stroke: props.hasStroke ?? true,
      is_stroke_dashed: props.isStrokeDashed ?? false,
      color: props.color,
      corner_radius: props.cornerRadius ?? void 0
    });
    this.pcb_note_rect_id = pcb_note_rect.pcb_note_rect_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    const width = typeof props.width === "string" ? parseFloat(props.width) : props.width;
    const height = typeof props.height === "string" ? parseFloat(props.height) : props.height;
    return { width, height };
  }
};

// lib/components/primitive-components/PcbNoteText.ts
import { pcbNoteTextProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint14 } from "transformation-matrix";
var PcbNoteText = class extends PrimitiveComponent2 {
  pcb_note_text_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "PcbNoteText",
      zodProps: pcbNoteTextProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const anchorPosition = applyToPoint14(transform, { x: 0, y: 0 });
    const subcircuit = this.getSubcircuit();
    const group = this.getGroup();
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id ?? void 0;
    const pcb_note_text = db.pcb_note_text.insert({
      pcb_component_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: group?.pcb_group_id ?? void 0,
      font: props.font ?? "tscircuit2024",
      font_size: props.fontSize ?? 1,
      text: props.text,
      anchor_position: anchorPosition,
      anchor_alignment: props.anchorAlignment ?? "center",
      color: props.color
    });
    this.pcb_note_text_id = pcb_note_text.pcb_note_text_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    const fontSize = typeof props.fontSize === "string" ? parseFloat(props.fontSize) : props.fontSize ?? 1;
    const charWidth = fontSize * 0.6;
    const width = props.text.length * charWidth;
    const height = fontSize;
    return { width, height };
  }
};

// lib/components/primitive-components/PcbNotePath.ts
import { pcbNotePathProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint15 } from "transformation-matrix";
var PcbNotePath = class extends PrimitiveComponent2 {
  pcb_note_path_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "PcbNotePath",
      zodProps: pcbNotePathProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const subcircuit = this.getSubcircuit();
    const group = this.getGroup();
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id ?? void 0;
    const transformedRoute = props.route.map((point) => {
      const { x, y, ...rest } = point;
      const numericX = typeof x === "string" ? parseFloat(x) : x;
      const numericY = typeof y === "string" ? parseFloat(y) : y;
      const transformed = applyToPoint15(transform, { x: numericX, y: numericY });
      return { ...rest, x: transformed.x, y: transformed.y };
    });
    const pcb_note_path = db.pcb_note_path.insert({
      pcb_component_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: group?.pcb_group_id ?? void 0,
      route: transformedRoute,
      stroke_width: props.strokeWidth ?? 0.1,
      color: props.color
    });
    this.pcb_note_path_id = pcb_note_path.pcb_note_path_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    if (props.route.length === 0) return { width: 0, height: 0 };
    const xs = props.route.map(
      (point) => typeof point.x === "string" ? parseFloat(point.x) : point.x
    );
    const ys = props.route.map(
      (point) => typeof point.y === "string" ? parseFloat(point.y) : point.y
    );
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    return { width: maxX - minX, height: maxY - minY };
  }
};

// lib/components/primitive-components/PcbNoteDimension.ts
import { pcbNoteDimensionProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint16 } from "transformation-matrix";
var PcbNoteDimension = class extends PrimitiveComponent2 {
  pcb_note_dimension_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "PcbNoteDimension",
      zodProps: pcbNoteDimensionProps
    };
  }
  _resolvePoint(input, transform) {
    if (typeof input === "string") {
      const target = this.getSubcircuit().selectOne(
        `.${input}`
      );
      if (!target) {
        this.renderError(`PcbNoteDimension could not find selector "${input}"`);
        return applyToPoint16(transform, { x: 0, y: 0 });
      }
      return target._getGlobalPcbPositionBeforeLayout();
    }
    const numericX = typeof input.x === "string" ? parseFloat(input.x) : input.x;
    const numericY = typeof input.y === "string" ? parseFloat(input.y) : input.y;
    return applyToPoint16(transform, { x: numericX, y: numericY });
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const from = this._resolvePoint(props.from, transform);
    const to = this._resolvePoint(props.to, transform);
    const subcircuit = this.getSubcircuit();
    const group = this.getGroup();
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id ?? void 0;
    const text = props.text ?? this._formatDistanceText({ from, to, units: props.units ?? "mm" });
    const pcb_note_dimension = db.pcb_note_dimension.insert({
      pcb_component_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: group?.pcb_group_id ?? void 0,
      from,
      to,
      text,
      font: props.font ?? "tscircuit2024",
      font_size: props.fontSize ?? 1,
      color: props.color,
      arrow_size: props.arrowSize ?? 1
    });
    this.pcb_note_dimension_id = pcb_note_dimension.pcb_note_dimension_id;
  }
  getPcbSize() {
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const from = this._resolvePoint(this._parsedProps.from, transform);
    const to = this._resolvePoint(this._parsedProps.to, transform);
    return {
      width: Math.abs(to.x - from.x),
      height: Math.abs(to.y - from.y)
    };
  }
  _formatDistanceText({
    from,
    to,
    units
  }) {
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const distanceInMillimeters = Math.sqrt(dx * dx + dy * dy);
    const distanceInUnits = units === "in" ? distanceInMillimeters / 25.4 : distanceInMillimeters;
    const roundedDistance = Math.round(distanceInUnits);
    const isWholeNumber = Math.abs(distanceInUnits - roundedDistance) < 1e-9;
    if (isWholeNumber) {
      return `${roundedDistance}${units}`;
    }
    const decimalPlaces = units === "in" ? 3 : 2;
    const valueText = units === "in" ? Number(distanceInUnits.toFixed(decimalPlaces)).toString() : distanceInUnits.toFixed(decimalPlaces);
    return `${valueText}${units}`;
  }
};

// lib/components/primitive-components/Group/Subcircuit/Subcircuit.ts
import "@tscircuit/props";
import { cju } from "@tscircuit/circuit-json-util";

// lib/components/primitive-components/Group/Subcircuit/inflators/inflatePcbComponent.ts
var inflatePcbComponent = (pcbElm, inflatorContext) => {
  const { injectionDb, normalComponent } = inflatorContext;
  if (!normalComponent) return;
  const components = createComponentsFromCircuitJson(
    {
      componentName: normalComponent.name,
      componentRotation: "0deg"
    },
    injectionDb.toArray().filter(
      (elm) => "pcb_component_id" in elm && elm.pcb_component_id === pcbElm.pcb_component_id
    )
  );
  normalComponent.addAll(components);
};

// lib/components/primitive-components/Group/Subcircuit/inflators/inflateSourceResistor.ts
function inflateSourceResistor(sourceElm, inflatorContext) {
  const { injectionDb, subcircuit, groupsMap } = inflatorContext;
  const pcbElm = injectionDb.pcb_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const cadElm = injectionDb.cad_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const resistor = new Resistor({
    name: sourceElm.name,
    resistance: sourceElm.resistance
  });
  if (pcbElm) {
    inflatePcbComponent(pcbElm, {
      ...inflatorContext,
      normalComponent: resistor
    });
  }
  if (sourceElm.source_group_id && groupsMap?.has(sourceElm.source_group_id)) {
    const group = groupsMap.get(sourceElm.source_group_id);
    group.add(resistor);
  } else {
    subcircuit.add(resistor);
  }
}

// lib/components/primitive-components/Group/Subcircuit/inflators/inflateSourcePort.ts
function inflateSourcePort(sourcePort, inflatorContext) {
  const { injectionDb, subcircuit } = inflatorContext;
  if (sourcePort.source_component_id !== null) {
    return;
  }
  const pcbPortFromInjection = injectionDb.pcb_port.getWhere({
    source_port_id: sourcePort.source_port_id
  });
  const port = new Port({
    name: sourcePort.name,
    pinNumber: sourcePort.pin_number
  });
  subcircuit.add(port);
  port.source_port_id = sourcePort.source_port_id;
  const root = subcircuit.root;
  if (root && pcbPortFromInjection) {
    const { db } = root;
    const pcb_port = db.pcb_port.insert({
      pcb_component_id: void 0,
      layers: pcbPortFromInjection.layers,
      subcircuit_id: subcircuit.subcircuit_id ?? void 0,
      pcb_group_id: subcircuit.getGroup()?.pcb_group_id ?? void 0,
      x: pcbPortFromInjection.x,
      y: pcbPortFromInjection.y,
      source_port_id: sourcePort.source_port_id,
      is_board_pinout: false
    });
    port.pcb_port_id = pcb_port.pcb_port_id;
  }
}

// lib/components/primitive-components/Group/Subcircuit/inflators/inflateSourceGroup.ts
function inflateSourceGroup(sourceGroup, inflatorContext) {
  const { subcircuit, groupsMap } = inflatorContext;
  const group = new Group6({
    name: sourceGroup.name
  });
  group.source_group_id = sourceGroup.source_group_id;
  subcircuit.add(group);
  if (groupsMap) {
    groupsMap.set(sourceGroup.source_group_id, group);
  }
  return group;
}

// lib/components/primitive-components/Group/Subcircuit/inflators/inflateSourceChip.ts
var mapInternallyConnectedSourcePortIdsToPinLabels = (sourcePortIds, inflatorContext) => {
  if (!sourcePortIds || sourcePortIds.length === 0) return void 0;
  const { injectionDb } = inflatorContext;
  const mapped = sourcePortIds.map(
    (group) => group.map((sourcePortId) => {
      const port = injectionDb.source_port.get(
        sourcePortId
      );
      if (!port) return null;
      if (port.pin_number !== void 0 && port.pin_number !== null) {
        return `pin${port.pin_number}`;
      }
      return port.name;
    }).filter((value) => value !== null)
  ).filter((group) => group.length > 0);
  return mapped.length > 0 ? mapped : void 0;
};
var inflateSourceChip = (sourceElm, inflatorContext) => {
  const { injectionDb, subcircuit, groupsMap } = inflatorContext;
  const pcbElm = injectionDb.pcb_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const schematicElm = injectionDb.schematic_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const cadElm = injectionDb.cad_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const internallyConnectedPins = mapInternallyConnectedSourcePortIdsToPinLabels(
    sourceElm.internally_connected_source_port_ids,
    inflatorContext
  );
  const chip = new Chip({
    name: sourceElm.name,
    manufacturerPartNumber: sourceElm.manufacturer_part_number,
    supplierPartNumbers: sourceElm.supplier_part_numbers ?? void 0,
    pinLabels: schematicElm?.port_labels ?? void 0,
    schWidth: schematicElm?.size?.width,
    schHeight: schematicElm?.size?.height,
    schPinSpacing: schematicElm?.pin_spacing,
    schX: schematicElm?.center?.x,
    schY: schematicElm?.center?.y,
    layer: pcbElm?.layer,
    pcbX: pcbElm?.center?.x,
    pcbY: pcbElm?.center?.y,
    pcbRotation: pcbElm?.rotation,
    doNotPlace: pcbElm?.do_not_place,
    obstructsWithinBounds: pcbElm?.obstructs_within_bounds,
    internallyConnectedPins
  });
  const footprint = cadElm?.footprinter_string ?? "soic8";
  if (footprint) {
    Object.assign(chip.props, { footprint });
    Object.assign(chip._parsedProps, { footprint });
    if (!cadElm) {
      ;
      chip._addChildrenFromStringFootprint?.();
    }
  }
  if (pcbElm) {
    inflatePcbComponent(pcbElm, {
      ...inflatorContext,
      normalComponent: chip
    });
  }
  if (sourceElm.source_group_id && groupsMap?.has(sourceElm.source_group_id)) {
    const group = groupsMap.get(sourceElm.source_group_id);
    group.add(chip);
  } else {
    subcircuit.add(chip);
  }
};

// lib/components/primitive-components/Group/Subcircuit/inflators/inflateSourceCapacitor.ts
function inflateSourceCapacitor(sourceElm, inflatorContext) {
  const { injectionDb, subcircuit, groupsMap } = inflatorContext;
  const pcbElm = injectionDb.pcb_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const cadElm = injectionDb.cad_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const capacitor = new Capacitor({
    name: sourceElm.name,
    capacitance: sourceElm.capacitance
  });
  if (pcbElm) {
    inflatePcbComponent(pcbElm, {
      ...inflatorContext,
      normalComponent: capacitor
    });
  }
  if (sourceElm.source_group_id && groupsMap?.has(sourceElm.source_group_id)) {
    const group = groupsMap.get(sourceElm.source_group_id);
    group.add(capacitor);
  } else {
    subcircuit.add(capacitor);
  }
}

// lib/components/normal-components/Inductor.ts
import { inductorProps } from "@tscircuit/props";
import { formatSiUnit as formatSiUnit4 } from "format-si-unit";
var Inductor = class extends NormalComponent3 {
  _adjustSilkscreenTextAutomatically = true;
  get config() {
    return {
      componentName: "Inductor",
      schematicSymbolName: this.props.symbolName ?? "inductor",
      zodProps: inductorProps,
      sourceFtype: FTYPE.simple_inductor
    };
  }
  _getSchematicSymbolDisplayValue() {
    return `${formatSiUnit4(this._parsedProps.inductance)}H`;
  }
  initPorts() {
    super.initPorts({
      additionalAliases: {
        pin1: ["anode", "pos", "left"],
        pin2: ["cathode", "neg", "right"]
      }
    });
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      name: this.name,
      ftype: FTYPE.simple_inductor,
      inductance: props.inductance,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/primitive-components/Group/Subcircuit/inflators/inflateSourceInductor.ts
function inflateSourceInductor(sourceElm, inflatorContext) {
  const { injectionDb, subcircuit, groupsMap } = inflatorContext;
  const pcbElm = injectionDb.pcb_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const cadElm = injectionDb.cad_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const inductor = new Inductor({
    name: sourceElm.name,
    inductance: sourceElm.inductance
  });
  if (pcbElm) {
    inflatePcbComponent(pcbElm, {
      ...inflatorContext,
      normalComponent: inductor
    });
  }
  if (sourceElm.source_group_id && groupsMap?.has(sourceElm.source_group_id)) {
    const group = groupsMap.get(sourceElm.source_group_id);
    group.add(inductor);
  } else {
    subcircuit.add(inductor);
  }
}

// lib/components/primitive-components/Group/Subcircuit/inflators/inflateSourceDiode.ts
function inflateSourceDiode(sourceElm, inflatorContext) {
  const { injectionDb, subcircuit, groupsMap } = inflatorContext;
  const pcbElm = injectionDb.pcb_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const cadElm = injectionDb.cad_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const diode = new Diode({
    name: sourceElm.name
  });
  if (pcbElm) {
    inflatePcbComponent(pcbElm, {
      ...inflatorContext,
      normalComponent: diode
    });
  }
  if (sourceElm.source_group_id && groupsMap?.has(sourceElm.source_group_id)) {
    const group = groupsMap.get(sourceElm.source_group_id);
    group.add(diode);
  } else {
    subcircuit.add(diode);
  }
}

// lib/components/primitive-components/Group/Subcircuit/inflators/inflateSourceTrace.ts
var getSelectorPath = (component, db) => {
  const path_parts = [];
  let currentGroupId = component.source_group_id;
  while (currentGroupId) {
    const group = db.source_group.get(currentGroupId);
    if (!group) break;
    path_parts.unshift(`.${group.name}`);
    currentGroupId = group.parent_source_group_id;
  }
  path_parts.push(`.${component.name}`);
  return path_parts.join(" > ");
};
function inflateSourceTrace(sourceTrace, inflatorContext) {
  const { injectionDb, subcircuit } = inflatorContext;
  const connectedSelectors = [];
  for (const sourcePortId of sourceTrace.connected_source_port_ids) {
    const sourcePort = injectionDb.source_port.get(sourcePortId);
    if (!sourcePort) continue;
    let selector;
    if (sourcePort.source_component_id) {
      const sourceComponent = injectionDb.source_component.get(
        sourcePort.source_component_id
      );
      if (sourceComponent) {
        const path = getSelectorPath(
          {
            name: sourceComponent.name,
            source_group_id: sourceComponent.source_group_id
          },
          injectionDb
        );
        selector = `${path} > .${sourcePort.name}`;
      }
    } else {
      selector = `.${sourcePort.name}`;
    }
    if (selector) {
      connectedSelectors.push(selector);
    }
  }
  for (const sourceNetId of sourceTrace.connected_source_net_ids) {
    const sourceNet = injectionDb.source_net.get(sourceNetId);
    if (sourceNet) {
      connectedSelectors.push(`net.${sourceNet.name}`);
    }
  }
  if (connectedSelectors.length < 2) return;
  const trace = new Trace3({
    path: connectedSelectors
  });
  trace.source_trace_id = sourceTrace.source_trace_id;
  subcircuit.add(trace);
}

// lib/components/normal-components/Transistor.ts
import { transistorProps } from "@tscircuit/props";
var Transistor = class extends NormalComponent3 {
  get config() {
    const baseSymbolName = this.props.type === "npn" ? "npn_bipolar_transistor" : "pnp_bipolar_transistor";
    return {
      componentName: "Transistor",
      schematicSymbolName: this.props.symbolName ?? baseSymbolName,
      zodProps: transistorProps,
      sourceFtype: "simple_transistor",
      shouldRenderAsSchematicBox: false
    };
  }
  initPorts() {
    const pinAliases = {
      pin1: ["collector", "c"],
      pin2: ["emitter", "e"],
      pin3: ["base", "b"]
    };
    super.initPorts({
      pinCount: 3,
      additionalAliases: pinAliases
    });
  }
  emitter = this.portMap.pin1;
  collector = this.portMap.pin2;
  base = this.portMap.pin3;
  doInitialCreateNetsFromProps() {
    this._createNetsFromProps([...this._getNetsFromConnectionsProp()]);
  }
  doInitialCreateTracesFromProps() {
    this._createTracesFromConnectionsProp();
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_transistor",
      name: this.name,
      transistor_type: props.type
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/primitive-components/Group/Subcircuit/inflators/inflateSourceTransistor.ts
function inflateSourceTransistor(sourceElm, inflatorContext) {
  const { injectionDb, subcircuit, groupsMap } = inflatorContext;
  const pcbElm = injectionDb.pcb_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const cadElm = injectionDb.cad_component.getWhere({
    source_component_id: sourceElm.source_component_id
  });
  const transistor = new Transistor({
    name: sourceElm.name,
    type: sourceElm.transistor_type
  });
  if (pcbElm) {
    inflatePcbComponent(pcbElm, {
      ...inflatorContext,
      normalComponent: transistor
    });
  }
  if (sourceElm.source_group_id && groupsMap?.has(sourceElm.source_group_id)) {
    const group = groupsMap.get(sourceElm.source_group_id);
    group.add(transistor);
  } else {
    subcircuit.add(transistor);
  }
}

// lib/components/primitive-components/Group/Subcircuit/Subcircuit.ts
var Subcircuit = class extends Group6 {
  constructor(props) {
    super({
      ...props,
      // @ts-ignore
      subcircuit: true
    });
  }
  /**
   * During this phase, we inflate the subcircuit circuit json into class
   * instances
   *
   * When subcircuit's define circuitJson, it's basically the same as having
   * a tree of components. All the data from circuit json has to be converted
   * into props for the tree of components
   *
   * We do this in two phases:
   * - Create the components
   * - Create the groups
   * - Add components to groups in the appropriate hierarchy
   */
  doInitialInflateSubcircuitCircuitJson() {
    const { circuitJson: injectionCircuitJson, children } = this._parsedProps;
    if (!injectionCircuitJson) return;
    const injectionDb = cju(injectionCircuitJson);
    if (injectionCircuitJson && children?.length > 0) {
      throw new Error("Subcircuit cannot have both circuitJson and children");
    }
    const groupsMap = /* @__PURE__ */ new Map();
    const inflationCtx = {
      injectionDb,
      subcircuit: this,
      groupsMap
    };
    const sourceGroups = injectionDb.source_group.list();
    for (const sourceGroup of sourceGroups) {
      inflateSourceGroup(sourceGroup, inflationCtx);
    }
    const sourceComponents = injectionDb.source_component.list();
    for (const sourceComponent of sourceComponents) {
      switch (sourceComponent.ftype) {
        case "simple_resistor":
          inflateSourceResistor(sourceComponent, inflationCtx);
          break;
        case "simple_capacitor":
          inflateSourceCapacitor(sourceComponent, inflationCtx);
          break;
        case "simple_inductor":
          inflateSourceInductor(sourceComponent, inflationCtx);
          break;
        case "simple_diode":
          inflateSourceDiode(sourceComponent, inflationCtx);
          break;
        case "simple_chip":
          inflateSourceChip(sourceComponent, inflationCtx);
          break;
        case "simple_transistor":
          inflateSourceTransistor(sourceComponent, inflationCtx);
          break;
        default:
          throw new Error(
            `No inflator implemented for source component ftype: "${sourceComponent.ftype}"`
          );
      }
    }
    const sourcePorts = injectionDb.source_port.list();
    for (const sourcePort of sourcePorts) {
      inflateSourcePort(sourcePort, inflationCtx);
    }
    const sourceTraces = injectionDb.source_trace.list();
    for (const sourceTrace of sourceTraces) {
      inflateSourceTrace(sourceTrace, inflationCtx);
    }
  }
};

// lib/components/primitive-components/Breakout/Breakout.ts
import "@tscircuit/props";
var Breakout = class extends Group6 {
  constructor(props) {
    super({
      ...props,
      // @ts-ignore
      subcircuit: true
    });
  }
  doInitialPcbPrimitiveRender() {
    super.doInitialPcbPrimitiveRender();
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const props = this._parsedProps;
    if (!this.pcb_group_id) return;
    const pcb_group = db.pcb_group.get(this.pcb_group_id);
    const padLeft = props.paddingLeft ?? props.padding ?? 0;
    const padRight = props.paddingRight ?? props.padding ?? 0;
    const padTop = props.paddingTop ?? props.padding ?? 0;
    const padBottom = props.paddingBottom ?? props.padding ?? 0;
    db.pcb_group.update(this.pcb_group_id, {
      width: (pcb_group.width ?? 0) + padLeft + padRight,
      height: (pcb_group.height ?? 0) + padTop + padBottom,
      center: {
        x: pcb_group.center.x + (padRight - padLeft) / 2,
        y: pcb_group.center.y + (padTop - padBottom) / 2
      }
    });
  }
};

// lib/components/primitive-components/BreakoutPoint.ts
import { breakoutPointProps } from "@tscircuit/props";
var BreakoutPoint = class extends PrimitiveComponent2 {
  pcb_breakout_point_id = null;
  matchedPort = null;
  matchedNet = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "BreakoutPoint",
      zodProps: breakoutPointProps
    };
  }
  _matchConnection() {
    const { connection } = this._parsedProps;
    const subcircuit = this.getSubcircuit();
    if (!subcircuit) return;
    this.matchedPort = subcircuit.selectOne(connection, {
      type: "port"
    });
    if (!this.matchedPort) {
      this.matchedNet = subcircuit.selectOne(connection, { type: "net" });
    }
    if (!this.matchedPort && !this.matchedNet) {
      this.renderError(`Could not find connection target "${connection}"`);
    }
  }
  _getSourceTraceIdForPort(port) {
    const { db } = this.root;
    const trace = db.source_trace.list().find((st) => st.connected_source_port_ids.includes(port.source_port_id));
    return trace?.source_trace_id;
  }
  _getSourceNetIdForPort(port) {
    const { db } = this.root;
    const trace = db.source_trace.list().find((st) => st.connected_source_port_ids.includes(port.source_port_id));
    return trace?.connected_source_net_ids[0];
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    this._matchConnection();
    const { pcbX = 0, pcbY = 0 } = this._parsedProps;
    const group = this.parent?.getGroup();
    const subcircuit = this.getSubcircuit();
    if (!group || !group.pcb_group_id) return;
    const pcb_breakout_point = db.pcb_breakout_point.insert({
      pcb_group_id: group.pcb_group_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      source_port_id: this.matchedPort?.source_port_id ?? void 0,
      source_trace_id: this.matchedPort ? this._getSourceTraceIdForPort(this.matchedPort) : void 0,
      source_net_id: this.matchedNet ? this.matchedNet.source_net_id : this.matchedPort ? this._getSourceNetIdForPort(this.matchedPort) : void 0,
      x: pcbX,
      y: pcbY
    });
    this.pcb_breakout_point_id = pcb_breakout_point.pcb_breakout_point_id;
  }
  _getPcbCircuitJsonBounds() {
    const { pcbX = 0, pcbY = 0 } = this._parsedProps;
    return {
      center: { x: pcbX, y: pcbY },
      bounds: { left: pcbX, top: pcbY, right: pcbX, bottom: pcbY },
      width: 0,
      height: 0
    };
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    if (!this.pcb_breakout_point_id) return;
    db.pcb_breakout_point.update(this.pcb_breakout_point_id, {
      x: newCenter.x,
      y: newCenter.y
    });
  }
  getPcbSize() {
    return { width: 0, height: 0 };
  }
};

// lib/components/primitive-components/NetLabel.ts
import { netLabelProps } from "@tscircuit/props";
import {
  applyToPoint as applyToPoint17,
  identity as identity5,
  translate as translate6
} from "transformation-matrix";
import { calculateElbow as calculateElbow2 } from "calculate-elbow";
var NetLabel = class extends PrimitiveComponent2 {
  source_net_label_id;
  get config() {
    return {
      componentName: "NetLabel",
      zodProps: netLabelProps
    };
  }
  _getAnchorSide() {
    const { _parsedProps: props } = this;
    if (props.anchorSide) return props.anchorSide;
    const connectsTo = this._resolveConnectsTo();
    if (!connectsTo) return "right";
    const anchorPos = this._getGlobalSchematicPositionBeforeLayout();
    const connectedPorts = this._getConnectedPorts();
    if (connectedPorts.length === 0) return "right";
    const connectedPortPosition = connectedPorts[0]._getGlobalSchematicPositionBeforeLayout();
    const dx = connectedPortPosition.x - anchorPos.x;
    const dy = connectedPortPosition.y - anchorPos.y;
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0) return "right";
      if (dx < 0) return "left";
    } else {
      if (dy > 0) return "top";
      if (dy < 0) return "bottom";
    }
    return "right";
  }
  _getConnectedPorts() {
    const connectsTo = this._resolveConnectsTo();
    if (!connectsTo) return [];
    const connectedPorts = [];
    for (const connection of connectsTo) {
      const port = this.getSubcircuit().selectOne(connection);
      if (port) {
        connectedPorts.push(port);
      }
    }
    return connectedPorts;
  }
  computeSchematicPropsTransform() {
    const { _parsedProps: props } = this;
    if (props.schX === void 0 && props.schY === void 0) {
      const connectedPorts = this._getConnectedPorts();
      if (connectedPorts.length > 0) {
        const portPos = connectedPorts[0]._getGlobalSchematicPositionBeforeLayout();
        const parentCenter = applyToPoint17(
          this.parent?.computeSchematicGlobalTransform?.() ?? identity5(),
          { x: 0, y: 0 }
        );
        return translate6(portPos.x - parentCenter.x, portPos.y - parentCenter.y);
      }
    }
    return super.computeSchematicPropsTransform();
  }
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const anchorPos = this._getGlobalSchematicPositionBeforeLayout();
    const net = this.getSubcircuit().selectOne(
      `net.${this._getNetName()}`
    );
    const anchorSide = props.anchorSide ?? "right";
    const center = computeSchematicNetLabelCenter({
      anchor_position: anchorPos,
      anchor_side: anchorSide,
      text: props.net
    });
    const netLabel = db.schematic_net_label.insert({
      text: props.net,
      source_net_id: net.source_net_id,
      anchor_position: anchorPos,
      center,
      anchor_side: this._getAnchorSide()
    });
    this.source_net_label_id = netLabel.source_net_id;
  }
  _resolveConnectsTo() {
    const { _parsedProps: props } = this;
    const connectsTo = props.connectsTo ?? props.connection;
    if (Array.isArray(connectsTo)) {
      return connectsTo;
    }
    if (typeof connectsTo === "string") {
      return [connectsTo];
    }
    return void 0;
  }
  _getNetName() {
    const { _parsedProps: props } = this;
    return props.net;
  }
  doInitialCreateNetsFromProps() {
    const { _parsedProps: props } = this;
    if (props.net) {
      createNetsFromProps(this, [`net.${props.net}`]);
    }
  }
  doInitialCreateTracesFromNetLabels() {
    if (this.root?.schematicDisabled) return;
    const connectsTo = this._resolveConnectsTo();
    if (!connectsTo) return;
    for (const connection of connectsTo) {
      this.add(
        new Trace3({
          from: connection,
          to: `net.${this._getNetName()}`
        })
      );
    }
  }
  doInitialSchematicTraceRender() {
    if (!this.root?._featureMspSchematicTraceRouting) return;
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const connectsTo = this._resolveConnectsTo();
    if (!connectsTo || connectsTo.length === 0) return;
    const anchorPos = this._getGlobalSchematicPositionBeforeLayout();
    const anchorSide = this._getAnchorSide();
    const sideToAxisDir = {
      left: "x-",
      right: "x+",
      top: "y+",
      bottom: "y-"
    };
    const anchorFacing = sideToAxisDir[anchorSide];
    const net = this.getSubcircuit().selectOne(
      `net.${this._getNetName()}`
    );
    for (const connection of connectsTo) {
      const port = this.getSubcircuit().selectOne(connection, {
        type: "port"
      });
      if (!port || !port.schematic_port_id) continue;
      let existingTraceForThisConnection = false;
      if (net?.source_net_id) {
        const candidateSourceTrace = db.source_trace.list().find(
          (st) => st.connected_source_net_ids?.includes(net.source_net_id) && st.connected_source_port_ids?.includes(port.source_port_id ?? "")
        );
        if (candidateSourceTrace) {
          existingTraceForThisConnection = db.schematic_trace.list().some(
            (t) => t.source_trace_id === candidateSourceTrace.source_trace_id
          );
        }
        if (existingTraceForThisConnection) continue;
      }
      const portPos = port._getGlobalSchematicPositionAfterLayout();
      const portFacing = convertFacingDirectionToElbowDirection(
        port.facingDirection ?? "right"
      ) ?? "x+";
      const path = calculateElbow2(
        {
          x: portPos.x,
          y: portPos.y,
          facingDirection: portFacing
        },
        {
          x: anchorPos.x,
          y: anchorPos.y,
          facingDirection: anchorFacing
        }
      );
      if (!Array.isArray(path) || path.length < 2) continue;
      const edges = [];
      for (let i = 0; i < path.length - 1; i++) {
        edges.push({
          from: { x: path[i].x, y: path[i].y },
          to: { x: path[i + 1].x, y: path[i + 1].y }
        });
      }
      let source_trace_id;
      let subcircuit_connectivity_map_key;
      if (net?.source_net_id && port.source_port_id) {
        const st = db.source_trace.list().find(
          (s) => s.connected_source_net_ids?.includes(net.source_net_id) && s.connected_source_port_ids?.includes(port.source_port_id)
        );
        source_trace_id = st?.source_trace_id;
        subcircuit_connectivity_map_key = st?.subcircuit_connectivity_map_key || db.source_net.get(net.source_net_id)?.subcircuit_connectivity_map_key;
      }
      db.schematic_trace.insert({
        source_trace_id,
        edges,
        junctions: [],
        subcircuit_connectivity_map_key
      });
      db.schematic_port.update(port.schematic_port_id, { is_connected: true });
    }
  }
};

// lib/components/primitive-components/SilkscreenCircle.ts
import { silkscreenCircleProps } from "@tscircuit/props";
var SilkscreenCircle = class extends PrimitiveComponent2 {
  pcb_silkscreen_circle_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SilkscreenCircle",
      zodProps: silkscreenCircleProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const layer = maybeFlipLayer(props.layer ?? "top");
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for SilkscreenCircle. Must be "top" or "bottom".`
      );
    }
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const subcircuit = this.getSubcircuit();
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id;
    const pcb_silkscreen_circle = db.pcb_silkscreen_circle.insert({
      pcb_component_id,
      layer,
      center: {
        x: props.pcbX ?? 0,
        y: props.pcbY ?? 0
      },
      radius: props.radius,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
      stroke_width: props.strokeWidth ?? 0.1
    });
    this.pcb_silkscreen_circle_id = pcb_silkscreen_circle.pcb_silkscreen_circle_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    const diameter = props.radius * 2;
    return { width: diameter, height: diameter };
  }
};

// lib/components/primitive-components/SilkscreenRect.ts
import { silkscreenRectProps } from "@tscircuit/props";
var SilkscreenRect = class extends PrimitiveComponent2 {
  pcb_silkscreen_rect_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SilkscreenRect",
      zodProps: silkscreenRectProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const layer = maybeFlipLayer(props.layer ?? "top");
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for SilkscreenRect. Must be "top" or "bottom".`
      );
    }
    const subcircuit = this.getSubcircuit();
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id;
    const pcb_silkscreen_rect = db.pcb_silkscreen_rect.insert({
      pcb_component_id,
      layer,
      center: {
        x: props.pcbX ?? 0,
        y: props.pcbY ?? 0
      },
      width: props.width,
      height: props.height,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this?.getGroup()?.pcb_group_id ?? void 0,
      stroke_width: props.strokeWidth ?? 0.1,
      is_filled: props.filled ?? false,
      corner_radius: props.cornerRadius ?? void 0
    });
    this.pcb_silkscreen_rect_id = pcb_silkscreen_rect.pcb_silkscreen_rect_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    return { width: props.width, height: props.height };
  }
};

// lib/components/primitive-components/SilkscreenLine.ts
import { silkscreenLineProps } from "@tscircuit/props";
var SilkscreenLine = class extends PrimitiveComponent2 {
  pcb_silkscreen_line_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SilkscreenLine",
      zodProps: silkscreenLineProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const layer = maybeFlipLayer(props.layer ?? "top");
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for SilkscreenLine. Must be "top" or "bottom".`
      );
    }
    const subcircuit = this.getSubcircuit();
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id;
    const pcb_silkscreen_line = db.pcb_silkscreen_line.insert({
      pcb_component_id,
      layer,
      x1: props.x1,
      y1: props.y1,
      x2: props.x2,
      y2: props.y2,
      stroke_width: props.strokeWidth ?? 0.1,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: subcircuit?.getGroup()?.pcb_group_id ?? void 0
    });
    this.pcb_silkscreen_line_id = pcb_silkscreen_line.pcb_silkscreen_line_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    const width = Math.abs(props.x2 - props.x1);
    const height = Math.abs(props.y2 - props.y1);
    return { width, height };
  }
};

// lib/components/primitive-components/Via.ts
import { viaProps } from "@tscircuit/props";
import "zod";
var Via = class extends PrimitiveComponent2 {
  pcb_via_id = null;
  matchedPort = null;
  isPcbPrimitive = true;
  source_manually_placed_via_id = null;
  subcircuit_connectivity_map_key = null;
  constructor(props) {
    super(props);
    const layers = this._getLayers();
    this._parsedProps.layers = layers;
    this.initPorts();
  }
  get config() {
    return {
      componentName: "Via",
      zodProps: viaProps
    };
  }
  getAvailablePcbLayers() {
    return ["top", "inner1", "inner2", "bottom"];
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    return { width: props.outerDiameter, height: props.outerDiameter };
  }
  _getPcbCircuitJsonBounds() {
    const { db } = this.root;
    const via = db.pcb_via.get(this.pcb_via_id);
    const size = this.getPcbSize();
    return {
      center: { x: via.x, y: via.y },
      bounds: {
        left: via.x - size.width / 2,
        top: via.y - size.height / 2,
        right: via.x + size.width / 2,
        bottom: via.y + size.height / 2
      },
      width: size.width,
      height: size.height
    };
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    db.pcb_via.update(this.pcb_via_id, {
      x: newCenter.x,
      y: newCenter.y
    });
  }
  _getLayers() {
    const { fromLayer = "top", toLayer = "bottom" } = this._parsedProps;
    if (fromLayer === toLayer) return [fromLayer];
    return [fromLayer, toLayer];
  }
  initPorts() {
    const layers = this._parsedProps.layers;
    for (const layer of layers) {
      const port2 = new Port({ name: layer, layer });
      port2.registerMatch(this);
      this.add(port2);
    }
    const port = new Port({ name: "pin1" });
    port.registerMatch(this);
    this.add(port);
  }
  /**
   * Find the Net or Trace that this via is connected to
   */
  _getConnectedNetOrTrace() {
    const connectsTo = this._parsedProps.connectsTo;
    if (!connectsTo) return null;
    const subcircuit = this.getSubcircuit();
    const selectors = Array.isArray(connectsTo) ? connectsTo : [connectsTo];
    for (const selector of selectors) {
      if (selector.startsWith("net.")) {
        const net = subcircuit.selectOne(selector, {
          type: "net"
        });
        if (net) return net;
      }
    }
    return null;
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const position = this._getGlobalPcbPositionBeforeLayout();
    const subcircuit = this.getSubcircuit();
    const pcb_component = db.pcb_component.insert({
      center: position,
      width: props.outerDiameter,
      height: props.outerDiameter,
      layer: props.fromLayer ?? "top",
      rotation: 0,
      source_component_id: this.source_component_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      obstructs_within_bounds: true
    });
    this.pcb_component_id = pcb_component.pcb_component_id;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const group = this.getGroup();
    const subcircuit = this.getSubcircuit();
    const source_via = db.source_manually_placed_via.insert({
      source_group_id: group?.source_group_id,
      source_net_id: props.net ?? "",
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0
    });
    this.source_component_id = source_via.source_manually_placed_via_id;
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const position = this._getGlobalPcbPositionBeforeLayout();
    const subcircuit = this.getSubcircuit();
    const pcb_via = db.pcb_via.insert({
      x: position.x,
      y: position.y,
      hole_diameter: props.holeDiameter,
      outer_diameter: props.outerDiameter,
      layers: ["bottom", "top"],
      from_layer: props.fromLayer || "bottom",
      to_layer: props.toLayer || "top",
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      subcircuit_connectivity_map_key: this.subcircuit_connectivity_map_key ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
      net_is_assignable: props.netIsAssignable ?? void 0
    });
    this.pcb_via_id = pcb_via.pcb_via_id;
  }
};

// lib/components/primitive-components/CopperPour/CopperPour.ts
import { copperPourProps } from "@tscircuit/props";
import {
  CopperPourPipelineSolver,
  convertCircuitJsonToInputProblem
} from "@tscircuit/copper-pour-solver";
var CopperPour = class extends PrimitiveComponent2 {
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "CopperPour",
      zodProps: copperPourProps
    };
  }
  getPcbSize() {
    return { width: 0, height: 0 };
  }
  doInitialCreateNetsFromProps() {
    const { _parsedProps: props } = this;
    createNetsFromProps(this, [props.connectsTo]);
  }
  doInitialPcbCopperPourRender() {
    if (this.root?.pcbDisabled) return;
    this._queueAsyncEffect("PcbCopperPourRender", async () => {
      const { db } = this.root;
      const { _parsedProps: props } = this;
      const net = this.getSubcircuit().selectOne(props.connectsTo);
      if (!net || !net.source_net_id) {
        this.renderError(`Net "${props.connectsTo}" not found for copper pour`);
        return;
      }
      const subcircuit = this.getSubcircuit();
      const sourceNet = db.toArray().filter(
        (elm) => elm.type === "source_net" && elm.name === net.name
      )[0] || "";
      const clearance = props.clearance ?? 0.2;
      const inputProblem = convertCircuitJsonToInputProblem(db.toArray(), {
        layer: props.layer,
        pour_connectivity_key: sourceNet.subcircuit_connectivity_map_key || "",
        pad_margin: props.padMargin ?? clearance,
        trace_margin: props.traceMargin ?? clearance,
        board_edge_margin: props.boardEdgeMargin ?? clearance,
        cutout_margin: props.cutoutMargin ?? clearance
      });
      const solver = new CopperPourPipelineSolver(inputProblem);
      const { brep_shapes } = solver.getOutput();
      const coveredWithSolderMask = props.coveredWithSolderMask ?? false;
      for (const brep_shape of brep_shapes) {
        db.pcb_copper_pour.insert({
          shape: "brep",
          layer: props.layer,
          brep_shape,
          source_net_id: net.source_net_id,
          subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
          covered_with_solder_mask: coveredWithSolderMask
        });
      }
    });
  }
};

// lib/components/normal-components/Battery.ts
import { batteryProps } from "@tscircuit/props";
var Battery = class extends NormalComponent3 {
  get config() {
    return {
      componentName: "Battery",
      schematicSymbolName: this.props.symbolName ?? "battery",
      zodProps: batteryProps,
      sourceFtype: "simple_power_source"
    };
  }
  initPorts() {
    super.initPorts({
      additionalAliases: {
        pin1: ["anode", "pos", "left"],
        pin2: ["cathode", "neg", "right"]
      }
    });
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      name: this.name,
      ftype: "simple_power_source",
      capacity: props.capacity,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: false
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/PinHeader.ts
import { pinHeaderProps } from "@tscircuit/props";
var PinHeader = class extends NormalComponent3 {
  _getPcbRotationBeforeLayout() {
    const orientationRotation = this.props.pcbOrientation === "vertical" ? -90 : 0;
    const baseRotation = super._getPcbRotationBeforeLayout() ?? 0;
    return baseRotation + orientationRotation;
  }
  get config() {
    return {
      componentName: "PinHeader",
      zodProps: pinHeaderProps,
      shouldRenderAsSchematicBox: true
    };
  }
  _getImpliedFootprintString() {
    const pinCount = this._parsedProps.pinCount ?? (Array.isArray(this._parsedProps.pinLabels) ? this._parsedProps.pinLabels.length : this._parsedProps.pinLabels ? Object.keys(this._parsedProps.pinLabels).length : 0);
    const holeDiameter = this._parsedProps.holeDiameter;
    const platedDiameter = this._parsedProps.platedDiameter;
    const pitch = this._parsedProps.pitch;
    const showSilkscreenPinLabels = this._parsedProps.showSilkscreenPinLabels;
    if (pinCount > 0) {
      let footprintString;
      if (pitch) {
        if (!holeDiameter && !platedDiameter) {
          footprintString = `pinrow${pinCount}_p${pitch}`;
        } else {
          footprintString = `pinrow${pinCount}_p${pitch}_id${holeDiameter}_od${platedDiameter}`;
        }
      } else {
        if (!holeDiameter && !platedDiameter) {
          footprintString = `pinrow${pinCount}`;
        } else {
          return null;
        }
      }
      if (showSilkscreenPinLabels !== true) {
        footprintString += "_nopinlabels";
      }
      return footprintString;
    }
    return null;
  }
  initPorts() {
    const pinCount = this._parsedProps.pinCount ?? (Array.isArray(this._parsedProps.pinLabels) ? this._parsedProps.pinLabels.length : this._parsedProps.pinLabels ? Object.keys(this._parsedProps.pinLabels).length : 1);
    for (let i = 1; i <= pinCount; i++) {
      const rawLabel = Array.isArray(this._parsedProps.pinLabels) ? this._parsedProps.pinLabels[i - 1] : this._parsedProps.pinLabels?.[`pin${i}`];
      if (rawLabel) {
        const primaryLabel = Array.isArray(rawLabel) ? rawLabel[0] : rawLabel;
        const otherLabels = Array.isArray(rawLabel) ? rawLabel.slice(1) : [];
        this.add(
          new Port({
            pinNumber: i,
            name: primaryLabel,
            aliases: [`pin${i}`, ...otherLabels]
          })
        );
      } else {
        this.add(
          new Port({
            pinNumber: i,
            name: `pin${i}`
          })
        );
      }
    }
  }
  _getSchematicPortArrangement() {
    const pinCount = this._parsedProps.pinCount ?? 1;
    const facingDirection = this._parsedProps.schFacingDirection ?? this._parsedProps.facingDirection ?? "right";
    const schPinArrangement = this._parsedProps.schPinArrangement;
    if (facingDirection === "left") {
      return {
        leftSide: {
          direction: schPinArrangement?.leftSide?.direction ?? "top-to-bottom",
          pins: schPinArrangement?.leftSide?.pins ?? Array.from({ length: pinCount }, (_, i) => `pin${i + 1}`)
        }
      };
    }
    return {
      rightSide: {
        direction: schPinArrangement?.rightSide?.direction ?? "top-to-bottom",
        pins: schPinArrangement?.rightSide?.pins ?? Array.from({ length: pinCount }, (_, i) => `pin${i + 1}`)
      }
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_pin_header",
      name: this.name,
      supplier_part_numbers: props.supplierPartNumbers,
      pin_count: props.pinCount,
      gender: props.gender,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Resonator.ts
import { resonatorProps } from "@tscircuit/props";
import { formatSiUnit as formatSiUnit5 } from "format-si-unit";
function getResonatorSymbolName(variant) {
  switch (variant) {
    case "two_ground_pins":
      return `crystal_4pin`;
    case "ground_pin":
      return "resonator";
    case "no_ground":
      return "crystal";
    default:
      return "crystal";
  }
}
var Resonator = class extends NormalComponent3 {
  get config() {
    return {
      componentName: "Resonator",
      schematicSymbolName: this.props.symbolName ?? getResonatorSymbolName(this.props.pinVariant),
      zodProps: resonatorProps,
      shouldRenderAsSchematicBox: false
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const pinVariant = props.pinVariant || "no_ground";
    const source_component = db.source_component.insert({
      ftype: "simple_resonator",
      name: this.name,
      frequency: props.frequency,
      load_capacitance: props.loadCapacitance,
      supplier_part_numbers: props.supplierPartNumbers,
      pin_variant: pinVariant,
      are_pins_interchangeable: pinVariant === "no_ground" || pinVariant === "ground_pin"
    });
    this.source_component_id = source_component.source_component_id;
  }
  _getSchematicSymbolDisplayValue() {
    const freqDisplay = `${formatSiUnit5(this._parsedProps.frequency)}Hz`;
    if (this._parsedProps.loadCapacitance) {
      return `${freqDisplay} / ${formatSiUnit5(this._parsedProps.loadCapacitance)}F`;
    }
    return freqDisplay;
  }
};

// lib/components/normal-components/Potentiometer.ts
import { potentiometerProps } from "@tscircuit/props";
import { formatSiUnit as formatSiUnit6 } from "format-si-unit";
function getPotentiometerSymbolName(variant) {
  switch (variant) {
    case "three_pin":
      return "potentiometer3";
    case "two_pin":
      return "potentiometer2";
    default:
      return "potentiometer2";
  }
}
var Potentiometer = class extends NormalComponent3 {
  get config() {
    return {
      componentName: "Potentiometer",
      schematicSymbolName: this.props.symbolName ?? getPotentiometerSymbolName(this.props.pinVariant),
      zodProps: potentiometerProps,
      shouldRenderAsSchematicBox: false
    };
  }
  _getSchematicSymbolDisplayValue() {
    return `${formatSiUnit6(this._parsedProps.maxResistance)}\u03A9`;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const pinVariant = props.pinVariant || "two_pin";
    const source_component = db.source_component.insert({
      ftype: "simple_potentiometer",
      name: this.name,
      max_resistance: props.maxResistance,
      pin_variant: pinVariant,
      are_pins_interchangeable: pinVariant === "two_pin"
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/PushButton.ts
import { pushButtonProps } from "@tscircuit/props";
import { symbols as symbols3 } from "schematic-symbols";
var PushButton = class extends NormalComponent3 {
  get config() {
    return {
      componentName: "PushButton",
      schematicSymbolName: this.props.symbolName ?? "push_button_normally_open_momentary",
      zodProps: pushButtonProps,
      sourceFtype: FTYPE.simple_push_button
    };
  }
  get defaultInternallyConnectedPinNames() {
    return [];
  }
  initPorts() {
    super.initPorts({
      pinCount: 2,
      ignoreSymbolPorts: true
    });
    const symbol = symbols3[this._getSchematicSymbolNameOrThrow()];
    const symPort1 = symbol.ports.find((p) => p.labels.includes("1"));
    const symPort2 = symbol.ports.find((p) => p.labels.includes("2"));
    const ports = this.selectAll("port");
    const pin1Port = ports.find((p) => p.props.pinNumber === 1);
    const pin2Port = ports.find((p) => p.props.pinNumber === 2);
    const pin3Port = ports.find((p) => p.props.pinNumber === 3);
    const pin4Port = ports.find((p) => p.props.pinNumber === 4);
    const { internallyConnectedPins } = this._parsedProps;
    pin1Port.schematicSymbolPortDef = symPort1;
    if (!internallyConnectedPins || internallyConnectedPins.length === 0) {
      pin2Port.schematicSymbolPortDef = symPort2;
    }
    for (const [pn, port] of [
      [2, pin2Port],
      [3, pin3Port],
      [4, pin4Port]
    ]) {
      const internallyConnectedRow = internallyConnectedPins?.find(
        ([pin1, pin2]) => pin1 === `pin${pn}` || pin2 === `pin${pn}`
      );
      if (!internallyConnectedRow) {
        port.schematicSymbolPortDef = symPort2;
        break;
      }
      const internallyConnectedTo = internallyConnectedRow?.[0] === `pin${pn}` ? internallyConnectedRow[1] : internallyConnectedRow?.[0];
      if (internallyConnectedTo === "pin1") {
        continue;
      }
      port.schematicSymbolPortDef = symPort2;
    }
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      name: this.name,
      ftype: FTYPE.simple_push_button,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Crystal.ts
import { crystalProps } from "@tscircuit/props";
import { formatSiUnit as formatSiUnit7 } from "format-si-unit";
var Crystal = class extends NormalComponent3 {
  // @ts-ignore
  get config() {
    const symbolName = this.props.symbolName ?? (this.props.pinVariant === "four_pin" ? "crystal_4pin" : "crystal");
    return {
      schematicSymbolName: symbolName,
      componentName: "Crystal",
      zodProps: crystalProps,
      sourceFtype: "simple_crystal"
    };
  }
  initPorts() {
    const additionalAliases = this.props.pinVariant === "four_pin" ? {
      pin1: ["left1", "1"],
      pin2: ["top1", "2", "gnd1"],
      pin3: ["right1", "3"],
      pin4: ["bottom1", "4", "gnd2"]
    } : {
      pin1: ["pos", "left"],
      pin2: ["neg", "right"]
    };
    super.initPorts({
      additionalAliases
    });
  }
  _getSchematicSymbolDisplayValue() {
    const freqDisplay = `${formatSiUnit7(this._parsedProps.frequency)}Hz`;
    if (this._parsedProps.loadCapacitance) {
      return `${freqDisplay} / ${formatSiUnit7(
        this._parsedProps.loadCapacitance
      )}F`;
    }
    return freqDisplay;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      name: this.name,
      ftype: "simple_crystal",
      frequency: props.frequency,
      load_capacitance: props.loadCapacitance,
      pin_variant: props.pinVariant || "two_pin",
      are_pins_interchangeable: (props.pinVariant || "two_pin") === "two_pin"
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Mosfet.ts
import { mosfetProps } from "@tscircuit/props";
var Mosfet = class extends NormalComponent3 {
  get config() {
    const mosfetMode = this.props.mosfetMode === "depletion" ? "d" : "e";
    const channelType = this.props.channelType;
    const baseSymbolName = `${channelType}_channel_${mosfetMode}_mosfet_transistor`;
    return {
      componentName: "Mosfet",
      schematicSymbolName: this.props.symbolName ?? baseSymbolName,
      zodProps: mosfetProps,
      shouldRenderAsSchematicBox: false
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_mosfet",
      name: this.name,
      mosfet_mode: props.mosfetMode,
      channel_type: props.channelType
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Switch.ts
import { switchProps } from "@tscircuit/props";
import { frequency as frequency2, ms } from "circuit-json";
function hasSimProps(props) {
  return props.simSwitchFrequency !== void 0 || props.simCloseAt !== void 0 || props.simOpenAt !== void 0 || props.simStartClosed !== void 0 || props.simStartOpen !== void 0;
}
var Switch = class extends NormalComponent3 {
  _getSwitchType() {
    const props = this._parsedProps;
    if (!props) return "spst";
    if (props.dpdt) return "dpdt";
    if (props.spst) return "spst";
    if (props.spdt) return "spdt";
    if (props.dpst) return "dpst";
    return props.type ?? "spst";
  }
  get config() {
    const switchType = this._getSwitchType();
    const isNormallyClosed = this._parsedProps?.isNormallyClosed ?? false;
    const symbolMap = {
      spst: isNormallyClosed ? "spst_normally_closed_switch" : "spst_switch",
      spdt: isNormallyClosed ? "spdt_normally_closed_switch" : "spdt_switch",
      dpst: isNormallyClosed ? "dpst_normally_closed_switch" : "dpst_switch",
      dpdt: isNormallyClosed ? "dpdt_normally_closed_switch" : "dpdt_switch"
    };
    return {
      componentName: "Switch",
      schematicSymbolName: this.props.symbolName ?? symbolMap[switchType],
      zodProps: switchProps,
      shouldRenderAsSchematicBox: false
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const props = this._parsedProps ?? {};
    const source_component = db.source_component.insert({
      ftype: "simple_switch",
      name: this.name,
      are_pins_interchangeable: this._getSwitchType() === "spst"
    });
    this.source_component_id = source_component.source_component_id;
  }
  doInitialSimulationRender() {
    const { _parsedProps: props } = this;
    if (!hasSimProps(props)) {
      return;
    }
    const { db } = this.root;
    const simulationSwitch = {
      type: "simulation_switch",
      source_component_id: this.source_component_id || ""
    };
    if (props.simSwitchFrequency !== void 0) {
      simulationSwitch.switching_frequency = frequency2.parse(
        props.simSwitchFrequency
      );
    }
    if (props.simCloseAt !== void 0) {
      simulationSwitch.closes_at = ms.parse(props.simCloseAt);
    }
    if (props.simOpenAt !== void 0) {
      simulationSwitch.opens_at = ms.parse(props.simOpenAt);
    }
    if (props.simStartOpen !== void 0) {
      simulationSwitch.starts_closed = !props.simStartOpen;
    }
    if (props.simStartClosed !== void 0) {
      simulationSwitch.starts_closed = props.simStartClosed;
    }
    db.simulation_switch.insert(simulationSwitch);
  }
};

// lib/components/normal-components/TestPoint.ts
import { testpointProps } from "@tscircuit/props";
var TESTPOINT_DEFAULTS = {
  HOLE_DIAMETER: 0.5,
  SMT_CIRCLE_DIAMETER: 1.2,
  SMT_RECT_SIZE: 2
};
var TestPoint = class extends NormalComponent3 {
  get config() {
    return {
      componentName: "TestPoint",
      schematicSymbolName: this.props.symbolName ?? "testpoint",
      zodProps: testpointProps,
      sourceFtype: FTYPE.simple_test_point
    };
  }
  _getPropsWithDefaults() {
    let {
      padShape,
      holeDiameter,
      footprintVariant,
      padDiameter,
      width,
      height
    } = this._parsedProps;
    if (!footprintVariant && holeDiameter) {
      footprintVariant = "through_hole";
    }
    footprintVariant ??= "through_hole";
    padShape ??= "circle";
    if (footprintVariant === "pad") {
      if (padShape === "circle") {
        padDiameter ??= TESTPOINT_DEFAULTS.SMT_CIRCLE_DIAMETER;
      } else if (padShape === "rect") {
        width ??= TESTPOINT_DEFAULTS.SMT_RECT_SIZE;
        height ??= width;
      }
    } else if (footprintVariant === "through_hole") {
      holeDiameter ??= TESTPOINT_DEFAULTS.HOLE_DIAMETER;
    }
    return {
      padShape,
      holeDiameter,
      footprintVariant,
      padDiameter,
      width,
      height
    };
  }
  _getImpliedFootprintString() {
    const {
      padShape,
      holeDiameter,
      footprintVariant,
      padDiameter,
      width,
      height
    } = this._getPropsWithDefaults();
    if (footprintVariant === "through_hole") {
      return `platedhole_d${holeDiameter}`;
    }
    if (footprintVariant === "pad") {
      if (padShape === "circle") {
        return `smtpad_circle_d${padDiameter}`;
      }
      if (padShape === "rect") {
        return `smtpad_rect_w${width}_h${height}`;
      }
    }
    throw new Error(
      `Footprint variant "${footprintVariant}" with pad shape "${padShape}" not implemented`
    );
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const {
      padShape,
      holeDiameter,
      footprintVariant,
      padDiameter,
      width,
      height
    } = this._getPropsWithDefaults();
    const source_component = db.source_component.insert({
      ftype: FTYPE.simple_test_point,
      name: this.name,
      supplier_part_numbers: props.supplierPartNumbers,
      footprint_variant: footprintVariant,
      pad_shape: padShape,
      pad_diameter: padDiameter,
      hole_diameter: holeDiameter,
      width,
      height,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/primitive-components/SchematicText.ts
import { schematicTextProps } from "@tscircuit/props";
var SchematicText = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  get config() {
    return {
      componentName: "SchematicText",
      zodProps: schematicTextProps
    };
  }
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const globalPos = this._getGlobalSchematicPositionBeforeLayout();
    db.schematic_text.insert({
      anchor: props.anchor ?? "center",
      text: props.text,
      font_size: props.fontSize,
      color: props.color || "#000000",
      position: {
        x: globalPos.x,
        y: globalPos.y
      },
      rotation: props.schRotation ?? 0
    });
  }
};

// lib/components/primitive-components/SchematicLine.ts
import { schematicLineProps } from "@tscircuit/props";
var SchematicLine = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  get config() {
    return {
      componentName: "SchematicLine",
      zodProps: schematicLineProps
    };
  }
  schematic_line_id;
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const globalPos = this._getGlobalSchematicPositionBeforeLayout();
    const schematic_component_id = this.getPrimitiveContainer()?.parent?.schematic_component_id;
    const schematic_line = db.schematic_line.insert({
      schematic_component_id,
      x1: props.x1 + globalPos.x,
      y1: props.y1 + globalPos.y,
      x2: props.x2 + globalPos.x,
      y2: props.y2 + globalPos.y,
      stroke_width: props.strokeWidth ?? SCHEMATIC_COMPONENT_OUTLINE_STROKE_WIDTH,
      color: props.color ?? SCHEMATIC_COMPONENT_OUTLINE_COLOR,
      is_dashed: false,
      subcircuit_id: this.getSubcircuit().subcircuit_id ?? void 0
    });
    this.schematic_line_id = schematic_line.schematic_line_id;
  }
};

// lib/components/primitive-components/SchematicRect.ts
import { schematicRectProps } from "@tscircuit/props";
var SchematicRect = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  get config() {
    return {
      componentName: "SchematicRect",
      zodProps: schematicRectProps
    };
  }
  schematic_rect_id;
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const globalPos = this._getGlobalSchematicPositionBeforeLayout();
    const schematic_component_id = this.getPrimitiveContainer()?.parent?.schematic_component_id;
    const schematic_rect = db.schematic_rect.insert({
      center: {
        x: globalPos.x,
        y: globalPos.y
      },
      width: props.width,
      height: props.height,
      stroke_width: props.strokeWidth ?? SCHEMATIC_COMPONENT_OUTLINE_STROKE_WIDTH,
      color: props.color ?? SCHEMATIC_COMPONENT_OUTLINE_COLOR,
      is_filled: props.isFilled,
      schematic_component_id,
      is_dashed: props.isDashed,
      rotation: props.rotation ?? 0,
      subcircuit_id: this.getSubcircuit().subcircuit_id ?? void 0
    });
    this.schematic_rect_id = schematic_rect.schematic_rect_id;
  }
};

// lib/components/primitive-components/SchematicArc.ts
import { schematicArcProps } from "@tscircuit/props";
var SchematicArc = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  get config() {
    return {
      componentName: "SchematicArc",
      zodProps: schematicArcProps
    };
  }
  schematic_arc_id;
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const globalPos = this._getGlobalSchematicPositionBeforeLayout();
    const schematic_component_id = this.getPrimitiveContainer()?.parent?.schematic_component_id;
    const schematic_arc = db.schematic_arc.insert({
      schematic_component_id,
      center: {
        x: props.center.x + globalPos.x,
        y: props.center.y + globalPos.y
      },
      radius: props.radius,
      start_angle_degrees: props.startAngleDegrees,
      end_angle_degrees: props.endAngleDegrees,
      direction: props.direction,
      stroke_width: props.strokeWidth ?? SCHEMATIC_COMPONENT_OUTLINE_STROKE_WIDTH,
      color: props.color ?? SCHEMATIC_COMPONENT_OUTLINE_COLOR,
      is_dashed: props.isDashed,
      subcircuit_id: this.getSubcircuit().subcircuit_id ?? void 0
    });
    this.schematic_arc_id = schematic_arc.schematic_arc_id;
  }
};

// lib/components/primitive-components/SchematicCircle.ts
import { schematicCircleProps } from "@tscircuit/props";
var SchematicCircle = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  get config() {
    return {
      componentName: "SchematicCircle",
      zodProps: schematicCircleProps
    };
  }
  schematic_circle_id;
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const globalPos = this._getGlobalSchematicPositionBeforeLayout();
    const schematic_component_id = this.getPrimitiveContainer()?.parent?.schematic_component_id;
    const schematic_circle = db.schematic_circle.insert({
      schematic_component_id,
      center: {
        x: props.center.x + globalPos.x,
        y: props.center.y + globalPos.y
      },
      radius: props.radius,
      stroke_width: props.strokeWidth ?? SCHEMATIC_COMPONENT_OUTLINE_STROKE_WIDTH,
      color: props.color ?? SCHEMATIC_COMPONENT_OUTLINE_COLOR,
      is_filled: props.isFilled,
      fill_color: props.fillColor,
      is_dashed: props.isDashed,
      subcircuit_id: this.getSubcircuit().subcircuit_id ?? void 0
    });
    this.schematic_circle_id = schematic_circle.schematic_circle_id;
  }
};

// lib/components/primitive-components/SchematicBox.ts
import { schematicBoxProps } from "@tscircuit/props";

// lib/components/primitive-components/getTitleAnchorAndPosition.ts
function getTitleAnchorAndPosition({
  anchor,
  x,
  y,
  width,
  height,
  isInside
}) {
  switch (anchor) {
    case "top_left":
      return {
        x,
        y: y + height,
        textAnchor: isInside ? "top_left" : "bottom_left"
      };
    case "top_center":
      return {
        x: x + width / 2,
        y: y + height,
        textAnchor: isInside ? "top_center" : "bottom_center"
      };
    case "top_right":
      return {
        x: x + width,
        y: y + height,
        textAnchor: isInside ? "top_right" : "bottom_right"
      };
    case "center_left":
      return {
        x,
        y: y + height / 2,
        textAnchor: isInside ? "center_left" : "center_right"
      };
    case "center":
      return {
        x: x + width / 2,
        y: y + height / 2,
        textAnchor: "center"
      };
    case "center_right":
      return {
        x: x + width,
        y: y + height / 2,
        textAnchor: isInside ? "center_right" : "center_left"
      };
    case "bottom_left":
      return {
        x,
        y,
        textAnchor: isInside ? "bottom_left" : "top_left"
      };
    case "bottom_center":
      return {
        x: x + width / 2,
        y,
        textAnchor: isInside ? "bottom_center" : "top_center"
      };
    case "bottom_right":
      return {
        x: x + width,
        y,
        textAnchor: isInside ? "bottom_right" : "top_right"
      };
    default:
      return {
        x: x + width / 2,
        y: y + height,
        textAnchor: "center"
      };
  }
}

// lib/components/primitive-components/SchematicBox.ts
var SchematicBox = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  get config() {
    return {
      componentName: "SchematicBox",
      zodProps: schematicBoxProps,
      shouldRenderAsSchematicBox: true
    };
  }
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const basePadding = 0.6;
    const generalPadding = typeof props.padding === "number" ? props.padding : 0;
    const paddingTop = typeof props.paddingTop === "number" ? props.paddingTop : generalPadding;
    const paddingBottom = typeof props.paddingBottom === "number" ? props.paddingBottom : generalPadding;
    const paddingLeft = typeof props.paddingLeft === "number" ? props.paddingLeft : generalPadding;
    const paddingRight = typeof props.paddingRight === "number" ? props.paddingRight : generalPadding;
    const hasOverlay = props.overlay && props.overlay.length > 0;
    const hasFixedSize = typeof props.width === "number" && typeof props.height === "number";
    let width;
    let height;
    let x;
    let y;
    let centerX;
    let centerY;
    if (hasOverlay) {
      const portsWithSelectors = props.overlay.map((selector) => ({
        selector,
        port: this.getSubcircuit().selectOne(selector, {
          type: "port"
        })
      })).filter(({ port }) => port != null);
      const portsWithPosition = portsWithSelectors.map(({ port }) => ({
        position: port._getGlobalSchematicPositionAfterLayout()
      }));
      if (portsWithPosition.length === 0) return;
      const xs = portsWithPosition.map((p) => p.position.x);
      const ys = portsWithPosition.map((p) => p.position.y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      const rawWidth = maxX - minX;
      const rawHeight = maxY - minY;
      const defaultHorizontalPadding = rawWidth === 0 ? basePadding : 0;
      const defaultVerticalPadding = rawHeight === 0 ? basePadding : 0;
      const finalPaddingLeft = paddingLeft + defaultHorizontalPadding / 2;
      const finalPaddingRight = paddingRight + defaultHorizontalPadding / 2;
      const finalPaddingTop = paddingTop + defaultVerticalPadding / 2;
      const finalPaddingBottom = paddingBottom + defaultVerticalPadding / 2;
      const left = minX - finalPaddingLeft;
      const right = maxX + finalPaddingRight;
      const top = minY - finalPaddingBottom;
      const bottom = maxY + finalPaddingTop;
      width = right - left;
      height = bottom - top;
      x = left + (props.schX ?? 0);
      y = top + (props.schY ?? 0);
      centerX = x + width / 2;
      centerY = y + height / 2;
    } else if (hasFixedSize) {
      width = props.width;
      height = props.height;
      const center = this._getGlobalSchematicPositionBeforeLayout();
      centerX = center.x;
      centerY = center.y;
      x = centerX - width / 2;
      y = centerY - height / 2;
    } else {
      return;
    }
    db.schematic_box.insert({
      height,
      width,
      x,
      y,
      is_dashed: props.strokeStyle === "dashed"
    });
    if (props.title) {
      const isInside = props.titleInside;
      const TITLE_PADDING = 0.1;
      const anchor = props.titleAlignment;
      const anchorPos = getTitleAnchorAndPosition({
        anchor,
        x,
        y,
        width,
        height,
        isInside
      });
      let titleOffsetY;
      let titleOffsetX;
      const textAnchor = anchorPos.textAnchor;
      if (isInside) {
        titleOffsetY = anchor.includes("top") ? -TITLE_PADDING : anchor.includes("bottom") ? TITLE_PADDING : 0;
        titleOffsetX = anchor.includes("left") ? TITLE_PADDING : anchor.includes("right") ? -TITLE_PADDING : 0;
      } else {
        titleOffsetY = anchor.includes("top") ? TITLE_PADDING : anchor.includes("bottom") ? -TITLE_PADDING : 0;
        titleOffsetX = anchor.includes("center_left") ? -TITLE_PADDING : anchor.includes("center_right") ? TITLE_PADDING : 0;
      }
      const titleX = anchorPos.x + titleOffsetX;
      const titleY = anchorPos.y + titleOffsetY;
      db.schematic_text.insert({
        anchor: textAnchor,
        text: props.title,
        font_size: props.titleFontSize ?? 0.18,
        color: props.titleColor ?? "#000000",
        position: {
          x: titleX,
          y: titleY
        },
        rotation: 0
      });
    }
  }
};

// lib/components/primitive-components/SchematicTable.ts
import { schematicTableProps } from "@tscircuit/props";
var SchematicTable = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  schematic_table_id = null;
  get config() {
    return {
      componentName: "SchematicTable",
      zodProps: schematicTableProps
    };
  }
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const rows = this.children.filter(
      (c) => c.componentName === "SchematicRow"
    );
    if (rows.length === 0) return;
    const grid = [];
    let maxCols = 0;
    for (const row of rows) {
      const cells = row.children.filter(
        (c) => c.componentName === "SchematicCell"
      );
      maxCols = Math.max(maxCols, cells.length);
    }
    for (let i = 0; i < rows.length; i++) {
      grid[i] = [];
    }
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      const cells = row.children.filter(
        (c) => c.componentName === "SchematicCell"
      );
      let k = 0;
      for (let j = 0; j < cells.length; j++) {
        while (grid[i][k]) {
          k++;
        }
        const cell = cells[j];
        const colSpan = cell._parsedProps.colSpan ?? 1;
        const rowSpan = cell._parsedProps.rowSpan ?? 1;
        for (let r = 0; r < rowSpan; r++) {
          for (let c = 0; c < colSpan; c++) {
            if (!grid[i + r]) grid[i + r] = [];
            grid[i + r][k + c] = cell;
          }
        }
        k += colSpan;
      }
    }
    maxCols = Math.max(0, ...grid.map((r) => r.length));
    const rowHeights = rows.map(
      (row, i) => row._parsedProps.height ?? 1
    );
    const colWidths = Array.from({ length: maxCols }, (_, j) => {
      let maxWidth = 0;
      for (let i = 0; i < rows.length; i++) {
        const cell = grid[i]?.[j];
        if (cell) {
          const text = cell._parsedProps.text ?? cell._parsedProps.children;
          const cellWidth = cell._parsedProps.width ?? (text?.length ?? 2) * 0.5;
          if (cellWidth > maxWidth) {
            maxWidth = cellWidth;
          }
        }
      }
      return maxWidth || 10;
    });
    const anchorPos = this._getGlobalSchematicPositionBeforeLayout();
    const table = db.schematic_table.insert({
      anchor_position: anchorPos,
      column_widths: colWidths,
      row_heights: rowHeights,
      cell_padding: props.cellPadding,
      border_width: props.borderWidth,
      anchor: props.anchor,
      subcircuit_id: this.getSubcircuit()?.subcircuit_id || "",
      schematic_component_id: this.parent?.schematic_component_id || ""
    });
    this.schematic_table_id = table.schematic_table_id;
    const processedCells = /* @__PURE__ */ new Set();
    let yOffset = 0;
    for (let i = 0; i < rows.length; i++) {
      let xOffset = 0;
      for (let j = 0; j < maxCols; j++) {
        const cell = grid[i]?.[j];
        if (cell && !processedCells.has(cell)) {
          processedCells.add(cell);
          const cellProps = cell._parsedProps;
          const rowSpan = cellProps.rowSpan ?? 1;
          const colSpan = cellProps.colSpan ?? 1;
          let cellWidth = 0;
          for (let c = 0; c < colSpan; c++) {
            cellWidth += colWidths[j + c];
          }
          let cellHeight = 0;
          for (let r = 0; r < rowSpan; r++) {
            cellHeight += rowHeights[i + r];
          }
          db.schematic_table_cell.insert({
            schematic_table_id: this.schematic_table_id,
            start_row_index: i,
            end_row_index: i + rowSpan - 1,
            start_column_index: j,
            end_column_index: j + colSpan - 1,
            text: cellProps.text ?? cellProps.children,
            center: {
              x: anchorPos.x + xOffset + cellWidth / 2,
              y: anchorPos.y - yOffset - cellHeight / 2
            },
            width: cellWidth,
            height: cellHeight,
            horizontal_align: cellProps.horizontalAlign,
            vertical_align: cellProps.verticalAlign,
            font_size: cellProps.fontSize ?? props.fontSize,
            subcircuit_id: this.getSubcircuit()?.subcircuit_id || ""
          });
        }
        if (colWidths[j]) {
          xOffset += colWidths[j];
        }
      }
      yOffset += rowHeights[i];
    }
  }
};

// lib/components/primitive-components/SchematicRow.ts
import { schematicRowProps } from "@tscircuit/props";
var SchematicRow = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  get config() {
    return {
      componentName: "SchematicRow",
      zodProps: schematicRowProps
    };
  }
};

// lib/components/primitive-components/SchematicCell.ts
import { schematicCellProps } from "@tscircuit/props";
var SchematicCell = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  canHaveTextChildren = true;
  get config() {
    return {
      componentName: "SchematicCell",
      zodProps: schematicCellProps
    };
  }
};

// lib/components/primitive-components/Symbol.ts
import { symbolProps } from "@tscircuit/props";
var SymbolComponent = class extends PrimitiveComponent2 {
  isPrimitiveContainer = true;
  get config() {
    return {
      componentName: "Symbol",
      zodProps: symbolProps
    };
  }
};

// lib/components/primitive-components/AnalogSimulation.ts
import {
  analogSimulationProps
} from "@tscircuit/props";
import "zod";
var AnalogSimulation = class extends PrimitiveComponent2 {
  get config() {
    return {
      componentName: "AnalogSimulation",
      zodProps: analogSimulationProps
    };
  }
  doInitialSimulationRender() {
    const { db } = this.root;
    const { duration, timePerStep } = this._parsedProps;
    const durationMs = duration || 10;
    const timePerStepMs = timePerStep || 0.01;
    db.simulation_experiment.insert({
      name: "spice_transient_analysis",
      experiment_type: "spice_transient_analysis",
      end_time_ms: durationMs,
      time_per_step: timePerStepMs
    });
  }
};

// lib/components/primitive-components/VoltageProbe.ts
import { voltageProbeProps } from "@tscircuit/props";
import "zod";
var VoltageProbe = class extends PrimitiveComponent2 {
  simulation_voltage_probe_id = null;
  schematic_voltage_probe_id = null;
  finalProbeName = null;
  color = null;
  get config() {
    return {
      componentName: "VoltageProbe",
      zodProps: voltageProbeProps
    };
  }
  doInitialSimulationRender() {
    const { db } = this.root;
    const { connectsTo, name } = this._parsedProps;
    const subcircuit = this.getSubcircuit();
    if (!subcircuit) {
      this.renderError("VoltageProbe must be inside a subcircuit");
      return;
    }
    const targets = Array.isArray(connectsTo) ? connectsTo : [connectsTo];
    if (targets.length !== 1) {
      this.renderError("VoltageProbe must connect to exactly one port or net");
      return;
    }
    const targetSelector = targets[0];
    const port = subcircuit.selectOne(targetSelector, {
      type: "port"
    });
    const net = !port ? subcircuit.selectOne(targetSelector, { type: "net" }) : null;
    if (net && net.componentName !== "Net") {
      this.renderError(
        `VoltageProbe connection target "${targetSelector}" resolved to a non-net component "${net.componentName}".`
      );
      return;
    }
    if (!port && !net) {
      this.renderError(
        `VoltageProbe could not find connection target "${targetSelector}"`
      );
      return;
    }
    const connectedId = port?.source_port_id ?? net?.source_net_id;
    if (!connectedId) {
      this.renderError(`Could not identify connected source for VoltageProbe`);
      return;
    }
    this.color = getSimulationColorForId(connectedId);
    let finalName = name;
    if (!finalName) {
      finalName = targets[0].split(" > ").map((s) => s.replace(/^\./, "")).join(".");
    }
    this.finalProbeName = finalName;
    const { simulation_voltage_probe_id } = db.simulation_voltage_probe.insert({
      name: finalName,
      source_port_id: port?.source_port_id ?? void 0,
      source_net_id: net?.source_net_id ?? void 0,
      subcircuit_id: subcircuit.subcircuit_id || void 0,
      color: this.color
    });
    this.simulation_voltage_probe_id = simulation_voltage_probe_id;
  }
  doInitialSchematicReplaceNetLabelsWithSymbols() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { connectsTo, name } = this._parsedProps;
    const subcircuit = this.getSubcircuit();
    if (!subcircuit) {
      return;
    }
    const targets = Array.isArray(connectsTo) ? connectsTo : [connectsTo];
    if (targets.length !== 1) {
      return;
    }
    const targetSelector = targets[0];
    const port = subcircuit.selectOne(targetSelector, {
      type: "port"
    });
    if (!port) return;
    if (!port.schematic_port_id) return;
    const position = port._getGlobalSchematicPositionAfterLayout();
    let targetTraceId = null;
    for (const trace of db.schematic_trace.list()) {
      for (const edge of trace.edges) {
        if (Math.abs(edge.from.x - position.x) < 1e-6 && Math.abs(edge.from.y - position.y) < 1e-6 || Math.abs(edge.to.x - position.x) < 1e-6 && Math.abs(edge.to.y - position.y) < 1e-6) {
          targetTraceId = trace.schematic_trace_id;
          break;
        }
      }
      if (targetTraceId) break;
    }
    if (!targetTraceId) {
      return;
    }
    const probeName = this.finalProbeName;
    const schematic_voltage_probe = db.schematic_voltage_probe.insert({
      name: probeName,
      position,
      schematic_trace_id: targetTraceId,
      subcircuit_id: subcircuit.subcircuit_id || void 0,
      color: this.color ?? void 0
    });
    this.schematic_voltage_probe_id = schematic_voltage_probe.schematic_voltage_probe_id;
  }
};

// lib/RootCircuit.ts
import { su as su5 } from "@tscircuit/circuit-json-util";
import { isValidElement as isValidElement2 } from "react";
import { identity as identity6 } from "transformation-matrix";

// package.json
var package_default = {
  name: "@tscircuit/core",
  type: "module",
  version: "0.0.869",
  types: "dist/index.d.ts",
  main: "dist/index.js",
  module: "dist/index.js",
  exports: {
    ".": {
      import: "./dist/index.js",
      types: "./dist/index.d.ts"
    }
  },
  files: [
    "dist"
  ],
  repository: {
    type: "git",
    url: "https://github.com/tscircuit/core"
  },
  scripts: {
    build: "tsup-node index.ts --format esm --dts",
    format: "biome format . --write",
    "measure-bundle": "howfat -r table .",
    "pkg-pr-new-release": "bunx pkg-pr-new publish --comment=off --peerDeps",
    "smoke-test:dist": "bun run scripts/smoke-tests/test-dist-simple-circuit.tsx",
    "build:benchmarking": "bun build --experimental-html ./benchmarking/website/index.html --outdir ./benchmarking-dist",
    "build:benchmarking:watch": `chokidar "./{benchmarking,lib}/**/*.{ts,tsx}" -c 'bun build --experimental-html ./benchmarking/website/index.html --outdir ./benchmarking-dist'`,
    "start:benchmarking": 'concurrently "bun run build:benchmarking:watch" "live-server ./benchmarking-dist"',
    "generate-test-plan": "bun run scripts/generate-test-plan.ts"
  },
  devDependencies: {
    "@biomejs/biome": "^1.8.3",
    "@resvg/resvg-js": "^2.6.2",
    "@tscircuit/capacity-autorouter": "^0.0.140",
    "@tscircuit/checks": "^0.0.85",
    "@tscircuit/circuit-json-util": "^0.0.72",
    "@tscircuit/common": "^0.0.20",
    "@tscircuit/copper-pour-solver": "^0.0.14",
    "@tscircuit/footprinter": "^0.0.236",
    "@tscircuit/import-snippet": "^0.0.4",
    "@tscircuit/infgrid-ijump-astar": "^0.0.33",
    "@tscircuit/log-soup": "^1.0.2",
    "@tscircuit/matchpack": "^0.0.16",
    "@tscircuit/math-utils": "^0.0.29",
    "@tscircuit/miniflex": "^0.0.4",
    "@tscircuit/ngspice-spice-engine": "^0.0.3",
    "@tscircuit/props": "^0.0.403",
    "@tscircuit/schematic-autolayout": "^0.0.6",
    "@tscircuit/schematic-match-adapt": "^0.0.16",
    "@tscircuit/schematic-trace-solver": "^v0.0.45",
    "@tscircuit/solver-utils": "^0.0.3",
    "@types/bun": "^1.2.16",
    "@types/debug": "^4.1.12",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@types/react-reconciler": "^0.28.9",
    "bpc-graph": "^0.0.57",
    "bun-match-svg": "0.0.12",
    "calculate-elbow": "^0.0.12",
    "chokidar-cli": "^3.0.0",
    "circuit-json": "^0.0.317",
    "circuit-json-to-bpc": "^0.0.13",
    "circuit-json-to-connectivity-map": "^0.0.22",
    "circuit-json-to-gltf": "^0.0.31",
    "circuit-json-to-simple-3d": "^0.0.9",
    "circuit-json-to-spice": "^0.0.24",
    "circuit-to-svg": "^0.0.274",
    concurrently: "^9.1.2",
    "connectivity-map": "^1.0.0",
    debug: "^4.3.6",
    "eecircuit-engine": "^1.5.6",
    flatbush: "^4.5.0",
    "graphics-debug": "^0.0.60",
    howfat: "^0.3.8",
    "live-server": "^1.2.2",
    "looks-same": "^9.0.1",
    minicssgrid: "^0.0.9",
    "pkg-pr-new": "^0.0.37",
    poppygl: "^0.0.16",
    react: "^19.1.0",
    "react-dom": "^19.1.0",
    "schematic-symbols": "^0.0.202",
    spicey: "^0.0.14",
    "ts-expect": "^1.3.0",
    tsup: "^8.2.4"
  },
  peerDependencies: {
    "@tscircuit/capacity-autorouter": "*",
    "@tscircuit/checks": "*",
    "@tscircuit/circuit-json-util": "*",
    "@tscircuit/footprinter": "*",
    "@tscircuit/infgrid-ijump-astar": "*",
    "@tscircuit/math-utils": "*",
    "@tscircuit/props": "*",
    "@tscircuit/schematic-autolayout": "*",
    "@tscircuit/schematic-match-adapt": "*",
    "circuit-json-to-bpc": "*",
    "bpc-graph": "*",
    "@tscircuit/matchpack": "*",
    "circuit-json": "*",
    "circuit-json-to-connectivity-map": "*",
    "schematic-symbols": "*",
    typescript: "^5.0.0"
  },
  dependencies: {
    "@flatten-js/core": "^1.6.2",
    "@lume/kiwi": "^0.4.3",
    "calculate-packing": "0.0.50",
    "css-select": "5.1.0",
    "format-si-unit": "^0.0.3",
    nanoid: "^5.0.7",
    "performance-now": "^2.1.0",
    "react-reconciler": "^0.32.0",
    "transformation-matrix": "^2.16.1",
    zod: "^3.25.67"
  }
};

// lib/RootCircuit.ts
import Debug14 from "debug";
var RootCircuit = class {
  firstChild = null;
  children;
  db;
  root = null;
  isRoot = true;
  _schematicDisabledOverride;
  get schematicDisabled() {
    if (this._schematicDisabledOverride !== void 0) {
      return this._schematicDisabledOverride;
    }
    const board = this._getBoard();
    return board?._parsedProps?.schematicDisabled ?? false;
  }
  set schematicDisabled(value) {
    this._schematicDisabledOverride = value;
  }
  pcbDisabled = false;
  pcbRoutingDisabled = false;
  _featureMspSchematicTraceRouting = true;
  /**
   * The RootCircuit name is usually set by the platform, it's not required but
   * if supplied can identify the circuit in certain effects, e.g. it is passed
   * as the display_name parameter for autorouting effects.
   */
  name;
  platform;
  /**
   * Optional URL pointing to where this project is hosted or documented.
   * When provided it is stored in the source_project_metadata.project_url field
   * of the generated Circuit JSON.
   */
  projectUrl;
  _hasRenderedAtleastOnce = false;
  constructor({
    platform,
    projectUrl
  } = {}) {
    this.children = [];
    this.db = su5([]);
    this.root = this;
    this.platform = platform;
    this.projectUrl = projectUrl;
    this.pcbDisabled = platform?.pcbDisabled ?? false;
  }
  add(componentOrElm) {
    let component;
    if (isValidElement2(componentOrElm)) {
      component = createInstanceFromReactElement(componentOrElm);
    } else {
      component = componentOrElm;
    }
    this.children.push(component);
  }
  setPlatform(platform) {
    this.platform = {
      ...this.platform,
      ...platform
    };
  }
  /**
   * Get the main board for this Circuit.
   */
  _getBoard() {
    const directBoard = this.children.find((c) => c.componentName === "Board");
    if (directBoard) {
      return directBoard;
    }
    return void 0;
  }
  _guessRootComponent() {
    if (this.firstChild) return;
    if (this.children.length === 0) {
      throw new Error(
        "Not able to guess root component: RootCircuit has no children (use circuit.add(...))"
      );
    }
    const panels = this.children.filter(
      (child) => child.lowercaseComponentName === "panel"
    );
    if (panels.length > 1) {
      throw new Error("Only one <panel> is allowed per circuit");
    }
    if (panels.length === 1) {
      if (this.children.length !== 1) {
        throw new Error("<panel> must be the root element of the circuit");
      }
      this.firstChild = panels[0];
      return;
    }
    if (this.children.length === 1 && this.children[0].isGroup) {
      this.firstChild = this.children[0];
      return;
    }
    const group = new Group6({ subcircuit: true });
    group.parent = this;
    group.addAll(this.children);
    this.children = [group];
    this.firstChild = group;
  }
  render() {
    if (!this.firstChild) {
      this._guessRootComponent();
    }
    const { firstChild, db } = this;
    if (!firstChild) throw new Error("RootCircuit has no root component");
    firstChild.parent = this;
    firstChild.runRenderCycle();
    this._hasRenderedAtleastOnce = true;
  }
  async renderUntilSettled() {
    const existing = this.db.source_project_metadata.list()?.[0];
    if (!existing) {
      this.db.source_project_metadata.insert({
        software_used_string: `@tscircuit/core@${this.getCoreVersion()}`,
        ...this.projectUrl ? { project_url: this.projectUrl } : {}
      });
    }
    this.render();
    while (this._hasIncompleteAsyncEffects()) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      this.render();
    }
    this.emit("renderComplete");
  }
  _hasIncompleteAsyncEffects() {
    return this.children.some((child) => {
      if (child._hasIncompleteAsyncEffects()) return true;
      return child.children.some(
        (grandchild) => grandchild._hasIncompleteAsyncEffects()
      );
    });
  }
  getCircuitJson() {
    if (!this._hasRenderedAtleastOnce) this.render();
    return this.db.toArray();
  }
  toJson() {
    return this.getCircuitJson();
  }
  async getSvg(options) {
    const circuitToSvg = await import("circuit-to-svg").catch((e) => {
      throw new Error(
        `To use circuit.getSvg, you must install the "circuit-to-svg" package.

"${e.message}"`
      );
    });
    if (options.view === "pcb") {
      return circuitToSvg.convertCircuitJsonToPcbSvg(this.getCircuitJson());
    }
    if (options.view === "schematic") {
      return circuitToSvg.convertCircuitJsonToSchematicSvg(
        this.getCircuitJson()
      );
    }
    throw new Error(`Invalid view: ${options.view}`);
  }
  getCoreVersion() {
    const [major, minor, patch] = package_default.version.split(".").map(Number);
    return `${major}.${minor}.${patch + 1}`;
  }
  async preview(previewNameOrOpts) {
    const previewOpts = typeof previewNameOrOpts === "object" ? previewNameOrOpts : { previewName: previewNameOrOpts };
    throw new Error("project.preview is not yet implemented");
  }
  computeSchematicGlobalTransform() {
    return identity6();
  }
  _computePcbGlobalTransformBeforeLayout() {
    return identity6();
  }
  selectAll(selector) {
    this._guessRootComponent();
    return this.firstChild?.selectAll(selector) ?? [];
  }
  selectOne(selector, opts) {
    this._guessRootComponent();
    return this.firstChild?.selectOne(selector, opts) ?? null;
  }
  _eventListeners = {};
  emit(event, ...args) {
    if (!this._eventListeners[event]) return;
    for (const listener of this._eventListeners[event]) {
      listener(...args);
    }
  }
  on(event, listener) {
    if (!this._eventListeners[event]) {
      this._eventListeners[event] = [];
    }
    this._eventListeners[event].push(listener);
  }
  removeListener(event, listener) {
    if (!this._eventListeners[event]) return;
    this._eventListeners[event] = this._eventListeners[event].filter(
      (l) => l !== listener
    );
  }
  enableDebug(debug11) {
    if (typeof debug11 === "string") {
      Debug14.enable(debug11);
    } else if (debug11 === null || debug11 === false) {
      Debug14.disable();
    }
  }
  getClientOrigin() {
    if (typeof window !== "undefined" && window.location) {
      return window.location.origin;
    }
    if (typeof self !== "undefined" && self.location) {
      return self.location.origin;
    }
    return "";
  }
};
var Project = RootCircuit;
var Circuit = RootCircuit;

// lib/hooks/use-rendered-circuit.ts
import React2 from "react";
var useRenderedCircuit = (reactElements) => {
  const [isLoading, setIsLoading] = React2.useState(true);
  const [error, setError] = React2.useState(null);
  const [circuit, setCircuit] = React2.useState();
  const [circuitJson, setCircuitJson] = React2.useState();
  React2.useEffect(() => {
    setIsLoading(true);
    setError(null);
    if (reactElements) {
      setTimeout(() => {
        try {
          const circuit2 = new RootCircuit();
          circuit2.add(reactElements);
          setCircuit(circuit2);
          setCircuitJson(circuit2.toJson());
        } catch (error2) {
          setError(error2);
        }
        setIsLoading(false);
      }, 1);
    }
  }, [reactElements]);
  return { isLoading, error, circuit, circuitJson };
};

// lib/hooks/create-use-component.tsx
import "react";
import "zod";
import "@tscircuit/props";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
var createUseComponent = (Component2, pins) => {
  return (name, props) => {
    const pinLabelsFlatArray = [];
    if (Array.isArray(pins)) {
      pinLabelsFlatArray.push(...pins.flat());
    } else if (typeof pins === "object") {
      pinLabelsFlatArray.push(
        ...Object.values(pins).flat(),
        ...Object.keys(pins)
      );
    }
    const R = (props2) => {
      if (props2?.name && props2.name !== name) {
        throw new Error(
          `Component name mismatch. Hook name: ${name}, Component prop name: ${props2.name}`
        );
      }
      const combinedProps = { ...props, ...props2, name };
      const tracesToCreate = [];
      for (const portLabel of pinLabelsFlatArray) {
        if (combinedProps[portLabel]) {
          const from = `.${name} > .${portLabel}`;
          const to = combinedProps[portLabel];
          tracesToCreate.push({ from, to });
          delete combinedProps[portLabel];
        }
      }
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(Component2, { ...combinedProps }),
        tracesToCreate.map((trace, i) => (
          // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>
          /* @__PURE__ */ jsx("trace", { ...trace }, i)
        ))
      ] });
    };
    for (const port of pinLabelsFlatArray) {
      R[port] = `.${name} > .${port}`;
    }
    return R;
  };
};

// lib/hooks/use-capacitor.tsx
import { capacitorPins } from "@tscircuit/props";
import { jsx as jsx2 } from "react/jsx-runtime";
var useCapacitor = createUseComponent(
  (props) => /* @__PURE__ */ jsx2("capacitor", { ...props }),
  capacitorPins
);

// lib/hooks/use-chip.tsx
import { jsx as jsx3 } from "react/jsx-runtime";
var useChip = (pinLabels) => createUseComponent(
  (props) => /* @__PURE__ */ jsx3("chip", { pinLabels, ...props }),
  pinLabels
);

// lib/hooks/use-diode.tsx
import { diodePins } from "@tscircuit/props";
import { jsx as jsx4 } from "react/jsx-runtime";
var useDiode = createUseComponent(
  (props) => /* @__PURE__ */ jsx4("diode", { ...props }),
  diodePins
);

// lib/hooks/use-led.tsx
import { ledPins } from "@tscircuit/props";
import { jsx as jsx5 } from "react/jsx-runtime";
var useLed = createUseComponent(
  (props) => /* @__PURE__ */ jsx5("led", { ...props }),
  ledPins
);

// lib/hooks/use-resistor.tsx
import { resistorPins as resistorPins2 } from "@tscircuit/props";
import { jsx as jsx6 } from "react/jsx-runtime";
var useResistor = createUseComponent(
  (props) => /* @__PURE__ */ jsx6("resistor", { ...props }),
  resistorPins2
);

// lib/sel/sel.ts
var sel = new Proxy(
  (refdes) => new Proxy(
    {},
    {
      get: (_, pin) => `.${refdes} > .${pin}`
    }
  ),
  {
    get: (_, prop1) => {
      const fn = (...args) => {
        const chipFnOrPinType = args[0];
        return new Proxy(
          {},
          {
            get: (_2, pinName) => {
              return `.${prop1} > .${pinName}`;
            }
          }
        );
      };
      return new Proxy(fn, {
        // This handles dot notation access like sel.U1.PIN
        get: (_2, prop2) => {
          if (prop1 === "net") {
            return `net.${prop2}`;
          }
          if (prop1 === "subcircuit") {
            return new Proxy(
              {},
              {
                get: (_3, prop3) => {
                  return new Proxy(
                    {},
                    {
                      get: (_4, prop4) => {
                        return `subcircuit.${prop2} > .${prop3} > .${prop4}`;
                      }
                    }
                  );
                }
              }
            );
          }
          return `.${prop1} > .${prop2}`;
        },
        // This handles function calls like...
        // - sel.U1(MyChip)
        // - sel.U1(({ selectors: { U1: { GND: "GND", VCC: "VCC" } } }) => ...)
        // - sel.U1(({ connections: { GND: "GND", VCC: "VCC" } }) => ...)
        apply: (target, _2, args) => {
          if (prop1 === "net") {
            return new Proxy(
              {},
              {
                get: (_3, netName) => `net.${netName}`
              }
            );
          }
          return new Proxy(
            {},
            {
              get: (_3, pinOrSubComponentName) => {
                const pinResult = `.${prop1} > .${pinOrSubComponentName}`;
                const chipPrefixes = ["U", "J", "CN"];
                if (chipPrefixes.some((p) => prop1.startsWith(p))) {
                  return pinResult;
                }
                return new Proxy(new String(pinResult), {
                  get: (_4, nestedProp) => {
                    if (typeof nestedProp === "symbol" || nestedProp === "toString") {
                      return () => pinResult;
                    }
                    return `.${prop1} > .${pinOrSubComponentName} > .${nestedProp}`;
                  }
                });
              }
            }
          );
        }
      });
    }
  }
);

// lib/index.ts
import { createElement } from "react";

// lib/register-catalogue.ts
extendCatalogue(components_exports);
extendCatalogue({
  Bug: Chip
});
export {
  AnalogSimulation,
  Battery,
  Board,
  Breakout,
  BreakoutPoint,
  CadAssembly,
  CadModel,
  Capacitor,
  Chip,
  Circuit,
  Constraint3 as Constraint,
  CopperPour,
  Crystal,
  Cutout,
  Diode,
  FabricationNoteDimension,
  FabricationNotePath,
  FabricationNoteRect,
  FabricationNoteText,
  Footprint,
  Fuse,
  Group6 as Group,
  Hole,
  Inductor,
  Jumper,
  Keepout,
  Led,
  Mosfet,
  Net,
  NetLabel,
  NormalComponent3 as NormalComponent,
  Panel,
  PcbNoteDimension,
  PcbNoteLine,
  PcbNotePath,
  PcbNoteRect,
  PcbNoteText,
  PcbTrace,
  PinHeader,
  Pinout,
  PlatedHole,
  Port,
  Potentiometer,
  PowerSource,
  PrimitiveComponent2 as PrimitiveComponent,
  Project,
  PushButton,
  Renderable,
  Resistor,
  Resonator,
  RootCircuit,
  SchematicArc,
  SchematicBox,
  SchematicCell,
  SchematicCircle,
  SchematicLine,
  SchematicRect,
  SchematicRow,
  SchematicTable,
  SchematicText,
  SilkscreenCircle,
  SilkscreenLine,
  SilkscreenPath,
  SilkscreenRect,
  SilkscreenText,
  SmtPad,
  SolderJumper,
  Subcircuit,
  Switch,
  SymbolComponent as Symbol,
  TestPoint,
  Trace3 as Trace,
  TraceHint,
  Transistor,
  Via,
  VoltageProbe,
  VoltageSource,
  applyEditEvents,
  applyEditEventsToManualEditsFile,
  applyPcbEditEventsToManualEditsFile,
  applySchematicEditEventsToManualEditsFile,
  createElement,
  createUseComponent,
  getPhaseTimingsFromRenderEvents,
  getSimpleRouteJsonFromCircuitJson,
  normalizePinLabels,
  orderedRenderPhases,
  resolveStaticFileImport,
  sel,
  useCapacitor,
  useChip,
  useDiode,
  useLed,
  useRenderedCircuit,
  useResistor
};
