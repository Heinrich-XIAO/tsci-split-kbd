// lib/constants/EPS.ts
var EPS = 1e-15;

// lib/parsing/NodeIndex.ts
var NodeIndex = class {
  map;
  rev;
  constructor() {
    this.map = /* @__PURE__ */ new Map([["0", 0]]);
    this.rev = ["0"];
  }
  getOrCreate(name) {
    const origName = String(name);
    const key = origName.toUpperCase();
    if (this.map.has(key)) return this.map.get(key);
    const idx = this.rev.length;
    this.map.set(key, idx);
    this.rev.push(origName);
    return idx;
  }
  get(name) {
    return this.map.get(String(name).toUpperCase());
  }
  count() {
    return this.rev.length;
  }
  matrixIndexOfNode(nodeId) {
    if (nodeId === 0) return -1;
    return nodeId - 1;
  }
};

// lib/parsing/parseNumberWithUnits.ts
function parseNumberWithUnits(raw) {
  if (raw == null) return NaN;
  let s = String(raw).trim();
  if (s === "") return NaN;
  if (/^[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?$/.test(s)) return parseFloat(s);
  const unitMul = {
    t: 1e12,
    g: 1e9,
    meg: 1e6,
    k: 1e3,
    m: 1e-3,
    u: 1e-6,
    n: 1e-9,
    p: 1e-12,
    f: 1e-15
  };
  const m = s.match(/^([+-]?\d*\.?\d+(?:[eE][+-]?\d+)?)([a-zA-Z]+)$/);
  if (!m) return parseFloat(s);
  const [, numberPart, suffixPart] = m;
  if (numberPart == null) return parseFloat(s);
  let val = parseFloat(numberPart);
  let suf = (suffixPart ?? "").toLowerCase();
  suf = suf.replace(/(ohm|v|a|s|h|f)$/g, "");
  if (suf === "meg") return val * unitMul.meg;
  if (suf.length === 1 && suf in unitMul) {
    const key = suf;
    return val * unitMul[key];
  }
  return val;
}

// lib/parsing/parsePulseArgs.ts
function parsePulseArgs(token) {
  const clean = token.trim().replace(/^pulse\s*\(/i, "(");
  const inside = clean.replace(/^\(/, "").replace(/\)$/, "").trim();
  const parts = inside.split(/[\s,]+/).filter((x) => x.length);
  if (parts.length < 7) throw new Error("PULSE(...) requires 7 or 8 args");
  const vals = parts.map((value) => parseNumberWithUnits(value));
  if (vals.some((v) => Number.isNaN(v)))
    throw new Error("Invalid PULSE() numeric value");
  return {
    v1: vals[0],
    v2: vals[1],
    td: vals[2],
    tr: vals[3],
    tf: vals[4],
    ton: vals[5],
    period: vals[6],
    ncycles: parts[7] != null ? vals[7] : Infinity
  };
}

// lib/parsing/parsePwlArgs.ts
function parsePwlArgs(token) {
  const clean = token.trim().replace(/^pwl\s*\(/i, "(");
  const inside = clean.replace(/^\(/, "").replace(/\)$/, "").trim();
  const parts = inside.split(/[\s,]+/).filter((x) => x.length);
  if (parts.length === 0 || parts.length % 2 !== 0)
    throw new Error("PWL(...) requires an even number of time/value pairs");
  const pairs = [];
  for (let i = 0; i < parts.length; i += 2) {
    const t = parseNumberWithUnits(parts[i]);
    const v = parseNumberWithUnits(parts[i + 1]);
    if (Number.isNaN(t) || Number.isNaN(v))
      throw new Error("Invalid PWL() numeric value");
    pairs.push({ t, v });
  }
  return pairs;
}

// lib/parsing/pulseValue.ts
function pulseValue(p, t) {
  if (t < p.td) return p.v1;
  const tt = t - p.td;
  const cyclesDone = Math.floor(tt / p.period);
  if (cyclesDone >= p.ncycles) return p.v1;
  const tc = tt - cyclesDone * p.period;
  if (tc < p.tr) {
    const a = tc / Math.max(p.tr, EPS);
    return p.v1 + (p.v2 - p.v1) * a;
  }
  if (tc < p.tr + p.ton) {
    return p.v2;
  }
  if (tc < p.tr + p.ton + p.tf) {
    const a = (tc - (p.tr + p.ton)) / Math.max(p.tf, EPS);
    return p.v2 + (p.v1 - p.v2) * a;
  }
  return p.v1;
}

// lib/parsing/pwlValue.ts
function pwlValue(pairs, t) {
  if (pairs.length === 0) return 0;
  if (t <= pairs[0].t) return pairs[0].v;
  for (let i = 1; i < pairs.length; i++) {
    const prev = pairs[i - 1];
    const curr = pairs[i];
    if (t <= curr.t) {
      const dt = Math.max(curr.t - prev.t, EPS);
      const a = (t - prev.t) / dt;
      return prev.v + (curr.v - prev.v) * a;
    }
  }
  return pairs[pairs.length - 1].v;
}

// lib/parsing/parseNetlist.ts
function smartTokens(line) {
  const re = /"[^"]*"|\w+\s*\([^)]*\)|\([^()]*\)|\S+/g;
  const out = [];
  let m;
  while ((m = re.exec(line)) !== null) out.push(m[0]);
  return out;
}
function requireToken(tokens, index, context) {
  const token = tokens[index];
  if (token == null) throw new Error(context);
  return token;
}
function parseNetlist(text) {
  const vswitchModels = /* @__PURE__ */ new Map();
  const diodeModels = /* @__PURE__ */ new Map();
  const ckt = {
    nodes: new NodeIndex(),
    R: [],
    C: [],
    L: [],
    V: [],
    S: [],
    D: [],
    analyses: { ac: null, tran: null },
    probes: { tran: [] },
    skipped: [],
    models: { vswitch: vswitchModels, diode: diodeModels }
  };
  const lines = text.split(/\r?\n/);
  let seenTitle = false;
  for (const raw of lines) {
    let line = raw.trim();
    if (!line) continue;
    if (/^\*/.test(line)) continue;
    if (/^\s*\.end\b/i.test(line)) break;
    line = line.replace(/\/\/.*$/, "");
    line = line.replace(/;.*$/, "");
    const tokens = smartTokens(line);
    if (tokens.length === 0) continue;
    const first = tokens[0];
    if (first.length === 0) continue;
    if (!seenTitle && !/^[rclvgsmiqd]\w*$/i.test(first) && !/^\./.test(first)) {
      seenTitle = true;
      continue;
    }
    if (/^\./.test(first)) {
      const dir = first.toLowerCase();
      if (dir === ".ac") {
        const mode = requireToken(tokens, 1, ".ac missing mode").toLowerCase();
        if (mode !== "dec" && mode !== "lin")
          throw new Error(".ac supports 'dec' or 'lin'");
        const N = parseInt(
          requireToken(tokens, 2, ".ac missing point count"),
          10
        );
        const f1 = parseNumberWithUnits(
          requireToken(tokens, 3, ".ac missing start frequency")
        );
        const f2 = parseNumberWithUnits(
          requireToken(tokens, 4, ".ac missing stop frequency")
        );
        ckt.analyses.ac = { mode, N, f1, f2 };
      } else if (dir === ".tran") {
        const dt = parseNumberWithUnits(
          requireToken(tokens, 1, ".tran missing timestep")
        );
        const tstop = parseNumberWithUnits(
          requireToken(tokens, 2, ".tran missing stop time")
        );
        ckt.analyses.tran = { dt, tstop };
      } else if (dir === ".print") {
        const analysisType = requireToken(
          tokens,
          1,
          ".print missing analysis type"
        ).toLowerCase();
        if (analysisType === "tran") {
          const probeTokens = tokens.slice(2);
          for (const token of probeTokens) {
            const match = token.match(/^v\(([^)]+)\)$/i);
            if (match && match[1]) {
              const nodeName = match[1];
              if (!ckt.probes.tran.some(
                (p) => p.toUpperCase() === nodeName.toUpperCase()
              )) {
                ckt.probes.tran.push(nodeName);
              }
            }
          }
        } else {
          ckt.skipped.push(line);
        }
      } else if (dir === ".model") {
        const nameToken = requireToken(tokens, 1, ".model missing name");
        const typeToken = requireToken(tokens, 2, ".model missing type");
        let type = typeToken;
        let paramsStr = "";
        if (type.includes("(")) {
          const idx = type.indexOf("(");
          paramsStr = type.slice(idx + 1);
          type = type.slice(0, idx);
        }
        if (!paramsStr) {
          const rest = tokens.slice(3).join(" ");
          paramsStr = rest.replace(/^\(/, "").replace(/\)$/, "");
        } else {
          const rest = tokens.slice(3).join(" ").replace(/\)$/, "");
          paramsStr = `${paramsStr} ${rest}`.trim();
        }
        paramsStr = paramsStr.replace(/^\(/, "").replace(/\)$/, "").trim();
        const typeLower = type.toLowerCase();
        if (typeLower === "vswitch" || typeLower === "sw") {
          const model = {
            name: nameToken,
            Ron: 1,
            Roff: 1e12,
            Von: 0,
            Voff: 0
          };
          let vt;
          let vh;
          if (paramsStr.length > 0) {
            const assignments = paramsStr.split(/[\s,]+/).filter(Boolean);
            for (const assignment of assignments) {
              const [keyRaw, valueRaw] = assignment.split("=");
              if (!keyRaw || valueRaw == null) continue;
              const key = keyRaw.toLowerCase();
              const value = parseNumberWithUnits(valueRaw);
              if (Number.isNaN(value)) continue;
              if (key === "ron") model.Ron = value;
              else if (key === "roff") model.Roff = value;
              else if (key === "von") model.Von = value;
              else if (key === "voff") model.Voff = value;
              else if (key === "vt") vt = value;
              else if (key === "vh") vh = value;
            }
          }
          if (vt !== void 0) {
            const Vh = vh ?? 0;
            model.Von = vt + Vh / 2;
            model.Voff = vt - Vh / 2;
          }
          vswitchModels.set(nameToken.toLowerCase(), model);
        } else if (typeLower === "d") {
          const model = {
            name: nameToken,
            Is: 1e-14,
            // default saturation current
            N: 1
            // default ideality factor
          };
          if (paramsStr.length > 0) {
            const assignments = paramsStr.split(/[\s,]+/).filter(Boolean);
            for (const assignment of assignments) {
              const [keyRaw, valueRaw] = assignment.split("=");
              if (!keyRaw || valueRaw == null) continue;
              const key = keyRaw.toLowerCase();
              const value = parseNumberWithUnits(valueRaw);
              if (Number.isNaN(value)) continue;
              if (key === "is") model.Is = value;
              else if (key === "n") model.N = value;
            }
          }
          diodeModels.set(nameToken.toLowerCase(), model);
        } else {
          ckt.skipped.push(line);
        }
      } else {
        ckt.skipped.push(line);
      }
      continue;
    }
    const typeChar = first.charAt(0).toLowerCase();
    const name = first;
    try {
      if (typeChar === "r") {
        const n1 = ckt.nodes.getOrCreate(
          requireToken(tokens, 1, "Resistor missing node")
        );
        const n2 = ckt.nodes.getOrCreate(
          requireToken(tokens, 2, "Resistor missing node")
        );
        const val = parseNumberWithUnits(
          requireToken(tokens, 3, "Resistor missing value")
        );
        ckt.R.push({ name, n1, n2, R: val });
      } else if (typeChar === "c") {
        const n1 = ckt.nodes.getOrCreate(
          requireToken(tokens, 1, "Capacitor missing node")
        );
        const n2 = ckt.nodes.getOrCreate(
          requireToken(tokens, 2, "Capacitor missing node")
        );
        const val = parseNumberWithUnits(
          requireToken(tokens, 3, "Capacitor missing value")
        );
        ckt.C.push({ name, n1, n2, C: val, vPrev: 0 });
      } else if (typeChar === "l") {
        const n1 = ckt.nodes.getOrCreate(
          requireToken(tokens, 1, "Inductor missing node")
        );
        const n2 = ckt.nodes.getOrCreate(
          requireToken(tokens, 2, "Inductor missing node")
        );
        const val = parseNumberWithUnits(
          requireToken(tokens, 3, "Inductor missing value")
        );
        ckt.L.push({ name, n1, n2, L: val, iPrev: 0 });
      } else if (typeChar === "v") {
        const n1 = ckt.nodes.getOrCreate(
          requireToken(tokens, 1, "Voltage source missing node")
        );
        const n2 = ckt.nodes.getOrCreate(
          requireToken(tokens, 2, "Voltage source missing node")
        );
        const spec = {
          dc: 0,
          acMag: 0,
          acPhaseDeg: 0,
          waveform: null,
          index: -1
        };
        let i = 3;
        if (i < tokens.length && !/^[a-zA-Z]/.test(tokens[i])) {
          spec.dc = parseNumberWithUnits(tokens[i]);
          i++;
        }
        while (i < tokens.length) {
          const key = tokens[i].toLowerCase();
          if (key === "dc") {
            const valueToken = requireToken(tokens, i + 1, "DC value missing");
            spec.dc = parseNumberWithUnits(valueToken);
            i += 2;
          } else if (key === "ac") {
            const magToken = requireToken(tokens, i + 1, "AC magnitude missing");
            spec.acMag = parseNumberWithUnits(magToken);
            const phaseToken = tokens[i + 2];
            if (phaseToken != null && /^[+-]?\d/.test(phaseToken)) {
              spec.acPhaseDeg = parseNumberWithUnits(phaseToken);
              i += 3;
            } else {
              i += 2;
            }
          } else if (key.startsWith("pulse")) {
            const argToken = key.includes("(") ? key : requireToken(tokens, i + 1, "PULSE() missing arguments");
            if (!argToken || !/\(.*\)/.test(argToken))
              throw new Error("Malformed PULSE() specification");
            const p = parsePulseArgs(argToken);
            spec.waveform = (t) => pulseValue(p, t);
            i += key.includes("(") ? 1 : 2;
          } else if (key.startsWith("pwl")) {
            const argToken = key.includes("(") ? key : requireToken(tokens, i + 1, "PWL() missing arguments");
            if (!argToken || !/\(.*\)/.test(argToken))
              throw new Error("Malformed PWL() specification");
            const pairs = parsePwlArgs(argToken);
            spec.waveform = (t) => pwlValue(pairs, t);
            i += key.includes("(") ? 1 : 2;
          } else if (/^\(.*\)$/.test(key)) {
            i++;
          } else {
            i++;
          }
        }
        ckt.V.push({
          name,
          n1,
          n2,
          dc: spec.dc,
          acMag: spec.acMag,
          acPhaseDeg: spec.acPhaseDeg,
          waveform: spec.waveform,
          index: spec.index ?? -1
        });
      } else if (typeChar === "s") {
        const n1 = ckt.nodes.getOrCreate(
          requireToken(tokens, 1, "Switch missing node")
        );
        const n2 = ckt.nodes.getOrCreate(
          requireToken(tokens, 2, "Switch missing node")
        );
        const ncPos = ckt.nodes.getOrCreate(
          requireToken(tokens, 3, "Switch missing control node")
        );
        const ncNeg = ckt.nodes.getOrCreate(
          requireToken(tokens, 4, "Switch missing control node")
        );
        const modelName = requireToken(tokens, 5, "Switch missing model");
        ckt.S.push({
          name,
          n1,
          n2,
          ncPos,
          ncNeg,
          modelName: modelName.toLowerCase(),
          model: null,
          isOn: false
        });
      } else if (typeChar === "d") {
        if (tokens.length === 4) {
          const nPlus = ckt.nodes.getOrCreate(
            requireToken(tokens, 1, "Diode missing node")
          );
          const nMinus = ckt.nodes.getOrCreate(
            requireToken(tokens, 2, "Diode missing node")
          );
          const modelName = requireToken(tokens, 3, "Diode missing model");
          ckt.D.push({
            name,
            nPlus,
            nMinus,
            modelName: modelName.toLowerCase(),
            model: null,
            vdPrev: 0
          });
        } else {
          ckt.skipped.push(line);
        }
      } else {
        ckt.skipped.push(line);
      }
    } catch (err) {
      if (err instanceof Error) {
        throw new Error(`Parse error on line: "${line}"
${err.message}`);
      }
      throw err;
    }
  }
  const nNodes = ckt.nodes.count() - 1;
  for (let i = 0; i < ckt.V.length; i++) {
    const vs = ckt.V[i];
    if (!vs) continue;
    vs.index = nNodes + i;
  }
  for (const sw of ckt.S) {
    const model = vswitchModels.get(sw.modelName);
    if (!model)
      throw new Error(
        `Unknown .model ${sw.modelName} referenced by switch ${sw.name}`
      );
    sw.model = model;
    sw.isOn = false;
  }
  for (const d of ckt.D) {
    const model = diodeModels.get(d.modelName);
    if (!model)
      throw new Error(
        `Unknown .model ${d.modelName} referenced by diode ${d.name}`
      );
    d.model = model;
  }
  return ckt;
}

// lib/math/Complex.ts
var Complex = class _Complex {
  re;
  im;
  constructor(re = 0, im = 0) {
    this.re = re;
    this.im = im;
  }
  static from(re, im = 0) {
    return new _Complex(re, im);
  }
  static fromPolar(mag, deg = 0) {
    const ph = deg * Math.PI / 180;
    return new _Complex(mag * Math.cos(ph), mag * Math.sin(ph));
  }
  clone() {
    return new _Complex(this.re, this.im);
  }
  add(b) {
    return new _Complex(this.re + b.re, this.im + b.im);
  }
  sub(b) {
    return new _Complex(this.re - b.re, this.im - b.im);
  }
  mul(b) {
    return new _Complex(
      this.re * b.re - this.im * b.im,
      this.re * b.im + this.im * b.re
    );
  }
  div(b) {
    const d = b.re * b.re + b.im * b.im;
    if (d < EPS) throw new Error("Complex divide by ~0");
    return new _Complex(
      (this.re * b.re + this.im * b.im) / d,
      (this.im * b.re - this.re * b.im) / d
    );
  }
  inv() {
    const d = this.re * this.re + this.im * this.im;
    if (d < EPS) throw new Error("Complex invert by ~0");
    return new _Complex(this.re / d, -this.im / d);
  }
  abs() {
    return Math.hypot(this.re, this.im);
  }
  phaseDeg() {
    return Math.atan2(this.im, this.re) * 180 / Math.PI;
  }
};

// lib/math/solveComplex.ts
function solveComplex(A, b) {
  const n = A.length;
  for (let i = 0; i < n; i++) {
    const row = A[i];
    const bi = b[i];
    if (!row || !bi) throw new Error("Matrix dimensions mismatch");
    const copy = row.map((z) => z.clone());
    copy.push(bi.clone());
    A[i] = copy;
  }
  for (let k = 0; k < n; k++) {
    let imax = k;
    const pivotRow = A[k];
    if (!pivotRow) throw new Error("Matrix row missing");
    let vmax = pivotRow[k]?.abs() ?? 0;
    for (let i = k + 1; i < n; i++) {
      const row = A[i];
      if (!row) throw new Error("Matrix row missing");
      const v = row[k]?.abs() ?? 0;
      if (v > vmax) {
        vmax = v;
        imax = i;
      }
    }
    if (vmax < EPS) throw new Error("Singular matrix (complex)");
    if (imax !== k) {
      const tmp = A[k];
      A[k] = A[imax];
      A[imax] = tmp;
    }
    const pivotRowUpdated = A[k];
    if (!pivotRowUpdated) throw new Error("Pivot row missing");
    const pivot = pivotRowUpdated[k];
    if (!pivot) throw new Error("Zero pivot encountered");
    for (let i = k + 1; i < n; i++) {
      const row = A[i];
      if (!row) throw new Error("Matrix row missing");
      const entry = row[k];
      if (!entry) continue;
      const f = entry.div(pivot);
      if (f.abs() < EPS) continue;
      for (let j = k; j <= n; j++) {
        const target = row[j];
        const source = pivotRowUpdated[j];
        if (!target || !source) continue;
        row[j] = target.sub(f.mul(source));
      }
    }
  }
  const x = new Array(n);
  for (let i = n - 1; i >= 0; i--) {
    const row = A[i];
    if (!row) throw new Error("Matrix row missing");
    let s = row[n];
    if (!s) throw new Error("Augmented column missing");
    for (let j = i + 1; j < n; j++) {
      const coeff = row[j];
      const sol = x[j];
      if (!coeff || !sol) continue;
      s = s.sub(coeff.mul(sol));
    }
    const pivot = row[i];
    if (!pivot) throw new Error("Zero pivot on back-substitution");
    x[i] = s.div(pivot);
  }
  return x;
}

// lib/utils/logspace.ts
function logspace(f1, f2, pointsPerDecade) {
  if (f1 <= 0 || f2 <= 0) throw new Error(".ac frequencies must be > 0");
  if (f2 < f1) [f1, f2] = [f2, f1];
  const decades = Math.log10(f2 / f1);
  const n = Math.max(1, Math.ceil(decades * pointsPerDecade));
  const arr = [];
  for (let i = 0; i <= n; i++) {
    arr.push(f1 * Math.pow(10, i / pointsPerDecade));
  }
  const last = arr[arr.length - 1];
  if (last == null || last < f2 * (1 - EPS)) arr.push(f2);
  return arr;
}

// lib/stamping/stampAdmittanceComplex.ts
function stampAdmittanceComplex(A, nidx, n1, n2, Y) {
  const i1 = nidx.matrixIndexOfNode(n1);
  const i2 = nidx.matrixIndexOfNode(n2);
  if (i1 >= 0) {
    const row1 = A[i1];
    if (!row1) throw new Error("Matrix row missing while stamping");
    row1[i1] = row1[i1]?.add(Y) ?? Y;
  }
  if (i2 >= 0) {
    const row2 = A[i2];
    if (!row2) throw new Error("Matrix row missing while stamping");
    row2[i2] = row2[i2]?.add(Y) ?? Y;
  }
  if (i1 >= 0 && i2 >= 0) {
    const row1 = A[i1];
    const row2 = A[i2];
    if (!row1 || !row2) throw new Error("Matrix row missing while stamping");
    row1[i2] = row1[i2]?.sub(Y) ?? Complex.from(0, 0).sub(Y);
    row2[i1] = row2[i1]?.sub(Y) ?? Complex.from(0, 0).sub(Y);
  }
}

// lib/stamping/stampVoltageSourceComplex.ts
function stampVoltageSourceComplex(A, b, nidx, source, voltage) {
  const i1 = nidx.matrixIndexOfNode(source.n1);
  const i2 = nidx.matrixIndexOfNode(source.n2);
  const j = source.index;
  const one = Complex.from(1, 0);
  const negOne = Complex.from(-1, 0);
  if (i1 >= 0) {
    const row1 = A[i1];
    if (!row1)
      throw new Error("Matrix row missing while stamping voltage source");
    row1[j] = row1[j]?.add(one) ?? one;
  }
  if (i2 >= 0) {
    const row2 = A[i2];
    if (!row2)
      throw new Error("Matrix row missing while stamping voltage source");
    row2[j] = row2[j]?.sub(one) ?? negOne;
  }
  const branchRow = A[j];
  if (!branchRow)
    throw new Error("Branch row missing while stamping voltage source");
  if (i1 >= 0) branchRow[i1] = branchRow[i1]?.add(one) ?? one;
  if (i2 >= 0) branchRow[i2] = branchRow[i2]?.sub(one) ?? negOne;
  b[j] = (b[j] ?? Complex.from(0, 0)).add(voltage);
}

// lib/analysis/simulateAC.ts
function buildFrequencyArray(params) {
  const { mode, N, f1, f2 } = params;
  if (mode === "dec") return logspace(f1, f2, N);
  const arr = [];
  const npts = Math.max(2, N);
  const step = (f2 - f1) / (npts - 1);
  for (let i = 0; i < npts; i++) arr.push(f1 + i * step);
  return arr;
}
function buildLinearSystemForAC(ckt, f, Nvar) {
  const A = Array.from(
    { length: Nvar },
    () => Array.from({ length: Nvar }, () => Complex.from(0, 0))
  );
  const b = Array.from({ length: Nvar }, () => Complex.from(0, 0));
  const twoPi = 2 * Math.PI;
  for (const r of ckt.R) {
    if (r.R <= 0) throw new Error(`R ${r.name} must be > 0`);
    const Y = Complex.from(1 / r.R, 0);
    stampAdmittanceComplex(A, ckt.nodes, r.n1, r.n2, Y);
  }
  for (const c of ckt.C) {
    const Y = Complex.from(0, twoPi * f * c.C);
    stampAdmittanceComplex(A, ckt.nodes, c.n1, c.n2, Y);
  }
  for (const l of ckt.L) {
    const denom = Complex.from(0, twoPi * f * l.L);
    const Y = denom.abs() < EPS ? Complex.from(0, 0) : Complex.from(1, 0).div(denom);
    stampAdmittanceComplex(A, ckt.nodes, l.n1, l.n2, Y);
  }
  for (const vs of ckt.V) {
    const Vph = Complex.fromPolar(vs.acMag || 0, vs.acPhaseDeg || 0);
    stampVoltageSourceComplex(A, b, ckt.nodes, vs, Vph);
  }
  return { A, b };
}
function simulateAC(ckt) {
  if (!ckt.analyses.ac) return null;
  const { mode, N, f1, f2 } = ckt.analyses.ac;
  const nNodeVars = ckt.nodes.count() - 1;
  const nVsrc = ckt.V.length;
  const Nvar = nNodeVars + nVsrc;
  const freqs = buildFrequencyArray({ mode, N, f1, f2 });
  const nodeVoltages = {};
  ckt.nodes.rev.forEach((name, id) => {
    if (id !== 0) nodeVoltages[name] = [];
  });
  const elementCurrents = {};
  const twoPi = 2 * Math.PI;
  for (const f of freqs) {
    const { A, b } = buildLinearSystemForAC(ckt, f, Nvar);
    const x = solveComplex(A, b);
    for (let id = 1; id < ckt.nodes.count(); id++) {
      const idx = id - 1;
      const nodeName = ckt.nodes.rev[id];
      if (!nodeName) continue;
      const series = nodeVoltages[nodeName];
      if (!series) continue;
      series.push(x[idx] ?? Complex.from(0, 0));
    }
    for (const r of ckt.R) {
      const v1 = r.n1 === 0 ? Complex.from(0, 0) : x[r.n1 - 1] ?? Complex.from(0, 0);
      const v2 = r.n2 === 0 ? Complex.from(0, 0) : x[r.n2 - 1] ?? Complex.from(0, 0);
      const Y = Complex.from(1 / r.R, 0);
      const i = Y.mul(v1.sub(v2));
      (elementCurrents[r.name] ||= []).push(i);
    }
    for (const c of ckt.C) {
      const v1 = c.n1 === 0 ? Complex.from(0, 0) : x[c.n1 - 1] ?? Complex.from(0, 0);
      const v2 = c.n2 === 0 ? Complex.from(0, 0) : x[c.n2 - 1] ?? Complex.from(0, 0);
      const Y = Complex.from(0, twoPi * f * c.C);
      const i = Y.mul(v1.sub(v2));
      (elementCurrents[c.name] ||= []).push(i);
    }
    for (const l of ckt.L) {
      const v1 = l.n1 === 0 ? Complex.from(0, 0) : x[l.n1 - 1] ?? Complex.from(0, 0);
      const v2 = l.n2 === 0 ? Complex.from(0, 0) : x[l.n2 - 1] ?? Complex.from(0, 0);
      const denom = Complex.from(0, twoPi * f * l.L);
      const Y = denom.abs() < EPS ? Complex.from(0, 0) : Complex.from(1, 0).div(denom);
      const i = Y.mul(v1.sub(v2));
      (elementCurrents[l.name] ||= []).push(i);
    }
    for (const vs of ckt.V) {
      const i = x[vs.index] ?? Complex.from(0, 0);
      (elementCurrents[vs.name] ||= []).push(i);
    }
  }
  return { freqs, nodeVoltages, elementCurrents };
}

// lib/constants/physics.ts
var VT_300K = 0.02585;

// lib/math/solveReal.ts
function solveReal(A, b) {
  const n = A.length;
  for (let i = 0; i < n; i++) {
    const row = A[i];
    const bi = b[i];
    if (!row || bi == null) throw new Error("Matrix dimensions mismatch");
    const copy = row.slice();
    copy.push(bi);
    A[i] = copy;
  }
  for (let k = 0; k < n; k++) {
    let imax = k;
    const pivotRow = A[k];
    if (!pivotRow) throw new Error("Matrix row missing");
    let vmax = Math.abs(pivotRow[k] ?? 0);
    for (let i = k + 1; i < n; i++) {
      const row = A[i];
      if (!row) throw new Error("Matrix row missing");
      const v = Math.abs(row[k] ?? 0);
      if (v > vmax) {
        vmax = v;
        imax = i;
      }
    }
    if (vmax < EPS) throw new Error("Singular matrix (real)");
    if (imax !== k) {
      const tmp = A[k];
      A[k] = A[imax];
      A[imax] = tmp;
    }
    const pivotRowUpdated = A[k];
    if (!pivotRowUpdated) throw new Error("Pivot row missing");
    const pivot = pivotRowUpdated[k];
    if (pivot == null) throw new Error("Zero pivot encountered");
    for (let i = k + 1; i < n; i++) {
      const row = A[i];
      if (!row) throw new Error("Matrix row missing");
      const entry = row[k];
      if (entry == null) continue;
      const f = entry / pivot;
      if (Math.abs(f) < EPS) continue;
      for (let j = k; j <= n; j++) {
        const target = row[j];
        const source = pivotRowUpdated[j];
        if (target == null || source == null) continue;
        row[j] = target - f * source;
      }
    }
  }
  const x = new Array(n).fill(0);
  for (let i = n - 1; i >= 0; i--) {
    const row = A[i];
    if (!row) throw new Error("Matrix row missing");
    let s = row[n];
    if (s == null) throw new Error("Augmented column missing");
    for (let j = i + 1; j < n; j++) {
      const coeff = row[j];
      const sol = x[j];
      if (coeff == null || sol == null) continue;
      s -= coeff * sol;
    }
    const pivot = row[i];
    if (pivot == null) throw new Error("Zero pivot on back-substitution");
    x[i] = s / pivot;
  }
  return x;
}

// lib/stamping/stampAdmittanceReal.ts
function stampAdmittanceReal(A, nidx, n1, n2, Y) {
  const i1 = nidx.matrixIndexOfNode(n1);
  const i2 = nidx.matrixIndexOfNode(n2);
  if (i1 >= 0) {
    const row1 = A[i1];
    if (!row1) throw new Error("Matrix row missing while stamping");
    row1[i1] = (row1[i1] ?? 0) + Y;
  }
  if (i2 >= 0) {
    const row2 = A[i2];
    if (!row2) throw new Error("Matrix row missing while stamping");
    row2[i2] = (row2[i2] ?? 0) + Y;
  }
  if (i1 >= 0 && i2 >= 0) {
    const row1 = A[i1];
    const row2 = A[i2];
    if (!row1 || !row2) throw new Error("Matrix row missing while stamping");
    row1[i2] = (row1[i2] ?? 0) - Y;
    row2[i1] = (row2[i1] ?? 0) - Y;
  }
}

// lib/stamping/stampCurrentReal.ts
function stampCurrentReal(b, nidx, nPlus, nMinus, current) {
  const iPlus = nidx.matrixIndexOfNode(nPlus);
  const iMinus = nidx.matrixIndexOfNode(nMinus);
  if (iPlus >= 0) b[iPlus] = (b[iPlus] ?? 0) - current;
  if (iMinus >= 0) b[iMinus] = (b[iMinus] ?? 0) + current;
}

// lib/stamping/stampVoltageSourceReal.ts
function stampVoltageSourceReal(A, b, nidx, source, voltage) {
  const i1 = nidx.matrixIndexOfNode(source.n1);
  const i2 = nidx.matrixIndexOfNode(source.n2);
  const j = source.index;
  if (i1 >= 0) {
    const row1 = A[i1];
    if (!row1)
      throw new Error("Matrix row missing while stamping voltage source");
    row1[j] = (row1[j] ?? 0) + 1;
  }
  if (i2 >= 0) {
    const row2 = A[i2];
    if (!row2)
      throw new Error("Matrix row missing while stamping voltage source");
    row2[j] = (row2[j] ?? 0) - 1;
  }
  const branchRow = A[j];
  if (!branchRow)
    throw new Error("Branch row missing while stamping voltage source");
  if (i1 >= 0) branchRow[i1] = (branchRow[i1] ?? 0) + 1;
  if (i2 >= 0) branchRow[i2] = (branchRow[i2] ?? 0) - 1;
  b[j] = (b[j] ?? 0) + voltage;
}

// lib/analysis/simulateTRAN.ts
function computeEffectiveTimeStep(dtRequested, tstop) {
  const dtEff = dtRequested > EPS ? dtRequested : Math.max(tstop / 1e3, EPS);
  const steps = Math.max(1, Math.ceil(tstop / Math.max(dtEff, EPS)));
  const dt = steps > 0 ? tstop / steps : tstop;
  return { dt, steps };
}
function stampAllElementsAtTime(A, b, ckt, t, dt, x, iter) {
  for (const r of ckt.R) {
    const G = 1 / r.R;
    stampAdmittanceReal(A, ckt.nodes, r.n1, r.n2, G);
  }
  for (const c of ckt.C) {
    const Gc = c.C / Math.max(dt, EPS);
    stampAdmittanceReal(A, ckt.nodes, c.n1, c.n2, Gc);
    const Ieq = -Gc * c.vPrev;
    stampCurrentReal(b, ckt.nodes, c.n1, c.n2, Ieq);
  }
  for (const l of ckt.L) {
    const Gl = Math.max(dt, EPS) / l.L;
    stampAdmittanceReal(A, ckt.nodes, l.n1, l.n2, Gl);
    stampCurrentReal(b, ckt.nodes, l.n1, l.n2, l.iPrev);
  }
  for (const sw of ckt.S) {
    const model = sw.model;
    if (!model) continue;
    const Rvalue = sw.isOn ? model.Ron : model.Roff;
    const Rclamped = Math.max(Math.abs(Rvalue), EPS);
    const G = 1 / Rclamped;
    stampAdmittanceReal(A, ckt.nodes, sw.n1, sw.n2, G);
  }
  for (const vs of ckt.V) {
    const Vt = vs.waveform ? vs.waveform(t) : vs.dc || 0;
    stampVoltageSourceReal(A, b, ckt.nodes, vs, Vt);
  }
  for (const d of ckt.D) {
    const model = d.model;
    if (!model) continue;
    const { nPlus, nMinus } = d;
    const vp_idx = ckt.nodes.matrixIndexOfNode(nPlus);
    const vn_idx = ckt.nodes.matrixIndexOfNode(nMinus);
    const v_plus_prev_iter = nPlus === 0 ? 0 : x[vp_idx] ?? 0;
    const v_minus_prev_iter = nMinus === 0 ? 0 : x[vn_idx] ?? 0;
    const vd_prev_iter = v_plus_prev_iter - v_minus_prev_iter;
    const vd = iter === 0 ? d.vdPrev : vd_prev_iter;
    const v_thermal = model.N * VT_300K;
    let vd_limited = vd;
    if (vd > 0.8) vd_limited = 0.8;
    if (vd < -1) vd_limited = -1;
    const exp_val = Math.exp(vd_limited / v_thermal);
    const id = model.Is * (exp_val - 1);
    const gd = Math.max(model.Is / v_thermal * exp_val, 1e-12);
    const ieq = id - gd * vd_limited;
    stampAdmittanceReal(A, ckt.nodes, nPlus, nMinus, gd);
    stampCurrentReal(b, ckt.nodes, nPlus, nMinus, ieq);
  }
}
function updateSwitchStatesFromSolution(ckt, x) {
  let switched = false;
  for (const sw of ckt.S) {
    const model = sw.model;
    if (!model) continue;
    const vp = sw.ncPos === 0 ? 0 : x[sw.ncPos - 1] ?? 0;
    const vn = sw.ncNeg === 0 ? 0 : x[sw.ncNeg - 1] ?? 0;
    const vctrl = vp - vn;
    let nextState = sw.isOn;
    if (sw.isOn) {
      if (vctrl < model.Voff) nextState = false;
    } else if (vctrl > model.Von) {
      nextState = true;
    }
    if (nextState !== sw.isOn) {
      sw.isOn = nextState;
      switched = true;
    }
  }
  return switched;
}
function simulateTRAN(ckt) {
  if (!ckt.analyses.tran) return null;
  const { dt: dtRequested, tstop } = ckt.analyses.tran;
  const { dt, steps } = computeEffectiveTimeStep(dtRequested, tstop);
  const nNodeVars = ckt.nodes.count() - 1;
  const nVsrc = ckt.V.length;
  const Nvar = nNodeVars + nVsrc;
  const times = [];
  const nodeVoltages = {};
  ckt.nodes.rev.forEach((name, id) => {
    if (id !== 0) nodeVoltages[name] = [];
  });
  const elementCurrents = {};
  let t = 0;
  for (let step = 0; step <= steps; step++, t = step * dt) {
    times.push(t);
    let x = new Array(Nvar).fill(0);
    for (let iter = 0; iter < 20; iter++) {
      const A = Array.from({ length: Nvar }, () => new Array(Nvar).fill(0));
      const b = new Array(Nvar).fill(0);
      stampAllElementsAtTime(A, b, ckt, t, dt, x, iter);
      x = solveReal(A, b);
      const switched = updateSwitchStatesFromSolution(ckt, x);
      if (!switched) break;
      if (iter === 19) break;
    }
    for (let id = 1; id < ckt.nodes.count(); id++) {
      const idx = id - 1;
      const nodeName = ckt.nodes.rev[id];
      if (!nodeName) continue;
      const series = nodeVoltages[nodeName];
      if (!series) continue;
      series.push(x[idx] ?? 0);
    }
    for (const r of ckt.R) {
      const v1 = r.n1 === 0 ? 0 : x[r.n1 - 1] ?? 0;
      const v2 = r.n2 === 0 ? 0 : x[r.n2 - 1] ?? 0;
      const i = (v1 - v2) / r.R;
      (elementCurrents[r.name] ||= []).push(i);
    }
    for (const c of ckt.C) {
      const v1 = c.n1 === 0 ? 0 : x[c.n1 - 1] ?? 0;
      const v2 = c.n2 === 0 ? 0 : x[c.n2 - 1] ?? 0;
      const i = c.C * (v1 - v2 - c.vPrev) / Math.max(dt, EPS);
      (elementCurrents[c.name] ||= []).push(i);
    }
    for (const l of ckt.L) {
      const v1 = l.n1 === 0 ? 0 : x[l.n1 - 1] ?? 0;
      const v2 = l.n2 === 0 ? 0 : x[l.n2 - 1] ?? 0;
      const Gl = Math.max(dt, EPS) / l.L;
      const i = Gl * (v1 - v2) + l.iPrev;
      (elementCurrents[l.name] ||= []).push(i);
    }
    for (const vs of ckt.V) {
      const i = x[vs.index] ?? 0;
      (elementCurrents[vs.name] ||= []).push(i);
    }
    for (const sw of ckt.S) {
      const model = sw.model;
      if (!model) continue;
      const v1 = sw.n1 === 0 ? 0 : x[sw.n1 - 1] ?? 0;
      const v2 = sw.n2 === 0 ? 0 : x[sw.n2 - 1] ?? 0;
      const Rvalue = sw.isOn ? model.Ron : model.Roff;
      const Rclamped = Math.max(Math.abs(Rvalue), EPS);
      const i = (v1 - v2) / Rclamped;
      (elementCurrents[sw.name] ||= []).push(i);
    }
    for (const d of ckt.D) {
      if (!d.model) continue;
      const { nPlus, nMinus, model } = d;
      const v1 = nPlus === 0 ? 0 : x[nPlus - 1] ?? 0;
      const v2 = nMinus === 0 ? 0 : x[nMinus - 1] ?? 0;
      const vd = v1 - v2;
      const v_thermal = model.N * VT_300K;
      const exp_val = Math.exp(vd / v_thermal);
      const id = model.Is * (exp_val - 1);
      (elementCurrents[d.name] ||= []).push(id);
    }
    for (const c of ckt.C) {
      const v1 = c.n1 === 0 ? 0 : x[c.n1 - 1] ?? 0;
      const v2 = c.n2 === 0 ? 0 : x[c.n2 - 1] ?? 0;
      c.vPrev = v1 - v2;
    }
    for (const l of ckt.L) {
      const v1 = l.n1 === 0 ? 0 : x[l.n1 - 1] ?? 0;
      const v2 = l.n2 === 0 ? 0 : x[l.n2 - 1] ?? 0;
      const Gl = Math.max(dt, EPS) / l.L;
      l.iPrev = Gl * (v1 - v2) + l.iPrev;
    }
    for (const d of ckt.D) {
      const v1 = d.nPlus === 0 ? 0 : x[d.nPlus - 1] ?? 0;
      const v2 = d.nMinus === 0 ? 0 : x[d.nMinus - 1] ?? 0;
      d.vdPrev = v1 - v2;
    }
  }
  if (ckt.probes.tran.length > 0) {
    const probedVoltages = {};
    const upperProbes = ckt.probes.tran.map((p) => p.toUpperCase());
    for (const nodeName in nodeVoltages) {
      if (upperProbes.includes(nodeName.toUpperCase())) {
        probedVoltages[nodeName] = nodeVoltages[nodeName];
      }
    }
    return { times, nodeVoltages: probedVoltages, elementCurrents };
  }
  return { times, nodeVoltages, elementCurrents };
}

// lib/analysis/simulate.ts
function simulate(netlistText) {
  const circuit = parseNetlist(netlistText);
  const ac = simulateAC(circuit);
  const tran = simulateTRAN(circuit);
  return { circuit, ac, tran };
}

// lib/formatting/formatAcResult.ts
function formatAcResult(ac) {
  if (!ac) return "No AC analysis.\n";
  const nodes = Object.keys(ac.nodeVoltages);
  const lines = [];
  lines.push(`f(Hz), ` + nodes.map((n) => `${n}:|V|,\u2220V(deg)`).join(", "));
  for (let k = 0; k < ac.freqs.length; k++) {
    const freq = ac.freqs[k];
    if (freq == null) continue;
    const parts = [freq.toPrecision(6)];
    for (const n of nodes) {
      const z = ac.nodeVoltages[n]?.[k];
      if (!z) continue;
      parts.push(`${z.abs().toPrecision(6)},${z.phaseDeg().toPrecision(6)}`);
    }
    lines.push(parts.join(", "));
  }
  return lines.join("\n");
}

// lib/formatting/formatTranResult.ts
function formatTranResult(tran) {
  if (!tran) return "No TRAN analysis.\n";
  const nodes = Object.keys(tran.nodeVoltages);
  const header = ["t(s)", ...nodes.map((n) => `${n}:V`)];
  const lines = [header.join(", ")];
  for (let k = 0; k < tran.times.length; k++) {
    const time = tran.times[k];
    if (time == null) continue;
    const row = [time.toPrecision(6)];
    for (const n of nodes) {
      const value = tran.nodeVoltages[n]?.[k];
      if (value == null) continue;
      row.push((+value).toPrecision(6));
    }
    lines.push(row.join(", "));
  }
  return lines.join("\n");
}

// lib/formatting/formatToVGraph.ts
function spiceyTranToVGraphs(tranResult, ckt, simulation_experiment_id) {
  if (!tranResult || !ckt.analyses.tran) return [];
  const { dt, tstop } = ckt.analyses.tran;
  const { times, nodeVoltages } = tranResult;
  const graphs = [];
  for (const nodeName in nodeVoltages) {
    const voltage_levels = nodeVoltages[nodeName];
    graphs.push({
      type: "simulation_transient_voltage_graph",
      simulation_transient_voltage_graph_id: `stvg_${simulation_experiment_id}_${nodeName}`,
      // simple id
      simulation_experiment_id,
      timestamps_ms: times.map((t) => t * 1e3),
      voltage_levels,
      time_per_step: dt * 1e3,
      start_time_ms: 0,
      end_time_ms: tstop * 1e3,
      name: `${nodeName}`
    });
  }
  return graphs;
}
function eecEngineTranToVGraphs(tranResult, ckt, simulation_experiment_id) {
  if (!ckt.analyses.tran) return [];
  const { dt, tstop } = ckt.analyses.tran;
  const graphs = [];
  for (const nodeName in tranResult.voltages) {
    const voltage_levels = tranResult.voltages[nodeName];
    graphs.push({
      type: "simulation_transient_voltage_graph",
      simulation_transient_voltage_graph_id: `stvg_${simulation_experiment_id}_${nodeName}_eec`,
      simulation_experiment_id,
      timestamps_ms: tranResult.time_s.map((t) => t * 1e3),
      voltage_levels,
      time_per_step: dt * 1e3,
      start_time_ms: 0,
      end_time_ms: tstop * 1e3,
      name: `${nodeName} (ngspice)`
    });
  }
  return graphs;
}
export {
  Complex,
  eecEngineTranToVGraphs,
  formatAcResult,
  formatTranResult,
  parseNetlist,
  simulate,
  simulateAC,
  simulateTRAN,
  spiceyTranToVGraphs
};
