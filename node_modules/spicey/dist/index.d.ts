import { SimulationTransientVoltageGraph } from 'circuit-json';

declare class NodeIndex {
    private map;
    rev: string[];
    constructor();
    getOrCreate(name: string): number;
    get(name: string): number | undefined;
    count(): number;
    matrixIndexOfNode(nodeId: number): number;
}

type Waveform = ((t: number) => number) | null;
type ParsedResistor = {
    name: string;
    n1: number;
    n2: number;
    R: number;
};
type ParsedCapacitor = {
    name: string;
    n1: number;
    n2: number;
    C: number;
    vPrev: number;
};
type ParsedInductor = {
    name: string;
    n1: number;
    n2: number;
    L: number;
    iPrev: number;
};
type ParsedDiodeModel = {
    name: string;
    Is: number;
    N: number;
};
type ParsedVoltageSource = {
    name: string;
    n1: number;
    n2: number;
    dc: number;
    acMag: number;
    acPhaseDeg: number;
    waveform: Waveform;
    index: number;
};
type ParsedVSwitchModel = {
    name: string;
    Ron: number;
    Roff: number;
    Von: number;
    Voff: number;
};
type ParsedDiode = {
    name: string;
    nPlus: number;
    nMinus: number;
    modelName: string;
    model: ParsedDiodeModel | null;
    vdPrev: number;
};
type ParsedSwitch = {
    name: string;
    n1: number;
    n2: number;
    ncPos: number;
    ncNeg: number;
    modelName: string;
    model: ParsedVSwitchModel | null;
    isOn: boolean;
};
type ParsedACAnalysis = {
    mode: "dec" | "lin";
    N: number;
    f1: number;
    f2: number;
} | null;
type ParsedTranAnalysis = {
    dt: number;
    tstop: number;
} | null;
type ParsedCircuit = {
    nodes: CircuitNodeIndex;
    R: ParsedResistor[];
    C: ParsedCapacitor[];
    L: ParsedInductor[];
    V: ParsedVoltageSource[];
    S: ParsedSwitch[];
    D: ParsedDiode[];
    analyses: {
        ac: ParsedACAnalysis;
        tran: ParsedTranAnalysis;
    };
    probes: {
        tran: string[];
    };
    skipped: string[];
    models: {
        vswitch: Map<string, ParsedVSwitchModel>;
        diode: Map<string, ParsedDiodeModel>;
    };
};
type CircuitNodeIndex = NodeIndex;
declare function parseNetlist(text: string): ParsedCircuit;

declare function simulate(netlistText: string): {
    circuit: ParsedCircuit;
    ac: {
        freqs: number[];
        nodeVoltages: Record<string, Complex[]>;
        elementCurrents: Record<string, Complex[]>;
    } | null;
    tran: {
        times: number[];
        nodeVoltages: Record<string, number[]>;
        elementCurrents: Record<string, number[]>;
    } | null;
};

declare class Complex {
    re: number;
    im: number;
    constructor(re?: number, im?: number);
    static from(re: number, im?: number): Complex;
    static fromPolar(mag: number, deg?: number): Complex;
    clone(): Complex;
    add(b: Complex): Complex;
    sub(b: Complex): Complex;
    mul(b: Complex): Complex;
    div(b: Complex): Complex;
    inv(): Complex;
    abs(): number;
    phaseDeg(): number;
}

declare function simulateAC(ckt: ParsedCircuit): {
    freqs: number[];
    nodeVoltages: Record<string, Complex[]>;
    elementCurrents: Record<string, Complex[]>;
} | null;

declare function simulateTRAN(ckt: ParsedCircuit): {
    times: number[];
    nodeVoltages: Record<string, number[]>;
    elementCurrents: Record<string, number[]>;
} | null;

declare function formatAcResult(ac: {
    freqs: number[];
    nodeVoltages: Record<string, Complex[]>;
} | null): string;

declare function formatTranResult(tran: {
    times: number[];
    nodeVoltages: Record<string, number[]>;
} | null): string;

type EecEngineTranResult = {
    time_s: number[];
    voltages: Record<string, number[]>;
};
declare function spiceyTranToVGraphs(tranResult: ReturnType<typeof simulateTRAN>, ckt: ParsedCircuit, simulation_experiment_id: string): SimulationTransientVoltageGraph[];
declare function eecEngineTranToVGraphs(tranResult: EecEngineTranResult, ckt: ParsedCircuit, // for dt/tstop
simulation_experiment_id: string): SimulationTransientVoltageGraph[];

export { Complex, type EecEngineTranResult, eecEngineTranToVGraphs, formatAcResult, formatTranResult, parseNetlist, simulate, simulateAC, simulateTRAN, spiceyTranToVGraphs };
