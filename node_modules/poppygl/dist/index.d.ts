import { mat4 } from 'gl-matrix';

type RGBA = readonly [number, number, number, number];
type MutableRGBA = [number, number, number, number];
interface BitmapLike {
    width: number;
    height: number;
    data: Uint8Array | Uint8ClampedArray;
}
type ImageFactory = (width: number, height: number) => BitmapLike;
declare const createUint8Bitmap: ImageFactory;

interface Material {
    baseColorFactor: [number, number, number, number];
    baseColorTexture: BitmapLike | null;
    alphaMode?: "OPAQUE" | "MASK" | "BLEND";
    alphaCutoff?: number;
}
interface DrawCall {
    positions: Float32Array;
    normals: Float32Array | null;
    uvs: Float32Array | null;
    indices: Uint32Array | null;
    model: mat4;
    material: Material;
    colors?: Float32Array | null;
    mode?: number;
}
interface GridOptions {
    size?: number | readonly [number, number, number];
    divisions?: number;
    color?: readonly [number, number, number];
    offset?: Partial<{
        x: number;
        y: number;
        z: number;
    }>;
    infiniteGrid?: boolean;
    cellSize?: number;
    sectionSize?: number;
    fadeDistance?: number;
    fadeStrength?: number;
    gridColor?: readonly [number, number, number];
    sectionColor?: readonly [number, number, number];
}
interface GLTFResources {
    buffers: Uint8Array[];
    images: BitmapLike[];
}
interface GLTFScene {
    drawCalls: DrawCall[];
    gltf: any;
}

declare const DEFAULT_LIGHT_DIR: readonly [-0.4, -0.9, -0.2];
interface RenderOptions {
    width: number;
    height: number;
    fov: number;
    cull: boolean;
    gamma: boolean;
    ambient: number;
    lightDir: readonly [number, number, number];
    camPos?: readonly [number, number, number] | null;
    lookAt?: readonly [number, number, number] | null;
    backgroundColor?: readonly [number, number, number] | null;
    grid?: boolean | GridOptions;
}
type RenderOptionsInput = Partial<RenderOptions>;
declare const DEFAULT_RENDER_OPTIONS: RenderOptions;
declare function getDefaultRenderOptions(): RenderOptions;

interface Camera {
    view: mat4;
    proj: mat4;
}
declare function buildCamera(drawCalls: DrawCall[], width: number, height: number, fovDeg: number, camPos: readonly [number, number, number] | null | undefined, lookAt: readonly [number, number, number] | null | undefined): Camera;

interface RenderResult {
    bitmap: BitmapLike;
    camera: Camera;
    options: RenderOptions;
}
declare function renderDrawCalls(drawCalls: DrawCall[], optionsInput?: RenderOptionsInput, imageFactory?: ImageFactory): RenderResult;

declare function resolveRenderOptions(options?: RenderOptionsInput): RenderOptions;

declare function createGrid(options?: GridOptions): DrawCall;

/**
 * Creates an infinite grid that matches the appearance of the 3d-viewer reference.
 * This grid uses a special rendering approach with procedural generation and fading.
 */
declare function createInfiniteGrid(options?: GridOptions): DrawCall & {
    isInfiniteGrid: boolean;
    cellSize: number;
    sectionSize: number;
    fadeDistance: number;
    fadeStrength: number;
    gridColor: readonly [number, number, number];
    sectionColor: readonly [number, number, number];
};

type GLTF = any;
declare function createSceneFromGLTF(gltf: GLTF, resources: GLTFResources): GLTFScene;

declare function computeSmoothNormals(positions: Float32Array, indices: Uint32Array | null): Float32Array;

declare function computeWorldAABB(drawCalls: DrawCall[]): {
    min: number[];
    max: number[];
};

interface FetchLikeResponse {
    ok: boolean;
    status: number;
    statusText: string;
    url?: string;
    arrayBuffer(): Promise<ArrayBuffer>;
}
type FetchLike = (input: string, init?: Record<string, unknown>) => Promise<FetchLikeResponse>;
interface LoadGLTFWithResourcesFromURLOptions {
    fetchImpl?: FetchLike;
}
declare function loadGLTFWithResourcesFromURL(url: string, options?: LoadGLTFWithResourcesFromURLOptions): Promise<{
    gltf: any;
    resources: GLTFResources;
}>;

declare function bufferFromDataURI(uri: string): Uint8Array;
declare function isPNG(filenameOrUri: string): boolean;
declare function isJPG(filenameOrUri: string): boolean;
declare function decodeImageFromBuffer(buf: Uint8Array, mimeType?: string | null): Promise<BitmapLike>;

interface LightSettings {
    dir: readonly [number, number, number];
    ambient: number;
}
declare class SoftwareRenderer {
    readonly width: number;
    readonly height: number;
    readonly bitmap: BitmapLike;
    readonly depth: Float32Array;
    constructor(width: number, height: number, imageFactory?: ImageFactory);
    get buffer(): Uint8Array<ArrayBufferLike> | Uint8ClampedArray<ArrayBufferLike>;
    clear(colorRGBA?: [number, number, number, number]): void;
    setPixel(x: number, y: number, r: number, g: number, b: number, a: number): void;
    drawLines(mesh: DrawCall, camera: Camera, gammaOut?: boolean): void;
    sampleTextureNearest(img: BitmapLike | null, u: number, v: number): MutableRGBA;
    perspInterp(attrs: number[][], invWs: number[], lambdas: number[]): number[];
    drawMesh(mesh: DrawCall, camera: Camera, light: LightSettings, material: Material, cullBackFaces?: boolean, gammaOut?: boolean): void;
}

/**
 * Draws an infinite grid with fade-out effect matching 3d-viewer appearance
 */
declare function drawInfiniteGrid(software_renderer: SoftwareRenderer, params: {
    camera: Camera;
    grid_y?: number;
    cell_size?: number;
    section_size?: number;
    fade_distance?: number;
    fade_strength?: number;
    grid_color?: readonly [number, number, number];
    section_color?: readonly [number, number, number];
    gamma_out?: boolean;
}): void;

declare const pureImageFactory: ImageFactory;

declare function encodePNGToBuffer(image: BitmapLike): Promise<Buffer>;

interface RenderGLTFToPNGBufferFromURLOptions extends RenderOptionsInput, LoadGLTFWithResourcesFromURLOptions {
}
declare function renderGLTFToPNGBufferFromURL(url: string, options?: RenderGLTFToPNGBufferFromURLOptions): Promise<Buffer>;

type RenderGLTFToPNGBufferFromGLBBufferOptions = RenderOptionsInput;
declare function renderGLTFToPNGBufferFromGLBBuffer(glb: ArrayBuffer | Uint8Array, options?: RenderGLTFToPNGBufferFromGLBBufferOptions): Promise<Buffer>;

declare function renderGLTFToPNGBuffer(gltfPathOrString: string, options?: RenderOptionsInput): Promise<Buffer>;

declare function renderSceneFromGLTF(scene: GLTFScene, options?: RenderOptionsInput, imageFactory?: ImageFactory): RenderResult;

export { type BitmapLike, type Camera, DEFAULT_LIGHT_DIR, DEFAULT_RENDER_OPTIONS, type DrawCall, type FetchLike, type GLTFResources, type GLTFScene, type GridOptions, type ImageFactory, type LightSettings, type LoadGLTFWithResourcesFromURLOptions, type Material, type MutableRGBA, type RGBA, type RenderGLTFToPNGBufferFromGLBBufferOptions, type RenderGLTFToPNGBufferFromURLOptions, type RenderOptions, type RenderOptionsInput, type RenderResult, SoftwareRenderer, bufferFromDataURI, buildCamera, computeSmoothNormals, computeWorldAABB, createGrid, createInfiniteGrid, createSceneFromGLTF, createUint8Bitmap, decodeImageFromBuffer, drawInfiniteGrid, encodePNGToBuffer, getDefaultRenderOptions, isJPG, isPNG, loadGLTFWithResourcesFromURL, pureImageFactory, renderDrawCalls, renderGLTFToPNGBuffer, renderGLTFToPNGBufferFromGLBBuffer, renderGLTFToPNGBufferFromURL, renderSceneFromGLTF, resolveRenderOptions };
