// lib/colors.ts
var COLORS = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20
].map((i) => `hsl(${i * 360 / 21}deg, 100%, 50%)`);
var stringHash = (str) => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
  }
  return hash;
};
var getColor = (str) => {
  return COLORS[Math.abs(stringHash(str)) % COLORS.length];
};

// lib/CssGrid/CssGrid_convertToHtml.ts
var CssGrid_convertToHtml = (grid) => {
  const stringifyTemplate = (tpl) => !tpl ? void 0 : typeof tpl === "string" ? tpl : tpl.join(" ");
  const s = ["display:grid", "background-color:gray"];
  const {
    gridTemplateRows,
    gridTemplateColumns,
    gap,
    justifyItems,
    alignItems,
    containerWidth,
    containerHeight
  } = grid.opts;
  const tRows = stringifyTemplate(gridTemplateRows);
  if (tRows) s.push(`grid-template-rows:${tRows}`);
  const tCols = stringifyTemplate(gridTemplateColumns);
  if (tCols) s.push(`grid-template-columns:${tCols}`);
  if (gap !== void 0) {
    if (typeof gap === "number") {
      s.push(`gap:${gap}px`);
    } else {
      const [rowGap, colGap] = gap;
      s.push(`row-gap:${rowGap}px`, `column-gap:${colGap}px`);
    }
  }
  if (justifyItems) s.push(`justify-items:${justifyItems}`);
  if (alignItems) s.push(`align-items:${alignItems}`);
  if (containerWidth != null) s.push(`width:${containerWidth}px`);
  if (containerHeight != null) s.push(`height:${containerHeight}px`);
  const containerStyle = s.join(";");
  const childDivs = grid.opts.children.map((c) => {
    const cs = ["display:flex", `background-color:${getColor(c.key)}`];
    if (c.area) {
      cs.push(`grid-area:${c.area}`);
    } else {
      if (typeof c.row === "string" && c.row.includes("/")) {
        cs.push(`grid-row:${c.row}`);
      } else {
        const start = c.rowStart ?? c.row;
        const end = c.rowEnd;
        const span = c.rowSpan;
        if (start !== void 0 || end !== void 0) {
          if (start !== void 0 && end !== void 0) {
            cs.push(`grid-row:${start} / ${end}`);
          } else if (start !== void 0) {
            span !== void 0 ? cs.push(`grid-row:${start} / span ${span}`) : cs.push(`grid-row-start:${start}`);
          } else {
            cs.push(`grid-row-end:${end}`);
          }
        } else if (span !== void 0) {
          cs.push(`grid-row:auto / span ${span}`);
        }
      }
      if (typeof c.column === "string" && c.column.includes("/")) {
        cs.push(`grid-column:${c.column}`);
      } else {
        const start = c.columnStart ?? c.column;
        const end = c.columnEnd;
        const span = c.columnSpan;
        if (start !== void 0 || end !== void 0) {
          if (start !== void 0 && end !== void 0) {
            cs.push(`grid-column:${start} / ${end}`);
          } else if (start !== void 0) {
            span !== void 0 ? cs.push(`grid-column:${start} / span ${span}`) : cs.push(`grid-column-start:${start}`);
          } else {
            cs.push(`grid-column-end:${end}`);
          }
        } else if (span !== void 0) {
          cs.push(`grid-column:auto / span ${span}`);
        }
      }
    }
    const childStyle = cs.join(";");
    const innerStyles = ["font-size: 7px"];
    if (c.contentWidth !== void 0) {
      const width = typeof c.contentWidth === "string" ? c.contentWidth : `${c.contentWidth}px`;
      innerStyles.push(`width:${width}`);
    } else {
      innerStyles.push(`width:${c.key.length * 5}px`);
    }
    if (c.contentHeight !== void 0) {
      const height = typeof c.contentHeight === "string" ? c.contentHeight : `${c.contentHeight}px`;
      innerStyles.push(`height:${height}`);
    }
    const innerStyle = innerStyles.join(";");
    return `  <div id="${c.key}" style="${childStyle}"><div style="${innerStyle}">${c.key}</div></div>`;
  });
  return `<div style="${containerStyle}">
${childDivs.join("\n")}
</div>`;
};

// lib/CssGrid/CssGrid_visualize.ts
var CssGrid_visualize = (grid) => {
  const layout = grid.layout();
  const go = {
    title: "CssGrid",
    coordinateSystem: "screen",
    lines: [],
    circles: [],
    points: [],
    rects: [],
    texts: []
  };
  const { cells } = layout;
  for (const cell of cells) {
    const { x, y, width, height, key } = cell;
    go.rects.push({
      center: { x: x + width / 2, y: y + height / 2 },
      width,
      height,
      fill: getColor(key),
      label: key
    });
  }
  return go;
};

// lib/CssGrid/CssGrid_layout.ts
function expandRepeat(templateStr) {
  return templateStr.replace(
    /repeat\((\d+),\s*([^)]+)\)/g,
    (_, count, val) => Array(Number(count)).fill(val.trim()).join(" ")
  );
}
function tokenize(templateStr) {
  return templateStr.trim().split(/\s+/).filter(Boolean);
}
function countTracks(tpl) {
  if (!tpl) return 0;
  return tokenize(expandRepeat(tpl)).length;
}
function pxFromToken(token, containerSize) {
  if (token === "auto") {
    return { fr: 1 };
  }
  if (token.endsWith("%")) {
    const n2 = parseFloat(token);
    return containerSize != null ? containerSize * n2 / 100 : 0;
  }
  if (token.endsWith("px")) {
    return parseFloat(token);
  }
  if (token.endsWith("em")) {
    return parseFloat(token) * 16;
  }
  if (token.endsWith("fr")) {
    return { fr: parseFloat(token) };
  }
  const n = parseFloat(token);
  if (!Number.isNaN(n)) return n;
  return 0;
}
function resolveNegativeLine(idx, trackCnt) {
  return idx > 0 ? idx : trackCnt + 2 + idx;
}
var CssGrid_layout = (grid) => {
  const opts = grid.opts;
  const children = opts.children;
  let rowsTpl;
  let colsTpl;
  if ("gridTemplate" in opts && typeof opts.gridTemplate === "string") {
    const [rows, cols] = opts.gridTemplate.split("/");
    rowsTpl = rows?.trim();
    colsTpl = cols?.trim();
  } else {
    rowsTpl = typeof opts.gridTemplateRows === "string" ? opts.gridTemplateRows : void 0;
    colsTpl = typeof opts.gridTemplateColumns === "string" ? opts.gridTemplateColumns : void 0;
  }
  const columnTrackCountDeclared = countTracks(colsTpl);
  const rowTrackCountDeclared = countTracks(rowsTpl);
  function calculateMinimumContainerSize(tpl, children2, isWidth, gap) {
    if (!tpl) return 0;
    const expanded = expandRepeat(tpl);
    const tokens = tokenize(expanded);
    const trackCount = tokens.length;
    let minContentSize = 0;
    let hasFlexibleTracks = false;
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token.endsWith("px")) {
        minContentSize += parseFloat(token);
      } else if (token.endsWith("em")) {
        minContentSize += parseFloat(token) * 16;
      } else if (token.endsWith("fr") || token === "auto") {
        hasFlexibleTracks = true;
        let maxContentInTrack = 0;
        for (const child of children2) {
          const childStart = isWidth ? child.columnStart || child.column : child.rowStart || child.row;
          const childSpan = isWidth ? child.columnSpan || 1 : child.rowSpan || 1;
          const contentSize = isWidth ? child.contentWidth : child.contentHeight;
          const startIdx = (typeof childStart === "number" ? childStart : parseInt(childStart || "1")) - 1;
          const span = typeof childSpan === "number" ? childSpan : parseInt(childSpan.toString());
          if (startIdx <= i && i < startIdx + span) {
            if (contentSize) {
              const size = typeof contentSize === "string" && contentSize.endsWith("px") ? parseFloat(contentSize) : typeof contentSize === "number" ? contentSize : 0;
              maxContentInTrack = Math.max(maxContentInTrack, size / span);
            }
          }
        }
        minContentSize += maxContentInTrack;
      }
    }
    const totalGaps = gap * (trackCount - 1);
    return minContentSize + totalGaps;
  }
  function buildTrackSizes(tpl, containerSize, gap, isWidth = true, crossTrackCount = 1) {
    if (!tpl) return [];
    if (containerSize == null) {
      const expanded2 = expandRepeat(tpl);
      const tokens2 = tokenize(expanded2);
      const trackCnt = tokens2.length;
      const toPx = (v) => {
        if (v === void 0) return 0;
        if (typeof v === "number") return v;
        if (v.endsWith("px")) return parseFloat(v);
        return parseFloat(v);
      };
      const sizes2 = new Array(trackCnt).fill(0);
      let autoCursor = 0;
      for (const child of children) {
        const span = isWidth ? typeof child.columnSpan === "number" ? child.columnSpan : child.columnSpan ? parseInt(child.columnSpan.toString()) : 1 : typeof child.rowSpan === "number" ? child.rowSpan : child.rowSpan ? parseInt(child.rowSpan.toString()) : 1;
        const rawSize = isWidth ? child.contentWidth : child.contentHeight;
        const sizePerTrack = toPx(rawSize) / span;
        let startIdx;
        if (isWidth) {
          if (child.columnStart !== void 0 || child.column !== void 0) {
            startIdx = parseInt(child.columnStart ?? child.column) - 1;
          }
        } else {
          if (child.rowStart !== void 0 || child.row !== void 0) {
            startIdx = parseInt(child.rowStart ?? child.row) - 1;
          }
        }
        if (startIdx === void 0 || Number.isNaN(startIdx)) {
          if (isWidth) {
            startIdx = autoCursor % trackCnt;
          } else {
            startIdx = Math.floor(autoCursor / crossTrackCount);
          }
          autoCursor += span;
        }
        for (let i = 0; i < span && startIdx + i < trackCnt; i++) {
          sizes2[startIdx + i] = Math.max(sizes2[startIdx + i], sizePerTrack);
        }
      }
      tokens2.forEach((tok, idx) => {
        const px = pxFromToken(tok, void 0);
        if (typeof px === "number") sizes2[idx] = px;
      });
      return sizes2;
    }
    const expanded = expandRepeat(tpl);
    const tokens = tokenize(expanded);
    const trackCount = tokens.length;
    let effectiveContainerSize = containerSize;
    if (effectiveContainerSize == null) {
      effectiveContainerSize = calculateMinimumContainerSize(
        tpl,
        children,
        isWidth,
        gap
      );
    }
    const sizeForTracks = effectiveContainerSize - gap * (trackCount - 1);
    let sumFixed = 0;
    let totalFr = 0;
    const frTokens = [];
    const sizes = [];
    tokens.forEach((token, i) => {
      const px = pxFromToken(token, sizeForTracks);
      if (typeof px === "number") {
        sizes.push(px);
        sumFixed += px;
      } else if (px && typeof px === "object" && "fr" in px) {
        sizes.push(px);
        totalFr += px.fr;
        frTokens.push({ idx: i, fr: px.fr });
      } else {
        sizes.push(0);
        sumFixed += 0;
      }
    });
    const free = Math.max(sizeForTracks - sumFixed, 0);
    return sizes.map(
      (v) => typeof v === "number" ? v : totalFr > 0 ? free / totalFr * v.fr : 0
    );
  }
  const rowGap = typeof opts.gap === "number" ? opts.gap : Array.isArray(opts.gap) ? opts.gap[0] : 0;
  const columnGap = typeof opts.gap === "number" ? opts.gap : Array.isArray(opts.gap) ? opts.gap[1] : 0;
  const rowSizes = buildTrackSizes(
    rowsTpl,
    opts.containerHeight,
    rowGap,
    /* isWidth = */
    false,
    /* cross-axis = */
    columnTrackCountDeclared || 1
  );
  const columnSizes = buildTrackSizes(
    colsTpl,
    opts.containerWidth,
    columnGap,
    /* isWidth = */
    true,
    /* cross-axis = */
    rowTrackCountDeclared || 1
  );
  const rowCount = rowSizes.length;
  let colCount = columnSizes.length;
  if (colCount === 0 && children.length > 0) {
    colCount = 1;
  }
  const cells = [];
  let nextAutoCell = 0;
  for (const child of children) {
    let rowStart = child.rowStart !== void 0 ? child.rowStart : child.row;
    let colStart = child.columnStart !== void 0 ? child.columnStart : child.column;
    let rowSpan = child.rowSpan !== void 0 ? typeof child.rowSpan === "string" ? parseInt(child.rowSpan) : child.rowSpan : 1;
    let colSpan = child.columnSpan !== void 0 ? typeof child.columnSpan === "string" ? parseInt(child.columnSpan) : child.columnSpan : 1;
    if (child.rowEnd !== void 0) {
      const end = typeof child.rowEnd === "string" ? parseInt(child.rowEnd) : child.rowEnd;
      if (rowStart !== void 0) {
        rowSpan = end - (typeof rowStart === "string" ? parseInt(rowStart) : rowStart);
      } else {
        rowStart = end - rowSpan;
      }
    }
    if (child.columnEnd !== void 0) {
      const end = typeof child.columnEnd === "string" ? parseInt(child.columnEnd) : child.columnEnd;
      if (colStart !== void 0) {
        colSpan = end - (typeof colStart === "string" ? parseInt(colStart) : colStart);
      } else {
        colStart = end - colSpan;
      }
    }
    if (typeof rowStart === "string") rowStart = parseInt(rowStart);
    if (typeof colStart === "string") colStart = parseInt(colStart);
    if (typeof rowStart === "number" && rowStart < 0)
      rowStart = resolveNegativeLine(rowStart, rowCount);
    if (typeof colStart === "number" && colStart < 0)
      colStart = resolveNegativeLine(colStart, colCount);
    if (rowStart === void 0 && colStart !== void 0) {
      rowStart = 1;
    } else if (colStart === void 0 && rowStart !== void 0) {
      colStart = 1;
    } else if (rowStart === void 0 && colStart === void 0) {
      const idx = nextAutoCell;
      rowStart = Math.floor(idx / colCount) + 1;
      colStart = idx % colCount + 1;
    }
    const row = rowStart - 1;
    const column = colStart - 1;
    rowSpan = Math.max(1, rowSpan);
    colSpan = Math.max(1, colSpan);
    cells.push({
      key: child.key,
      row,
      column,
      rowSpan,
      columnSpan: colSpan,
      x: 0,
      // Will be calculated below
      y: 0,
      // Will be calculated below
      width: 0,
      // Will be calculated below
      height: 0
      // Will be calculated below
    });
    nextAutoCell += colSpan;
  }
  let maxRow = rowSizes.length;
  let maxCol = columnSizes.length;
  for (const cell of cells) {
    if (cell.row + cell.rowSpan > maxRow) maxRow = cell.row + cell.rowSpan;
    if (cell.column + cell.columnSpan > maxCol)
      maxCol = cell.column + cell.columnSpan;
  }
  if (rowSizes.length === 0 && maxRow > 0 && opts.containerHeight) {
    const implicitRowCount = maxRow;
    const availableHeight = opts.containerHeight - rowGap * (implicitRowCount - 1);
    const implicitRowHeight = availableHeight / implicitRowCount;
    for (let i = 0; i < implicitRowCount; i++) {
      rowSizes.push(implicitRowHeight);
    }
  } else {
    while (rowSizes.length < maxRow) rowSizes.push(0);
  }
  if (columnSizes.length === 0 && maxCol > 0 && opts.containerWidth) {
    const implicitColCount = maxCol;
    const availableWidth = opts.containerWidth - columnGap * (implicitColCount - 1);
    const implicitColWidth = availableWidth / implicitColCount;
    for (let i = 0; i < implicitColCount; i++) {
      columnSizes.push(implicitColWidth);
    }
  } else if (columnSizes.length === 0 && children.length > 0 && opts.containerWidth) {
    columnSizes.push(opts.containerWidth);
  } else {
    while (columnSizes.length < maxCol) columnSizes.push(0);
  }
  const getPositionFromTracks = (trackIndex, trackSizes, gap) => {
    let position = 0;
    for (let i = 0; i < trackIndex; i++) {
      position += trackSizes[i] || 0;
      position += gap;
    }
    return position;
  };
  const getSizeFromSpan = (trackIndex, span, trackSizes, gap) => {
    let size = 0;
    for (let i = trackIndex; i < trackIndex + span; i++) {
      size += trackSizes[i] || 0;
      if (i > trackIndex) size += gap;
    }
    return size;
  };
  const itemCoordinates = {};
  for (const cell of cells) {
    const child = children.find((c) => c.key === cell.key);
    const cellX = getPositionFromTracks(cell.column, columnSizes, columnGap);
    const cellY = getPositionFromTracks(cell.row, rowSizes, rowGap);
    const cellWidth = getSizeFromSpan(
      cell.column,
      cell.columnSpan,
      columnSizes,
      columnGap
    );
    const cellHeight = getSizeFromSpan(cell.row, cell.rowSpan, rowSizes, rowGap);
    const getContentDimension = (value) => {
      if (value === void 0) return 0;
      if (typeof value === "string") {
        if (value.endsWith("px")) return parseFloat(value);
        if (value.endsWith("%")) return 0;
        return parseFloat(value);
      }
      return value;
    };
    const contentWidth = getContentDimension(child?.contentWidth);
    const contentHeight = getContentDimension(child?.contentHeight);
    let itemWidth = cellWidth;
    let itemHeight = cellHeight;
    let itemX = cellX;
    let itemY = cellY;
    if (contentWidth > 0) {
      itemWidth = contentWidth;
      const justifyItems = opts.justifyItems || "stretch";
      switch (justifyItems) {
        case "start":
          itemX = cellX;
          break;
        case "end":
          itemX = cellX + cellWidth - itemWidth;
          break;
        case "center":
          itemX = cellX + (cellWidth - itemWidth) / 2;
          break;
        case "stretch":
          itemWidth = cellWidth;
          itemX = cellX;
          break;
      }
    }
    if (contentHeight > 0) {
      itemHeight = contentHeight;
      const alignItems = opts.alignItems || "stretch";
      switch (alignItems) {
        case "start":
          itemY = cellY;
          break;
        case "end":
          itemY = cellY + cellHeight - itemHeight;
          break;
        case "center":
          itemY = cellY + (cellHeight - itemHeight) / 2;
          break;
        case "stretch":
          itemHeight = cellHeight;
          itemY = cellY;
          break;
      }
    }
    cell.x = itemX;
    cell.y = itemY;
    cell.width = itemWidth;
    cell.height = itemHeight;
    itemCoordinates[cell.key] = {
      x: itemX,
      y: itemY,
      width: itemWidth,
      height: itemHeight
    };
  }
  return {
    cells,
    rowSizes,
    columnSizes,
    rowGap,
    columnGap,
    itemCoordinates
  };
};

// lib/CssGrid/CssGrid.ts
var CssGrid = class {
  opts;
  constructor(opts) {
    this.opts = opts;
  }
  /** Returns the computed layout matrix, ready for rendering elsewhere */
  layout() {
    return CssGrid_layout(this);
  }
  convertToHtml() {
    return CssGrid_convertToHtml(this);
  }
  visualize() {
    return CssGrid_visualize(this);
  }
};
export {
  CssGrid
};
