// lib/math/rotatePoint.ts
var rotatePoint = (point, angle, origin = { x: 0, y: 0 }) => {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const dx = point.x - origin.x;
  const dy = point.y - origin.y;
  return {
    x: origin.x + dx * cos - dy * sin,
    y: origin.y + dx * sin + dy * cos
  };
};

// lib/PackSolver2/setPackedComponentPadCenters.ts
var setPackedComponentPadCenters = (packedComponent) => {
  packedComponent.pads = packedComponent.pads.map((pad) => {
    const rotated = rotatePoint(
      pad.offset,
      packedComponent.ccwRotationOffset * Math.PI / 180
    );
    const normalizedRotation = (packedComponent.ccwRotationOffset % 360 + 360) % 360;
    const shouldSwapDimensions = normalizedRotation === 90 || normalizedRotation === 270;
    return {
      ...pad,
      size: shouldSwapDimensions ? { x: pad.size.y, y: pad.size.x } : pad.size,
      // Keep original dimensions for 0°/180° rotations
      absoluteCenter: {
        x: packedComponent.center.x + rotated.x,
        y: packedComponent.center.y + rotated.y
      }
    };
  });
};

// lib/PackSolver2/sortComponentQueue.ts
function sortComponentQueue({
  components,
  packOrderStrategy,
  packFirst = []
}) {
  const packFirstMap = /* @__PURE__ */ new Map();
  packFirst.forEach((componentId, index) => {
    packFirstMap.set(componentId, index);
  });
  return [...components].sort((a, b) => {
    const aPackFirstIndex = packFirstMap.get(a.componentId);
    const bPackFirstIndex = packFirstMap.get(b.componentId);
    if (aPackFirstIndex !== void 0 && bPackFirstIndex !== void 0) {
      return aPackFirstIndex - bPackFirstIndex;
    }
    if (aPackFirstIndex !== void 0) return -1;
    if (bPackFirstIndex !== void 0) return 1;
    if (packOrderStrategy === "largest_to_smallest") {
      return b.pads.length - a.pads.length;
    }
    return a.pads.length - b.pads.length;
  });
}

// lib/constructOutlinesFromPackedComponents.ts
import Flatten from "@flatten-js/core";

// lib/math/cross.ts
var cross = (O, A, B) => (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);

// lib/geometry/simplify-collinear-segments.ts
function simplifyCollinearSegments(outline, tolerance = 1e-10) {
  if (outline.length <= 1) {
    return outline;
  }
  const simplified = [];
  let currentSegmentStart = outline[0][0];
  let currentSegmentEnd = outline[0][1];
  for (let i = 1; i < outline.length; i++) {
    const nextSegment = outline[i];
    const [nextStart, nextEnd] = nextSegment;
    const connectionTolerance = 1e-10;
    const isConnected = Math.abs(currentSegmentEnd.x - nextStart.x) < connectionTolerance && Math.abs(currentSegmentEnd.y - nextStart.y) < connectionTolerance;
    if (!isConnected) {
      simplified.push([currentSegmentStart, currentSegmentEnd]);
      currentSegmentStart = nextStart;
      currentSegmentEnd = nextEnd;
      continue;
    }
    const crossProduct = cross(currentSegmentStart, currentSegmentEnd, nextEnd);
    if (Math.abs(crossProduct) < tolerance) {
      currentSegmentEnd = nextEnd;
    } else {
      simplified.push([currentSegmentStart, currentSegmentEnd]);
      currentSegmentStart = nextStart;
      currentSegmentEnd = nextEnd;
    }
  }
  if (outline.length > 2) {
    const firstSegment = simplified[0];
    const lastSegmentCandidate = [
      currentSegmentStart,
      currentSegmentEnd
    ];
    if (firstSegment && simplified.length > 0) {
      const connectionTolerance = 1e-10;
      const isLastConnectedToFirst = Math.abs(currentSegmentEnd.x - firstSegment[0].x) < connectionTolerance && Math.abs(currentSegmentEnd.y - firstSegment[0].y) < connectionTolerance;
      if (isLastConnectedToFirst) {
        const crossProduct = cross(
          currentSegmentStart,
          currentSegmentEnd,
          firstSegment[1]
        );
        if (Math.abs(crossProduct) < tolerance) {
          simplified[0] = [currentSegmentStart, firstSegment[1]];
        } else {
          simplified.push(lastSegmentCandidate);
        }
      } else {
        simplified.push(lastSegmentCandidate);
      }
    } else {
      simplified.push(lastSegmentCandidate);
    }
  } else {
    simplified.push([currentSegmentStart, currentSegmentEnd]);
  }
  return simplified;
}

// lib/geometry/getComponentBounds.ts
var getComponentBounds = (component, minGap = 0) => {
  const bounds = {
    minX: Infinity,
    maxX: -Infinity,
    minY: Infinity,
    maxY: -Infinity
  };
  component.pads.forEach((pad) => {
    const hw = pad.size.x / 2;
    const hh = pad.size.y / 2;
    const localCorners = [
      { x: pad.offset.x - hw, y: pad.offset.y - hh },
      { x: pad.offset.x + hw, y: pad.offset.y - hh },
      { x: pad.offset.x + hw, y: pad.offset.y + hh },
      { x: pad.offset.x - hw, y: pad.offset.y + hh }
    ];
    localCorners.forEach((corner) => {
      const world = rotatePoint(
        corner,
        component.ccwRotationOffset * Math.PI / 180
      );
      const x = world.x + component.center.x;
      const y = world.y + component.center.y;
      bounds.minX = Math.min(bounds.minX, x);
      bounds.maxX = Math.max(bounds.maxX, x);
      bounds.minY = Math.min(bounds.minY, y);
      bounds.maxY = Math.max(bounds.maxY, y);
    });
  });
  return {
    minX: bounds.minX - minGap,
    maxX: bounds.maxX + minGap,
    minY: bounds.minY - minGap,
    maxY: bounds.maxY + minGap
  };
};

// lib/geometry/combineBounds.ts
var combineBounds = (bounds) => {
  const minX = Math.min(...bounds.map((b) => b.minX));
  const minY = Math.min(...bounds.map((b) => b.minY));
  const maxX = Math.max(...bounds.map((b) => b.maxX));
  const maxY = Math.max(...bounds.map((b) => b.maxY));
  return { minX, minY, maxX, maxY };
};

// lib/constructOutlinesFromPackedComponents.ts
var createPadPolygons = (component, minGap) => {
  return component.pads.map((pad) => {
    const hw = pad.size.x / 2 + minGap;
    const hh = pad.size.y / 2 + minGap;
    const localCorners = [
      { x: pad.offset.x - hw, y: pad.offset.y - hh },
      { x: pad.offset.x + hw, y: pad.offset.y - hh },
      { x: pad.offset.x + hw, y: pad.offset.y + hh },
      { x: pad.offset.x - hw, y: pad.offset.y + hh }
    ];
    const worldCorners = localCorners.map((corner) => {
      const rotated = rotatePoint(
        corner,
        component.ccwRotationOffset * Math.PI / 180
      );
      return {
        x: rotated.x + component.center.x,
        y: rotated.y + component.center.y
      };
    });
    const arr = worldCorners.map(({ x, y }) => [x, y]);
    const poly = new Flatten.Polygon(arr);
    const xs = worldCorners.map((p) => p.x);
    const ys = worldCorners.map((p) => p.y);
    const bbox = {
      minX: Math.min(...xs),
      minY: Math.min(...ys),
      maxX: Math.max(...xs),
      maxY: Math.max(...ys)
    };
    return { poly, bbox };
  });
};
var createObstaclePolygons = (obstacles, minGap) => {
  return obstacles.map((obs) => {
    const hw = obs.width / 2 + minGap;
    const hh = obs.height / 2 + minGap;
    const cx = obs.absoluteCenter.x;
    const cy = obs.absoluteCenter.y;
    const worldCorners = [
      { x: cx - hw, y: cy - hh },
      { x: cx + hw, y: cy - hh },
      { x: cx + hw, y: cy + hh },
      { x: cx - hw, y: cy + hh }
    ];
    const arr = worldCorners.map(({ x, y }) => [x, y]);
    const poly = new Flatten.Polygon(arr);
    const xs = worldCorners.map((p) => p.x);
    const ys = worldCorners.map((p) => p.y);
    const bbox = {
      minX: Math.min(...xs),
      minY: Math.min(...ys),
      maxX: Math.max(...xs),
      maxY: Math.max(...ys)
    };
    return { poly, bbox };
  });
};
var constructOutlinesFromPackedComponents = (components, opts = {}) => {
  const { minGap = 0, obstacles = [] } = opts;
  if (components.length === 0 && obstacles.length === 0) return [];
  const componentBounds = components.map((c) => getComponentBounds(c, minGap));
  const obstacleBounds = obstacles.map((o) => ({
    minX: o.absoluteCenter.x - o.width / 2 - minGap,
    minY: o.absoluteCenter.y - o.height / 2 - minGap,
    maxX: o.absoluteCenter.x + o.width / 2 + minGap,
    maxY: o.absoluteCenter.y + o.height / 2 + minGap
  }));
  const bounds = combineBounds([...componentBounds, ...obstacleBounds]);
  const allPadShapes = [];
  for (const component of components) {
    const padShapes = createPadPolygons(component, minGap);
    allPadShapes.push(...padShapes);
  }
  const obstacleShapes = createObstaclePolygons(obstacles, minGap);
  allPadShapes.push(...obstacleShapes);
  if (allPadShapes.length === 0) return [];
  const areaOfBox = (b) => Math.max(0, b.maxX - b.minX) * Math.max(0, b.maxY - b.minY);
  const containsBox = (outer, inner, eps = 1e-9) => outer.minX - eps <= inner.minX && outer.minY - eps <= inner.minY && outer.maxX + eps >= inner.maxX && outer.maxY + eps >= inner.maxY;
  const sortedByAreaDesc = [...allPadShapes].sort(
    (a, b) => areaOfBox(b.bbox) - areaOfBox(a.bbox)
  );
  const filteredPadShapes = [];
  for (const shape of sortedByAreaDesc) {
    const w = shape.bbox.maxX - shape.bbox.minX;
    const h = shape.bbox.maxY - shape.bbox.minY;
    if (!(w > 1e-12 && h > 1e-12)) continue;
    let contained = false;
    for (const kept of filteredPadShapes) {
      if (containsBox(kept.bbox, shape.bbox)) {
        contained = true;
        break;
      }
    }
    if (!contained) filteredPadShapes.push(shape);
  }
  const keptPadPolys = filteredPadShapes.map((s) => s.poly);
  let A = new Flatten.Polygon(
    new Flatten.Box(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY)
  );
  const B = A.clone();
  for (let i = 0; i < keptPadPolys.length; i++) {
    try {
      A = Flatten.BooleanOperations.subtract(A, keptPadPolys[i]);
    } catch (e) {
    }
  }
  let union = null;
  try {
    union = Flatten.BooleanOperations.subtract(B, A);
  } catch (e) {
    try {
      if (keptPadPolys.length > 0) {
        let U = keptPadPolys[0];
        for (let i = 1; i < keptPadPolys.length; i++) {
          try {
            U = Flatten.BooleanOperations.unify(U, keptPadPolys[i]);
          } catch {
          }
        }
        union = U;
      }
    } catch {
      union = null;
    }
  }
  const outlines = [];
  for (const face of union.faces) {
    if (face.isHole) continue;
    const outline = [];
    let edge = face.first;
    if (!edge) continue;
    do {
      const shp = edge.shape;
      const ps = shp.start ?? shp.ps;
      const pe = shp.end ?? shp.pe;
      outline.push([
        { x: ps.x, y: ps.y },
        { x: pe.x, y: pe.y }
      ]);
      edge = edge.next;
    } while (edge !== face.first);
    const simplifiedOutline = simplifyCollinearSegments(outline);
    outlines.push(simplifiedOutline);
  }
  return outlines;
};

// lib/OutlineSegmentCandidatePointSolver/OutlineSegmentCandidatePointSolver.ts
import { clamp } from "@tscircuit/math-utils";

// lib/solver-utils/makeNumbersRounded.ts
var makeNumbersRounded = (obj) => {
  if (typeof obj === "number") {
    return Math.round(obj * 100) / 100;
  }
  if (typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => [
        key,
        makeNumbersRounded(value)
      ])
    );
  }
  return obj;
};

// lib/solver-utils/BaseSolver.ts
var BaseSolver = class {
  MAX_ITERATIONS = 1e5;
  solved = false;
  failed = false;
  iterations = 0;
  progress = 0;
  error = null;
  activeSubSolver;
  failedSubSolvers;
  timeToSolve;
  stats = {};
  _setupDone = false;
  setup() {
    if (this._setupDone) return;
    this._setup();
    this._setupDone = true;
  }
  /** DO NOT OVERRIDE! Override _step() instead */
  step() {
    if (!this._setupDone) {
      this.setup();
    }
    if (this.solved) return;
    if (this.failed) return;
    this.iterations++;
    try {
      this._step();
    } catch (e) {
      this.error = `${this.constructor.name} error: ${e}`;
      console.error(this.error);
      this.failed = true;
      throw e;
    }
    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {
      this.tryFinalAcceptance();
    }
    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {
      this.error = `${this.constructor.name} ran out of iterations`;
      console.error(this.error);
      this.failed = true;
    }
    if ("computeProgress" in this) {
      this.progress = this.computeProgress();
    }
  }
  _setup() {
  }
  _step() {
  }
  getConstructorParams() {
    throw new Error("getConstructorParams not implemented");
  }
  solve() {
    const startTime = Date.now();
    while (!this.solved && !this.failed) {
      this.step();
    }
    const endTime = Date.now();
    this.timeToSolve = endTime - startTime;
  }
  visualize() {
    return {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
  }
  /**
   * Called when the solver is about to fail, but we want to see if we have an
   * "acceptable" or "passable" solution. Mostly used for optimizers that
   * have an aggressive early stopping criterion.
   */
  tryFinalAcceptance() {
  }
  /**
   * A lightweight version of the visualize method that can be used to stream
   * progress
   */
  preview() {
    return {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
  }
  noisySolve() {
    const startTime = Date.now();
    while (!this.solved && !this.failed) {
      this.step();
      console.log(JSON.stringify(makeNumbersRounded(this.visualize())));
    }
    const endTime = Date.now();
    this.timeToSolve = endTime - startTime;
  }
};

// lib/solver-utils/MultiOffsetIrlsSolver.ts
var MultiOffsetIrlsSolver = class extends BaseSolver {
  offsetPadPoints;
  targetPointMap;
  currentPosition;
  constraintFn;
  epsilon;
  useSquaredDistance;
  optimalPosition;
  initialPosition;
  constructor(params) {
    super();
    this.offsetPadPoints = [...params.offsetPadPoints];
    this.targetPointMap = new Map(params.targetPointMap);
    this.initialPosition = { ...params.initialPosition };
    this.currentPosition = { ...params.initialPosition };
    this.constraintFn = params.constraintFn;
    this.epsilon = params.epsilon ?? 1e-6;
    this.useSquaredDistance = params.useSquaredDistance ?? false;
    this.MAX_ITERATIONS = params.maxIterations ?? 100;
  }
  getConstructorParams() {
    return {
      offsetPadPoints: this.offsetPadPoints.map((pad) => ({ ...pad })),
      targetPointMap: new Map(this.targetPointMap),
      initialPosition: this.initialPosition,
      constraintFn: this.constraintFn,
      epsilon: this.epsilon,
      useSquaredDistance: this.useSquaredDistance,
      maxIterations: this.MAX_ITERATIONS
    };
  }
  _setup() {
    this.currentPosition = { ...this.initialPosition };
    this.optimalPosition = void 0;
    const hasTargets = Array.from(this.targetPointMap.values()).some(
      (targets) => targets.length > 0
    );
    if (!hasTargets || this.offsetPadPoints.length === 0) {
      this.optimalPosition = { ...this.currentPosition };
      this.solved = true;
    }
  }
  _step() {
    if (this.offsetPadPoints.length === 0) return;
    const { x: currentX, y: currentY } = this.currentPosition;
    let weightedSumX = 0;
    let weightedSumY = 0;
    let totalWeight = 0;
    for (const pad of this.offsetPadPoints) {
      const targetPoints = this.targetPointMap.get(pad.id) || [];
      if (targetPoints.length === 0) continue;
      const padX = currentX + pad.offsetX;
      const padY = currentY + pad.offsetY;
      for (const targetPoint of targetPoints) {
        const dx2 = padX - targetPoint.x;
        const dy2 = padY - targetPoint.y;
        const distance = Math.sqrt(dx2 * dx2 + dy2 * dy2);
        let weight;
        if (this.useSquaredDistance) {
          weight = 1;
        } else {
          weight = distance < this.epsilon ? 1e6 : 1 / distance;
        }
        const targetForCurrentPos = {
          x: targetPoint.x - pad.offsetX,
          y: targetPoint.y - pad.offsetY
        };
        weightedSumX += weight * targetForCurrentPos.x;
        weightedSumY += weight * targetForCurrentPos.y;
        totalWeight += weight;
      }
    }
    const newPosition = {
      x: totalWeight > 0 ? weightedSumX / totalWeight : currentX,
      y: totalWeight > 0 ? weightedSumY / totalWeight : currentY
    };
    const constrainedPosition = this.constraintFn ? this.constraintFn(newPosition) : newPosition;
    const dx = constrainedPosition.x - currentX;
    const dy = constrainedPosition.y - currentY;
    const positionChange = Math.sqrt(dx * dx + dy * dy);
    if (positionChange < this.epsilon) {
      this.optimalPosition = { ...constrainedPosition };
      this.solved = true;
      return;
    }
    this.currentPosition = constrainedPosition;
  }
  /**
   * Get the current best position
   */
  getBestPosition() {
    return this.optimalPosition || this.currentPosition;
  }
  /**
   * Get the current absolute positions for all offset pad points
   */
  getOffsetPadPositions() {
    const currentPos = this.getBestPosition();
    const padPositions = /* @__PURE__ */ new Map();
    for (const pad of this.offsetPadPoints) {
      padPositions.set(pad.id, {
        x: currentPos.x + pad.offsetX,
        y: currentPos.y + pad.offsetY
      });
    }
    return padPositions;
  }
  /**
   * Get the absolute position for a specific offset pad point
   */
  getOffsetPadPosition(padId) {
    const positions = this.getOffsetPadPositions();
    return positions.get(padId);
  }
  /**
   * Calculate total distance from current position to all assigned target points
   */
  getTotalDistance(position) {
    const pos = position || this.getBestPosition();
    let totalDistance = 0;
    for (const pad of this.offsetPadPoints) {
      const padPosition = {
        x: pos.x + pad.offsetX,
        y: pos.y + pad.offsetY
      };
      const targetPoints = this.targetPointMap.get(pad.id) || [];
      for (const target of targetPoints) {
        const dx = padPosition.x - target.x;
        const dy = padPosition.y - target.y;
        if (this.useSquaredDistance) {
          totalDistance += dx * dx + dy * dy;
        } else {
          totalDistance += Math.sqrt(dx * dx + dy * dy);
        }
      }
    }
    return totalDistance;
  }
  /**
   * Calculate total distance for a specific offset pad point
   */
  getDistanceForPad(padId, position) {
    const pos = position || this.getBestPosition();
    const pad = this.offsetPadPoints.find((p) => p.id === padId);
    if (!pad) return 0;
    const padPosition = {
      x: pos.x + pad.offsetX,
      y: pos.y + pad.offsetY
    };
    const targetPoints = this.targetPointMap.get(padId) || [];
    return targetPoints.reduce((sum, target) => {
      const dx = padPosition.x - target.x;
      const dy = padPosition.y - target.y;
      if (this.useSquaredDistance) {
        return sum + (dx * dx + dy * dy);
      } else {
        return sum + Math.sqrt(dx * dx + dy * dy);
      }
    }, 0);
  }
  computeProgress() {
    if (this.offsetPadPoints.length === 0) return 1;
    const initialDistance = this.getTotalDistance(this.initialPosition);
    const currentDistance = this.getTotalDistance();
    if (initialDistance === 0) return 1;
    const improvement = Math.max(0, initialDistance - currentDistance);
    return Math.min(1, improvement / initialDistance);
  }
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    const colors = [
      "#4CAF50",
      "#2196F3",
      "#FF9800",
      "#9C27B0",
      "#F44336",
      "#607D8B"
    ];
    const currentPos = this.getBestPosition();
    for (let i = 0; i < this.offsetPadPoints.length; i++) {
      const pad = this.offsetPadPoints[i];
      if (!pad) continue;
      const color = colors[i % colors.length];
      const targetPoints = this.targetPointMap.get(pad.id) || [];
      const padPosition = {
        x: currentPos.x + pad.offsetX,
        y: currentPos.y + pad.offsetY
      };
      for (const point of targetPoints) {
        graphics.points.push({
          ...point,
          color
        });
      }
      for (const point of targetPoints) {
        graphics.lines.push({
          points: [padPosition, point],
          strokeColor: color
        });
      }
      graphics.points.push({
        x: padPosition.x,
        y: padPosition.y,
        color
      });
    }
    graphics.points.push({
      ...this.currentPosition,
      color: "#f44336"
      // Red like in IrlsSolver
    });
    if (this.optimalPosition) {
      graphics.points.push({
        ...this.optimalPosition,
        color: "rgba(76, 175, 80, 0.3)"
        // Semi-transparent green like in IrlsSolver
      });
    }
    return graphics;
  }
};

// lib/solver-utils/TwoPhaseIrlsSolver.ts
var TwoPhaseIrlsSolver = class extends BaseSolver {
  offsetPadPoints;
  targetPointMap;
  constraintFn;
  currentPosition;
  optimalPosition;
  initialPosition;
  phase1Epsilon;
  phase2Epsilon;
  maxIterations;
  phase1Solver;
  phase2Solver;
  currentPhase = 1;
  phase1Position;
  closestTargetPadId;
  closestTargetPoint;
  constructor(params) {
    super();
    this.offsetPadPoints = [...params.offsetPadPoints];
    this.targetPointMap = new Map(params.targetPointMap);
    this.initialPosition = { ...params.initialPosition };
    this.currentPosition = { ...params.initialPosition };
    this.constraintFn = params.constraintFn;
    this.phase1Epsilon = params.phase1Epsilon ?? params.epsilon ?? 1e-6;
    this.phase2Epsilon = params.phase2Epsilon ?? params.epsilon ?? 1e-6;
    this.maxIterations = params.maxIterations ?? 100;
  }
  getConstructorParams() {
    return {
      offsetPadPoints: this.offsetPadPoints.map((pad) => ({ ...pad })),
      targetPointMap: new Map(this.targetPointMap),
      initialPosition: this.initialPosition,
      constraintFn: this.constraintFn,
      phase1Epsilon: this.phase1Epsilon,
      phase2Epsilon: this.phase2Epsilon,
      maxIterations: this.maxIterations
    };
  }
  _setup() {
    this.currentPosition = { ...this.initialPosition };
    this.optimalPosition = void 0;
    this.currentPhase = 1;
    this.phase1Position = void 0;
    this.closestTargetPadId = void 0;
    this.closestTargetPoint = void 0;
    const hasTargets = Array.from(this.targetPointMap.values()).some(
      (targets) => targets.length > 0
    );
    if (!hasTargets || this.offsetPadPoints.length === 0) {
      this.optimalPosition = { ...this.currentPosition };
      this.solved = true;
      return;
    }
    this.phase1Solver = new MultiOffsetIrlsSolver({
      offsetPadPoints: this.offsetPadPoints,
      targetPointMap: this.targetPointMap,
      initialPosition: this.initialPosition,
      constraintFn: this.constraintFn,
      epsilon: this.phase1Epsilon,
      maxIterations: this.maxIterations,
      useSquaredDistance: true
      // Phase 1 uses squared distance
    });
    this.phase1Solver.setup();
  }
  _step() {
    if (this.currentPhase === 1) {
      this.stepPhase1();
    } else {
      this.stepPhase2();
    }
  }
  stepPhase1() {
    if (!this.phase1Solver) return;
    this.phase1Solver.step();
    this.currentPosition = this.phase1Solver.getBestPosition();
    if (this.phase1Solver.solved) {
      this.phase1Position = this.phase1Solver.getBestPosition();
      this.setupPhase2();
    } else if (this.phase1Solver.failed) {
      this.failed = true;
      this.error = `Phase 1 failed: ${this.phase1Solver.error}`;
    }
  }
  setupPhase2() {
    if (!this.phase1Position) return;
    let minDistance = Infinity;
    let closestPadId;
    let closestTarget;
    for (const pad of this.offsetPadPoints) {
      const targetPoints = this.targetPointMap.get(pad.id) || [];
      if (targetPoints.length === 0) continue;
      const padX = this.phase1Position.x + pad.offsetX;
      const padY = this.phase1Position.y + pad.offsetY;
      for (const targetPoint of targetPoints) {
        const dx = padX - targetPoint.x;
        const dy = padY - targetPoint.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < minDistance) {
          minDistance = distance;
          closestPadId = pad.id;
          closestTarget = targetPoint;
        }
      }
    }
    this.closestTargetPadId = closestPadId;
    this.closestTargetPoint = closestTarget;
    if (!closestPadId || !closestTarget) {
      this.optimalPosition = this.phase1Position;
      this.solved = true;
      return;
    }
    const phase2TargetMap = /* @__PURE__ */ new Map();
    phase2TargetMap.set(closestPadId, [closestTarget]);
    this.phase2Solver = new MultiOffsetIrlsSolver({
      offsetPadPoints: this.offsetPadPoints,
      targetPointMap: phase2TargetMap,
      initialPosition: this.phase1Position,
      constraintFn: this.constraintFn,
      epsilon: this.phase2Epsilon,
      maxIterations: this.maxIterations,
      useSquaredDistance: false
      // Phase 2 uses regular distance
    });
    this.phase2Solver.setup();
    this.currentPhase = 2;
  }
  stepPhase2() {
    if (!this.phase2Solver) return;
    this.phase2Solver.step();
    this.currentPosition = this.phase2Solver.getBestPosition();
    if (this.phase2Solver.solved) {
      this.optimalPosition = this.phase2Solver.getBestPosition();
      this.solved = true;
    } else if (this.phase2Solver.failed) {
      this.failed = true;
      this.error = `Phase 2 failed: ${this.phase2Solver.error}`;
    }
  }
  /**
   * Get the current best position
   */
  getBestPosition() {
    return this.optimalPosition || this.currentPosition;
  }
  /**
   * Get the current absolute positions for all offset pad points
   */
  getOffsetPadPositions() {
    const currentPos = this.getBestPosition();
    const padPositions = /* @__PURE__ */ new Map();
    for (const pad of this.offsetPadPoints) {
      padPositions.set(pad.id, {
        x: currentPos.x + pad.offsetX,
        y: currentPos.y + pad.offsetY
      });
    }
    return padPositions;
  }
  /**
   * Calculate total distance from current position to all assigned target points
   */
  getTotalDistance(position) {
    const pos = position || this.getBestPosition();
    let totalDistance = 0;
    for (const pad of this.offsetPadPoints) {
      const padPosition = {
        x: pos.x + pad.offsetX,
        y: pos.y + pad.offsetY
      };
      const targetPoints = this.targetPointMap.get(pad.id) || [];
      for (const target of targetPoints) {
        const dx = padPosition.x - target.x;
        const dy = padPosition.y - target.y;
        totalDistance += dx * dx + dy * dy;
      }
    }
    return totalDistance;
  }
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    graphics.points.push({
      ...this.currentPosition,
      color: this.currentPhase === 1 ? "#FF6B6B" : "#4ECDC4",
      label: `Phase ${this.currentPhase}`
    });
    if (this.phase1Position && this.currentPhase === 2) {
      graphics.points.push({
        ...this.phase1Position,
        color: "rgba(255, 107, 107, 0.5)",
        label: "Phase 1 result"
      });
    }
    if (this.closestTargetPoint && this.closestTargetPadId) {
      graphics.points.push({
        ...this.closestTargetPoint,
        color: "#FFA500",
        label: `Closest target (${this.closestTargetPadId})`
      });
      const closestPad = this.offsetPadPoints.find(
        (p) => p.id === this.closestTargetPadId
      );
      if (closestPad) {
        const currentPos = this.getBestPosition();
        const padPos = {
          x: currentPos.x + closestPad.offsetX,
          y: currentPos.y + closestPad.offsetY
        };
        graphics.lines.push({
          points: [padPos, this.closestTargetPoint],
          strokeColor: "#FFA500"
        });
      }
    }
    const activeSolver = this.currentPhase === 1 ? this.phase1Solver : this.phase2Solver;
    if (activeSolver) {
      const solverViz = activeSolver.visualize();
      const phaseColor = this.currentPhase === 1 ? "rgba(255, 107, 107, 0.7)" : "rgba(76, 205, 196, 0.7)";
      if (solverViz.lines) {
        const modifiedLines = solverViz.lines.map((line) => ({
          ...line,
          strokeColor: phaseColor
        }));
        graphics.lines.push(...modifiedLines);
      }
      if (solverViz.points) {
        graphics.points.push(...solverViz.points);
      }
      if (solverViz.rects) {
        graphics.rects.push(...solverViz.rects);
      }
      if (solverViz.circles) {
        graphics.circles.push(...solverViz.circles);
      }
    }
    if (this.optimalPosition) {
      graphics.points.push({
        ...this.optimalPosition,
        color: "rgba(76, 175, 80, 0.8)",
        label: "Final optimal position"
      });
    }
    return graphics;
  }
};

// lib/testing/createColorMapFromStrings.ts
var createColorMapFromStrings = (strings) => {
  const colorMap = {};
  for (let i = 0; i < strings.length; i++) {
    colorMap[strings[i]] = `hsl(${i * 300 / strings.length}, 100%, 50%)`;
  }
  return colorMap;
};
var getColorForString = (string, alpha = 1) => {
  const hash = string.split("").reduce((acc, char) => {
    return acc * 31 + char.charCodeAt(0);
  }, 0);
  return `hsl(${hash % 360}, 100%, 50%, ${alpha})`;
};

// lib/geometry/pointInOutline.ts
var EPS = 1e-9;
function cross2(ax, ay, bx, by) {
  return ax * by - ay * bx;
}
function isLeft(a, b, p) {
  return cross2(b.x - a.x, b.y - a.y, p.x - a.x, p.y - a.y);
}
function pointOnSegment(p, a, b, eps = EPS) {
  const area2 = isLeft(a, b, p);
  if (Math.abs(area2) > eps) return false;
  const minx = Math.min(a.x, b.x) - eps;
  const maxx = Math.max(a.x, b.x) + eps;
  const miny = Math.min(a.y, b.y) - eps;
  const maxy = Math.max(a.y, b.y) + eps;
  return p.x >= minx && p.x <= maxx && p.y >= miny && p.y <= maxy;
}
function pointInOutline(p, segments, rule = "even-odd") {
  let minx = Infinity;
  let miny = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  for (const s of segments) {
    const [a, b] = s;
    minx = Math.min(minx, a.x, b.x);
    miny = Math.min(miny, a.y, b.y);
    maxx = Math.max(maxx, a.x, b.x);
    maxy = Math.max(maxy, a.y, b.y);
  }
  if (p.x < minx - EPS || p.x > maxx + EPS || p.y < miny - EPS || p.y > maxy + EPS) {
    return "outside";
  }
  for (const s of segments) {
    const [a, b] = s;
    if (pointOnSegment(p, a, b)) return "boundary";
  }
  if (rule === "even-odd") {
    let crossings = 0;
    for (const s of segments) {
      const [a, b] = s;
      const ay = a.y;
      const by = b.y;
      const ax = a.x;
      const bx = b.x;
      const cond = ay <= p.y && p.y < by || by <= p.y && p.y < ay;
      if (!cond) continue;
      const dy = by - ay;
      if (Math.abs(dy) < EPS) continue;
      const t = (p.y - ay) / dy;
      const xAtY = ax + t * (bx - ax);
      if (xAtY > p.x + EPS) crossings++;
    }
    return crossings % 2 === 1 ? "inside" : "outside";
  } else {
    let winding = 0;
    for (const s of segments) {
      const [a, b] = s;
      if (a.y <= p.y) {
        if (b.y > p.y && isLeft(a, b, p) > EPS) winding++;
      } else {
        if (b.y <= p.y && isLeft(a, b, p) < -EPS) winding--;
      }
    }
    return winding !== 0 ? "inside" : "outside";
  }
}

// lib/OutlineSegmentCandidatePointSolver/getOutwardNormal.ts
function getOutwardNormal(outlineSegment, fullOutline) {
  const [p1, p2] = outlineSegment;
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const len = Math.hypot(dx, dy);
  if (len === 0) {
    return { x: 0, y: 1 };
  }
  const dirX = dx / len;
  const dirY = dy / len;
  const left = { x: -dirY, y: dirX };
  const right = { x: dirY, y: -dirX };
  const mid = {
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2
  };
  const bbox = getOutlineBoundsWithMargin(fullOutline);
  const scale = Math.max(bbox.maxX - bbox.minX, bbox.maxY - bbox.minY) || 1;
  const testDistance = Math.max(1e-4, 1e-3 * scale);
  const testLeft = {
    x: mid.x + left.x * testDistance,
    y: mid.y + left.y * testDistance
  };
  const testRight = {
    x: mid.x + right.x * testDistance,
    y: mid.y + right.y * testDistance
  };
  const locLeft = pointInOutline(testLeft, fullOutline);
  if (locLeft === "outside") {
    return left;
  }
  const locRight = pointInOutline(testRight, fullOutline);
  if (locRight === "outside") {
    return right;
  }
  const verts = [];
  if (fullOutline.length > 0) {
    verts.push(fullOutline[0][0]);
    for (const seg of fullOutline) {
      verts.push(seg[1]);
    }
  }
  const signedArea = (() => {
    let a = 0;
    for (let i = 0; i < verts.length; i++) {
      const v1 = verts[i];
      const v2 = verts[(i + 1) % verts.length];
      a += v1.x * v2.y - v2.x * v1.y;
    }
    return a / 2;
  })();
  if (Math.abs(signedArea) > 1e-12) {
    return signedArea > 0 ? right : left;
  }
  const center = {
    x: (bbox.minX + bbox.maxX) / 2,
    y: (bbox.minY + bbox.maxY) / 2
  };
  const away = { x: mid.x - center.x, y: mid.y - center.y };
  const dotLeft = left.x * away.x + left.y * away.y;
  const dotRight = right.x * away.x + right.y * away.y;
  return dotRight >= dotLeft ? right : left;
}
function getOutlineBoundsWithMargin(fullOutline, margin = 0) {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const [p1, p2] of fullOutline) {
    minX = Math.min(minX, p1.x, p2.x);
    minY = Math.min(minY, p1.y, p2.y);
    maxX = Math.max(maxX, p1.x, p2.x);
    maxY = Math.max(maxY, p1.y, p2.y);
  }
  return {
    minX: minX - margin,
    minY: minY - margin,
    maxX: maxX + margin,
    maxY: maxY + margin
  };
}

// lib/LargestRectOutsideOutlineFromPointSolver.ts
var LargestRectOutsideOutlineFromPointSolver = class extends BaseSolver {
  fullOutline;
  origin;
  globalBounds;
  largestRect = null;
  constructor(params) {
    super();
    this.fullOutline = params.fullOutline;
    this.origin = params.origin;
    this.globalBounds = params.globalBounds;
  }
  getConstructorParams() {
    return {
      fullOutline: this.fullOutline,
      origin: this.origin,
      globalBounds: this.globalBounds
    };
  }
  _setup() {
  }
  _step() {
    this.largestRect = this.computeLargestRectOutside();
    this.solved = true;
  }
  computeLargestRectOutside() {
    const edges = this.makeEdges(this.fullOutline);
    const bounds = {
      x: this.globalBounds.minX,
      y: this.globalBounds.minY,
      w: this.globalBounds.maxX - this.globalBounds.minX,
      h: this.globalBounds.maxY - this.globalBounds.minY
    };
    return this.largestRectContainingPointRegion(
      edges,
      this.origin,
      bounds,
      "outside"
    );
  }
  almostEqual(a, b, eps = 1e-9) {
    return Math.abs(a - b) <= eps;
  }
  makeEdges(poly) {
    const edges = [];
    for (let i = 0; i < poly.length; i++) {
      const a = poly[i];
      const b = poly[(i + 1) % poly.length];
      if (!a || !b) continue;
      if (this.almostEqual(a.x, b.x) && this.almostEqual(a.y, b.y)) continue;
      edges.push([a, b]);
    }
    return edges;
  }
  isVertical(e) {
    return this.almostEqual(e[0].x, e[1].x);
  }
  isHorizontal(e) {
    return this.almostEqual(e[0].y, e[1].y);
  }
  scanlineIntervalsAtY(edges, y0) {
    const xs = [];
    for (const e of edges) {
      if (!this.isVertical(e)) continue;
      const y1 = e[0].y;
      const y2 = e[1].y;
      const x = e[0].x;
      const ymin = Math.min(y1, y2);
      const ymax = Math.max(y1, y2);
      if (ymin <= y0 && y0 < ymax) {
        xs.push(x);
      }
    }
    xs.sort((a, b) => a - b);
    const intervals = [];
    for (let i = 0; i + 1 < xs.length; i += 2) {
      const x1 = xs[i];
      const x2 = xs[i + 1];
      if (x1 !== void 0 && x2 !== void 0) {
        intervals.push([x1, x2]);
      }
    }
    return intervals;
  }
  clipIntervals(intervals, a, b) {
    const out = [];
    for (const [L, R] of intervals) {
      const l = Math.max(a, L);
      const r = Math.min(b, R);
      if (r > l) out.push([l, r]);
    }
    return out;
  }
  regionIntervalsAtY(edges, y0, bx1, bx2, mode) {
    const inside = this.clipIntervals(
      this.scanlineIntervalsAtY(edges, y0),
      bx1,
      bx2
    );
    const outs = [];
    let prev = bx1;
    for (const [L, R] of inside) {
      if (L > prev) outs.push([prev, L]);
      prev = Math.max(prev, R);
    }
    if (prev < bx2) outs.push([prev, bx2]);
    return outs;
  }
  largestRectContainingPointRegion(edges, p, bounds, mode) {
    const BX1 = bounds.x;
    const BX2 = bounds.x + bounds.w;
    const BY1 = bounds.y;
    const BY2 = bounds.y + bounds.h;
    const intervals = this.regionIntervalsAtY(edges, p.y, BX1, BX2, mode);
    const interval = intervals.find(
      ([xL, xR]) => xL - 1e-9 <= p.x && p.x <= xR + 1e-9
    );
    if (!interval) return null;
    let [X_L, X_R] = interval;
    const xset = /* @__PURE__ */ new Set([X_L, X_R]);
    for (const e of edges) {
      if (!this.isVertical(e)) continue;
      const x = e[0].x;
      if (X_L < x && x < X_R) xset.add(x);
    }
    const xs = Array.from(xset).sort((a, b) => a - b);
    const m = xs.length - 1;
    if (m <= 0) return null;
    const top = Array(m).fill(-Infinity);
    const bot = Array(m).fill(Infinity);
    for (let i = 0; i < m; i++) {
      const xi = xs[i];
      const xi1 = xs[i + 1];
      if (xi === void 0 || xi1 === void 0) continue;
      let xm = 0.5 * (xi + xi1);
      if (xset.has(xm)) xm += 1e-6;
      let minAbove = BY2;
      let maxBelow = BY1;
      for (const e of edges) {
        if (!this.isHorizontal(e)) continue;
        const y = e[0].y;
        const x1 = Math.min(e[0].x, e[1].x);
        const x2 = Math.max(e[0].x, e[1].x);
        if (x1 - 1e-9 <= xm && xm <= x2 + 1e-9) {
          if (y > p.y) minAbove = Math.min(minAbove, y);
          if (y < p.y) maxBelow = Math.max(maxBelow, y);
        }
      }
      if (!(maxBelow < minAbove)) {
        top[i] = -Infinity;
        bot[i] = Infinity;
      } else {
        top[i] = minAbove;
        bot[i] = maxBelow;
      }
    }
    let s0 = -1;
    for (let i = 0; i < m; i++) {
      const xi = xs[i];
      const xi1 = xs[i + 1];
      if (xi === void 0 || xi1 === void 0) continue;
      if (xi - 1e-9 <= p.x && p.x <= xi1 + 1e-9) {
        s0 = i;
        break;
      }
    }
    if (s0 === -1) return null;
    let best = null;
    let bestArea = -1;
    for (let i = 0; i <= s0; i++) {
      let minTop = Infinity;
      let maxBot = -Infinity;
      for (let j = i; j < m; j++) {
        const topJ = top[j];
        const botJ = bot[j];
        if (topJ === void 0 || botJ === void 0) continue;
        minTop = Math.min(minTop, topJ);
        maxBot = Math.max(maxBot, botJ);
        if (j < s0) continue;
        const height = Math.max(0, minTop - maxBot);
        if (height <= 0) continue;
        const xi = xs[i];
        const xj1 = xs[j + 1];
        if (xi === void 0 || xj1 === void 0) continue;
        const width = xj1 - xi;
        const area = width * height;
        if (area > bestArea) {
          bestArea = area;
          best = { x: xi, y: maxBot, w: width, h: height };
        }
      }
    }
    return best;
  }
  getLargestRect() {
    if (!this.solved) {
      this.solve();
    }
    return this.largestRect;
  }
  getLargestRectBounds() {
    if (!this.solved) {
      this.solve();
    }
    if (!this.largestRect) {
      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    }
    return {
      minX: this.largestRect.x,
      minY: this.largestRect.y,
      maxX: this.largestRect.x + this.largestRect.w,
      maxY: this.largestRect.y + this.largestRect.h
    };
  }
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    for (let i = 0; i < this.fullOutline.length; i++) {
      const p1 = this.fullOutline[i];
      const p2 = this.fullOutline[(i + 1) % this.fullOutline.length];
      if (p1 && p2) {
        graphics.lines.push({
          points: [p1, p2],
          strokeColor: "rgba(0,0,0,0.5)"
        });
      }
    }
    graphics.lines.push({
      points: [...this.fullOutline, this.fullOutline[0]],
      strokeColor: "rgba(200, 200, 200, 0.5)",
      strokeDash: [10, 5]
    });
    graphics.circles.push({
      center: this.origin,
      radius: 0.05,
      fill: "#f44336",
      label: "Origin"
    });
    if (this.largestRect) {
      graphics.rects.push({
        center: {
          x: this.largestRect.x + this.largestRect.w / 2,
          y: this.largestRect.y + this.largestRect.h / 2
        },
        width: this.largestRect.w,
        height: this.largestRect.h,
        fill: "rgba(0, 255, 0, 0.3)",
        stroke: "#4CAF50",
        label: `Largest Rectangle (Area: ${(this.largestRect.w * this.largestRect.h).toFixed(3)})`
      });
    }
    return graphics;
  }
};

// lib/geometry/getInputComponentBounds.ts
var getInputComponentBounds = (component, { rotationDegrees = 0 }) => {
  const bounds = {
    minX: Infinity,
    maxX: -Infinity,
    minY: Infinity,
    maxY: -Infinity
  };
  for (const pad of component.pads) {
    const hw = pad.size.x / 2;
    const hh = pad.size.y / 2;
    const localCorners = [
      { x: pad.offset.x - hw, y: pad.offset.y - hh },
      { x: pad.offset.x + hw, y: pad.offset.y - hh },
      { x: pad.offset.x + hw, y: pad.offset.y + hh },
      { x: pad.offset.x - hw, y: pad.offset.y + hh }
    ];
    for (const corner of localCorners) {
      const world = rotatePoint(corner, rotationDegrees * Math.PI / 180);
      const x = world.x;
      const y = world.y;
      bounds.minX = Math.min(bounds.minX, x);
      bounds.maxX = Math.max(bounds.maxX, x);
      bounds.minY = Math.min(bounds.minY, y);
      bounds.maxY = Math.max(bounds.maxY, y);
    }
  }
  return {
    minX: bounds.minX,
    maxX: bounds.maxX,
    minY: bounds.minY,
    maxY: bounds.maxY
  };
};

// lib/math/expandSegment.ts
var expandSegment = (segment, amount) => {
  const [p1, p2] = segment;
  const direction = {
    x: p2.x - p1.x,
    y: p2.y - p1.y
  };
  const normalizedDirection = normalizeVector(direction);
  const expandedSegment = [
    {
      x: p1.x - normalizedDirection.x * amount,
      y: p1.y - normalizedDirection.y * amount
    },
    {
      x: p2.x + normalizedDirection.x * amount,
      y: p2.y + normalizedDirection.y * amount
    }
  ];
  return expandedSegment;
};
function normalizeVector(direction) {
  const length = Math.hypot(direction.x, direction.y);
  return {
    x: direction.x / length,
    y: direction.y / length
  };
}

// lib/math/isPointInPolygon.ts
function isPointInPolygon(point, polygon) {
  if (polygon.length < 3) return false;
  let inside = false;
  const n = polygon.length;
  const poly = [...polygon];
  if (poly[0].x !== poly[n - 1].x || poly[0].y !== poly[n - 1].y) {
    poly.push({ ...poly[0] });
  }
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i].x;
    const yi = poly[i].y;
    const xj = poly[j].x;
    const yj = poly[j].y;
    const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}

// lib/OutlineSegmentCandidatePointSolver/OutlineSegmentCandidatePointSolver.ts
var OutlineSegmentCandidatePointSolver = class extends BaseSolver {
  outlineSegment;
  viableOutlineSegment = null;
  fullOutline;
  // The entire outline containing the segment
  componentRotationDegrees;
  packStrategy;
  minGap;
  obstacles;
  packedComponents;
  componentToPack;
  viableBounds;
  globalBounds;
  boundaryOutline;
  optimalPosition;
  irlsSolver;
  twoPhaseIrlsSolver;
  constructor(params) {
    super();
    this.outlineSegment = params.outlineSegment;
    this.fullOutline = params.fullOutline;
    this.componentRotationDegrees = params.componentRotationDegrees;
    this.packStrategy = params.packStrategy;
    this.minGap = params.minGap;
    this.packedComponents = params.packedComponents;
    this.componentToPack = params.componentToPack;
    this.obstacles = params.obstacles ?? [];
    this.globalBounds = params.globalBounds;
    this.boundaryOutline = params.boundaryOutline;
  }
  getConstructorParams() {
    return {
      outlineSegment: this.outlineSegment,
      fullOutline: this.fullOutline,
      componentRotationDegrees: this.componentRotationDegrees,
      packStrategy: this.packStrategy,
      minGap: this.minGap,
      packedComponents: this.packedComponents,
      componentToPack: this.componentToPack,
      obstacles: this.obstacles,
      globalBounds: this.globalBounds,
      boundaryOutline: this.boundaryOutline
    };
  }
  _getOutlineBoundsWithMargin(params = {}) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (const [p1, p2] of this.fullOutline) {
      minX = Math.min(minX, p1.x, p2.x);
      minY = Math.min(minY, p1.y, p2.y);
      maxX = Math.max(maxX, p1.x, p2.x);
      maxY = Math.max(maxY, p1.y, p2.y);
    }
    const margin = params.margin ?? 0;
    return {
      minX: minX - margin,
      minY: minY - margin,
      maxX: maxX + margin,
      maxY: maxY + margin
    };
  }
  _setup() {
    const { offsetPadPoints, targetPointMap } = this.getNetworkTargetPointMappings();
    const [p1, p2] = this.outlineSegment;
    const constraintFn = (point) => {
      const projectedPoint = this.projectPointOntoSegment(
        point,
        this.viableOutlineSegment
      );
      return this.adjustPositionForOutlineCollision(projectedPoint);
    };
    const outwardNormal = getOutwardNormal(
      this.outlineSegment,
      this.fullOutline
    );
    const componentBounds = getInputComponentBounds(this.componentToPack, {
      rotationDegrees: this.componentRotationDegrees
    });
    const packedComponentBoundsWithMargin = this._getOutlineBoundsWithMargin({
      margin: Math.max(
        componentBounds.maxX - componentBounds.minX,
        componentBounds.maxY - componentBounds.minY
      ) * 2 + this.minGap * 2
    });
    const largestRectSolverParams = {
      fullOutline: this.fullOutline.flatMap(([p]) => p),
      globalBounds: packedComponentBoundsWithMargin,
      origin: {
        x: (p1.x + p2.x) / 2 + outwardNormal.x * 1e-4,
        y: (p1.y + p2.y) / 2 + outwardNormal.y * 1e-4
      }
    };
    const largestRectSolver = new LargestRectOutsideOutlineFromPointSolver(
      largestRectSolverParams
    );
    largestRectSolver.solve();
    const largestRectBounds = largestRectSolver.getLargestRectBounds();
    const segmentNormAbs = {
      x: Math.abs(
        Math.sign(this.outlineSegment[1].x - this.outlineSegment[0].x)
      ),
      y: Math.abs(
        Math.sign(this.outlineSegment[1].y - this.outlineSegment[0].y)
      )
    };
    let viableBounds = {
      minX: largestRectBounds.minX - componentBounds.minX * segmentNormAbs.x,
      minY: largestRectBounds.minY - componentBounds.minY * segmentNormAbs.y,
      maxX: largestRectBounds.maxX - componentBounds.maxX * segmentNormAbs.x,
      maxY: largestRectBounds.maxY - componentBounds.maxY * segmentNormAbs.y
    };
    if (this.boundaryOutline && this.boundaryOutline.length >= 3) {
      let boundaryMinX = Infinity;
      let boundaryMinY = Infinity;
      let boundaryMaxX = -Infinity;
      let boundaryMaxY = -Infinity;
      for (const point of this.boundaryOutline) {
        boundaryMinX = Math.min(boundaryMinX, point.x);
        boundaryMinY = Math.min(boundaryMinY, point.y);
        boundaryMaxX = Math.max(boundaryMaxX, point.x);
        boundaryMaxY = Math.max(boundaryMaxY, point.y);
      }
      viableBounds = {
        minX: Math.max(viableBounds.minX, boundaryMinX - componentBounds.minX),
        minY: Math.max(viableBounds.minY, boundaryMinY - componentBounds.minY),
        maxX: Math.min(viableBounds.maxX, boundaryMaxX - componentBounds.maxX),
        maxY: Math.min(viableBounds.maxY, boundaryMaxY - componentBounds.maxY)
      };
    }
    this.viableBounds = viableBounds;
    const viableBoundsWidth = viableBounds.maxX - viableBounds.minX;
    const viableBoundsHeight = viableBounds.maxY - viableBounds.minY;
    const componentBoundsWidth = componentBounds.maxX - componentBounds.minX;
    const componentBoundsHeight = componentBounds.maxY - componentBounds.minY;
    if (viableBoundsWidth < componentBoundsWidth || viableBoundsHeight < componentBoundsHeight) {
      this.failed = true;
      this.error = "There is nowhere for the component to fit along this outline section";
      return;
    }
    const segmentLength = Math.hypot(p2.x - p1.x, p2.y - p1.y);
    const expandedOutlineSegment = expandSegment(
      this.outlineSegment,
      segmentLength
    );
    const [s1, s2] = expandedOutlineSegment;
    this.viableOutlineSegment = [
      {
        x: clamp(s1.x, viableBounds.minX, viableBounds.maxX),
        y: clamp(s1.y, viableBounds.minY, viableBounds.maxY)
      },
      {
        x: clamp(s2.x, viableBounds.minX, viableBounds.maxX),
        y: clamp(s2.y, viableBounds.minY, viableBounds.maxY)
      }
    ];
    const [vp1, vp2] = this.viableOutlineSegment;
    const initialPosition = this.adjustPositionForOutlineCollision({
      x: (vp1.x + vp2.x) / 2,
      y: (vp1.y + vp2.y) / 2
    });
    if (this.packStrategy === "minimum_closest_sum_squared_distance") {
      this.twoPhaseIrlsSolver = new TwoPhaseIrlsSolver({
        offsetPadPoints,
        targetPointMap,
        initialPosition,
        constraintFn,
        epsilon: 1e-6,
        maxIterations: 50
      });
    } else {
      this.irlsSolver = new MultiOffsetIrlsSolver({
        offsetPadPoints,
        targetPointMap,
        initialPosition,
        constraintFn,
        epsilon: 1e-6,
        maxIterations: 50,
        useSquaredDistance: this.packStrategy === "minimum_sum_squared_distance_to_network"
      });
    }
  }
  _step() {
    const activeSolver = this.irlsSolver || this.twoPhaseIrlsSolver;
    if (!activeSolver) {
      this.solved = true;
      return;
    }
    activeSolver.step();
    if (activeSolver.solved) {
      const rawPosition = activeSolver.getBestPosition();
      this.optimalPosition = rawPosition;
      this.solved = true;
    } else if (activeSolver.failed) {
      this.failed = true;
      this.error = activeSolver.error;
    }
  }
  /**
   * Get pad offset points and target point mappings for network connections
   */
  getNetworkTargetPointMappings() {
    const rotatedPads = this.getRotatedComponentPads();
    const offsetPadPoints = rotatedPads.map((pad) => ({
      id: pad.padId,
      offsetX: pad.offset.x,
      offsetY: pad.offset.y
    }));
    const targetPointMap = /* @__PURE__ */ new Map();
    for (const pad of rotatedPads) {
      const targetPoints = [];
      for (const packedComponent of this.packedComponents) {
        for (const packedPad of packedComponent.pads) {
          if (packedPad.networkId === pad.networkId) {
            targetPoints.push({
              ...packedPad.absoluteCenter,
              networkId: packedPad.networkId
            });
          }
        }
      }
      targetPointMap.set(pad.padId, targetPoints);
    }
    return { offsetPadPoints, targetPointMap };
  }
  /**
   * Project a point onto the outline segment
   */
  projectPointOntoSegment(point, segment) {
    const [p1, p2] = segment;
    const segmentX = p2.x - p1.x;
    const segmentY = p2.y - p1.y;
    const pointX = point.x - p1.x;
    const pointY = point.y - p1.y;
    const segmentLengthSq = segmentX * segmentX + segmentY * segmentY;
    if (segmentLengthSq === 0) {
      return { x: p1.x, y: p1.y };
    }
    const t = Math.max(
      0,
      Math.min(1, (pointX * segmentX + pointY * segmentY) / segmentLengthSq)
    );
    return {
      x: p1.x + t * segmentX,
      y: p1.y + t * segmentY
    };
  }
  /**
   * Get rotated pads for the component being placed
   */
  getRotatedComponentPads() {
    const rotationRadians = this.componentRotationDegrees * Math.PI / 180;
    return this.componentToPack.pads.map((pad) => ({
      ...pad,
      size: (this.componentRotationDegrees + 90) % 180 === 0 ? {
        x: pad.size.y,
        y: pad.size.x
      } : pad.size,
      offset: rotatePoint(pad.offset, rotationRadians)
    }));
  }
  /**
   * Create a temporary PackedComponent with the given center position and applied rotation
   */
  createTemporaryPackedComponent(center) {
    const rotationRadians = this.componentRotationDegrees * Math.PI / 180;
    const flipWidthHeight = (this.componentRotationDegrees + 90) % 180 === 0;
    return {
      componentId: this.componentToPack.componentId,
      center,
      ccwRotationOffset: this.componentRotationDegrees,
      pads: this.componentToPack.pads.map((pad) => {
        const rotatedOffset = rotatePoint(pad.offset, rotationRadians);
        return {
          ...pad,
          size: {
            x: flipWidthHeight ? pad.size.y : pad.size.x,
            y: flipWidthHeight ? pad.size.x : pad.size.y
          },
          absoluteCenter: {
            x: center.x + rotatedOffset.x,
            y: center.y + rotatedOffset.y
          }
        };
      })
    };
  }
  /**
   * Adjust position to avoid component bounds crossing to the inside of the outline
   * and ensure the component stays within the boundary outline
   */
  adjustPositionForOutlineCollision(center) {
    const tempComponent = this.createTemporaryPackedComponent(center);
    const bounds = getComponentBounds(tempComponent, 0);
    const outwardNormal = getOutwardNormal(
      this.outlineSegment,
      this.fullOutline
    );
    const isHorizontalNormal = Math.abs(outwardNormal.x) > Math.abs(outwardNormal.y);
    const isVerticalNormal = !isHorizontalNormal;
    let adjustedCenter = center;
    if (isHorizontalNormal) {
      const isXPlusFacing = outwardNormal.x > 0;
      const isXMinusFacing = !isXPlusFacing;
      if (isXPlusFacing) {
        adjustedCenter = {
          x: bounds.maxX,
          y: center.y
        };
      } else if (isXMinusFacing) {
        adjustedCenter = {
          x: bounds.minX,
          y: center.y
        };
      }
    } else if (isVerticalNormal) {
      const isYPlusFacing = outwardNormal.y > 0;
      const isYMinusFacing = !isYPlusFacing;
      if (isYPlusFacing) {
        adjustedCenter = {
          x: center.x,
          y: bounds.maxY
        };
      } else if (isYMinusFacing) {
        adjustedCenter = {
          x: center.x,
          y: bounds.minY
        };
      }
    }
    if (this.boundaryOutline && this.boundaryOutline.length >= 3) {
      const adjustedComponent = this.createTemporaryPackedComponent(adjustedCenter);
      const adjustedBounds = getComponentBounds(adjustedComponent, 0);
      const allPadsInside = adjustedComponent.pads.every(
        (pad) => isPointInPolygon(pad.absoluteCenter, this.boundaryOutline)
      );
      const cornersInside = [
        { x: adjustedBounds.minX, y: adjustedBounds.minY },
        { x: adjustedBounds.minX, y: adjustedBounds.maxY },
        { x: adjustedBounds.maxX, y: adjustedBounds.minY },
        { x: adjustedBounds.maxX, y: adjustedBounds.maxY }
      ].every((corner) => isPointInPolygon(corner, this.boundaryOutline));
      if (!allPadsInside || !cornersInside) {
        if (this.viableBounds) {
          adjustedCenter = {
            x: clamp(
              adjustedCenter.x,
              this.viableBounds.minX,
              this.viableBounds.maxX
            ),
            y: clamp(
              adjustedCenter.y,
              this.viableBounds.minY,
              this.viableBounds.maxY
            )
          };
        }
      }
    }
    return adjustedCenter;
  }
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    if (this.obstacles && this.obstacles.length > 0) {
      for (const obstacle of this.obstacles) {
        graphics.rects.push({
          center: obstacle.absoluteCenter,
          width: obstacle.width,
          height: obstacle.height,
          fill: "rgba(0,0,0,0.1)",
          stroke: "#555",
          label: obstacle.obstacleId
        });
      }
    }
    if (this.globalBounds) {
      graphics.lines.push({
        points: [
          { x: this.globalBounds.minX, y: this.globalBounds.minY },
          { x: this.globalBounds.minX, y: this.globalBounds.maxY },
          { x: this.globalBounds.maxX, y: this.globalBounds.maxY },
          { x: this.globalBounds.maxX, y: this.globalBounds.minY },
          { x: this.globalBounds.minX, y: this.globalBounds.minY }
        ],
        strokeColor: "rgba(255,0,255,0.5)",
        strokeDash: "2 2"
      });
    }
    if (this.boundaryOutline && this.boundaryOutline.length) {
      const outlinePoints = [...this.boundaryOutline];
      if (outlinePoints.length > 0 && (outlinePoints[0].x !== outlinePoints[outlinePoints.length - 1].x || outlinePoints[0].y !== outlinePoints[outlinePoints.length - 1].y)) {
        outlinePoints.push({ ...outlinePoints[0] });
      }
      graphics.lines.push({
        points: outlinePoints,
        strokeColor: "rgba(0, 0, 255, 0.5)",
        strokeDash: "4 2"
      });
    }
    if (this.viableBounds) {
      graphics.rects.push({
        center: {
          x: (this.viableBounds.minX + this.viableBounds.maxX) / 2,
          y: (this.viableBounds.minY + this.viableBounds.maxY) / 2
        },
        width: this.viableBounds.maxX - this.viableBounds.minX,
        height: this.viableBounds.maxY - this.viableBounds.minY,
        fill: "rgba(0,255,0,0.1)",
        label: "Viable Bounds"
      });
    }
    if (this.viableOutlineSegment) {
      const [p1, p2] = this.viableOutlineSegment;
      graphics.lines.push({
        points: [p1, p2],
        strokeColor: "#2196F3"
      });
    }
    const [osp1, osp2] = this.outlineSegment;
    graphics.lines.push({
      points: [osp1, osp2],
      strokeColor: "rgba(255,0,0,1)",
      strokeDash: "3 3"
    });
    for (const [p1, p2] of this.fullOutline) {
      graphics.lines.push({
        points: [p1, p2],
        strokeColor: "rgba(0,0,0,0.5)",
        strokeDash: "4 4"
      });
    }
    for (const component of this.packedComponents) {
      for (const pad of component.pads) {
        graphics.rects.push({
          center: pad.absoluteCenter,
          width: pad.size.x,
          height: pad.size.y,
          fill: getColorForString(pad.networkId, 0.5),
          stroke: "#333",
          label: `${pad.padId} (${pad.networkId})`
        });
      }
    }
    const pos = this.optimalPosition ?? this.irlsSolver?.currentPosition ?? this.twoPhaseIrlsSolver?.currentPosition ?? {
      x: 0,
      y: 0
    };
    const rotatedPads = this.getRotatedComponentPads();
    for (const pad of rotatedPads) {
      const padPos = {
        x: pos.x + pad.offset.x,
        y: pos.y + pad.offset.y
      };
      graphics.rects.push({
        center: padPos,
        width: pad.size.x,
        height: pad.size.y,
        fill: this.failed ? "rgba(255,0,0,0.5)" : getColorForString(pad.networkId, 0.5),
        label: `${pad.padId} (${pad.networkId})`
      });
      for (const packedComponent of this.packedComponents) {
        for (const packedPad of packedComponent.pads) {
          if (packedPad.networkId === pad.networkId) {
            graphics.lines.push({
              points: [padPos, packedPad.absoluteCenter],
              strokeColor: pad.networkId === "VCC" ? "#FF6B6B" : "#4ECDC4",
              strokeDash: [2, 2],
              label: `${pad.networkId} connection`
            });
          }
        }
      }
    }
    const activeSolver = this.irlsSolver || this.twoPhaseIrlsSolver;
    if (activeSolver) {
      const currentPos = activeSolver.currentPosition;
      graphics.points.push({
        ...currentPos,
        color: "#f44336"
      });
      const solverViz = activeSolver.visualize();
      if (solverViz.lines) {
        graphics.lines.push(...solverViz.lines);
      }
      if (solverViz.circles) {
        graphics.circles.push(...solverViz.circles);
      }
      if (solverViz.rects) {
        graphics.rects.push(...solverViz.rects);
      }
      if (solverViz.points) {
        graphics.points.push(...solverViz.points);
      }
    }
    if (this.optimalPosition) {
      graphics.points.push({
        ...this.optimalPosition,
        color: "rgba(76, 175, 80, 0.3)"
      });
    }
    return graphics;
  }
};

// lib/testing/getGraphicsFromPackOutput.ts
var getGraphicsFromPackOutput = (packOutput) => {
  const rects = [];
  const lines = [];
  if (packOutput.boundaryOutline && packOutput.boundaryOutline.length) {
    const outlinePoints = [...packOutput.boundaryOutline];
    if (outlinePoints.length > 0 && (outlinePoints[0].x !== outlinePoints[outlinePoints.length - 1].x || outlinePoints[0].y !== outlinePoints[outlinePoints.length - 1].y)) {
      outlinePoints.push({ ...outlinePoints[0] });
    }
    lines.push({
      points: outlinePoints,
      strokeColor: "rgba(0, 0, 255, 0.5)",
      strokeDash: "4 2"
    });
  }
  const allNetworkIds = Array.from(
    new Set(
      packOutput.components.flatMap((c) => c.pads.map((p) => p.networkId))
    )
  );
  const colorMap = createColorMapFromStrings(allNetworkIds);
  if (packOutput.obstacles && packOutput.obstacles.length > 0) {
    for (const obstacle of packOutput.obstacles) {
      rects.push({
        center: { x: obstacle.absoluteCenter.x, y: obstacle.absoluteCenter.y },
        width: obstacle.width,
        height: obstacle.height,
        fill: "rgba(0,0,0,0.1)",
        stroke: "#555",
        label: obstacle.obstacleId
      });
    }
  }
  for (const component of packOutput.components) {
    const bounds = getComponentBounds(component);
    const width = bounds.maxX - bounds.minX;
    const height = bounds.maxY - bounds.minY;
    const rect = {
      center: { x: component.center.x, y: component.center.y },
      width,
      height,
      fill: "rgba(0,0,0,0.25)",
      label: [
        component.componentId,
        `ccwRotationOffset: ${component.ccwRotationOffset.toFixed(1)}\xB0`
      ].join("\n")
    };
    rects.push(rect);
    for (const pad of component.pads) {
      const { absoluteCenter, size, padId, networkId } = pad;
      const padRect = {
        center: { x: absoluteCenter.x, y: absoluteCenter.y },
        width: size.x,
        height: size.y,
        label: `${padId} ${networkId}`,
        fill: "rgba(255,0,0,0.8)"
      };
      rects.push(padRect);
    }
  }
  for (const netId of allNetworkIds) {
    const padsOnNet = packOutput.components.flatMap(
      (c) => c.pads.filter((p) => p.networkId === netId)
    );
    for (let i = 0; i < padsOnNet.length; i++) {
      for (let j = i + 1; j < padsOnNet.length; j++) {
        lines.push({
          points: [padsOnNet[i].absoluteCenter, padsOnNet[j].absoluteCenter],
          strokeColor: colorMap[netId]
        });
      }
    }
  }
  return {
    coordinateSystem: "cartesian",
    rects,
    lines
  };
};

// lib/PackSolver2/checkOverlapWithPackedComponents.ts
import { computeDistanceBetweenBoxes } from "@tscircuit/math-utils";
function checkOverlapWithPackedComponents({
  component,
  packedComponents,
  minGap
}) {
  const allPackedPadBoxes = packedComponents.flatMap(
    (c) => c.pads.map((p) => ({
      center: { x: p.absoluteCenter.x, y: p.absoluteCenter.y },
      width: p.size.x,
      height: p.size.y
    }))
  );
  const newComponentPadBoxes = component.pads.map((p) => ({
    center: { x: p.absoluteCenter.x, y: p.absoluteCenter.y },
    width: p.size.x,
    height: p.size.y
  }));
  for (const newComponentPadBox of newComponentPadBoxes) {
    for (const packedPadBox of allPackedPadBoxes) {
      const { distance: boxDist } = computeDistanceBetweenBoxes(
        newComponentPadBox,
        packedPadBox
      );
      if (boxDist + 1e-6 < minGap) {
        return {
          hasOverlap: true,
          gapDistance: boxDist
        };
      }
    }
  }
  return {
    hasOverlap: false
  };
}

// lib/SingleComponentPackSolver/SingleComponentPackSolver.ts
import { computeDistanceBetweenBoxes as computeDistanceBetweenBoxes2 } from "@tscircuit/math-utils";
var SingleComponentPackSolver = class extends BaseSolver {
  componentToPack;
  packedComponents;
  packPlacementStrategy;
  minGap;
  obstacles;
  boundaryOutline;
  // Phase management
  currentPhase = "outline";
  outlines = [];
  queuedOutlineSegments = [];
  currentSegmentIndex = 0;
  currentRotationIndex = 0;
  activeSubSolver = null;
  candidateResults = [];
  rejectedCandidates = [];
  bestCandidate;
  outputPackedComponent;
  bounds;
  constructor(params) {
    super();
    this.componentToPack = params.componentToPack;
    this.packedComponents = params.packedComponents;
    this.packPlacementStrategy = params.packPlacementStrategy;
    this.minGap = params.minGap ?? 0;
    this.obstacles = params.obstacles ?? [];
    this.bounds = params.bounds;
    this.boundaryOutline = params.boundaryOutline;
  }
  _setup() {
    super._setup();
    this.currentPhase = "outline";
    this.outlines = [];
    this.queuedOutlineSegments = [];
    this.candidateResults = [];
    this.activeSubSolver = void 0;
    this.currentSegmentIndex = 0;
    this.currentRotationIndex = 0;
  }
  _step() {
    if (this.solved || this.failed) return;
    switch (this.currentPhase) {
      case "outline":
        this.executeOutlinePhase();
        break;
      case "segment_candidate":
        this.executeSegmentCandidatePhase();
        break;
      case "evaluate":
        this.executeEvaluatePhase();
        break;
    }
  }
  executeOutlinePhase() {
    if (this.packedComponents.length === 0) {
      const availableRotations2 = this.componentToPack.availableRotationDegrees ?? [0, 90, 180, 270];
      const position = { x: 0, y: 0 };
      const rotation = availableRotations2[0] ?? 0;
      const candidate = this.createPackedComponent(position, rotation);
      const tooCloseToObstacles = (this.obstacles ?? []).some((obs) => {
        const obsBox = {
          center: { x: obs.absoluteCenter.x, y: obs.absoluteCenter.y },
          width: obs.width,
          height: obs.height
        };
        return candidate.pads.some((p) => {
          const padBox = {
            center: { x: p.absoluteCenter.x, y: p.absoluteCenter.y },
            width: p.size.x,
            height: p.size.y
          };
          const { distance } = computeDistanceBetweenBoxes2(padBox, obsBox);
          return distance + 1e-6 < this.minGap;
        });
      });
      if (!tooCloseToObstacles) {
        this.outputPackedComponent = candidate;
        this.solved = true;
        return;
      }
    }
    this.outlines = constructOutlinesFromPackedComponents(
      this.packedComponents,
      {
        minGap: this.minGap,
        obstacles: this.obstacles
      }
    );
    const availableRotations = this.componentToPack.availableRotationDegrees ?? [0, 90, 180, 270];
    for (let segmentIndex = 0; segmentIndex < this.outlines.length; segmentIndex++) {
      const outline = this.outlines[segmentIndex];
      for (let i = 0; i < outline.length; i++) {
        const segment = outline[i];
        this.queuedOutlineSegments.push({
          segment,
          availableRotations: [...availableRotations],
          segmentIndex: segmentIndex * 1e3 + i,
          // Unique index across all outlines
          fullOutline: outline
          // Pass the entire outline containing this segment
        });
      }
    }
    this.currentPhase = "segment_candidate";
    this.currentSegmentIndex = 0;
    this.currentRotationIndex = 0;
  }
  executeSegmentCandidatePhase() {
    if (this.activeSubSolver?.solved || this.activeSubSolver?.failed) {
      const queuedSegment = this.queuedOutlineSegments[this.currentSegmentIndex];
      const rotation = queuedSegment.availableRotations[this.currentRotationIndex];
      let distance = Infinity;
      let optimalPosition;
      if (this.activeSubSolver.solved && this.activeSubSolver.optimalPosition) {
        optimalPosition = this.activeSubSolver.optimalPosition;
        const candidateComponent = this.createPackedComponent(
          optimalPosition,
          rotation
        );
        const { hasOverlap, gapDistance } = checkOverlapWithPackedComponents({
          component: candidateComponent,
          packedComponents: this.packedComponents,
          minGap: this.minGap
        });
        let minObstacleGapDistance = Infinity;
        const tooCloseToObstacles = (this.obstacles ?? []).some((obs) => {
          const obsBox = {
            center: { x: obs.absoluteCenter.x, y: obs.absoluteCenter.y },
            width: obs.width,
            height: obs.height
          };
          return candidateComponent.pads.some((p) => {
            const padBox = {
              center: { x: p.absoluteCenter.x, y: p.absoluteCenter.y },
              width: p.size.x,
              height: p.size.y
            };
            const { distance: distance2 } = computeDistanceBetweenBoxes2(padBox, obsBox);
            minObstacleGapDistance = Math.min(minObstacleGapDistance, distance2);
            return distance2 + 1e-6 < this.minGap;
          });
        });
        let outsideBounds = false;
        if (this.bounds) {
          const componentBounds = getComponentBounds(candidateComponent, 0);
          outsideBounds = componentBounds.minX < this.bounds.minX || componentBounds.maxX > this.bounds.maxX || componentBounds.minY < this.bounds.minY || componentBounds.maxY > this.bounds.maxY;
        }
        let outsideBoundaryOutline = false;
        if (this.boundaryOutline && this.boundaryOutline.length >= 3) {
          const componentBounds = getComponentBounds(candidateComponent, 0);
          const allPadsInside = candidateComponent.pads.every(
            (pad) => isPointInPolygon(pad.absoluteCenter, this.boundaryOutline)
          );
          const cornersInside = [
            { x: componentBounds.minX, y: componentBounds.minY },
            { x: componentBounds.minX, y: componentBounds.maxY },
            { x: componentBounds.maxX, y: componentBounds.minY },
            { x: componentBounds.maxX, y: componentBounds.maxY }
          ].every((corner) => isPointInPolygon(corner, this.boundaryOutline));
          outsideBoundaryOutline = !allPadsInside || !cornersInside;
        }
        distance = this.calculateDistance(optimalPosition, rotation);
        if (hasOverlap) {
          this.rejectedCandidates.push({
            segment: queuedSegment.segment,
            rotation,
            optimalPosition,
            distance,
            segmentIndex: queuedSegment.segmentIndex,
            rotationIndex: this.currentRotationIndex,
            gapDistance
          });
        } else if (tooCloseToObstacles) {
          this.rejectedCandidates.push({
            segment: queuedSegment.segment,
            rotation,
            optimalPosition,
            distance,
            segmentIndex: queuedSegment.segmentIndex,
            rotationIndex: this.currentRotationIndex,
            gapDistance: minObstacleGapDistance
          });
        } else if (outsideBounds) {
          this.rejectedCandidates.push({
            segment: queuedSegment.segment,
            rotation,
            optimalPosition,
            distance,
            segmentIndex: queuedSegment.segmentIndex,
            rotationIndex: this.currentRotationIndex,
            gapDistance: -1
            // Special marker for bounds violation
          });
        } else if (outsideBoundaryOutline) {
          this.rejectedCandidates.push({
            segment: queuedSegment.segment,
            rotation,
            optimalPosition,
            distance,
            segmentIndex: queuedSegment.segmentIndex,
            rotationIndex: this.currentRotationIndex,
            gapDistance: -1
            // Special marker for boundary violation
          });
        } else {
          this.candidateResults.push({
            segment: queuedSegment.segment,
            rotation,
            optimalPosition,
            distance,
            segmentIndex: queuedSegment.segmentIndex,
            rotationIndex: this.currentRotationIndex
          });
        }
      }
      this.currentRotationIndex++;
      this.activeSubSolver = void 0;
    }
    while (!this.activeSubSolver) {
      if (this.currentSegmentIndex >= this.queuedOutlineSegments.length) {
        this.currentPhase = "evaluate";
        return;
      }
      const queuedSegment = this.queuedOutlineSegments[this.currentSegmentIndex];
      if (this.currentRotationIndex >= queuedSegment.availableRotations.length) {
        this.currentSegmentIndex++;
        this.currentRotationIndex = 0;
        continue;
      }
      const rotation = queuedSegment.availableRotations[this.currentRotationIndex];
      this.activeSubSolver = new OutlineSegmentCandidatePointSolver({
        outlineSegment: queuedSegment.segment,
        fullOutline: queuedSegment.fullOutline,
        componentRotationDegrees: rotation,
        packStrategy: this.packPlacementStrategy,
        minGap: this.minGap,
        packedComponents: this.packedComponents,
        componentToPack: this.componentToPack,
        obstacles: this.obstacles,
        globalBounds: this.bounds,
        boundaryOutline: this.boundaryOutline
      });
      this.activeSubSolver.setup();
      break;
    }
    this.activeSubSolver.step();
  }
  executeEvaluatePhase() {
    if (this.candidateResults.length === 0) {
      this.failed = true;
      this.error = "No valid candidates found";
      return;
    }
    this.candidateResults.sort((a, b) => a.distance - b.distance);
    this.bestCandidate = this.candidateResults[0];
    if (this.bestCandidate.optimalPosition) {
      this.outputPackedComponent = this.createPackedComponent(
        this.bestCandidate.optimalPosition,
        this.bestCandidate.rotation
      );
    }
    this.solved = true;
  }
  calculateDistance(position, rotation) {
    const tempComponent = this.createPackedComponent(position, rotation);
    let totalDistance = 0;
    const useSquaredDistance = this.packPlacementStrategy === "minimum_sum_squared_distance_to_network" || this.packPlacementStrategy === "minimum_closest_sum_squared_distance";
    for (const pad of tempComponent.pads) {
      let minDistanceToNetwork = Infinity;
      for (const packedComponent of this.packedComponents) {
        for (const packedPad of packedComponent.pads) {
          if (packedPad.networkId === pad.networkId) {
            const dx = pad.absoluteCenter.x - packedPad.absoluteCenter.x;
            const dy = pad.absoluteCenter.y - packedPad.absoluteCenter.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            minDistanceToNetwork = Math.min(minDistanceToNetwork, dist);
          }
        }
      }
      if (minDistanceToNetwork < Infinity) {
        totalDistance += useSquaredDistance ? minDistanceToNetwork * minDistanceToNetwork : minDistanceToNetwork;
      }
    }
    return totalDistance;
  }
  createPackedComponent(position, rotation) {
    const component = {
      ...this.componentToPack,
      center: position,
      ccwRotationOffset: rotation,
      pads: this.componentToPack.pads.map((pad) => ({
        ...pad,
        absoluteCenter: { x: 0, y: 0 }
        // Will be set by setPackedComponentPadCenters
      }))
    };
    setPackedComponentPadCenters(component);
    return component;
  }
  visualize() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.visualize();
    }
    const graphics = getGraphicsFromPackOutput({
      components: this.packedComponents,
      minGap: this.minGap,
      packOrderStrategy: "largest_to_smallest",
      packPlacementStrategy: this.packPlacementStrategy
    });
    graphics.points ??= [];
    graphics.lines ??= [];
    graphics.rects ??= [];
    graphics.texts ??= [];
    graphics.circles ??= [];
    if (this.obstacles && this.obstacles.length > 0) {
      for (const obstacle of this.obstacles) {
        graphics.rects.push({
          center: obstacle.absoluteCenter,
          width: obstacle.width,
          height: obstacle.height,
          fill: "rgba(0,0,0,0.1)",
          stroke: "#555",
          label: obstacle.obstacleId
        });
      }
    }
    if (this.bounds) {
      graphics.lines.push({
        points: [
          { x: this.bounds.minX, y: this.bounds.minY },
          { x: this.bounds.minX, y: this.bounds.maxY },
          { x: this.bounds.maxX, y: this.bounds.maxY },
          { x: this.bounds.maxX, y: this.bounds.minY },
          { x: this.bounds.minX, y: this.bounds.minY }
        ],
        strokeColor: "rgba(0,0,0,0.5)",
        strokeDash: "2 2"
      });
    }
    if (this.boundaryOutline && this.boundaryOutline.length) {
      const outlinePoints = [...this.boundaryOutline];
      if (outlinePoints.length > 0 && (outlinePoints[0].x !== outlinePoints[outlinePoints.length - 1].x || outlinePoints[0].y !== outlinePoints[outlinePoints.length - 1].y)) {
        outlinePoints.push({ ...outlinePoints[0] });
      }
      graphics.lines.push({
        points: outlinePoints,
        strokeColor: "rgba(0, 0, 255, 0.5)",
        strokeDash: "4 2"
      });
    }
    switch (this.currentPhase) {
      case "outline":
        this.visualizeOutlinePhase(graphics);
        break;
      case "segment_candidate":
        this.visualizeSegmentCandidatePhase(graphics);
        break;
      case "evaluate":
        this.visualizeEvaluatePhase(graphics);
        break;
    }
    return graphics;
  }
  visualizeOutlinePhase(graphics) {
    for (const outline of this.outlines) {
      for (const segment of outline) {
        const [p1, p2] = segment;
        graphics.lines.push({
          points: [p1, p2],
          strokeColor: "#ff4444"
        });
      }
    }
  }
  visualizeSegmentCandidatePhase(graphics) {
    this.visualizeOutlinePhase(graphics);
    if (this.activeSubSolver) {
      const subSolverViz = this.activeSubSolver.visualize();
      if (subSolverViz.lines) graphics.lines.push(...subSolverViz.lines);
      if (subSolverViz.points) graphics.points.push(...subSolverViz.points);
      if (subSolverViz.rects) graphics.rects.push(...subSolverViz.rects);
      if (subSolverViz.circles)
        graphics.circles.push(...subSolverViz.circles ?? []);
    } else {
      for (let i = 0; i < this.candidateResults.length; i++) {
        const candidate = this.candidateResults[i];
        if (candidate.optimalPosition) {
          const tempComponent = this.createPackedComponent(
            candidate.optimalPosition,
            candidate.rotation
          );
          for (const pad of tempComponent.pads) {
            graphics.rects.push({
              center: pad.absoluteCenter,
              width: pad.size.x,
              height: pad.size.y,
              fill: `rgba(255,165,0,0.3)`,
              stroke: `rgba(255,165,0,0.8)`,
              strokeWidth: 1
            });
          }
          graphics.points.push({
            x: candidate.optimalPosition.x,
            y: candidate.optimalPosition.y,
            label: `c${i}, d=${candidate.distance.toFixed(3)}`,
            color: "rgba(255,165,0,0.8)"
          });
        }
      }
    }
  }
  visualizeEvaluatePhase(graphics) {
    this.visualizeOutlinePhase(graphics);
    for (let i = 0; i < this.candidateResults.length; i++) {
      const candidate = this.candidateResults[i];
      if (!candidate.optimalPosition) continue;
      const step = i;
      const isBest = step === 0;
      graphics.points.push({
        x: candidate.optimalPosition.x,
        y: candidate.optimalPosition.y,
        label: `step=${step}, d=${candidate.distance.toFixed(3)}`,
        color: isBest ? "rgba(0,255,0,0.8)" : "rgba(255,165,0,0.6)"
      });
    }
    for (let i = 0; i < this.rejectedCandidates.length; i++) {
      const candidate = this.rejectedCandidates[i];
      if (!candidate.optimalPosition) continue;
      graphics.points.push({
        x: candidate.optimalPosition.x,
        y: candidate.optimalPosition.y,
        label: `rejected, d=${candidate.distance.toFixed(3)}
gap_distance=${candidate.gapDistance}`,
        color: "rgba(255,0,0,0.8)"
      });
    }
    if (this.outputPackedComponent) {
      for (const pad of this.outputPackedComponent.pads) {
        graphics.rects.push({
          center: pad.absoluteCenter,
          width: pad.size.x,
          height: pad.size.y,
          fill: "rgba(0,255,0,0.7)"
        });
      }
    }
  }
  getResult() {
    return this.outputPackedComponent;
  }
  getConstructorParams() {
    return {
      componentToPack: this.componentToPack,
      packedComponents: this.packedComponents,
      packPlacementStrategy: this.packPlacementStrategy,
      minGap: this.minGap,
      obstacles: this.obstacles,
      bounds: this.bounds,
      boundaryOutline: this.boundaryOutline
    };
  }
};

// lib/PackSolver2/PackSolver2.ts
import { computeDistanceBetweenBoxes as computeDistanceBetweenBoxes3 } from "@tscircuit/math-utils";

// lib/math/getPolygonCentroid.ts
function getPolygonCentroid(points) {
  if (points.length < 3) {
    const sumX = points.reduce((sum, p) => sum + p.x, 0);
    const sumY = points.reduce((sum, p) => sum + p.y, 0);
    return { x: sumX / points.length, y: sumY / points.length };
  }
  let signedArea = 0;
  let cx = 0;
  let cy = 0;
  for (let i = 0; i < points.length; i++) {
    const p1 = points[i];
    const p2 = points[(i + 1) % points.length];
    const crossProduct = p1.x * p2.y - p2.x * p1.y;
    signedArea += crossProduct;
    cx += (p1.x + p2.x) * crossProduct;
    cy += (p1.y + p2.y) * crossProduct;
  }
  signedArea *= 0.5;
  const area = Math.abs(signedArea);
  if (area < 1e-10) {
    const sumX = points.reduce((sum, p) => sum + p.x, 0);
    const sumY = points.reduce((sum, p) => sum + p.y, 0);
    return { x: sumX / points.length, y: sumY / points.length };
  }
  cx /= 6 * signedArea;
  cy /= 6 * signedArea;
  return { x: cx, y: cy };
}

// lib/PackSolver2/PackSolver2.ts
var PackSolver2 = class extends BaseSolver {
  packInput;
  unpackedComponentQueue = [];
  packedComponents = [];
  componentToPack;
  constructor(packInput) {
    super();
    this.packInput = packInput;
  }
  getConstructorParams() {
    return this.packInput;
  }
  _setup() {
    const { components, packOrderStrategy, packFirst = [] } = this.packInput;
    this.unpackedComponentQueue = sortComponentQueue({
      components,
      packOrderStrategy,
      packFirst
    });
    this.packedComponents = [];
  }
  packFirstComponent() {
    const firstComponentToPack = this.unpackedComponentQueue.shift();
    let initialPosition = { x: 0, y: 0 };
    if (this.packInput.boundaryOutline && this.packInput.boundaryOutline.length >= 3) {
      initialPosition = getPolygonCentroid(this.packInput.boundaryOutline);
    }
    const newPackedComponent = {
      ...firstComponentToPack,
      center: initialPosition,
      ccwRotationOffset: 0,
      pads: firstComponentToPack.pads.map((p) => ({
        ...p,
        absoluteCenter: { x: 0, y: 0 }
      }))
    };
    setPackedComponentPadCenters(newPackedComponent);
    const obstacles = this.packInput.obstacles ?? [];
    const tooCloseToObstacles = obstacles.some((obs) => {
      const obsBox = {
        center: { x: obs.absoluteCenter.x, y: obs.absoluteCenter.y },
        width: obs.width,
        height: obs.height
      };
      return newPackedComponent.pads.some((p) => {
        const padBox = {
          center: { x: p.absoluteCenter.x, y: p.absoluteCenter.y },
          width: p.size.x,
          height: p.size.y
        };
        const { distance } = computeDistanceBetweenBoxes3(padBox, obsBox);
        return distance + 1e-6 < this.packInput.minGap;
      });
    });
    let outsideBoundaryOutline = false;
    if (this.packInput.boundaryOutline && this.packInput.boundaryOutline.length >= 3) {
      const componentBounds = getComponentBounds(newPackedComponent, 0);
      const allPadsInside = newPackedComponent.pads.every(
        (pad) => isPointInPolygon(pad.absoluteCenter, this.packInput.boundaryOutline)
      );
      const cornersInside = [
        { x: componentBounds.minX, y: componentBounds.minY },
        { x: componentBounds.minX, y: componentBounds.maxY },
        { x: componentBounds.maxX, y: componentBounds.minY },
        { x: componentBounds.maxX, y: componentBounds.maxY }
      ].every(
        (corner) => isPointInPolygon(corner, this.packInput.boundaryOutline)
      );
      outsideBoundaryOutline = !allPadsInside || !cornersInside;
    }
    if (!tooCloseToObstacles && !outsideBoundaryOutline) {
      this.packedComponents.push(newPackedComponent);
      return;
    }
    const fallbackSolver = new SingleComponentPackSolver({
      packedComponents: [],
      componentToPack: firstComponentToPack,
      packPlacementStrategy: this.packInput.packPlacementStrategy,
      minGap: this.packInput.minGap,
      obstacles,
      bounds: this.packInput.bounds,
      boundaryOutline: this.packInput.boundaryOutline
    });
    fallbackSolver.solve();
    const result = fallbackSolver.getResult();
    if (result) {
      this.packedComponents.push(result);
    } else {
      this.packedComponents.push(newPackedComponent);
    }
  }
  _step() {
    if (this.solved || this.failed) return;
    if (this.packedComponents.length === 0) {
      if (this.unpackedComponentQueue.length === 0) {
        this.solved = true;
        return;
      }
      this.packFirstComponent();
      return;
    }
    if (!this.activeSubSolver) {
      if (this.unpackedComponentQueue.length === 0) {
        this.solved = true;
        return;
      }
      this.componentToPack = this.unpackedComponentQueue.shift();
      if (!this.componentToPack) {
        this.solved = true;
        return;
      }
      this.activeSubSolver = new SingleComponentPackSolver({
        packedComponents: this.packedComponents,
        componentToPack: this.componentToPack,
        packPlacementStrategy: this.packInput.packPlacementStrategy,
        minGap: this.packInput.minGap,
        obstacles: this.packInput.obstacles ?? [],
        bounds: this.packInput.bounds,
        boundaryOutline: this.packInput.boundaryOutline
      });
      this.activeSubSolver.setup();
    }
    this.activeSubSolver.step();
    if (this.activeSubSolver.failed) {
      this.failed = true;
      return;
    }
    if (this.activeSubSolver.solved) {
      const result = this.activeSubSolver.getResult();
      if (result) {
        this.packedComponents.push(result);
      } else {
        const packedComponent = {
          ...this.componentToPack,
          center: { x: 0, y: 0 },
          ccwRotationOffset: 0,
          pads: this.componentToPack.pads.map((p) => ({
            ...p,
            absoluteCenter: { x: 0, y: 0 }
          }))
        };
        setPackedComponentPadCenters(packedComponent);
        this.packedComponents.push(packedComponent);
      }
      this.componentToPack = void 0;
      this.activeSubSolver = void 0;
    }
  }
  visualize() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.visualize();
    }
    const graphics = {
      coordinateSystem: "cartesian",
      title: "Pack Solver 2",
      points: [],
      lines: [],
      rects: [],
      circles: [],
      texts: []
    };
    if (this.packInput.obstacles && this.packInput.obstacles.length > 0) {
      for (const obstacle of this.packInput.obstacles) {
        graphics.rects.push({
          center: obstacle.absoluteCenter,
          width: obstacle.width,
          height: obstacle.height,
          fill: "rgba(0,0,0,0.1)",
          stroke: "#555",
          label: obstacle.obstacleId
        });
      }
    }
    if (this.packInput.bounds) {
      graphics.lines.push({
        points: [
          { x: this.packInput.bounds.minX, y: this.packInput.bounds.minY },
          { x: this.packInput.bounds.minX, y: this.packInput.bounds.maxY },
          { x: this.packInput.bounds.maxX, y: this.packInput.bounds.maxY },
          { x: this.packInput.bounds.maxX, y: this.packInput.bounds.minY },
          { x: this.packInput.bounds.minX, y: this.packInput.bounds.minY }
        ],
        strokeColor: "rgba(0,0,0,0.5)",
        strokeDash: "2 2"
      });
    }
    if (this.packInput.boundaryOutline && this.packInput.boundaryOutline.length) {
      const points = [...this.packInput.boundaryOutline];
      if (points.length > 0 && (points[0].x !== points[points.length - 1].x || points[0].y !== points[points.length - 1].y)) {
        points.push({ ...points[0] });
      }
      graphics.lines.push({
        points,
        strokeColor: "rgba(0, 0, 255, 0.5)",
        strokeDash: "4 2"
      });
    }
    if (this.packedComponents.length === 0) {
      for (const component of this.unpackedComponentQueue) {
        for (const pad of component.pads) {
          graphics.rects.push({
            center: { x: 0, y: 0 },
            width: pad.size.x,
            height: pad.size.y,
            fill: "rgba(0,0,0,0.1)"
          });
        }
      }
    }
    const allPads = this.packedComponents.flatMap((c) => c.pads);
    const networkToPadMap = /* @__PURE__ */ new Map();
    for (const pad of allPads) {
      if (pad.networkId) {
        networkToPadMap.set(pad.networkId, [
          ...networkToPadMap.get(pad.networkId) || [],
          pad
        ]);
      }
    }
    for (const pad of allPads) {
      graphics.rects.push({
        center: pad.absoluteCenter,
        width: pad.size.x,
        height: pad.size.y,
        fill: "rgba(255,0,0,0.5)"
      });
    }
    for (const [networkId, pads] of networkToPadMap.entries()) {
      for (let i = 0; i < pads.length; i++) {
        for (let j = i + 1; j < pads.length; j++) {
          const pad1 = pads[i];
          const pad2 = pads[j];
          graphics.lines.push({
            points: [pad1.absoluteCenter, pad2.absoluteCenter],
            strokeColor: getColorForString(networkId, 0.5)
          });
        }
      }
    }
    return graphics;
  }
};

// lib/pack.ts
var pack = (input) => {
  const solver = new PackSolver2(input);
  solver.solve();
  return {
    ...input,
    components: solver.packedComponents
  };
};

// lib/plumbing/convertCircuitJsonToPackOutput.ts
import { cju, getCircuitJsonTree } from "@tscircuit/circuit-json-util";

// lib/plumbing/extractPadInfos.ts
var extractPadInfos = (pcbComponent, db, getNetworkId) => {
  const out = [];
  const pushPad = ({
    padId,
    pcbPortId,
    sx,
    sy,
    x,
    y
  }) => out.push({
    padId,
    networkId: getNetworkId(pcbPortId),
    size: { x: sx, y: sy },
    absoluteCenter: { x, y }
  });
  for (const ph of db.pcb_plated_hole.list({
    pcb_component_id: pcbComponent.pcb_component_id
  })) {
    switch (ph.shape) {
      case "circle": {
        pushPad({
          padId: ph.pcb_plated_hole_id,
          pcbPortId: ph.pcb_port_id,
          sx: ph.outer_diameter ?? ph.hole_diameter ?? 0,
          sy: ph.outer_diameter ?? ph.hole_diameter ?? 0,
          x: ph.x,
          y: ph.y
        });
        break;
      }
      case "oval": {
        pushPad({
          padId: ph.pcb_plated_hole_id,
          pcbPortId: ph.pcb_port_id,
          sx: ph.outer_width,
          sy: ph.outer_height,
          x: ph.x,
          y: ph.y
        });
        break;
      }
      case "circular_hole_with_rect_pad": {
        pushPad({
          padId: ph.pcb_plated_hole_id,
          pcbPortId: ph.pcb_port_id,
          sx: ph.rect_pad_width,
          sy: ph.rect_pad_height,
          x: ph.x,
          y: ph.y
        });
        break;
      }
      case "pill": {
        pushPad({
          padId: ph.pcb_plated_hole_id,
          pcbPortId: ph.pcb_port_id,
          sx: ph.outer_width,
          sy: ph.outer_height,
          x: ph.x,
          y: ph.y
        });
        break;
      }
      case "pill_hole_with_rect_pad": {
        pushPad({
          padId: ph.pcb_plated_hole_id,
          pcbPortId: ph.pcb_port_id,
          sx: ph.rect_pad_width,
          sy: ph.rect_pad_height,
          x: ph.x,
          y: ph.y
        });
        break;
      }
      default: {
        console.warn(`Unsupported plated hole shape ${ph.shape}`);
        break;
      }
    }
  }
  for (const sp of db.pcb_smtpad.list({
    pcb_component_id: pcbComponent.pcb_component_id
  })) {
    switch (sp.shape) {
      case "rect": {
        pushPad({
          padId: sp.pcb_smtpad_id,
          pcbPortId: sp.pcb_port_id,
          sx: sp.width ?? 0,
          sy: sp.height ?? 0,
          x: sp.x,
          y: sp.y
        });
        break;
      }
      case "circle": {
        pushPad({
          padId: sp.pcb_smtpad_id,
          pcbPortId: sp.pcb_port_id,
          sx: sp.radius ?? 0,
          sy: sp.radius ?? 0,
          x: sp.x,
          y: sp.y
        });
        break;
      }
      case "pill": {
        pushPad({
          padId: sp.pcb_smtpad_id,
          pcbPortId: sp.pcb_port_id,
          sx: sp.width ?? 0,
          sy: sp.height ?? 0,
          x: sp.x,
          y: sp.y
        });
        break;
      }
      default: {
        console.warn(
          `smtpad shape ${sp.shape} pads are not supported in pack layout yet`
        );
        break;
      }
    }
  }
  return out;
};

// lib/plumbing/convertCircuitJsonToPackOutput.ts
var buildPackedComponent = (pcbComponents, componentId, db, getNetworkId, shouldAddInnerObstacles, chipMarginsMap = {}) => {
  const padInfos = pcbComponents.flatMap((pc) => {
    const pads2 = extractPadInfos(pc, db, getNetworkId);
    const margins = chipMarginsMap[pc.pcb_component_id];
    if (!margins) return pads2;
    return pads2.map((p) => ({
      ...p,
      size: {
        x: p.size.x + margins.left + margins.right,
        y: p.size.y + margins.top + margins.bottom
      },
      absoluteCenter: {
        x: p.absoluteCenter.x + (margins.right - margins.left) / 2,
        y: p.absoluteCenter.y + (margins.top - margins.bottom) / 2
      }
    }));
  });
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const p of padInfos) {
    minX = Math.min(minX, p.absoluteCenter.x - p.size.x / 2);
    maxX = Math.max(maxX, p.absoluteCenter.x + p.size.x / 2);
    minY = Math.min(minY, p.absoluteCenter.y - p.size.y / 2);
    maxY = Math.max(maxY, p.absoluteCenter.y + p.size.y / 2);
  }
  const center = { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
  const pads = padInfos.map((p) => ({
    padId: p.padId,
    networkId: p.networkId,
    type: "rect",
    size: p.size,
    absoluteCenter: p.absoluteCenter,
    offset: {
      x: p.absoluteCenter.x - center.x,
      y: p.absoluteCenter.y - center.y
    }
  }));
  if (shouldAddInnerObstacles) {
    const innerPad = {
      padId: `${componentId}-inner`,
      networkId: `${componentId}-inner`,
      type: "rect",
      size: { x: maxX - minX, y: maxY - minY },
      absoluteCenter: center,
      offset: { x: 0, y: 0 }
    };
    pads.push(innerPad);
  }
  return {
    componentId,
    center,
    ccwRotationOffset: 0,
    pads
  };
};
var collectPcbComponents = (node, db) => {
  if (node.nodeType === "component") {
    const pcbId = node.otherChildElements[0]?.pcb_component_id;
    return pcbId ? [db.pcb_component.get(pcbId)] : [];
  }
  return node.childNodes.flatMap((n) => collectPcbComponents(n, db));
};
var convertCircuitJsonToPackOutput = (circuitJson, opts = {}) => {
  const packOutput = {
    components: [],
    minGap: 0,
    packOrderStrategy: "largest_to_smallest",
    packPlacementStrategy: "shortest_connection_along_outline",
    obstacles: opts.obstacles
  };
  const tree = getCircuitJsonTree(circuitJson, {
    source_group_id: opts.source_group_id
  });
  const db = cju(circuitJson);
  let unnamedCounter = 0;
  const pcbBoard = circuitJson.find(
    (item) => item.type === "pcb_board"
  );
  if (pcbBoard && pcbBoard.outline) {
    packOutput.boundaryOutline = pcbBoard.outline;
  }
  const getNetworkId = (pcbPortId) => {
    if (pcbPortId) {
      const pcbPort = db.pcb_port.get(pcbPortId);
      if (pcbPort) {
        const sourcePort = db.source_port.get(pcbPort.source_port_id);
        if (sourcePort?.subcircuit_connectivity_map_key) {
          return sourcePort.subcircuit_connectivity_map_key;
        }
      }
    }
    return `unnamed${unnamedCounter++}`;
  };
  const topLevelNodes = tree.childNodes ?? [];
  for (const node of topLevelNodes) {
    if (node.nodeType === "component") {
      const pcbComponent = node.otherChildElements.find(
        (e) => e.type === "pcb_component"
      );
      if (!pcbComponent) continue;
      let shouldAddInnerObstaclesForComp = opts.shouldAddInnerObstacles;
      if (pcbComponent.obstructs_within_bounds === false) {
        shouldAddInnerObstaclesForComp = false;
      }
      packOutput.components.push(
        buildPackedComponent(
          [pcbComponent],
          pcbComponent.pcb_component_id,
          db,
          getNetworkId,
          shouldAddInnerObstaclesForComp,
          opts.chipMarginsMap
        )
      );
    } else if (node.nodeType === "group") {
      const pcbComps = collectPcbComponents(node, db);
      if (!pcbComps.length) continue;
      const compId = node.sourceGroup?.source_group_id ?? node.sourceGroup?.name ?? `group_${packOutput.components.length}`;
      packOutput.components.push(
        buildPackedComponent(
          pcbComps,
          compId,
          db,
          getNetworkId,
          void 0,
          opts.chipMarginsMap
        )
      );
    }
  }
  return packOutput;
};

// lib/plumbing/convertPackOutputToPackInput.ts
var convertPackOutputToPackInput = (packed) => {
  const strippedComponents = packed.components.map((pc) => ({
    componentId: pc.componentId,
    availableRotationDegrees: pc.availableRotationDegrees,
    // Preserve rotation constraints
    pads: pc.pads.map(({ absoluteCenter: _ac, ...rest }) => rest)
  }));
  return {
    ...packed,
    // overwrite the components field with strippedComponents
    components: strippedComponents
  };
};
export {
  LargestRectOutsideOutlineFromPointSolver,
  PackSolver2,
  convertCircuitJsonToPackOutput,
  convertPackOutputToPackInput,
  getGraphicsFromPackOutput,
  pack
};
