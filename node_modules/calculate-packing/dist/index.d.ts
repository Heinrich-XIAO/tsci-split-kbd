import { CircuitJson } from 'circuit-json';
import { GraphicsObject, Point as Point$3 } from 'graphics-debug';
import { Bounds, Point as Point$2 } from '@tscircuit/math-utils';

type ComponentId = string;
type PadId = string;
type NetworkId = string;
interface InputPad {
    padId: string;
    networkId: string;
    type: "rect";
    offset: {
        x: number;
        y: number;
    };
    size: {
        x: number;
        y: number;
    };
}
interface OutputPad extends InputPad {
    absoluteCenter: {
        x: number;
        y: number;
    };
}
interface InputComponent {
    componentId: string;
    /**
     * If not provided, the component can be rotated by 0, 90, 180, or 270 degrees.
     */
    availableRotationDegrees?: number[];
    pads: InputPad[];
}
interface PackedComponent extends InputComponent {
    center: {
        x: number;
        y: number;
    };
    /** @deprecated Rotation in degrees (counterclockwise) */
    ccwRotationOffset: number;
    /** Rotation in degrees (counterclockwise) - output field */
    ccwRotationDegrees?: number;
    pads: OutputPad[];
}
interface InputObstacle {
    obstacleId: string;
    absoluteCenter: {
        x: number;
        y: number;
    };
    width: number;
    height: number;
}
type PackPlacementStrategy = "shortest_connection_along_outline" | "minimum_sum_distance_to_network" | "minimum_sum_squared_distance_to_network" | "minimum_closest_sum_squared_distance";
interface PackInput {
    components: InputComponent[];
    obstacles?: InputObstacle[];
    bounds?: {
        minX: number;
        minY: number;
        maxX: number;
        maxY: number;
    };
    boundaryOutline?: Array<{
        x: number;
        y: number;
    }>;
    minGap: number;
    packOrderStrategy: "largest_to_smallest";
    packPlacementStrategy: PackPlacementStrategy;
    disconnectedPackDirection?: "left" | "right" | "up" | "down" | "nearest_to_center";
    packFirst?: ComponentId[];
}
interface PackOutput extends PackInput {
    components: PackedComponent[];
}

/**
 * The pack algorithm performs the following steps:
 * 1. Sort the components using the packOrderStrategy
 * 2. Select the next component to pack
 * 3. If the first component, pack at center (0,0) and go to step 2
 * 4. Compute the outline of all packed components with a gap of minGap + max(pad.width, pad.height)/2
 * 5. Find the point along the outline that minimizes the distance of the pad
 *    centers within a networkId. If no shared pads, pack to the defaultPackDirection
 * 6. Add the component at the selected point, with it's pad at the position
 *    minimizing the distance between the pad centers
 * 7. To determine the component rotation, find the minimum distance between pad
 *    centers for the remaining pads at each possible rotation (making sure that
 *    we never pack such that two pads overlap)
 * 8. Go to step 2 until all components are packed
 */
declare const pack: (input: PackInput) => PackOutput;

declare const convertCircuitJsonToPackOutput: (circuitJson: CircuitJson, opts?: {
    source_group_id?: string;
    shouldAddInnerObstacles?: boolean;
    chipMarginsMap?: Record<string, {
        left: number;
        right: number;
        top: number;
        bottom: number;
    }>;
    obstacles?: InputObstacle[];
}) => PackOutput;

declare const getGraphicsFromPackOutput: (packOutput: PackOutput) => GraphicsObject;

/**
 * Strip all “output only” properties (those added by the pack() solver)
 * so the result can be fed back into pack() again or compared against an
 * original PackInput.  Everything else must be preserved verbatim.
 *
 * NOTE:
 * – PackInput.components is an array of **InputComponent**,
 *   while PackOutput.components is an array of **PackedComponent**.
 *   We therefore have to:
 *     • copy componentId
 *     • copy each pad but drop `absoluteCenter`
 *     • drop `center` and `ccwRotationOffset`
 */
declare const convertPackOutputToPackInput: (packed: PackOutput) => PackInput;

declare class BaseSolver {
    MAX_ITERATIONS: number;
    solved: boolean;
    failed: boolean;
    iterations: number;
    progress: number;
    error: string | null;
    activeSubSolver?: BaseSolver | null;
    failedSubSolvers?: BaseSolver[];
    timeToSolve?: number;
    stats: Record<string, any>;
    _setupDone: boolean;
    setup(): void;
    /** DO NOT OVERRIDE! Override _step() instead */
    step(): void;
    _setup(): void;
    _step(): void;
    getConstructorParams(): void;
    solve(): void;
    visualize(): GraphicsObject;
    /**
     * Called when the solver is about to fail, but we want to see if we have an
     * "acceptable" or "passable" solution. Mostly used for optimizers that
     * have an aggressive early stopping criterion.
     */
    tryFinalAcceptance(): void;
    /**
     * A lightweight version of the visualize method that can be used to stream
     * progress
     */
    preview(): GraphicsObject;
    noisySolve(): void;
}

type Point$1 = {
    x: number;
    y: number;
};
type Segment = [Point$1, Point$1];

type Rect = {
    x: number;
    y: number;
    w: number;
    h: number;
};

type GlobalBounds = Bounds;
declare class LargestRectOutsideOutlineFromPointSolver extends BaseSolver {
    fullOutline: Point$1[];
    origin: Point$1;
    globalBounds: Bounds;
    largestRect: Rect | null;
    constructor(params: {
        fullOutline: Point$1[];
        origin: Point$1;
        globalBounds: Bounds;
    });
    getConstructorParams(): {
        fullOutline: Point$1[];
        origin: Point$1;
        globalBounds: Bounds;
    };
    _setup(): void;
    _step(): void;
    private computeLargestRectOutside;
    private almostEqual;
    private makeEdges;
    private isVertical;
    private isHorizontal;
    private scanlineIntervalsAtY;
    private clipIntervals;
    private regionIntervalsAtY;
    private largestRectContainingPointRegion;
    getLargestRect(): Rect | null;
    getLargestRectBounds(): Bounds;
    visualize(): GraphicsObject;
}

interface Point {
    x: number;
    y: number;
}
interface PointWithNetworkId extends Point {
    networkId?: string;
}
interface OffsetPadPoint {
    id: string;
    offsetX: number;
    offsetY: number;
}
interface MultiOffsetIrlsSolverParams {
    /** Offset pad points relative to the current position */
    offsetPadPoints: OffsetPadPoint[];
    /** Map from offset pad ID to array of target points it should minimize distance to */
    targetPointMap: Map<string, Point[]>;
    /** Initial position for the algorithm */
    initialPosition: Point;
    /** Optional constraint function that maps a point to the nearest valid position */
    constraintFn?: (point: Point) => Point;
    /** Convergence tolerance */
    epsilon?: number;
    /** Maximum iterations before giving up */
    maxIterations?: number;
    /** Whether to use squared distances (for sum of squared distances optimization) */
    useSquaredDistance?: boolean;
}
/**
 * Multi-Offset IRLS (Iteratively Reweighted Least Squares) Solver
 * Extends the Weiszfeld algorithm to optimize a single position that minimizes
 * the total distance from multiple offset pad points to their assigned target points.
 *
 * The offset pad points are positioned relative to the current position, and the
 * algorithm finds the optimal position that minimizes the sum of distances from
 * each offset pad to its assigned target points.
 */
declare class MultiOffsetIrlsSolver extends BaseSolver {
    offsetPadPoints: OffsetPadPoint[];
    targetPointMap: Map<string, PointWithNetworkId[]>;
    currentPosition: Point;
    constraintFn?: (point: Point) => Point;
    epsilon: number;
    useSquaredDistance: boolean;
    optimalPosition?: Point;
    private readonly initialPosition;
    constructor(params: MultiOffsetIrlsSolverParams);
    getConstructorParams(): MultiOffsetIrlsSolverParams;
    _setup(): void;
    _step(): void;
    /**
     * Get the current best position
     */
    getBestPosition(): Point;
    /**
     * Get the current absolute positions for all offset pad points
     */
    getOffsetPadPositions(): Map<string, Point>;
    /**
     * Get the absolute position for a specific offset pad point
     */
    getOffsetPadPosition(padId: string): Point | undefined;
    /**
     * Calculate total distance from current position to all assigned target points
     */
    getTotalDistance(position?: Point): number;
    /**
     * Calculate total distance for a specific offset pad point
     */
    getDistanceForPad(padId: string, position?: Point): number;
    computeProgress(): number;
    visualize(): GraphicsObject;
}

interface TwoPhaseIrlsSolverParams extends Omit<MultiOffsetIrlsSolverParams, "useSquaredDistance"> {
    /** Phase 1 convergence tolerance */
    phase1Epsilon?: number;
    /** Phase 2 convergence tolerance */
    phase2Epsilon?: number;
}
/**
 * Two-Phase IRLS Solver that implements the "minimum_closest_sum_squared_distance" strategy.
 *
 * Phase 1: Solves for minimum sum squared distance (like regular squared distance optimization)
 * Phase 2: From the Phase 1 solution, finds the closest point to any target and optimizes
 *          to minimize JUST the distance to that single closest point
 */
declare class TwoPhaseIrlsSolver extends BaseSolver {
    offsetPadPoints: MultiOffsetIrlsSolverParams["offsetPadPoints"];
    targetPointMap: MultiOffsetIrlsSolverParams["targetPointMap"];
    constraintFn?: MultiOffsetIrlsSolverParams["constraintFn"];
    currentPosition: {
        x: number;
        y: number;
    };
    optimalPosition?: {
        x: number;
        y: number;
    };
    private readonly initialPosition;
    private readonly phase1Epsilon;
    private readonly phase2Epsilon;
    private readonly maxIterations;
    private phase1Solver?;
    private phase2Solver?;
    private currentPhase;
    private phase1Position?;
    private closestTargetPadId?;
    private closestTargetPoint?;
    constructor(params: TwoPhaseIrlsSolverParams);
    getConstructorParams(): TwoPhaseIrlsSolverParams;
    _setup(): void;
    _step(): void;
    private stepPhase1;
    private setupPhase2;
    private stepPhase2;
    /**
     * Get the current best position
     */
    getBestPosition(): {
        x: number;
        y: number;
    };
    /**
     * Get the current absolute positions for all offset pad points
     */
    getOffsetPadPositions(): Map<string, {
        x: number;
        y: number;
    }>;
    /**
     * Calculate total distance from current position to all assigned target points
     */
    getTotalDistance(position?: {
        x: number;
        y: number;
    }): number;
    visualize(): GraphicsObject;
}

/**
 * Given a single segment on the outline, the component's rotation, compute the
 * optimal position for the rotated component (the position that minimizes the
 * packStrategy, generally minimizing the sum of the distances to other pads in
 * the network)
 *
 * To do this, we use the IRLS/Weiszfeld Weighted Least Squares algorithm, look
 * at the site/algorithm-visualizations/irls-weiszfeld-algorithm.page.tsx for
 * an interactive visualization of how it works.
 */
declare class OutlineSegmentCandidatePointSolver extends BaseSolver {
    outlineSegment: [Point$2, Point$2];
    viableOutlineSegment: [Point$2, Point$2] | null;
    fullOutline: [Point$2, Point$2][];
    componentRotationDegrees: number;
    packStrategy: PackPlacementStrategy;
    minGap: number;
    obstacles: InputObstacle[];
    packedComponents: PackedComponent[];
    componentToPack: InputComponent;
    viableBounds?: Bounds;
    globalBounds?: Bounds;
    boundaryOutline?: Array<{
        x: number;
        y: number;
    }>;
    optimalPosition?: Point$2;
    irlsSolver?: MultiOffsetIrlsSolver;
    twoPhaseIrlsSolver?: TwoPhaseIrlsSolver;
    constructor(params: {
        outlineSegment: [Point$2, Point$2];
        fullOutline: [Point$2, Point$2][];
        componentRotationDegrees: number;
        packStrategy: PackPlacementStrategy;
        minGap: number;
        packedComponents: PackedComponent[];
        componentToPack: InputComponent;
        obstacles?: InputObstacle[];
        globalBounds?: Bounds;
        boundaryOutline?: Array<{
            x: number;
            y: number;
        }>;
    });
    getConstructorParams(): ConstructorParameters<typeof OutlineSegmentCandidatePointSolver>[0];
    _getOutlineBoundsWithMargin(params?: {
        margin?: number;
    }): Bounds;
    _setup(): void;
    _step(): void;
    /**
     * Get pad offset points and target point mappings for network connections
     */
    private getNetworkTargetPointMappings;
    /**
     * Project a point onto the outline segment
     */
    private projectPointOntoSegment;
    /**
     * Get rotated pads for the component being placed
     */
    private getRotatedComponentPads;
    /**
     * Create a temporary PackedComponent with the given center position and applied rotation
     */
    private createTemporaryPackedComponent;
    /**
     * Adjust position to avoid component bounds crossing to the inside of the outline
     * and ensure the component stays within the boundary outline
     */
    private adjustPositionForOutlineCollision;
    visualize(): GraphicsObject;
}

type Phase = "outline" | "segment_candidate" | "evaluate";
interface QueuedOutlineSegment {
    segment: Segment;
    availableRotations: number[];
    segmentIndex: number;
    fullOutline: Segment[];
}
interface CandidateResult {
    segment: Segment;
    rotation: number;
    optimalPosition?: Point$3;
    distance: number;
    segmentIndex: number;
    rotationIndex: number;
}
/**
 * Packs a single component given a set of already packed components.
 *
 * Runs subsolvers and operates in several phases:
 * Phase 1: Compute outline (visualization shows outline)
 * Phase 2: Compute candidate point for each segment by finding the optimal
 *          point on each segment of the outline for each rotation-segment pair.
 *          (visualization shows candidate point for active segment using the
 *           visualize method of the OutlineSegmentCandidatePointSolver)
 * Phase 3: Score the points. Show the points in visualization with a "step"
 *          where step=0 is the best point (lowest distance) and step=N is the
 *          worst point.
 */
declare class SingleComponentPackSolver extends BaseSolver {
    componentToPack: InputComponent;
    packedComponents: PackedComponent[];
    packPlacementStrategy: PackPlacementStrategy;
    minGap: number;
    obstacles: InputObstacle[];
    boundaryOutline?: Array<{
        x: number;
        y: number;
    }>;
    currentPhase: Phase;
    outlines: Segment[][];
    queuedOutlineSegments: QueuedOutlineSegment[];
    currentSegmentIndex: number;
    currentRotationIndex: number;
    activeSubSolver?: OutlineSegmentCandidatePointSolver | null;
    candidateResults: CandidateResult[];
    rejectedCandidates: Array<CandidateResult & {
        gapDistance: number;
    }>;
    bestCandidate?: CandidateResult;
    outputPackedComponent?: PackedComponent;
    bounds?: Bounds;
    constructor(params: {
        componentToPack: InputComponent;
        packedComponents: PackedComponent[];
        packPlacementStrategy: PackPlacementStrategy;
        minGap?: number;
        obstacles?: InputObstacle[];
        bounds?: Bounds;
        boundaryOutline?: Array<{
            x: number;
            y: number;
        }>;
    });
    _setup(): void;
    _step(): void;
    private executeOutlinePhase;
    private executeSegmentCandidatePhase;
    private executeEvaluatePhase;
    private calculateDistance;
    private createPackedComponent;
    visualize(): GraphicsObject;
    private visualizeOutlinePhase;
    private visualizeSegmentCandidatePhase;
    private visualizeEvaluatePhase;
    getResult(): PackedComponent | undefined;
    getConstructorParams(): {
        componentToPack: InputComponent;
        packedComponents: PackedComponent[];
        packPlacementStrategy: PackPlacementStrategy;
        minGap: number;
        obstacles: InputObstacle[];
        bounds: Bounds | undefined;
        boundaryOutline: {
            x: number;
            y: number;
        }[] | undefined;
    };
}

declare class PackSolver2 extends BaseSolver {
    activeSubSolver: SingleComponentPackSolver | null | undefined;
    packInput: PackInput;
    unpackedComponentQueue: InputComponent[];
    packedComponents: PackedComponent[];
    componentToPack?: InputComponent | null | undefined;
    constructor(packInput: PackInput);
    getConstructorParams(): PackInput;
    _setup(): void;
    private packFirstComponent;
    _step(): void;
    visualize(): GraphicsObject;
}

export { type ComponentId, type GlobalBounds, type InputComponent, type InputObstacle, type InputPad, LargestRectOutsideOutlineFromPointSolver, type NetworkId, type OutputPad, type PackInput, type PackOutput, type PackPlacementStrategy, PackSolver2, type PackedComponent, type PadId, type Point$1 as Point, type Rect, convertCircuitJsonToPackOutput, convertPackOutputToPackInput, getGraphicsFromPackOutput, pack };
