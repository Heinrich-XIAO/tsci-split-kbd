// lib/index.ts
import jscad from "@jscad/modeling";
import { executeJscadOperations } from "jscad-planner";
import { Buffer } from "buffer";
var GLTF_MODE_TRIANGLES = 4;
var GLTF_MODE_LINES = 1;
var GLTF_COMPONENT_FLOAT = 5126;
var GLTF_TYPE_VEC3 = "VEC3";
var align = (value, multiple) => {
  const remainder = value % multiple;
  return remainder === 0 ? value : value + multiple - remainder;
};
var toColorTuple = (value, fallback) => {
  if (Array.isArray(value) && value.length >= 3) {
    const r = Number(value[0]);
    const g = Number(value[1]);
    const b = Number(value[2]);
    return [
      Number.isFinite(r) ? r : fallback[0],
      Number.isFinite(g) ? g : fallback[1],
      Number.isFinite(b) ? b : fallback[2]
    ];
  }
  return fallback;
};
var normalizeColorChannel = (value) => {
  if (!Number.isFinite(value)) return 0;
  if (value < 0) return 0;
  if (value > 1) return Math.min(value / 255, 1);
  return value;
};
var parseColorArray = (value) => {
  if (!Array.isArray(value) || value.length < 3) return void 0;
  const r = normalizeColorChannel(Number(value[0]));
  const g = normalizeColorChannel(Number(value[1]));
  const b = normalizeColorChannel(Number(value[2]));
  if ([r, g, b].some((channel) => !Number.isFinite(channel))) return void 0;
  return [r, g, b];
};
var parseHexColor = (value) => {
  const hex = value.slice(1);
  const isShort = hex.length === 3;
  const isLong = hex.length === 6 || hex.length === 8;
  if (!isShort && !isLong) return void 0;
  const expand = (component) => isShort ? component + component : component;
  const components = [0, 1, 2].map((index) => {
    const start = index * (isShort ? 1 : 2);
    const part = expand(hex.slice(start, start + (isShort ? 1 : 2)));
    const parsed = parseInt(part, 16);
    if (Number.isNaN(parsed)) return void 0;
    return normalizeColorChannel(parsed);
  });
  if (components.some((channel) => channel === void 0)) return void 0;
  return components;
};
var parseRgbColor = (value) => {
  const match = value.match(/^rgba?\(([^)]+)\)$/i);
  if (!match) return void 0;
  const partsSource = match[1];
  if (!partsSource) return void 0;
  const parts = partsSource.split(",").map((part) => part.trim()).filter(Boolean);
  if (parts.length < 3) return void 0;
  const toChannel = (part) => {
    if (part.endsWith("%")) {
      const percent = Number(part.slice(0, -1));
      if (!Number.isFinite(percent)) return void 0;
      return Math.min(Math.max(percent / 100, 0), 1);
    }
    const numeric = Number(part);
    if (!Number.isFinite(numeric)) return void 0;
    return normalizeColorChannel(numeric);
  };
  const channels = parts.slice(0, 3).map(toChannel);
  if (channels.some((channel) => channel === void 0)) return void 0;
  return channels;
};
var namedColors = {
  red: "#ff0000",
  green: "#008000",
  blue: "#0000ff",
  black: "#000000",
  white: "#ffffff",
  gray: "#808080",
  grey: "#808080",
  yellow: "#ffff00",
  cyan: "#00ffff",
  magenta: "#ff00ff",
  orange: "#ffa500",
  pink: "#ffc0cb",
  purple: "#800080",
  brown: "#a52a2a"
};
var parseColorValue = (value) => {
  if (value == null) return void 0;
  const fromArray = parseColorArray(value);
  if (fromArray) return fromArray;
  if (typeof value === "string") {
    const trimmed = value.trim().toLowerCase();
    if (!trimmed) return void 0;
    const named = namedColors[trimmed];
    if (named) return parseHexColor(named);
    if (/^[0-9a-f]{3,8}$/i.test(trimmed)) {
      return parseHexColor("#" + trimmed);
    }
    if (trimmed.startsWith("#")) {
      return parseHexColor(trimmed);
    }
    return parseRgbColor(trimmed);
  }
  return void 0;
};
var extractVertexPosition = (vertex) => {
  if (!vertex) return [0, 0, 0];
  if (Array.isArray(vertex) && vertex.length >= 3) {
    return [
      Number(vertex[0]) || 0,
      Number(vertex[1]) || 0,
      Number(vertex[2]) || 0
    ];
  }
  if (vertex.pos && Array.isArray(vertex.pos) && vertex.pos.length >= 3) {
    return [
      Number(vertex.pos[0]) || 0,
      Number(vertex.pos[1]) || 0,
      Number(vertex.pos[2]) || 0
    ];
  }
  if (Array.isArray(vertex.position) && vertex.position.length >= 3) {
    return [
      Number(vertex.position[0]) || 0,
      Number(vertex.position[1]) || 0,
      Number(vertex.position[2]) || 0
    ];
  }
  return [0, 0, 0];
};
var extractVertexColor = (vertex, defaultColor) => {
  if (vertex?.color) return toColorTuple(vertex.color, defaultColor);
  return defaultColor;
};
var applyTransform = (vector, matrix) => {
  if (!Array.isArray(matrix) || matrix.length !== 16) return vector;
  const m = matrix;
  const [x, y, z] = vector;
  const nx = m[0] * x + m[4] * y + m[8] * z + m[12];
  const ny = m[1] * x + m[5] * y + m[9] * z + m[13];
  const nz = m[2] * x + m[6] * y + m[10] * z + m[14];
  const w = m[3] * x + m[7] * y + m[11] * z + m[15];
  if (w && w !== 1) {
    return [nx / w, ny / w, nz / w];
  }
  return [nx, ny, nz];
};
var subtract = (a, b) => [
  a[0] - b[0],
  a[1] - b[1],
  a[2] - b[2]
];
var cross = (a, b) => [
  a[1] * b[2] - a[2] * b[1],
  a[2] * b[0] - a[0] * b[2],
  a[0] * b[1] - a[1] * b[0]
];
var normalize = (v) => {
  const length = Math.hypot(v[0], v[1], v[2]);
  if (!length) return [0, 0, 1];
  return [v[0] / length, v[1] / length, v[2] / length];
};
var AXIS_TRANSFORM_MATRICES = {
  "jscad_y+ -> gltf_z+": [
    // Rotate +90Â° around X-axis: Y becomes -Z, Z becomes Y
    1,
    0,
    0,
    0,
    0,
    0,
    -1,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1
  ],
  none: null
};
var applyAxisTransform = (vector, axisTransform) => {
  const matrix = AXIS_TRANSFORM_MATRICES[axisTransform];
  if (!matrix) return vector;
  return applyTransform(vector, matrix);
};
var convertPolygonGeometry = (csg, name, axisTransform = "none") => {
  if (!csg.polygons || csg.polygons.length === 0) {
    throw new Error("Expected polygon data in JSCAD geometry");
  }
  const positions = [];
  const normals = [];
  const colors = [];
  const defaultColor = csg.color ? toColorTuple(csg.color, [1, 1, 1]) : [1, 1, 1];
  for (const polygon of csg.polygons) {
    if (!polygon?.vertices || polygon.vertices.length < 3) continue;
    const transformedVertices = polygon.vertices.map((vertex) => {
      const position = extractVertexPosition(vertex);
      const afterTransforms = applyTransform(position, csg.transforms);
      return applyAxisTransform(afterTransforms, axisTransform);
    });
    const vertexColors = polygon.vertices.map(
      (vertex) => extractVertexColor(vertex, defaultColor)
    );
    for (let i = 1; i < transformedVertices.length - 1; i++) {
      const a = transformedVertices[0];
      const b = transformedVertices[i];
      const c = transformedVertices[i + 1];
      const ab = subtract(b, a);
      const ac = subtract(c, a);
      const normal = normalize(cross(ab, ac));
      positions.push(...a, ...b, ...c);
      normals.push(...normal, ...normal, ...normal);
      const colorA = vertexColors[0];
      const colorB = vertexColors[i];
      const colorC = vertexColors[i + 1];
      colors.push(...colorA, ...colorB, ...colorC);
    }
  }
  if (positions.length === 0) {
    throw new Error("Unable to build triangle mesh from JSCAD polygons");
  }
  return {
    name,
    positions: new Float32Array(positions),
    normals: new Float32Array(normals),
    colors: colors.length ? new Float32Array(colors) : void 0,
    mode: GLTF_MODE_TRIANGLES
  };
};
var convertSideGeometry = (csg, name, axisTransform = "none") => {
  if (!csg.sides || csg.sides.length === 0) {
    throw new Error("Expected side data in JSCAD 2D geometry");
  }
  const positions = [];
  const colors = [];
  const defaultColor = csg.color ? toColorTuple(csg.color, [1, 1, 1]) : [1, 1, 1];
  for (const side of csg.sides) {
    if (!Array.isArray(side) || side.length < 2) continue;
    const startRaw = side[0];
    const endRaw = side[side.length - 1];
    const startTransformed = applyTransform(
      [
        Number(startRaw[0]) || 0,
        Number(startRaw[1]) || 0,
        Number(startRaw[2]) || 0
      ],
      csg.transforms
    );
    const start = applyAxisTransform(startTransformed, axisTransform);
    const endTransformed = applyTransform(
      [Number(endRaw[0]) || 0, Number(endRaw[1]) || 0, Number(endRaw[2]) || 0],
      csg.transforms
    );
    const end = applyAxisTransform(endTransformed, axisTransform);
    positions.push(...start, ...end);
    colors.push(...defaultColor, ...defaultColor);
  }
  if (positions.length === 0) {
    throw new Error("Unable to build line geometry from JSCAD sides");
  }
  return {
    name,
    positions: new Float32Array(positions),
    colors: colors.length ? new Float32Array(colors) : void 0,
    mode: GLTF_MODE_LINES
  };
};
var collectGeometries = (csg, name, axisTransform = "none") => {
  if (Array.isArray(csg)) {
    return csg.flatMap(
      (child, index) => collectGeometries(child, `${name}_${index}`, axisTransform)
    );
  }
  if (csg?.polygons) {
    return [convertPolygonGeometry(csg, name, axisTransform)];
  }
  if (csg?.sides) {
    return [convertSideGeometry(csg, name, axisTransform)];
  }
  throw new Error(
    "JSCAD plan evaluation did not return a supported geometry (expected geom2 or geom3)"
  );
};
var addBufferView = (chunks, bufferViews, data, currentLength, target) => {
  const offset = align(currentLength, 4);
  const padding = offset - currentLength;
  if (padding > 0) {
    chunks.push(Buffer.alloc(padding));
  }
  const arrayBuffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  chunks.push(arrayBuffer);
  bufferViews.push({
    buffer: 0,
    byteOffset: offset,
    byteLength: data.byteLength,
    target
  });
  return {
    bufferViewIndex: bufferViews.length - 1,
    newLength: offset + data.byteLength
  };
};
var computeMinMax = (values) => {
  const min = [
    Number.POSITIVE_INFINITY,
    Number.POSITIVE_INFINITY,
    Number.POSITIVE_INFINITY
  ];
  const max = [
    Number.NEGATIVE_INFINITY,
    Number.NEGATIVE_INFINITY,
    Number.NEGATIVE_INFINITY
  ];
  for (let i = 0; i < values.length; i += 3) {
    const x = values[i];
    const y = values[i + 1];
    const z = values[i + 2];
    const minX = min[0];
    const minY = min[1];
    const minZ = min[2];
    if (x < minX) min[0] = x;
    if (y < minY) min[1] = y;
    if (z < minZ) min[2] = z;
    const maxX = max[0];
    const maxY = max[1];
    const maxZ = max[2];
    if (x > maxX) max[0] = x;
    if (y > maxY) max[1] = y;
    if (z > maxZ) max[2] = z;
  }
  return { min, max };
};
var buildGltfCore = (geometries) => {
  const bufferChunks = [];
  const bufferViews = [];
  const accessors = [];
  const meshes = [];
  const nodes = [];
  let bufferLength = 0;
  geometries.forEach((geometry, index) => {
    const primitiveAttributes = {};
    const positionResult = addBufferView(
      bufferChunks,
      bufferViews,
      geometry.positions,
      bufferLength,
      34962
    );
    bufferLength = positionResult.newLength;
    const { min, max } = computeMinMax(geometry.positions);
    const positionAccessorIndex = accessors.length;
    accessors.push({
      bufferView: positionResult.bufferViewIndex,
      componentType: GLTF_COMPONENT_FLOAT,
      count: geometry.positions.length / 3,
      type: GLTF_TYPE_VEC3,
      min,
      max
    });
    primitiveAttributes.POSITION = positionAccessorIndex;
    if (geometry.normals) {
      const normalResult = addBufferView(
        bufferChunks,
        bufferViews,
        geometry.normals,
        bufferLength,
        34962
      );
      bufferLength = normalResult.newLength;
      const normalAccessorIndex = accessors.length;
      accessors.push({
        bufferView: normalResult.bufferViewIndex,
        componentType: GLTF_COMPONENT_FLOAT,
        count: geometry.normals.length / 3,
        type: GLTF_TYPE_VEC3
      });
      primitiveAttributes.NORMAL = normalAccessorIndex;
    }
    if (geometry.colors) {
      const colorResult = addBufferView(
        bufferChunks,
        bufferViews,
        geometry.colors,
        bufferLength,
        34962
      );
      bufferLength = colorResult.newLength;
      const colorAccessorIndex = accessors.length;
      accessors.push({
        bufferView: colorResult.bufferViewIndex,
        componentType: GLTF_COMPONENT_FLOAT,
        count: geometry.colors.length / 3,
        type: GLTF_TYPE_VEC3
      });
      primitiveAttributes["COLOR_0"] = colorAccessorIndex;
    }
    meshes.push({
      name: geometry.name,
      primitives: [
        {
          attributes: primitiveAttributes,
          mode: geometry.mode
        }
      ]
    });
    nodes.push({
      name: geometry.name,
      mesh: index
    });
  });
  const alignedLength = align(bufferLength, 4);
  if (alignedLength > bufferLength) {
    bufferChunks.push(Buffer.alloc(alignedLength - bufferLength));
    bufferLength = alignedLength;
  }
  const binary = Buffer.concat(bufferChunks, bufferLength);
  const json = {
    asset: { version: "2.0", generator: "jscad-plan-to-gltf" },
    buffers: [{ byteLength: bufferLength }],
    bufferViews,
    accessors,
    meshes,
    nodes: nodes.map((node, idx) => ({ ...node, mesh: idx })),
    scenes: [{ name: "Scene", nodes: nodes.map((_, idx) => idx) }],
    scene: 0
  };
  return { json, binary };
};
var buildGlb = (json, binary) => {
  const jsonString = JSON.stringify(json);
  const jsonBuffer = Buffer.from(jsonString, "utf8");
  const jsonPadding = align(jsonBuffer.length, 4) - jsonBuffer.length;
  const paddedJson = jsonPadding > 0 ? Buffer.concat([jsonBuffer, Buffer.alloc(jsonPadding, 32)]) : jsonBuffer;
  const binPadding = align(binary.length, 4) - binary.length;
  const paddedBinary = binPadding > 0 ? Buffer.concat([binary, Buffer.alloc(binPadding)]) : binary;
  const header = Buffer.alloc(12);
  header.writeUInt32LE(1179937895, 0);
  header.writeUInt32LE(2, 4);
  const totalLength = 12 + 8 + paddedJson.length + 8 + paddedBinary.length;
  header.writeUInt32LE(totalLength, 8);
  const jsonChunkHeader = Buffer.alloc(8);
  jsonChunkHeader.writeUInt32LE(paddedJson.length, 0);
  jsonChunkHeader.writeUInt32LE(1313821514, 4);
  const binChunkHeader = Buffer.alloc(8);
  binChunkHeader.writeUInt32LE(paddedBinary.length, 0);
  binChunkHeader.writeUInt32LE(5130562, 4);
  const glbBuffer = Buffer.concat([
    header,
    jsonChunkHeader,
    paddedJson,
    binChunkHeader,
    paddedBinary
  ]);
  return glbBuffer.buffer.slice(
    glbBuffer.byteOffset,
    glbBuffer.byteOffset + glbBuffer.byteLength
  );
};
var buildConversionResult = (geometries, format, prettyJson) => {
  if (!geometries.length) {
    throw new Error("JSCAD plan execution returned no geometry");
  }
  const { json, binary } = buildGltfCore(geometries);
  if (format === "glb") {
    const arrayBuffer = buildGlb(json, binary);
    return {
      data: arrayBuffer,
      format,
      mimeType: "model/gltf-binary",
      byteLength: arrayBuffer.byteLength
    };
  }
  const jsonDoc = JSON.parse(JSON.stringify(json));
  jsonDoc.buffers[0].uri = `data:application/octet-stream;base64,${binary.toString("base64")}`;
  const jsonString = JSON.stringify(jsonDoc, null, prettyJson ? 2 : 0);
  const byteLength = Buffer.byteLength(jsonString, "utf8");
  return {
    data: jsonString,
    format,
    mimeType: "model/gltf+json",
    byteLength
  };
};
var ensureColorTupleOnCsg = (geom, colorHint) => {
  const parsedColor = parseColorValue(colorHint) ?? parseColorValue(geom.color);
  if (parsedColor) {
    return { ...geom, color: parsedColor };
  }
  return geom;
};
var normalizeRenderedGeometries = (model) => {
  if (!model || !Array.isArray(model.geometries)) return [];
  const prepared = [];
  for (const entry of model.geometries) {
    if (!entry?.geom) continue;
    prepared.push(ensureColorTupleOnCsg(entry.geom, entry.color));
  }
  return prepared;
};
var convertJscadPlanToGltf = async (plan, options = {}) => {
  const meshName = options.meshName ?? "JSCADMesh";
  const axisTransform = options.axisTransform ?? "none";
  const csgResult = executeJscadOperations(jscad, plan);
  if (!csgResult) {
    throw new Error("JSCAD plan execution returned no geometry");
  }
  const geometries = collectGeometries(csgResult, meshName, axisTransform);
  const format = options.format ?? "glb";
  return buildConversionResult(geometries, format, options.prettyJson);
};
var convertJscadModelToGltf = async (model, options = {}) => {
  const meshName = options.meshName ?? "JSCADMesh";
  const axisTransform = options.axisTransform ?? "none";
  const csgGeometries = normalizeRenderedGeometries(model);
  if (csgGeometries.length === 0) {
    throw new Error("JSCAD model did not contain any geometries");
  }
  const geometries = collectGeometries(csgGeometries, meshName, axisTransform);
  const format = options.format ?? "glb";
  return buildConversionResult(geometries, format, options.prettyJson);
};
var index_default = convertJscadPlanToGltf;
export {
  convertJscadModelToGltf,
  convertJscadPlanToGltf,
  index_default as default
};
