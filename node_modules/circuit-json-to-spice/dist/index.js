// lib/spice-utils/convertSpiceNetlistToString.ts
var convertSpiceNetlistToString = (netlist) => {
  const lines = [];
  lines.push(netlist.title);
  if (netlist.models.size > 0) {
    lines.push(...Array.from(netlist.models.values()));
  }
  for (const component of netlist.components) {
    lines.push(component.toSpiceString());
  }
  for (const subcircuit of netlist.subcircuits) {
    lines.push(subcircuit.toSpiceString());
  }
  if (netlist.printStatements.length > 0) {
    lines.push(...netlist.printStatements);
  }
  if (netlist.controls.length > 0) {
    lines.push(".control");
    lines.push(...netlist.controls);
    lines.push(".endc");
  }
  if (netlist.tranCommand && !lines.some((l) => l.trim().toLowerCase().startsWith(".tran"))) {
    lines.push(netlist.tranCommand);
  }
  lines.push(".END");
  return lines.join("\n");
};

// lib/spice-classes/SpiceNetlist.ts
var SpiceNetlist = class {
  title;
  components;
  nodes;
  controls;
  subcircuits;
  models;
  tranCommand;
  printStatements;
  constructor(title = "Circuit Netlist") {
    this.title = title;
    this.components = [];
    this.nodes = /* @__PURE__ */ new Set();
    this.controls = [];
    this.subcircuits = [];
    this.models = /* @__PURE__ */ new Map();
    this.tranCommand = null;
    this.printStatements = [];
  }
  addComponent(component) {
    this.components.push(component);
    for (const node of component.nodes) {
      this.nodes.add(node);
    }
  }
  addSubcircuit(subcircuit) {
    if (this.subcircuits.find((s) => s.name === subcircuit.name)) return;
    this.subcircuits.push(subcircuit);
  }
  toSpiceString() {
    return convertSpiceNetlistToString(this);
  }
};

// lib/spice-classes/SpiceComponent.ts
var SpiceComponent = class {
  name;
  command;
  nodes;
  constructor(name, command, nodes) {
    this.name = name;
    this.command = command;
    this.nodes = nodes;
  }
  toSpiceString() {
    return this.command.toSpiceString();
  }
};

// lib/spice-commands/ResistorCommand.ts
var ResistorCommand = class {
  commandName = "resistor";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const { name, positiveNode, negativeNode, model, value } = this.props;
    let spiceString = `R${name} ${positiveNode} ${negativeNode}`;
    if (model) {
      spiceString += ` ${model}`;
    }
    spiceString += ` ${value}`;
    return spiceString;
  }
};

// lib/spice-commands/CapacitorCommand.ts
var CapacitorCommand = class {
  commandName = "capacitor";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const {
      name,
      positiveNode,
      negativeNode,
      modelName,
      value,
      initialCondition
    } = this.props;
    let spiceString = `C${name} ${positiveNode} ${negativeNode}`;
    if (modelName) {
      spiceString += ` ${modelName}`;
    }
    spiceString += ` ${value}`;
    if (initialCondition) {
      spiceString += ` IC=${initialCondition}`;
    }
    return spiceString;
  }
};

// lib/spice-commands/VoltageSourceCommand.ts
var VoltageSourceCommand = class {
  commandName = "voltage_source";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const { name, positiveNode, negativeNode, value, acMagnitude, acPhase } = this.props;
    let spiceString = `V${name} ${positiveNode} ${negativeNode}`;
    if (value) {
      spiceString += ` ${value}`;
    }
    if (acMagnitude) {
      spiceString += ` AC ${acMagnitude}`;
      if (acPhase) {
        spiceString += ` ${acPhase}`;
      }
    }
    return spiceString;
  }
};

// lib/spice-commands/DiodeCommand.ts
var DiodeCommand = class {
  commandName = "diode";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const { name, positiveNode, negativeNode, model, area } = this.props;
    let spiceString = `D${name} ${positiveNode} ${negativeNode} ${model}`;
    if (area) {
      spiceString += ` ${area}`;
    }
    return spiceString;
  }
};

// lib/spice-commands/InductorCommand.ts
var InductorCommand = class {
  commandName = "inductor";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const { name, positiveNode, negativeNode, model, value, initialCondition } = this.props;
    let spiceString = `L${name} ${positiveNode} ${negativeNode}`;
    if (model) {
      spiceString += ` ${model}`;
    }
    spiceString += ` ${value}`;
    if (initialCondition) {
      spiceString += ` IC=${initialCondition}`;
    }
    return spiceString;
  }
};

// lib/spice-commands/VoltageControlledSwitchCommand.ts
var VoltageControlledSwitchCommand = class {
  commandName = "voltage_controlled_switch";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const {
      name,
      positiveNode,
      negativeNode,
      positiveControl,
      negativeControl,
      model
    } = this.props;
    return `S${name} ${positiveNode} ${negativeNode} ${positiveControl} ${negativeControl} ${model}`;
  }
};

// lib/circuitJsonToSpice.ts
import { getSourcePortConnectivityMapFromCircuitJson } from "circuit-json-to-connectivity-map";
import { su } from "@tscircuit/circuit-json-util";
function circuitJsonToSpice(circuitJson) {
  const netlist = new SpiceNetlist("* Circuit JSON to SPICE Netlist");
  const sourceComponents = su(circuitJson).source_component.list();
  const sourcePorts = su(circuitJson).source_port.list();
  const sourceTraces = su(circuitJson).source_trace.list();
  const simulationProbes = circuitJson.filter(
    (elm) => elm.type === "simulation_voltage_probe"
  );
  const simulationSwitches = circuitJson.filter(
    (element) => element.type === "simulation_switch"
  ).map((element) => element);
  const simulationSwitchMap = /* @__PURE__ */ new Map();
  for (const simSwitch of simulationSwitches) {
    if (simSwitch.source_component_id) {
      simulationSwitchMap.set(simSwitch.source_component_id, simSwitch);
    }
  }
  const connMap = getSourcePortConnectivityMapFromCircuitJson(circuitJson);
  const nodeMap = /* @__PURE__ */ new Map();
  const netToNodeName = /* @__PURE__ */ new Map();
  let nodeCounter = 1;
  const probeNames = /* @__PURE__ */ new Set();
  if (simulationProbes.length > 0) {
    for (const probe of simulationProbes) {
      if (probe.name) {
        probeNames.add(probe.name);
      }
    }
  }
  const numericProbeNames = [...probeNames].map((name) => /^N(\d+)$/i.exec(name)).filter((m) => m !== null).map((m) => parseInt(m[1], 10));
  if (numericProbeNames.length > 0) {
    nodeCounter = Math.max(...numericProbeNames) + 1;
  }
  const groundNets = /* @__PURE__ */ new Set();
  const gndSourceNetIds = new Set(
    su(circuitJson).source_net.list().filter((sn) => sn.name?.toLowerCase().includes("gnd")).map((sn) => sn.source_net_id)
  );
  if (gndSourceNetIds.size > 0) {
    for (const trace of su(circuitJson).source_trace.list()) {
      if (trace.connected_source_port_ids.length > 0) {
        const isOnGndNet = trace.connected_source_net_ids.some(
          (netId) => gndSourceNetIds.has(netId)
        );
        if (isOnGndNet) {
          const aPortOnGnd = trace.connected_source_port_ids[0];
          const gndNet = connMap.getNetConnectedToId(aPortOnGnd);
          if (gndNet) {
            groundNets.add(gndNet);
          }
        }
      }
    }
  }
  const groundPorts = sourcePorts.filter((p) => p.name?.toLowerCase() === "gnd");
  for (const groundPort of groundPorts) {
    const groundNet = connMap.getNetConnectedToId(groundPort.source_port_id);
    if (groundNet) {
      groundNets.add(groundNet);
    }
  }
  for (const simSource of su(circuitJson).simulation_voltage_source.list()) {
    const neg_port_id = simSource.negative_source_port_id ?? simSource.terminal2_source_port_id;
    if (neg_port_id) {
      const gnd_net = connMap.getNetConnectedToId(neg_port_id);
      if (gnd_net) {
        groundNets.add(gnd_net);
      }
    }
  }
  for (const groundNet of groundNets) {
    netToNodeName.set(groundNet, "0");
  }
  if (simulationProbes.length > 0) {
    for (const probe of simulationProbes) {
      if (!probe.name) continue;
      let net;
      if (probe.source_port_id) {
        net = connMap.getNetConnectedToId(probe.source_port_id);
      } else if (probe.source_net_id) {
        const trace = sourceTraces.find(
          (t) => t.connected_source_net_ids.includes(probe.source_net_id)
        );
        if (trace && trace.connected_source_port_ids.length > 0) {
          const portId = trace.connected_source_port_ids[0];
          net = connMap.getNetConnectedToId(portId);
        }
      }
      if (net) {
        if (!netToNodeName.has(net)) {
          netToNodeName.set(net, probe.name);
        }
      } else if (probe.source_port_id && probe.name) {
        nodeMap.set(probe.source_port_id, probe.name);
      }
    }
  }
  for (const port of sourcePorts) {
    const portId = port.source_port_id;
    const net = connMap.getNetConnectedToId(portId);
    if (net) {
      if (!netToNodeName.has(net)) {
        netToNodeName.set(net, `N${nodeCounter++}`);
      }
      nodeMap.set(portId, netToNodeName.get(net));
    }
  }
  for (const port of sourcePorts) {
    const portId = port.source_port_id;
    if (!nodeMap.has(portId)) {
      nodeMap.set(portId, `N${nodeCounter++}`);
    }
  }
  for (const component of sourceComponents) {
    if (component.type !== "source_component") continue;
    const componentPorts = su(circuitJson).source_port.list({
      source_component_id: component.source_component_id
    }).sort((a, b) => (a.pin_number ?? 0) - (b.pin_number ?? 0));
    const nodes = componentPorts.map((port) => {
      return nodeMap.get(port.source_port_id) || "0";
    });
    if ("ftype" in component) {
      let spiceComponent = null;
      switch (component.ftype) {
        case "simple_resistor": {
          if ("resistance" in component && "name" in component) {
            const resistorCmd = new ResistorCommand({
              name: component.name,
              positiveNode: nodes[0] || "0",
              negativeNode: nodes[1] || "0",
              value: formatResistance(component.resistance)
            });
            spiceComponent = new SpiceComponent(
              component.name,
              resistorCmd,
              nodes
            );
          }
          break;
        }
        case "simple_switch": {
          const sanitizedBase = sanitizeIdentifier(
            component.name ?? component.source_component_id,
            "SW"
          );
          const positiveNode = nodes[0] || "0";
          const negativeNode = nodes[1] || "0";
          const controlNode = `NCTRL_${sanitizedBase}`;
          const modelName = `SW_${sanitizedBase}`;
          const associatedSimulationSwitch = simulationSwitchMap.get(
            component.source_component_id
          );
          const controlValue = buildSimulationSwitchControlValue(
            associatedSimulationSwitch
          );
          const switchCmd = new VoltageControlledSwitchCommand({
            name: sanitizedBase,
            positiveNode,
            negativeNode,
            positiveControl: controlNode,
            negativeControl: "0",
            model: modelName
          });
          spiceComponent = new SpiceComponent(sanitizedBase, switchCmd, [
            positiveNode,
            negativeNode,
            controlNode,
            "0"
          ]);
          if (!netlist.models.has(modelName)) {
            netlist.models.set(
              modelName,
              `.MODEL ${modelName} SW(Ron=0.1 Roff=1e9 Vt=2.5 Vh=0.1)`
            );
          }
          const controlSourceName = `CTRL_${sanitizedBase}`;
          const controlSourceCmd = new VoltageSourceCommand({
            name: controlSourceName,
            positiveNode: controlNode,
            negativeNode: "0",
            value: controlValue
          });
          const controlComponent = new SpiceComponent(
            controlSourceName,
            controlSourceCmd,
            [controlNode, "0"]
          );
          netlist.addComponent(controlComponent);
          break;
        }
        case "simple_capacitor": {
          if ("capacitance" in component && "name" in component) {
            const capacitorCmd = new CapacitorCommand({
              name: component.name,
              positiveNode: nodes[0] || "0",
              negativeNode: nodes[1] || "0",
              value: formatCapacitance(component.capacitance)
            });
            spiceComponent = new SpiceComponent(
              component.name,
              capacitorCmd,
              nodes
            );
          }
          break;
        }
        case "simple_diode": {
          if ("name" in component) {
            const anodePort = componentPorts.find(
              (p) => p.name?.toLowerCase() === "anode" || p.port_hints?.includes("anode")
            );
            const cathodePort = componentPorts.find(
              (p) => p.name?.toLowerCase() === "cathode" || p.port_hints?.includes("cathode")
            );
            const positiveNode = nodeMap.get(anodePort?.source_port_id ?? "") || "0";
            const negativeNode = nodeMap.get(cathodePort?.source_port_id ?? "") || "0";
            const modelName = "D";
            const diodeCmd = new DiodeCommand({
              name: component.name,
              positiveNode,
              negativeNode,
              model: modelName
              // generic model
            });
            netlist.models.set(modelName, `.MODEL ${modelName} D`);
            spiceComponent = new SpiceComponent(component.name, diodeCmd, [
              positiveNode,
              negativeNode
            ]);
          }
          break;
        }
        case "simple_inductor": {
          if ("inductance" in component && "name" in component) {
            const inductorCmd = new InductorCommand({
              name: component.name,
              positiveNode: nodes[0] || "0",
              negativeNode: nodes[1] || "0",
              value: formatInductance(component.inductance)
            });
            spiceComponent = new SpiceComponent(
              component.name,
              inductorCmd,
              nodes
            );
          }
          break;
        }
        case "simple_mosfet": {
          if ("name" in component) {
            const drainPort = componentPorts.find(
              (p) => p.name?.toLowerCase() === "drain" || p.port_hints?.includes("drain")
            );
            const gatePort = componentPorts.find(
              (p) => p.name?.toLowerCase() === "gate" || p.port_hints?.includes("gate")
            );
            const sourcePort = componentPorts.find(
              (p) => p.name?.toLowerCase() === "source" || p.port_hints?.includes("source")
            );
            const drainNode = nodeMap.get(drainPort?.source_port_id ?? "") || "0";
            const gateNode = nodeMap.get(gatePort?.source_port_id ?? "") || "0";
            const sourceNode = nodeMap.get(sourcePort?.source_port_id ?? "") || "0";
            const modelName = "SWMOD";
            const switchCmd = new VoltageControlledSwitchCommand({
              name: component.name,
              positiveNode: drainNode,
              negativeNode: sourceNode,
              positiveControl: gateNode,
              negativeControl: sourceNode,
              model: modelName
            });
            netlist.models.set(modelName, `.MODEL ${modelName} SW`);
            spiceComponent = new SpiceComponent(component.name, switchCmd, [
              drainNode,
              gateNode,
              sourceNode
            ]);
          }
          break;
        }
      }
      if (spiceComponent) {
        netlist.addComponent(spiceComponent);
      }
    }
  }
  const simulationVoltageSources = su(circuitJson).simulation_voltage_source.list();
  for (const simSource of simulationVoltageSources) {
    if (simSource.type !== "simulation_voltage_source") continue;
    if (simSource.is_dc_source === false) {
      if ("terminal1_source_port_id" in simSource && "terminal2_source_port_id" in simSource && simSource.terminal1_source_port_id && simSource.terminal2_source_port_id) {
        const positiveNode = nodeMap.get(simSource.terminal1_source_port_id) || "0";
        const negativeNode = nodeMap.get(simSource.terminal2_source_port_id) || "0";
        let value = "";
        const wave_shape = simSource.wave_shape;
        if (wave_shape === "sinewave") {
          const v_offset = 0;
          const v_peak = simSource.voltage ?? 0;
          const freq = simSource.frequency ?? 0;
          const delay = 0;
          const damping_factor = 0;
          const phase = simSource.phase ?? 0;
          if (freq > 0) {
            value = `SIN(${v_offset} ${v_peak} ${freq} ${delay} ${damping_factor} ${phase})`;
          } else {
            value = `DC ${simSource.voltage ?? 0}`;
          }
        } else if (wave_shape === "square") {
          const v_initial = 0;
          const v_pulsed = simSource.voltage ?? 0;
          const freq = simSource.frequency ?? 0;
          const period_from_freq = freq === 0 ? Infinity : 1 / freq;
          const period = simSource.period ?? period_from_freq;
          const duty_cycle = simSource.duty_cycle ?? 0.5;
          const pulse_width = period * duty_cycle;
          const delay = 0;
          const rise_time = "1n";
          const fall_time = "1n";
          value = `PULSE(${v_initial} ${v_pulsed} ${delay} ${rise_time} ${fall_time} ${pulse_width} ${period})`;
        } else if (simSource.voltage !== void 0) {
          value = `DC ${simSource.voltage}`;
        }
        if (value) {
          const voltageSourceCmd = new VoltageSourceCommand({
            name: simSource.simulation_voltage_source_id,
            positiveNode,
            negativeNode,
            value
          });
          const spiceComponent = new SpiceComponent(
            simSource.simulation_voltage_source_id,
            voltageSourceCmd,
            [positiveNode, negativeNode]
          );
          netlist.addComponent(spiceComponent);
        }
      }
    } else {
      const positivePortId = simSource.positive_source_port_id ?? simSource.terminal1_source_port_id;
      const negativePortId = simSource.negative_source_port_id ?? simSource.terminal2_source_port_id;
      if (positivePortId && negativePortId && "voltage" in simSource && simSource.voltage !== void 0) {
        const positiveNode = nodeMap.get(positivePortId) || "0";
        const negativeNode = nodeMap.get(negativePortId) || "0";
        const voltageSourceCmd = new VoltageSourceCommand({
          name: simSource.simulation_voltage_source_id,
          positiveNode,
          negativeNode,
          value: `DC ${simSource.voltage}`
        });
        const spiceComponent = new SpiceComponent(
          simSource.simulation_voltage_source_id,
          voltageSourceCmd,
          [positiveNode, negativeNode]
        );
        netlist.addComponent(spiceComponent);
      }
    }
  }
  const simExperiment = circuitJson.find(
    (elm) => elm.type === "simulation_experiment"
  );
  if (simExperiment) {
    if (simulationProbes.length > 0) {
      const nodesToProbe = /* @__PURE__ */ new Set();
      for (const probe of simulationProbes) {
        let nodeName;
        if (probe.source_port_id) {
          nodeName = nodeMap.get(probe.source_port_id);
        } else if (probe.source_net_id) {
          const trace = sourceTraces.find(
            (t) => t.connected_source_net_ids.includes(probe.source_net_id)
          );
          if (trace && trace.connected_source_port_ids.length > 0) {
            const portId = trace.connected_source_port_ids[0];
            nodeName = nodeMap.get(portId);
          }
        }
        if (nodeName && nodeName !== "0") {
          nodesToProbe.add(`V(${nodeName})`);
        }
      }
      if (nodesToProbe.size > 0 && simExperiment.experiment_type?.includes("transient")) {
        netlist.printStatements.push(
          `.PRINT TRAN ${[...nodesToProbe].join(" ")}`
        );
      }
    }
    const timePerStep = simExperiment.time_per_step;
    const endTime = simExperiment.end_time_ms;
    const startTimeMs = simExperiment.start_time_ms;
    if (timePerStep && endTime) {
      const startTime = (startTimeMs ?? 0) / 1e3;
      let tranCmd = `.tran ${formatNumberForSpice(
        timePerStep / 1e3
      )} ${formatNumberForSpice(endTime / 1e3)}`;
      if (startTime > 0) {
        tranCmd += ` ${formatNumberForSpice(startTime)}`;
      }
      tranCmd += " UIC";
      netlist.tranCommand = tranCmd;
    }
  }
  return netlist;
}
function formatResistance(resistance) {
  if (resistance >= 1e6) return `${resistance / 1e6}MEG`;
  if (resistance >= 1e3) return `${resistance / 1e3}K`;
  return resistance.toString();
}
function formatCapacitance(capacitance) {
  if (capacitance >= 1e-3) return `${capacitance * 1e3}M`;
  if (capacitance >= 1e-6) return `${capacitance * 1e6}U`;
  if (capacitance >= 1e-9) return `${capacitance * 1e9}N`;
  if (capacitance >= 1e-12) return `${capacitance * 1e12}P`;
  return capacitance.toString();
}
function formatInductance(inductance) {
  if (inductance >= 1) return inductance.toString();
  if (inductance >= 1e-3) return `${inductance * 1e3}m`;
  if (inductance >= 1e-6) return `${inductance * 1e6}u`;
  if (inductance >= 1e-9) return `${inductance * 1e9}n`;
  if (inductance >= 1e-12) return `${inductance * 1e12}p`;
  return inductance.toString();
}
function sanitizeIdentifier(value, prefix) {
  if (!value) return prefix;
  const sanitized = value.replace(/[^A-Za-z0-9_]/g, "_");
  if (!sanitized) return prefix;
  if (/^[0-9]/.test(sanitized)) {
    return `${prefix}_${sanitized}`;
  }
  return sanitized;
}
function buildSimulationSwitchControlValue(simulationSwitch) {
  const highVoltage = 5;
  const lowVoltage = 0;
  const riseTime = "1n";
  const fallTime = "1n";
  if (!simulationSwitch) {
    return `DC ${lowVoltage}`;
  }
  const startsClosed = simulationSwitch.starts_closed ?? false;
  const closesAt = simulationSwitch.closes_at ?? 0;
  const opensAt = simulationSwitch.opens_at;
  const switchingFrequency = simulationSwitch.switching_frequency;
  const [initialVoltage, pulsedVoltage] = startsClosed ? [highVoltage, lowVoltage] : [lowVoltage, highVoltage];
  if (switchingFrequency && switchingFrequency > 0) {
    const period = 1 / switchingFrequency;
    const widthFromOpenClose = opensAt && opensAt > closesAt ? Math.min(opensAt - closesAt, period) : 0;
    const pulseWidth = widthFromOpenClose > 0 ? widthFromOpenClose : Math.max(period / 2, 1e-9);
    return `PULSE(${formatNumberForSpice(initialVoltage)} ${formatNumberForSpice(pulsedVoltage)} ${formatNumberForSpice(closesAt)} ${riseTime} ${fallTime} ${formatNumberForSpice(pulseWidth)} ${formatNumberForSpice(period)})`;
  }
  if (opensAt !== void 0 && opensAt > closesAt) {
    const pulseWidth = Math.max(opensAt - closesAt, 1e-9);
    const period = closesAt + pulseWidth * 2;
    return `PULSE(${formatNumberForSpice(initialVoltage)} ${formatNumberForSpice(pulsedVoltage)} ${formatNumberForSpice(closesAt)} ${riseTime} ${fallTime} ${formatNumberForSpice(pulseWidth)} ${formatNumberForSpice(period)})`;
  }
  if (closesAt > 0) {
    const period = closesAt * 2;
    const pulseWidth = Math.max(period / 2, 1e-9);
    return `PULSE(${formatNumberForSpice(initialVoltage)} ${formatNumberForSpice(pulsedVoltage)} ${formatNumberForSpice(closesAt)} ${riseTime} ${fallTime} ${formatNumberForSpice(pulseWidth)} ${formatNumberForSpice(period)})`;
  }
  return `DC ${startsClosed ? highVoltage : lowVoltage}`;
}
function formatNumberForSpice(value) {
  if (!Number.isFinite(value)) return `${value}`;
  if (value === 0) return "0";
  const absValue = Math.abs(value);
  if (absValue >= 1e3 || absValue <= 1e-3) {
    return Number(value.toExponential(6)).toString();
  }
  return Number(value.toPrecision(6)).toString();
}

// lib/spice-classes/SpiceSubcircuit.ts
var SpiceSubcircuit = class {
  name;
  pins;
  constructor(name, pins) {
    this.name = name;
    this.pins = pins;
  }
  toSpiceString() {
    const pinString = this.pins.join(" ");
    const header = `.SUBCKT ${this.name} ${pinString}`;
    const footer = `.ENDS ${this.name}`;
    const body = `* Placeholder for ${this.name}. No definition found in circuit JSON.`;
    return ["", header, body, footer].join("\n");
  }
};

// lib/spice-commands/BJTCommand.ts
var BJTCommand = class {
  commandName = "bjt";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const { name, collector, base, emitter, substrate, model, area } = this.props;
    let spiceString = `Q${name} ${collector} ${base} ${emitter}`;
    if (substrate) {
      spiceString += ` ${substrate}`;
    }
    spiceString += ` ${model}`;
    if (area) {
      spiceString += ` ${area}`;
    }
    return spiceString;
  }
};

// lib/spice-commands/CurrentSourceCommand.ts
var CurrentSourceCommand = class {
  commandName = "current_source";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const { name, positiveNode, negativeNode, value, acMagnitude, acPhase } = this.props;
    let spiceString = `I${name} ${positiveNode} ${negativeNode}`;
    if (value) {
      spiceString += ` ${value}`;
    }
    if (acMagnitude) {
      spiceString += ` AC ${acMagnitude}`;
      if (acPhase) {
        spiceString += ` ${acPhase}`;
      }
    }
    return spiceString;
  }
};

// lib/spice-commands/InductorCouplingCommand.ts
var InductorCouplingCommand = class {
  commandName = "inductor_coupling";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const { name, inductors, coupling } = this.props;
    return `K${name} ${inductors.join(" ")} ${coupling}`;
  }
};

// lib/spice-commands/JFETCommand.ts
var JFETCommand = class {
  commandName = "jfet";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const { name, drain, gate, source, model, area } = this.props;
    let spiceString = `J${name} ${drain} ${gate} ${source} ${model}`;
    if (area) {
      spiceString += ` ${area}`;
    }
    return spiceString;
  }
};

// lib/spice-commands/MOSFETCommand.ts
var MOSFETCommand = class {
  commandName = "mosfet";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const {
      name,
      drain,
      gate,
      source,
      substrate,
      model,
      length,
      width,
      drainArea,
      sourceArea,
      drainPerimeter,
      sourcePerimeter,
      drainResistance,
      sourceResistance
    } = this.props;
    let spiceString = `M${name} ${drain} ${gate} ${source} ${substrate} ${model}`;
    const params = {
      L: length,
      W: width,
      AD: drainArea,
      AS: sourceArea,
      PD: drainPerimeter,
      PS: sourcePerimeter,
      NRD: drainResistance,
      NRS: sourceResistance
    };
    Object.entries(params).forEach(([key, value]) => {
      if (value) {
        spiceString += ` ${key}=${value}`;
      }
    });
    return spiceString;
  }
};

// lib/spice-commands/SubcircuitCallCommand.ts
var SubcircuitCallCommand = class {
  commandName = "subcircuit_call";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const { name, nodes, subcircuitName } = this.props;
    return `X${name} ${nodes.join(" ")} ${subcircuitName}`;
  }
};

// lib/spice-commands/TransmissionLineCommand.ts
var TransmissionLineCommand = class {
  commandName = "transmission_line";
  props;
  constructor(props) {
    this.props = props;
  }
  toSpiceString() {
    const {
      name,
      aPositive,
      aNegative,
      bPositive,
      bNegative,
      impedance,
      delay,
      frequency,
      normalizedLength
    } = this.props;
    let spiceString = `T${name} ${aPositive} ${aNegative} ${bPositive} ${bNegative} Z0=${impedance}`;
    if (delay) {
      spiceString += ` TD=${delay}`;
    } else if (frequency) {
      spiceString += ` F=${frequency}`;
      if (normalizedLength) {
        spiceString += ` NL=${normalizedLength}`;
      }
    }
    return spiceString;
  }
};
export {
  BJTCommand,
  CapacitorCommand,
  CurrentSourceCommand,
  DiodeCommand,
  InductorCommand,
  InductorCouplingCommand,
  JFETCommand,
  MOSFETCommand,
  ResistorCommand,
  SpiceComponent,
  SpiceNetlist,
  SpiceSubcircuit,
  SubcircuitCallCommand,
  TransmissionLineCommand,
  VoltageControlledSwitchCommand,
  VoltageSourceCommand,
  circuitJsonToSpice,
  convertSpiceNetlistToString
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbGliL3NwaWNlLXV0aWxzL2NvbnZlcnRTcGljZU5ldGxpc3RUb1N0cmluZy50cyIsICIuLi9saWIvc3BpY2UtY2xhc3Nlcy9TcGljZU5ldGxpc3QudHMiLCAiLi4vbGliL3NwaWNlLWNsYXNzZXMvU3BpY2VDb21wb25lbnQudHMiLCAiLi4vbGliL3NwaWNlLWNvbW1hbmRzL1Jlc2lzdG9yQ29tbWFuZC50cyIsICIuLi9saWIvc3BpY2UtY29tbWFuZHMvQ2FwYWNpdG9yQ29tbWFuZC50cyIsICIuLi9saWIvc3BpY2UtY29tbWFuZHMvVm9sdGFnZVNvdXJjZUNvbW1hbmQudHMiLCAiLi4vbGliL3NwaWNlLWNvbW1hbmRzL0Rpb2RlQ29tbWFuZC50cyIsICIuLi9saWIvc3BpY2UtY29tbWFuZHMvSW5kdWN0b3JDb21tYW5kLnRzIiwgIi4uL2xpYi9zcGljZS1jb21tYW5kcy9Wb2x0YWdlQ29udHJvbGxlZFN3aXRjaENvbW1hbmQudHMiLCAiLi4vbGliL2NpcmN1aXRKc29uVG9TcGljZS50cyIsICIuLi9saWIvc3BpY2UtY2xhc3Nlcy9TcGljZVN1YmNpcmN1aXQudHMiLCAiLi4vbGliL3NwaWNlLWNvbW1hbmRzL0JKVENvbW1hbmQudHMiLCAiLi4vbGliL3NwaWNlLWNvbW1hbmRzL0N1cnJlbnRTb3VyY2VDb21tYW5kLnRzIiwgIi4uL2xpYi9zcGljZS1jb21tYW5kcy9JbmR1Y3RvckNvdXBsaW5nQ29tbWFuZC50cyIsICIuLi9saWIvc3BpY2UtY29tbWFuZHMvSkZFVENvbW1hbmQudHMiLCAiLi4vbGliL3NwaWNlLWNvbW1hbmRzL01PU0ZFVENvbW1hbmQudHMiLCAiLi4vbGliL3NwaWNlLWNvbW1hbmRzL1N1YmNpcmN1aXRDYWxsQ29tbWFuZC50cyIsICIuLi9saWIvc3BpY2UtY29tbWFuZHMvVHJhbnNtaXNzaW9uTGluZUNvbW1hbmQudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB0eXBlIHsgU3BpY2VOZXRsaXN0IH0gZnJvbSBcIi4uL3NwaWNlLWNsYXNzZXMvU3BpY2VOZXRsaXN0XCJcblxuZXhwb3J0IGNvbnN0IGNvbnZlcnRTcGljZU5ldGxpc3RUb1N0cmluZyA9IChuZXRsaXN0OiBTcGljZU5ldGxpc3QpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXVxuXG4gIC8vIFRpdGxlIGxpbmUgKHJlcXVpcmVkIGZpcnN0IGxpbmUgaW4gU1BJQ0UpXG4gIGxpbmVzLnB1c2gobmV0bGlzdC50aXRsZSlcblxuICAvLyBBZGQgbW9kZWxzXG4gIGlmIChuZXRsaXN0Lm1vZGVscy5zaXplID4gMCkge1xuICAgIGxpbmVzLnB1c2goLi4uQXJyYXkuZnJvbShuZXRsaXN0Lm1vZGVscy52YWx1ZXMoKSkpXG4gIH1cblxuICAvLyBDb21wb25lbnQgbGluZXNcbiAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgbmV0bGlzdC5jb21wb25lbnRzKSB7XG4gICAgbGluZXMucHVzaChjb21wb25lbnQudG9TcGljZVN0cmluZygpKVxuICB9XG5cbiAgLy8gQWRkIHN1YmNpcmN1aXQgZGVmaW5pdGlvbnNcbiAgZm9yIChjb25zdCBzdWJjaXJjdWl0IG9mIG5ldGxpc3Quc3ViY2lyY3VpdHMpIHtcbiAgICBsaW5lcy5wdXNoKHN1YmNpcmN1aXQudG9TcGljZVN0cmluZygpKVxuICB9XG5cbiAgaWYgKG5ldGxpc3QucHJpbnRTdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBsaW5lcy5wdXNoKC4uLm5ldGxpc3QucHJpbnRTdGF0ZW1lbnRzKVxuICB9XG5cbiAgLy8gQWRkIGNvbnRyb2wgYmxvY2sgaWYgcHJlc2VudFxuICBpZiAobmV0bGlzdC5jb250cm9scy5sZW5ndGggPiAwKSB7XG4gICAgbGluZXMucHVzaChcIi5jb250cm9sXCIpXG4gICAgbGluZXMucHVzaCguLi5uZXRsaXN0LmNvbnRyb2xzKVxuICAgIGxpbmVzLnB1c2goXCIuZW5kY1wiKVxuICB9XG5cbiAgaWYgKFxuICAgIG5ldGxpc3QudHJhbkNvbW1hbmQgJiZcbiAgICAhbGluZXMuc29tZSgobCkgPT4gbC50cmltKCkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiLnRyYW5cIikpXG4gICkge1xuICAgIGxpbmVzLnB1c2gobmV0bGlzdC50cmFuQ29tbWFuZClcbiAgfVxuXG4gIC8vIEVuZCB3aXRoIC5FTkRcbiAgbGluZXMucHVzaChcIi5FTkRcIilcblxuICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKVxufVxuIiwgImltcG9ydCB7IGNvbnZlcnRTcGljZU5ldGxpc3RUb1N0cmluZyB9IGZyb20gXCIuLi9zcGljZS11dGlscy9jb252ZXJ0U3BpY2VOZXRsaXN0VG9TdHJpbmdcIlxuaW1wb3J0IHR5cGUgeyBTcGljZUNvbXBvbmVudCB9IGZyb20gXCIuL1NwaWNlQ29tcG9uZW50XCJcbmltcG9ydCB0eXBlIHsgU3BpY2VTdWJjaXJjdWl0IH0gZnJvbSBcIi4vU3BpY2VTdWJjaXJjdWl0XCJcblxuZXhwb3J0IGNsYXNzIFNwaWNlTmV0bGlzdCB7XG4gIHRpdGxlOiBzdHJpbmdcbiAgY29tcG9uZW50czogU3BpY2VDb21wb25lbnRbXVxuICBub2RlczogU2V0PHN0cmluZz5cbiAgY29udHJvbHM6IHN0cmluZ1tdXG4gIHN1YmNpcmN1aXRzOiBTcGljZVN1YmNpcmN1aXRbXVxuICBtb2RlbHM6IE1hcDxzdHJpbmcsIHN0cmluZz5cbiAgdHJhbkNvbW1hbmQ6IHN0cmluZyB8IG51bGxcbiAgcHJpbnRTdGF0ZW1lbnRzOiBzdHJpbmdbXVxuXG4gIGNvbnN0cnVjdG9yKHRpdGxlID0gXCJDaXJjdWl0IE5ldGxpc3RcIikge1xuICAgIHRoaXMudGl0bGUgPSB0aXRsZVxuICAgIHRoaXMuY29tcG9uZW50cyA9IFtdXG4gICAgdGhpcy5ub2RlcyA9IG5ldyBTZXQoKVxuICAgIHRoaXMuY29udHJvbHMgPSBbXVxuICAgIHRoaXMuc3ViY2lyY3VpdHMgPSBbXVxuICAgIHRoaXMubW9kZWxzID0gbmV3IE1hcCgpXG4gICAgdGhpcy50cmFuQ29tbWFuZCA9IG51bGxcbiAgICB0aGlzLnByaW50U3RhdGVtZW50cyA9IFtdXG4gIH1cblxuICBhZGRDb21wb25lbnQoY29tcG9uZW50OiBTcGljZUNvbXBvbmVudCkge1xuICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudClcbiAgICAvLyBBZGQgbm9kZXMgdG8gdGhlIHNldFxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjb21wb25lbnQubm9kZXMpIHtcbiAgICAgIHRoaXMubm9kZXMuYWRkKG5vZGUpXG4gICAgfVxuICB9XG5cbiAgYWRkU3ViY2lyY3VpdChzdWJjaXJjdWl0OiBTcGljZVN1YmNpcmN1aXQpIHtcbiAgICBpZiAodGhpcy5zdWJjaXJjdWl0cy5maW5kKChzKSA9PiBzLm5hbWUgPT09IHN1YmNpcmN1aXQubmFtZSkpIHJldHVyblxuICAgIHRoaXMuc3ViY2lyY3VpdHMucHVzaChzdWJjaXJjdWl0KVxuICB9XG5cbiAgdG9TcGljZVN0cmluZygpIHtcbiAgICByZXR1cm4gY29udmVydFNwaWNlTmV0bGlzdFRvU3RyaW5nKHRoaXMpXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJhc2VTcGljZUNvbW1hbmQgfSBmcm9tIFwiLi4vc3BpY2UtY29tbWFuZHMvQmFzZVNwaWNlQ29tbWFuZFwiXG5cbmV4cG9ydCBjbGFzcyBTcGljZUNvbXBvbmVudCB7XG4gIG5hbWU6IHN0cmluZ1xuICBjb21tYW5kOiBCYXNlU3BpY2VDb21tYW5kXG4gIG5vZGVzOiBzdHJpbmdbXVxuXG4gIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgY29tbWFuZDogQmFzZVNwaWNlQ29tbWFuZCwgbm9kZXM6IHN0cmluZ1tdKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmRcbiAgICB0aGlzLm5vZGVzID0gbm9kZXNcbiAgfVxuXG4gIHRvU3BpY2VTdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kLnRvU3BpY2VTdHJpbmcoKVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBCYXNlU3BpY2VDb21tYW5kIH0gZnJvbSBcIi4vQmFzZVNwaWNlQ29tbWFuZFwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzaXN0b3JDb21tYW5kUHJvcHMge1xuICBuYW1lOiBzdHJpbmdcbiAgcG9zaXRpdmVOb2RlOiBzdHJpbmdcbiAgbmVnYXRpdmVOb2RlOiBzdHJpbmdcbiAgbW9kZWw/OiBzdHJpbmdcbiAgdmFsdWU6IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgUmVzaXN0b3JDb21tYW5kIGltcGxlbWVudHMgQmFzZVNwaWNlQ29tbWFuZCB7XG4gIGNvbW1hbmROYW1lID0gXCJyZXNpc3RvclwiIGFzIGNvbnN0XG4gIHByb3BzOiBSZXNpc3RvckNvbW1hbmRQcm9wc1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBSZXNpc3RvckNvbW1hbmRQcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSBwcm9wc1xuICB9XG5cbiAgdG9TcGljZVN0cmluZygpOiBzdHJpbmcge1xuICAgIGNvbnN0IHsgbmFtZSwgcG9zaXRpdmVOb2RlLCBuZWdhdGl2ZU5vZGUsIG1vZGVsLCB2YWx1ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCBzcGljZVN0cmluZyA9IGBSJHtuYW1lfSAke3Bvc2l0aXZlTm9kZX0gJHtuZWdhdGl2ZU5vZGV9YFxuICAgIGlmIChtb2RlbCkge1xuICAgICAgc3BpY2VTdHJpbmcgKz0gYCAke21vZGVsfWBcbiAgICB9XG4gICAgc3BpY2VTdHJpbmcgKz0gYCAke3ZhbHVlfWBcbiAgICByZXR1cm4gc3BpY2VTdHJpbmdcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgQmFzZVNwaWNlQ29tbWFuZCB9IGZyb20gXCIuL0Jhc2VTcGljZUNvbW1hbmRcIlxuXG5leHBvcnQgaW50ZXJmYWNlIENhcGFjaXRvckNvbW1hbmRQcm9wcyB7XG4gIG5hbWU6IHN0cmluZ1xuICBwb3NpdGl2ZU5vZGU6IHN0cmluZ1xuICBuZWdhdGl2ZU5vZGU6IHN0cmluZ1xuICBtb2RlbE5hbWU/OiBzdHJpbmdcbiAgdmFsdWU6IHN0cmluZ1xuICBpbml0aWFsQ29uZGl0aW9uPzogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBDYXBhY2l0b3JDb21tYW5kIGltcGxlbWVudHMgQmFzZVNwaWNlQ29tbWFuZCB7XG4gIGNvbW1hbmROYW1lID0gXCJjYXBhY2l0b3JcIiBhcyBjb25zdFxuXG4gIHByb3BzOiBDYXBhY2l0b3JDb21tYW5kUHJvcHNcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogQ2FwYWNpdG9yQ29tbWFuZFByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzXG4gIH1cblxuICB0b1NwaWNlU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHBvc2l0aXZlTm9kZSxcbiAgICAgIG5lZ2F0aXZlTm9kZSxcbiAgICAgIG1vZGVsTmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgaW5pdGlhbENvbmRpdGlvbixcbiAgICB9ID0gdGhpcy5wcm9wc1xuXG4gICAgbGV0IHNwaWNlU3RyaW5nID0gYEMke25hbWV9ICR7cG9zaXRpdmVOb2RlfSAke25lZ2F0aXZlTm9kZX1gXG4gICAgaWYgKG1vZGVsTmFtZSkge1xuICAgICAgc3BpY2VTdHJpbmcgKz0gYCAke21vZGVsTmFtZX1gXG4gICAgfVxuICAgIHNwaWNlU3RyaW5nICs9IGAgJHt2YWx1ZX1gXG4gICAgaWYgKGluaXRpYWxDb25kaXRpb24pIHtcbiAgICAgIHNwaWNlU3RyaW5nICs9IGAgSUM9JHtpbml0aWFsQ29uZGl0aW9ufWBcbiAgICB9XG4gICAgcmV0dXJuIHNwaWNlU3RyaW5nXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJhc2VTcGljZUNvbW1hbmQgfSBmcm9tIFwiLi9CYXNlU3BpY2VDb21tYW5kXCJcblxuZXhwb3J0IGludGVyZmFjZSBWb2x0YWdlU291cmNlQ29tbWFuZFByb3BzIHtcbiAgbmFtZTogc3RyaW5nXG4gIHBvc2l0aXZlTm9kZTogc3RyaW5nXG4gIG5lZ2F0aXZlTm9kZTogc3RyaW5nXG4gIHZhbHVlPzogc3RyaW5nXG4gIGFjTWFnbml0dWRlPzogc3RyaW5nXG4gIGFjUGhhc2U/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGNsYXNzIFZvbHRhZ2VTb3VyY2VDb21tYW5kIGltcGxlbWVudHMgQmFzZVNwaWNlQ29tbWFuZCB7XG4gIGNvbW1hbmROYW1lID0gXCJ2b2x0YWdlX3NvdXJjZVwiIGFzIGNvbnN0XG4gIHByb3BzOiBWb2x0YWdlU291cmNlQ29tbWFuZFByb3BzXG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFZvbHRhZ2VTb3VyY2VDb21tYW5kUHJvcHMpIHtcbiAgICB0aGlzLnByb3BzID0gcHJvcHNcbiAgfVxuXG4gIHRvU3BpY2VTdHJpbmcoKTogc3RyaW5nIHtcbiAgICBjb25zdCB7IG5hbWUsIHBvc2l0aXZlTm9kZSwgbmVnYXRpdmVOb2RlLCB2YWx1ZSwgYWNNYWduaXR1ZGUsIGFjUGhhc2UgfSA9XG4gICAgICB0aGlzLnByb3BzXG4gICAgbGV0IHNwaWNlU3RyaW5nID0gYFYke25hbWV9ICR7cG9zaXRpdmVOb2RlfSAke25lZ2F0aXZlTm9kZX1gXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzcGljZVN0cmluZyArPSBgICR7dmFsdWV9YFxuICAgIH1cbiAgICBpZiAoYWNNYWduaXR1ZGUpIHtcbiAgICAgIHNwaWNlU3RyaW5nICs9IGAgQUMgJHthY01hZ25pdHVkZX1gXG4gICAgICBpZiAoYWNQaGFzZSkge1xuICAgICAgICBzcGljZVN0cmluZyArPSBgICR7YWNQaGFzZX1gXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGljZVN0cmluZ1xuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBCYXNlU3BpY2VDb21tYW5kIH0gZnJvbSBcIi4vQmFzZVNwaWNlQ29tbWFuZFwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlvZGVDb21tYW5kUHJvcHMge1xuICBuYW1lOiBzdHJpbmdcbiAgcG9zaXRpdmVOb2RlOiBzdHJpbmdcbiAgbmVnYXRpdmVOb2RlOiBzdHJpbmdcbiAgbW9kZWw6IHN0cmluZ1xuICBhcmVhPzogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBEaW9kZUNvbW1hbmQgaW1wbGVtZW50cyBCYXNlU3BpY2VDb21tYW5kIHtcbiAgY29tbWFuZE5hbWUgPSBcImRpb2RlXCIgYXMgY29uc3RcbiAgcHJvcHM6IERpb2RlQ29tbWFuZFByb3BzXG5cbiAgY29uc3RydWN0b3IocHJvcHM6IERpb2RlQ29tbWFuZFByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzXG4gIH1cblxuICB0b1NwaWNlU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBuYW1lLCBwb3NpdGl2ZU5vZGUsIG5lZ2F0aXZlTm9kZSwgbW9kZWwsIGFyZWEgfSA9IHRoaXMucHJvcHNcbiAgICBsZXQgc3BpY2VTdHJpbmcgPSBgRCR7bmFtZX0gJHtwb3NpdGl2ZU5vZGV9ICR7bmVnYXRpdmVOb2RlfSAke21vZGVsfWBcbiAgICBpZiAoYXJlYSkge1xuICAgICAgc3BpY2VTdHJpbmcgKz0gYCAke2FyZWF9YFxuICAgIH1cbiAgICByZXR1cm4gc3BpY2VTdHJpbmdcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgQmFzZVNwaWNlQ29tbWFuZCB9IGZyb20gXCIuL0Jhc2VTcGljZUNvbW1hbmRcIlxuXG5leHBvcnQgaW50ZXJmYWNlIEluZHVjdG9yQ29tbWFuZFByb3BzIHtcbiAgbmFtZTogc3RyaW5nXG4gIHBvc2l0aXZlTm9kZTogc3RyaW5nXG4gIG5lZ2F0aXZlTm9kZTogc3RyaW5nXG4gIG1vZGVsPzogc3RyaW5nXG4gIHZhbHVlOiBzdHJpbmdcbiAgaW5pdGlhbENvbmRpdGlvbj86IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgSW5kdWN0b3JDb21tYW5kIGltcGxlbWVudHMgQmFzZVNwaWNlQ29tbWFuZCB7XG4gIGNvbW1hbmROYW1lID0gXCJpbmR1Y3RvclwiIGFzIGNvbnN0XG4gIHByb3BzOiBJbmR1Y3RvckNvbW1hbmRQcm9wc1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJbmR1Y3RvckNvbW1hbmRQcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSBwcm9wc1xuICB9XG5cbiAgdG9TcGljZVN0cmluZygpOiBzdHJpbmcge1xuICAgIGNvbnN0IHsgbmFtZSwgcG9zaXRpdmVOb2RlLCBuZWdhdGl2ZU5vZGUsIG1vZGVsLCB2YWx1ZSwgaW5pdGlhbENvbmRpdGlvbiB9ID1cbiAgICAgIHRoaXMucHJvcHNcbiAgICBsZXQgc3BpY2VTdHJpbmcgPSBgTCR7bmFtZX0gJHtwb3NpdGl2ZU5vZGV9ICR7bmVnYXRpdmVOb2RlfWBcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIHNwaWNlU3RyaW5nICs9IGAgJHttb2RlbH1gXG4gICAgfVxuICAgIHNwaWNlU3RyaW5nICs9IGAgJHt2YWx1ZX1gXG4gICAgaWYgKGluaXRpYWxDb25kaXRpb24pIHtcbiAgICAgIHNwaWNlU3RyaW5nICs9IGAgSUM9JHtpbml0aWFsQ29uZGl0aW9ufWBcbiAgICB9XG4gICAgcmV0dXJuIHNwaWNlU3RyaW5nXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJhc2VTcGljZUNvbW1hbmQgfSBmcm9tIFwiLi9CYXNlU3BpY2VDb21tYW5kXCJcblxuZXhwb3J0IGludGVyZmFjZSBWb2x0YWdlQ29udHJvbGxlZFN3aXRjaENvbW1hbmRQcm9wcyB7XG4gIG5hbWU6IHN0cmluZ1xuICBwb3NpdGl2ZU5vZGU6IHN0cmluZ1xuICBuZWdhdGl2ZU5vZGU6IHN0cmluZ1xuICBwb3NpdGl2ZUNvbnRyb2w6IHN0cmluZ1xuICBuZWdhdGl2ZUNvbnRyb2w6IHN0cmluZ1xuICBtb2RlbDogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBWb2x0YWdlQ29udHJvbGxlZFN3aXRjaENvbW1hbmQgaW1wbGVtZW50cyBCYXNlU3BpY2VDb21tYW5kIHtcbiAgY29tbWFuZE5hbWUgPSBcInZvbHRhZ2VfY29udHJvbGxlZF9zd2l0Y2hcIiBhcyBjb25zdFxuICBwcm9wczogVm9sdGFnZUNvbnRyb2xsZWRTd2l0Y2hDb21tYW5kUHJvcHNcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogVm9sdGFnZUNvbnRyb2xsZWRTd2l0Y2hDb21tYW5kUHJvcHMpIHtcbiAgICB0aGlzLnByb3BzID0gcHJvcHNcbiAgfVxuXG4gIHRvU3BpY2VTdHJpbmcoKTogc3RyaW5nIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgcG9zaXRpdmVOb2RlLFxuICAgICAgbmVnYXRpdmVOb2RlLFxuICAgICAgcG9zaXRpdmVDb250cm9sLFxuICAgICAgbmVnYXRpdmVDb250cm9sLFxuICAgICAgbW9kZWwsXG4gICAgfSA9IHRoaXMucHJvcHNcbiAgICByZXR1cm4gYFMke25hbWV9ICR7cG9zaXRpdmVOb2RlfSAke25lZ2F0aXZlTm9kZX0gJHtwb3NpdGl2ZUNvbnRyb2x9ICR7bmVnYXRpdmVDb250cm9sfSAke21vZGVsfWBcbiAgfVxufVxuIiwgImltcG9ydCB7IFNwaWNlTmV0bGlzdCB9IGZyb20gXCIuL3NwaWNlLWNsYXNzZXMvU3BpY2VOZXRsaXN0XCJcbmltcG9ydCB7IFNwaWNlQ29tcG9uZW50IH0gZnJvbSBcIi4vc3BpY2UtY2xhc3Nlcy9TcGljZUNvbXBvbmVudFwiXG5pbXBvcnQgeyBSZXNpc3RvckNvbW1hbmQgfSBmcm9tIFwiLi9zcGljZS1jb21tYW5kcy9SZXNpc3RvckNvbW1hbmRcIlxuaW1wb3J0IHsgQ2FwYWNpdG9yQ29tbWFuZCB9IGZyb20gXCIuL3NwaWNlLWNvbW1hbmRzL0NhcGFjaXRvckNvbW1hbmRcIlxuaW1wb3J0IHsgVm9sdGFnZVNvdXJjZUNvbW1hbmQgfSBmcm9tIFwiLi9zcGljZS1jb21tYW5kcy9Wb2x0YWdlU291cmNlQ29tbWFuZFwiXG5pbXBvcnQgeyBEaW9kZUNvbW1hbmQgfSBmcm9tIFwiLi9zcGljZS1jb21tYW5kcy9EaW9kZUNvbW1hbmRcIlxuaW1wb3J0IHsgSW5kdWN0b3JDb21tYW5kIH0gZnJvbSBcIi4vc3BpY2UtY29tbWFuZHMvSW5kdWN0b3JDb21tYW5kXCJcbmltcG9ydCB7IFZvbHRhZ2VDb250cm9sbGVkU3dpdGNoQ29tbWFuZCB9IGZyb20gXCIuL3NwaWNlLWNvbW1hbmRzL1ZvbHRhZ2VDb250cm9sbGVkU3dpdGNoQ29tbWFuZFwiXG5pbXBvcnQgdHlwZSB7XG4gIEFueUNpcmN1aXRFbGVtZW50LFxuICBTaW11bGF0aW9uU3dpdGNoLFxuICBTaW11bGF0aW9uVm9sdGFnZVByb2JlLFxufSBmcm9tIFwiY2lyY3VpdC1qc29uXCJcbmltcG9ydCB7IGdldFNvdXJjZVBvcnRDb25uZWN0aXZpdHlNYXBGcm9tQ2lyY3VpdEpzb24gfSBmcm9tIFwiY2lyY3VpdC1qc29uLXRvLWNvbm5lY3Rpdml0eS1tYXBcIlxuaW1wb3J0IHsgc3UgfSBmcm9tIFwiQHRzY2lyY3VpdC9jaXJjdWl0LWpzb24tdXRpbFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjdWl0SnNvblRvU3BpY2UoXG4gIGNpcmN1aXRKc29uOiBBbnlDaXJjdWl0RWxlbWVudFtdLFxuKTogU3BpY2VOZXRsaXN0IHtcbiAgY29uc3QgbmV0bGlzdCA9IG5ldyBTcGljZU5ldGxpc3QoXCIqIENpcmN1aXQgSlNPTiB0byBTUElDRSBOZXRsaXN0XCIpXG4gIGNvbnN0IHNvdXJjZUNvbXBvbmVudHMgPSBzdShjaXJjdWl0SnNvbikuc291cmNlX2NvbXBvbmVudC5saXN0KClcbiAgY29uc3Qgc291cmNlUG9ydHMgPSBzdShjaXJjdWl0SnNvbikuc291cmNlX3BvcnQubGlzdCgpXG4gIGNvbnN0IHNvdXJjZVRyYWNlcyA9IHN1KGNpcmN1aXRKc29uKS5zb3VyY2VfdHJhY2UubGlzdCgpXG4gIGNvbnN0IHNpbXVsYXRpb25Qcm9iZXMgPSBjaXJjdWl0SnNvbi5maWx0ZXIoXG4gICAgKGVsbSkgPT4gZWxtLnR5cGUgPT09IFwic2ltdWxhdGlvbl92b2x0YWdlX3Byb2JlXCIsXG4gICkgYXMgU2ltdWxhdGlvblZvbHRhZ2VQcm9iZVtdXG4gIGNvbnN0IHNpbXVsYXRpb25Td2l0Y2hlcyA9IGNpcmN1aXRKc29uXG4gICAgLmZpbHRlcihcbiAgICAgIChlbGVtZW50KSA9PiAoZWxlbWVudCBhcyB7IHR5cGU/OiBzdHJpbmcgfSkudHlwZSA9PT0gXCJzaW11bGF0aW9uX3N3aXRjaFwiLFxuICAgIClcbiAgICAubWFwKChlbGVtZW50KSA9PiBlbGVtZW50IGFzIHVua25vd24gYXMgU2ltdWxhdGlvblN3aXRjaClcbiAgY29uc3Qgc2ltdWxhdGlvblN3aXRjaE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBTaW11bGF0aW9uU3dpdGNoPigpXG5cbiAgZm9yIChjb25zdCBzaW1Td2l0Y2ggb2Ygc2ltdWxhdGlvblN3aXRjaGVzKSB7XG4gICAgaWYgKHNpbVN3aXRjaC5zb3VyY2VfY29tcG9uZW50X2lkKSB7XG4gICAgICBzaW11bGF0aW9uU3dpdGNoTWFwLnNldChzaW1Td2l0Y2guc291cmNlX2NvbXBvbmVudF9pZCwgc2ltU3dpdGNoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNvbm5NYXAgPSBnZXRTb3VyY2VQb3J0Q29ubmVjdGl2aXR5TWFwRnJvbUNpcmN1aXRKc29uKGNpcmN1aXRKc29uKVxuXG4gIC8vIENyZWF0ZSBub2RlIG1hcHBpbmcgZnJvbSBwb3J0IGNvbm5lY3Rpb25zXG4gIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXG4gIGNvbnN0IG5ldFRvTm9kZU5hbWUgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXG4gIGxldCBub2RlQ291bnRlciA9IDFcblxuICBjb25zdCBwcm9iZU5hbWVzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgaWYgKHNpbXVsYXRpb25Qcm9iZXMubGVuZ3RoID4gMCkge1xuICAgIGZvciAoY29uc3QgcHJvYmUgb2Ygc2ltdWxhdGlvblByb2Jlcykge1xuICAgICAgaWYgKHByb2JlLm5hbWUpIHtcbiAgICAgICAgcHJvYmVOYW1lcy5hZGQocHJvYmUubmFtZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgcHJvYmUgbmFtZXMgbGlrZSBOMSwgTjIsIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIGNvbmZsaWN0c1xuICBjb25zdCBudW1lcmljUHJvYmVOYW1lcyA9IFsuLi5wcm9iZU5hbWVzXVxuICAgIC5tYXAoKG5hbWUpID0+IC9eTihcXGQrKSQvaS5leGVjKG5hbWUpKVxuICAgIC5maWx0ZXIoKG0pOiBtIGlzIFJlZ0V4cEV4ZWNBcnJheSA9PiBtICE9PSBudWxsKVxuICAgIC5tYXAoKG0pID0+IHBhcnNlSW50KG1bMV0sIDEwKSlcblxuICBpZiAobnVtZXJpY1Byb2JlTmFtZXMubGVuZ3RoID4gMCkge1xuICAgIG5vZGVDb3VudGVyID0gTWF0aC5tYXgoLi4ubnVtZXJpY1Byb2JlTmFtZXMpICsgMVxuICB9XG5cbiAgY29uc3QgZ3JvdW5kTmV0cyA9IG5ldyBTZXQ8c3RyaW5nPigpXG5cbiAgLy8gRmluZCBncm91bmQgZnJvbSBzb3VyY2UgbmV0cyB0aGF0IGluY2x1ZGUgXCJnbmRcIiBpbiB0aGUgbmFtZVxuICBjb25zdCBnbmRTb3VyY2VOZXRJZHMgPSBuZXcgU2V0KFxuICAgIHN1KGNpcmN1aXRKc29uKVxuICAgICAgLnNvdXJjZV9uZXQubGlzdCgpXG4gICAgICAuZmlsdGVyKChzbikgPT4gc24ubmFtZT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImduZFwiKSlcbiAgICAgIC5tYXAoKHNuKSA9PiBzbi5zb3VyY2VfbmV0X2lkKSxcbiAgKVxuXG4gIGlmIChnbmRTb3VyY2VOZXRJZHMuc2l6ZSA+IDApIHtcbiAgICBmb3IgKGNvbnN0IHRyYWNlIG9mIHN1KGNpcmN1aXRKc29uKS5zb3VyY2VfdHJhY2UubGlzdCgpKSB7XG4gICAgICBpZiAodHJhY2UuY29ubmVjdGVkX3NvdXJjZV9wb3J0X2lkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGlzT25HbmROZXQgPSB0cmFjZS5jb25uZWN0ZWRfc291cmNlX25ldF9pZHMuc29tZSgobmV0SWQpID0+XG4gICAgICAgICAgZ25kU291cmNlTmV0SWRzLmhhcyhuZXRJZCksXG4gICAgICAgIClcbiAgICAgICAgaWYgKGlzT25HbmROZXQpIHtcbiAgICAgICAgICBjb25zdCBhUG9ydE9uR25kID0gdHJhY2UuY29ubmVjdGVkX3NvdXJjZV9wb3J0X2lkc1swXVxuICAgICAgICAgIGNvbnN0IGduZE5ldCA9IGNvbm5NYXAuZ2V0TmV0Q29ubmVjdGVkVG9JZChhUG9ydE9uR25kKVxuICAgICAgICAgIGlmIChnbmROZXQpIHtcbiAgICAgICAgICAgIGdyb3VuZE5ldHMuYWRkKGduZE5ldClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIGdyb3VuZCBub2RlIGZyb20gcG9ydHMgbmFtZWQgXCJHTkRcIlxuICBjb25zdCBncm91bmRQb3J0cyA9IHNvdXJjZVBvcnRzLmZpbHRlcigocCkgPT4gcC5uYW1lPy50b0xvd2VyQ2FzZSgpID09PSBcImduZFwiKVxuICBmb3IgKGNvbnN0IGdyb3VuZFBvcnQgb2YgZ3JvdW5kUG9ydHMpIHtcbiAgICBjb25zdCBncm91bmROZXQgPSBjb25uTWFwLmdldE5ldENvbm5lY3RlZFRvSWQoZ3JvdW5kUG9ydC5zb3VyY2VfcG9ydF9pZClcbiAgICBpZiAoZ3JvdW5kTmV0KSB7XG4gICAgICBncm91bmROZXRzLmFkZChncm91bmROZXQpXG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBzaW1Tb3VyY2Ugb2Ygc3UoY2lyY3VpdEpzb24pLnNpbXVsYXRpb25fdm9sdGFnZV9zb3VyY2UubGlzdCgpKSB7XG4gICAgY29uc3QgbmVnX3BvcnRfaWQgPVxuICAgICAgKHNpbVNvdXJjZSBhcyBhbnkpLm5lZ2F0aXZlX3NvdXJjZV9wb3J0X2lkID8/XG4gICAgICAoc2ltU291cmNlIGFzIGFueSkudGVybWluYWwyX3NvdXJjZV9wb3J0X2lkXG4gICAgaWYgKG5lZ19wb3J0X2lkKSB7XG4gICAgICBjb25zdCBnbmRfbmV0ID0gY29ubk1hcC5nZXROZXRDb25uZWN0ZWRUb0lkKG5lZ19wb3J0X2lkKVxuICAgICAgaWYgKGduZF9uZXQpIHtcbiAgICAgICAgZ3JvdW5kTmV0cy5hZGQoZ25kX25ldClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGdyb3VuZE5ldCBvZiBncm91bmROZXRzKSB7XG4gICAgbmV0VG9Ob2RlTmFtZS5zZXQoZ3JvdW5kTmV0LCBcIjBcIilcbiAgfVxuXG4gIC8vIFByZS1hc3NpZ24gbm9kZSBuYW1lcyBmcm9tIHZvbHRhZ2UgcHJvYmVzXG4gIGlmIChzaW11bGF0aW9uUHJvYmVzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGNvbnN0IHByb2JlIG9mIHNpbXVsYXRpb25Qcm9iZXMpIHtcbiAgICAgIGlmICghcHJvYmUubmFtZSkgY29udGludWVcbiAgICAgIGxldCBuZXQ6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGxcbiAgICAgIGlmIChwcm9iZS5zb3VyY2VfcG9ydF9pZCkge1xuICAgICAgICBuZXQgPSBjb25uTWFwLmdldE5ldENvbm5lY3RlZFRvSWQocHJvYmUuc291cmNlX3BvcnRfaWQpXG4gICAgICB9IGVsc2UgaWYgKHByb2JlLnNvdXJjZV9uZXRfaWQpIHtcbiAgICAgICAgY29uc3QgdHJhY2UgPSBzb3VyY2VUcmFjZXMuZmluZCgodCkgPT5cbiAgICAgICAgICB0LmNvbm5lY3RlZF9zb3VyY2VfbmV0X2lkcy5pbmNsdWRlcyhwcm9iZS5zb3VyY2VfbmV0X2lkISksXG4gICAgICAgIClcbiAgICAgICAgaWYgKHRyYWNlICYmIHRyYWNlLmNvbm5lY3RlZF9zb3VyY2VfcG9ydF9pZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHBvcnRJZCA9IHRyYWNlLmNvbm5lY3RlZF9zb3VyY2VfcG9ydF9pZHNbMF1cbiAgICAgICAgICBuZXQgPSBjb25uTWFwLmdldE5ldENvbm5lY3RlZFRvSWQocG9ydElkKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXQpIHtcbiAgICAgICAgaWYgKCFuZXRUb05vZGVOYW1lLmhhcyhuZXQpKSB7XG4gICAgICAgICAgbmV0VG9Ob2RlTmFtZS5zZXQobmV0LCBwcm9iZS5uYW1lKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb2JlLnNvdXJjZV9wb3J0X2lkICYmIHByb2JlLm5hbWUpIHtcbiAgICAgICAgLy8gSXQncyBhIGZsb2F0aW5nIHBvcnQgd2l0aCBhIHByb2JlLCBzbyB3ZSBtYXAgaXQgZGlyZWN0bHkuIFRoaXMgcG9ydFxuICAgICAgICAvLyB3aWxsIG5vdyBiZSBza2lwcGVkIGluIHRoZSBzZWNvbmQtcGFzcyBmb3IgdW5jb25uZWN0ZWQgcG9ydHMuXG4gICAgICAgIG5vZGVNYXAuc2V0KHByb2JlLnNvdXJjZV9wb3J0X2lkLCBwcm9iZS5uYW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpcnN0IHBhc3M6IGFzc2lnbiBub2RlIG51bWJlcnMgdG8gYWxsIGNvbm5lY3RlZCBuZXRzXG4gIGZvciAoY29uc3QgcG9ydCBvZiBzb3VyY2VQb3J0cykge1xuICAgIGNvbnN0IHBvcnRJZCA9IHBvcnQuc291cmNlX3BvcnRfaWRcbiAgICBjb25zdCBuZXQgPSBjb25uTWFwLmdldE5ldENvbm5lY3RlZFRvSWQocG9ydElkKVxuICAgIGlmIChuZXQpIHtcbiAgICAgIGlmICghbmV0VG9Ob2RlTmFtZS5oYXMobmV0KSkge1xuICAgICAgICBuZXRUb05vZGVOYW1lLnNldChuZXQsIGBOJHtub2RlQ291bnRlcisrfWApXG4gICAgICB9XG4gICAgICBub2RlTWFwLnNldChwb3J0SWQsIG5ldFRvTm9kZU5hbWUuZ2V0KG5ldCkhKVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlY29uZCBwYXNzOiBhc3NpZ24gbm9kZSBudW1iZXJzIHRvIHVuY29ubmVjdGVkIHBvcnRzXG4gIGZvciAoY29uc3QgcG9ydCBvZiBzb3VyY2VQb3J0cykge1xuICAgIGNvbnN0IHBvcnRJZCA9IHBvcnQuc291cmNlX3BvcnRfaWRcbiAgICAvLyBJZiBhIHBvcnQgd2Fzbid0IGluIGEgbmV0LCBpdCB3b24ndCBiZSBpbiB0aGUgbm9kZU1hcCB5ZXRcbiAgICBpZiAoIW5vZGVNYXAuaGFzKHBvcnRJZCkpIHtcbiAgICAgIC8vIFVuY29ubmVjdGVkIHBvcnQsIGNyZWF0ZSBhIG5ldyBmbG9hdGluZyBub2RlIGZvciBpdFxuICAgICAgbm9kZU1hcC5zZXQocG9ydElkLCBgTiR7bm9kZUNvdW50ZXIrK31gKVxuICAgIH1cbiAgfVxuXG4gIC8vIFByb2Nlc3MgZWFjaCBjb21wb25lbnRcbiAgZm9yIChjb25zdCBjb21wb25lbnQgb2Ygc291cmNlQ29tcG9uZW50cykge1xuICAgIGlmIChjb21wb25lbnQudHlwZSAhPT0gXCJzb3VyY2VfY29tcG9uZW50XCIpIGNvbnRpbnVlXG5cbiAgICBjb25zdCBjb21wb25lbnRQb3J0cyA9IHN1KGNpcmN1aXRKc29uKVxuICAgICAgLnNvdXJjZV9wb3J0Lmxpc3Qoe1xuICAgICAgICBzb3VyY2VfY29tcG9uZW50X2lkOiBjb21wb25lbnQuc291cmNlX2NvbXBvbmVudF9pZCxcbiAgICAgIH0pXG4gICAgICAuc29ydCgoYSwgYikgPT4gKGEucGluX251bWJlciA/PyAwKSAtIChiLnBpbl9udW1iZXIgPz8gMCkpXG5cbiAgICAvLyBHZXQgbm9kZSBuYW1lcyBmb3IgY29tcG9uZW50IHBvcnRzXG4gICAgY29uc3Qgbm9kZXMgPSBjb21wb25lbnRQb3J0cy5tYXAoKHBvcnQpID0+IHtcbiAgICAgIHJldHVybiBub2RlTWFwLmdldChwb3J0LnNvdXJjZV9wb3J0X2lkKSB8fCBcIjBcIlxuICAgIH0pXG5cbiAgICAvLyBDcmVhdGUgU1BJQ0UgY29tcG9uZW50IGJhc2VkIG9uIHR5cGVcbiAgICBpZiAoXCJmdHlwZVwiIGluIGNvbXBvbmVudCkge1xuICAgICAgbGV0IHNwaWNlQ29tcG9uZW50OiBTcGljZUNvbXBvbmVudCB8IG51bGwgPSBudWxsXG5cbiAgICAgIHN3aXRjaCAoY29tcG9uZW50LmZ0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzaW1wbGVfcmVzaXN0b3JcIjoge1xuICAgICAgICAgIGlmIChcInJlc2lzdGFuY2VcIiBpbiBjb21wb25lbnQgJiYgXCJuYW1lXCIgaW4gY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb25zdCByZXNpc3RvckNtZCA9IG5ldyBSZXNpc3RvckNvbW1hbmQoe1xuICAgICAgICAgICAgICBuYW1lOiBjb21wb25lbnQubmFtZSxcbiAgICAgICAgICAgICAgcG9zaXRpdmVOb2RlOiBub2Rlc1swXSB8fCBcIjBcIixcbiAgICAgICAgICAgICAgbmVnYXRpdmVOb2RlOiBub2Rlc1sxXSB8fCBcIjBcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZvcm1hdFJlc2lzdGFuY2UoY29tcG9uZW50LnJlc2lzdGFuY2UpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHNwaWNlQ29tcG9uZW50ID0gbmV3IFNwaWNlQ29tcG9uZW50KFxuICAgICAgICAgICAgICBjb21wb25lbnQubmFtZSxcbiAgICAgICAgICAgICAgcmVzaXN0b3JDbWQsXG4gICAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzaW1wbGVfc3dpdGNoXCI6IHtcbiAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRCYXNlID0gc2FuaXRpemVJZGVudGlmaWVyKFxuICAgICAgICAgICAgY29tcG9uZW50Lm5hbWUgPz8gY29tcG9uZW50LnNvdXJjZV9jb21wb25lbnRfaWQsXG4gICAgICAgICAgICBcIlNXXCIsXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IHBvc2l0aXZlTm9kZSA9IG5vZGVzWzBdIHx8IFwiMFwiXG4gICAgICAgICAgY29uc3QgbmVnYXRpdmVOb2RlID0gbm9kZXNbMV0gfHwgXCIwXCJcbiAgICAgICAgICBjb25zdCBjb250cm9sTm9kZSA9IGBOQ1RSTF8ke3Nhbml0aXplZEJhc2V9YFxuICAgICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IGBTV18ke3Nhbml0aXplZEJhc2V9YFxuXG4gICAgICAgICAgY29uc3QgYXNzb2NpYXRlZFNpbXVsYXRpb25Td2l0Y2ggPSBzaW11bGF0aW9uU3dpdGNoTWFwLmdldChcbiAgICAgICAgICAgIGNvbXBvbmVudC5zb3VyY2VfY29tcG9uZW50X2lkLFxuICAgICAgICAgIClcblxuICAgICAgICAgIGNvbnN0IGNvbnRyb2xWYWx1ZSA9IGJ1aWxkU2ltdWxhdGlvblN3aXRjaENvbnRyb2xWYWx1ZShcbiAgICAgICAgICAgIGFzc29jaWF0ZWRTaW11bGF0aW9uU3dpdGNoLFxuICAgICAgICAgIClcblxuICAgICAgICAgIGNvbnN0IHN3aXRjaENtZCA9IG5ldyBWb2x0YWdlQ29udHJvbGxlZFN3aXRjaENvbW1hbmQoe1xuICAgICAgICAgICAgbmFtZTogc2FuaXRpemVkQmFzZSxcbiAgICAgICAgICAgIHBvc2l0aXZlTm9kZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlTm9kZSxcbiAgICAgICAgICAgIHBvc2l0aXZlQ29udHJvbDogY29udHJvbE5vZGUsXG4gICAgICAgICAgICBuZWdhdGl2ZUNvbnRyb2w6IFwiMFwiLFxuICAgICAgICAgICAgbW9kZWw6IG1vZGVsTmFtZSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgc3BpY2VDb21wb25lbnQgPSBuZXcgU3BpY2VDb21wb25lbnQoc2FuaXRpemVkQmFzZSwgc3dpdGNoQ21kLCBbXG4gICAgICAgICAgICBwb3NpdGl2ZU5vZGUsXG4gICAgICAgICAgICBuZWdhdGl2ZU5vZGUsXG4gICAgICAgICAgICBjb250cm9sTm9kZSxcbiAgICAgICAgICAgIFwiMFwiLFxuICAgICAgICAgIF0pXG5cbiAgICAgICAgICBpZiAoIW5ldGxpc3QubW9kZWxzLmhhcyhtb2RlbE5hbWUpKSB7XG4gICAgICAgICAgICBuZXRsaXN0Lm1vZGVscy5zZXQoXG4gICAgICAgICAgICAgIG1vZGVsTmFtZSxcbiAgICAgICAgICAgICAgYC5NT0RFTCAke21vZGVsTmFtZX0gU1coUm9uPTAuMSBSb2ZmPTFlOSBWdD0yLjUgVmg9MC4xKWAsXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY29udHJvbFNvdXJjZU5hbWUgPSBgQ1RSTF8ke3Nhbml0aXplZEJhc2V9YFxuICAgICAgICAgIGNvbnN0IGNvbnRyb2xTb3VyY2VDbWQgPSBuZXcgVm9sdGFnZVNvdXJjZUNvbW1hbmQoe1xuICAgICAgICAgICAgbmFtZTogY29udHJvbFNvdXJjZU5hbWUsXG4gICAgICAgICAgICBwb3NpdGl2ZU5vZGU6IGNvbnRyb2xOb2RlLFxuICAgICAgICAgICAgbmVnYXRpdmVOb2RlOiBcIjBcIixcbiAgICAgICAgICAgIHZhbHVlOiBjb250cm9sVmFsdWUsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGNvbnN0IGNvbnRyb2xDb21wb25lbnQgPSBuZXcgU3BpY2VDb21wb25lbnQoXG4gICAgICAgICAgICBjb250cm9sU291cmNlTmFtZSxcbiAgICAgICAgICAgIGNvbnRyb2xTb3VyY2VDbWQsXG4gICAgICAgICAgICBbY29udHJvbE5vZGUsIFwiMFwiXSxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBuZXRsaXN0LmFkZENvbXBvbmVudChjb250cm9sQ29tcG9uZW50KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIFwic2ltcGxlX2NhcGFjaXRvclwiOiB7XG4gICAgICAgICAgaWYgKFwiY2FwYWNpdGFuY2VcIiBpbiBjb21wb25lbnQgJiYgXCJuYW1lXCIgaW4gY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjYXBhY2l0b3JDbWQgPSBuZXcgQ2FwYWNpdG9yQ29tbWFuZCh7XG4gICAgICAgICAgICAgIG5hbWU6IGNvbXBvbmVudC5uYW1lLFxuICAgICAgICAgICAgICBwb3NpdGl2ZU5vZGU6IG5vZGVzWzBdIHx8IFwiMFwiLFxuICAgICAgICAgICAgICBuZWdhdGl2ZU5vZGU6IG5vZGVzWzFdIHx8IFwiMFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZm9ybWF0Q2FwYWNpdGFuY2UoY29tcG9uZW50LmNhcGFjaXRhbmNlKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBzcGljZUNvbXBvbmVudCA9IG5ldyBTcGljZUNvbXBvbmVudChcbiAgICAgICAgICAgICAgY29tcG9uZW50Lm5hbWUsXG4gICAgICAgICAgICAgIGNhcGFjaXRvckNtZCxcbiAgICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInNpbXBsZV9kaW9kZVwiOiB7XG4gICAgICAgICAgaWYgKFwibmFtZVwiIGluIGNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29uc3QgYW5vZGVQb3J0ID0gY29tcG9uZW50UG9ydHMuZmluZChcbiAgICAgICAgICAgICAgKHApID0+XG4gICAgICAgICAgICAgICAgcC5uYW1lPy50b0xvd2VyQ2FzZSgpID09PSBcImFub2RlXCIgfHxcbiAgICAgICAgICAgICAgICBwLnBvcnRfaGludHM/LmluY2x1ZGVzKFwiYW5vZGVcIiksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBjb25zdCBjYXRob2RlUG9ydCA9IGNvbXBvbmVudFBvcnRzLmZpbmQoXG4gICAgICAgICAgICAgIChwKSA9PlxuICAgICAgICAgICAgICAgIHAubmFtZT8udG9Mb3dlckNhc2UoKSA9PT0gXCJjYXRob2RlXCIgfHxcbiAgICAgICAgICAgICAgICBwLnBvcnRfaGludHM/LmluY2x1ZGVzKFwiY2F0aG9kZVwiKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aXZlTm9kZSA9XG4gICAgICAgICAgICAgIG5vZGVNYXAuZ2V0KGFub2RlUG9ydD8uc291cmNlX3BvcnRfaWQgPz8gXCJcIikgfHwgXCIwXCJcbiAgICAgICAgICAgIGNvbnN0IG5lZ2F0aXZlTm9kZSA9XG4gICAgICAgICAgICAgIG5vZGVNYXAuZ2V0KGNhdGhvZGVQb3J0Py5zb3VyY2VfcG9ydF9pZCA/PyBcIlwiKSB8fCBcIjBcIlxuXG4gICAgICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSBcIkRcIlxuICAgICAgICAgICAgY29uc3QgZGlvZGVDbWQgPSBuZXcgRGlvZGVDb21tYW5kKHtcbiAgICAgICAgICAgICAgbmFtZTogY29tcG9uZW50Lm5hbWUsXG4gICAgICAgICAgICAgIHBvc2l0aXZlTm9kZSxcbiAgICAgICAgICAgICAgbmVnYXRpdmVOb2RlLFxuICAgICAgICAgICAgICBtb2RlbDogbW9kZWxOYW1lLCAvLyBnZW5lcmljIG1vZGVsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgbmV0bGlzdC5tb2RlbHMuc2V0KG1vZGVsTmFtZSwgYC5NT0RFTCAke21vZGVsTmFtZX0gRGApXG4gICAgICAgICAgICBzcGljZUNvbXBvbmVudCA9IG5ldyBTcGljZUNvbXBvbmVudChjb21wb25lbnQubmFtZSwgZGlvZGVDbWQsIFtcbiAgICAgICAgICAgICAgcG9zaXRpdmVOb2RlLFxuICAgICAgICAgICAgICBuZWdhdGl2ZU5vZGUsXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzaW1wbGVfaW5kdWN0b3JcIjoge1xuICAgICAgICAgIGlmIChcImluZHVjdGFuY2VcIiBpbiBjb21wb25lbnQgJiYgXCJuYW1lXCIgaW4gY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmR1Y3RvckNtZCA9IG5ldyBJbmR1Y3RvckNvbW1hbmQoe1xuICAgICAgICAgICAgICBuYW1lOiBjb21wb25lbnQubmFtZSxcbiAgICAgICAgICAgICAgcG9zaXRpdmVOb2RlOiBub2Rlc1swXSB8fCBcIjBcIixcbiAgICAgICAgICAgICAgbmVnYXRpdmVOb2RlOiBub2Rlc1sxXSB8fCBcIjBcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZvcm1hdEluZHVjdGFuY2UoY29tcG9uZW50LmluZHVjdGFuY2UpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHNwaWNlQ29tcG9uZW50ID0gbmV3IFNwaWNlQ29tcG9uZW50KFxuICAgICAgICAgICAgICBjb21wb25lbnQubmFtZSxcbiAgICAgICAgICAgICAgaW5kdWN0b3JDbWQsXG4gICAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzaW1wbGVfbW9zZmV0XCI6IHtcbiAgICAgICAgICBpZiAoXCJuYW1lXCIgaW4gY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkcmFpblBvcnQgPSBjb21wb25lbnRQb3J0cy5maW5kKFxuICAgICAgICAgICAgICAocCkgPT5cbiAgICAgICAgICAgICAgICBwLm5hbWU/LnRvTG93ZXJDYXNlKCkgPT09IFwiZHJhaW5cIiB8fFxuICAgICAgICAgICAgICAgIHAucG9ydF9oaW50cz8uaW5jbHVkZXMoXCJkcmFpblwiKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGNvbnN0IGdhdGVQb3J0ID0gY29tcG9uZW50UG9ydHMuZmluZChcbiAgICAgICAgICAgICAgKHApID0+XG4gICAgICAgICAgICAgICAgcC5uYW1lPy50b0xvd2VyQ2FzZSgpID09PSBcImdhdGVcIiB8fFxuICAgICAgICAgICAgICAgIHAucG9ydF9oaW50cz8uaW5jbHVkZXMoXCJnYXRlXCIpLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9ydCA9IGNvbXBvbmVudFBvcnRzLmZpbmQoXG4gICAgICAgICAgICAgIChwKSA9PlxuICAgICAgICAgICAgICAgIHAubmFtZT8udG9Mb3dlckNhc2UoKSA9PT0gXCJzb3VyY2VcIiB8fFxuICAgICAgICAgICAgICAgIHAucG9ydF9oaW50cz8uaW5jbHVkZXMoXCJzb3VyY2VcIiksXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGNvbnN0IGRyYWluTm9kZSA9XG4gICAgICAgICAgICAgIG5vZGVNYXAuZ2V0KGRyYWluUG9ydD8uc291cmNlX3BvcnRfaWQgPz8gXCJcIikgfHwgXCIwXCJcbiAgICAgICAgICAgIGNvbnN0IGdhdGVOb2RlID0gbm9kZU1hcC5nZXQoZ2F0ZVBvcnQ/LnNvdXJjZV9wb3J0X2lkID8/IFwiXCIpIHx8IFwiMFwiXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VOb2RlID1cbiAgICAgICAgICAgICAgbm9kZU1hcC5nZXQoc291cmNlUG9ydD8uc291cmNlX3BvcnRfaWQgPz8gXCJcIikgfHwgXCIwXCJcblxuICAgICAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gXCJTV01PRFwiXG4gICAgICAgICAgICBjb25zdCBzd2l0Y2hDbWQgPSBuZXcgVm9sdGFnZUNvbnRyb2xsZWRTd2l0Y2hDb21tYW5kKHtcbiAgICAgICAgICAgICAgbmFtZTogY29tcG9uZW50Lm5hbWUsXG4gICAgICAgICAgICAgIHBvc2l0aXZlTm9kZTogZHJhaW5Ob2RlLFxuICAgICAgICAgICAgICBuZWdhdGl2ZU5vZGU6IHNvdXJjZU5vZGUsXG4gICAgICAgICAgICAgIHBvc2l0aXZlQ29udHJvbDogZ2F0ZU5vZGUsXG4gICAgICAgICAgICAgIG5lZ2F0aXZlQ29udHJvbDogc291cmNlTm9kZSxcbiAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsTmFtZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBuZXRsaXN0Lm1vZGVscy5zZXQobW9kZWxOYW1lLCBgLk1PREVMICR7bW9kZWxOYW1lfSBTV2ApXG5cbiAgICAgICAgICAgIHNwaWNlQ29tcG9uZW50ID0gbmV3IFNwaWNlQ29tcG9uZW50KGNvbXBvbmVudC5uYW1lLCBzd2l0Y2hDbWQsIFtcbiAgICAgICAgICAgICAgZHJhaW5Ob2RlLFxuICAgICAgICAgICAgICBnYXRlTm9kZSxcbiAgICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNwaWNlQ29tcG9uZW50KSB7XG4gICAgICAgIG5ldGxpc3QuYWRkQ29tcG9uZW50KHNwaWNlQ29tcG9uZW50KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFByb2Nlc3Mgc2ltdWxhdGlvbiB2b2x0YWdlIHNvdXJjZXNcbiAgY29uc3Qgc2ltdWxhdGlvblZvbHRhZ2VTb3VyY2VzID1cbiAgICBzdShjaXJjdWl0SnNvbikuc2ltdWxhdGlvbl92b2x0YWdlX3NvdXJjZS5saXN0KClcblxuICBmb3IgKGNvbnN0IHNpbVNvdXJjZSBvZiBzaW11bGF0aW9uVm9sdGFnZVNvdXJjZXMpIHtcbiAgICBpZiAoc2ltU291cmNlLnR5cGUgIT09IFwic2ltdWxhdGlvbl92b2x0YWdlX3NvdXJjZVwiKSBjb250aW51ZVxuXG4gICAgaWYgKChzaW1Tb3VyY2UgYXMgYW55KS5pc19kY19zb3VyY2UgPT09IGZhbHNlKSB7XG4gICAgICAvLyBBQyBTb3VyY2VcbiAgICAgIGlmIChcbiAgICAgICAgXCJ0ZXJtaW5hbDFfc291cmNlX3BvcnRfaWRcIiBpbiBzaW1Tb3VyY2UgJiZcbiAgICAgICAgXCJ0ZXJtaW5hbDJfc291cmNlX3BvcnRfaWRcIiBpbiBzaW1Tb3VyY2UgJiZcbiAgICAgICAgKHNpbVNvdXJjZSBhcyBhbnkpLnRlcm1pbmFsMV9zb3VyY2VfcG9ydF9pZCAmJlxuICAgICAgICAoc2ltU291cmNlIGFzIGFueSkudGVybWluYWwyX3NvdXJjZV9wb3J0X2lkXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgcG9zaXRpdmVOb2RlID1cbiAgICAgICAgICBub2RlTWFwLmdldCgoc2ltU291cmNlIGFzIGFueSkudGVybWluYWwxX3NvdXJjZV9wb3J0X2lkKSB8fCBcIjBcIlxuICAgICAgICBjb25zdCBuZWdhdGl2ZU5vZGUgPVxuICAgICAgICAgIG5vZGVNYXAuZ2V0KChzaW1Tb3VyY2UgYXMgYW55KS50ZXJtaW5hbDJfc291cmNlX3BvcnRfaWQpIHx8IFwiMFwiXG5cbiAgICAgICAgbGV0IHZhbHVlID0gXCJcIlxuICAgICAgICBjb25zdCB3YXZlX3NoYXBlID0gKHNpbVNvdXJjZSBhcyBhbnkpLndhdmVfc2hhcGVcbiAgICAgICAgaWYgKHdhdmVfc2hhcGUgPT09IFwic2luZXdhdmVcIikge1xuICAgICAgICAgIGNvbnN0IHZfb2Zmc2V0ID0gMCAvLyBub3QgcHJvdmlkZWQgaW4gY2lyY3VpdEpzb25cbiAgICAgICAgICBjb25zdCB2X3BlYWsgPSAoc2ltU291cmNlIGFzIGFueSkudm9sdGFnZSA/PyAwXG4gICAgICAgICAgY29uc3QgZnJlcSA9IChzaW1Tb3VyY2UgYXMgYW55KS5mcmVxdWVuY3kgPz8gMFxuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gMCAvLyBub3QgcHJvdmlkZWQgaW4gY2lyY3VpdEpzb25cbiAgICAgICAgICBjb25zdCBkYW1waW5nX2ZhY3RvciA9IDAgLy8gbm90IHByb3ZpZGVkIGluIGNpcmN1aXRKc29uXG4gICAgICAgICAgY29uc3QgcGhhc2UgPSAoc2ltU291cmNlIGFzIGFueSkucGhhc2UgPz8gMFxuICAgICAgICAgIGlmIChmcmVxID4gMCkge1xuICAgICAgICAgICAgdmFsdWUgPSBgU0lOKCR7dl9vZmZzZXR9ICR7dl9wZWFrfSAke2ZyZXF9ICR7ZGVsYXl9ICR7ZGFtcGluZ19mYWN0b3J9ICR7cGhhc2V9KWBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBgREMgJHsoc2ltU291cmNlIGFzIGFueSkudm9sdGFnZSA/PyAwfWBcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2F2ZV9zaGFwZSA9PT0gXCJzcXVhcmVcIikge1xuICAgICAgICAgIGNvbnN0IHZfaW5pdGlhbCA9IDBcbiAgICAgICAgICBjb25zdCB2X3B1bHNlZCA9IChzaW1Tb3VyY2UgYXMgYW55KS52b2x0YWdlID8/IDBcbiAgICAgICAgICBjb25zdCBmcmVxID0gKHNpbVNvdXJjZSBhcyBhbnkpLmZyZXF1ZW5jeSA/PyAwXG4gICAgICAgICAgY29uc3QgcGVyaW9kX2Zyb21fZnJlcSA9IGZyZXEgPT09IDAgPyBJbmZpbml0eSA6IDEgLyBmcmVxXG4gICAgICAgICAgY29uc3QgcGVyaW9kID0gKHNpbVNvdXJjZSBhcyBhbnkpLnBlcmlvZCA/PyBwZXJpb2RfZnJvbV9mcmVxXG4gICAgICAgICAgY29uc3QgZHV0eV9jeWNsZSA9IChzaW1Tb3VyY2UgYXMgYW55KS5kdXR5X2N5Y2xlID8/IDAuNVxuICAgICAgICAgIGNvbnN0IHB1bHNlX3dpZHRoID0gcGVyaW9kICogZHV0eV9jeWNsZVxuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gMFxuICAgICAgICAgIGNvbnN0IHJpc2VfdGltZSA9IFwiMW5cIlxuICAgICAgICAgIGNvbnN0IGZhbGxfdGltZSA9IFwiMW5cIlxuICAgICAgICAgIHZhbHVlID0gYFBVTFNFKCR7dl9pbml0aWFsfSAke3ZfcHVsc2VkfSAke2RlbGF5fSAke3Jpc2VfdGltZX0gJHtmYWxsX3RpbWV9ICR7cHVsc2Vfd2lkdGh9ICR7cGVyaW9kfSlgXG4gICAgICAgIH0gZWxzZSBpZiAoKHNpbVNvdXJjZSBhcyBhbnkpLnZvbHRhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbHVlID0gYERDICR7KHNpbVNvdXJjZSBhcyBhbnkpLnZvbHRhZ2V9YFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgY29uc3Qgdm9sdGFnZVNvdXJjZUNtZCA9IG5ldyBWb2x0YWdlU291cmNlQ29tbWFuZCh7XG4gICAgICAgICAgICBuYW1lOiBzaW1Tb3VyY2Uuc2ltdWxhdGlvbl92b2x0YWdlX3NvdXJjZV9pZCxcbiAgICAgICAgICAgIHBvc2l0aXZlTm9kZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlTm9kZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBjb25zdCBzcGljZUNvbXBvbmVudCA9IG5ldyBTcGljZUNvbXBvbmVudChcbiAgICAgICAgICAgIHNpbVNvdXJjZS5zaW11bGF0aW9uX3ZvbHRhZ2Vfc291cmNlX2lkLFxuICAgICAgICAgICAgdm9sdGFnZVNvdXJjZUNtZCxcbiAgICAgICAgICAgIFtwb3NpdGl2ZU5vZGUsIG5lZ2F0aXZlTm9kZV0sXG4gICAgICAgICAgKVxuICAgICAgICAgIG5ldGxpc3QuYWRkQ29tcG9uZW50KHNwaWNlQ29tcG9uZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERDIFNvdXJjZSAoaXNfZGNfc291cmNlIGlzIHRydWUgb3IgdW5kZWZpbmVkKVxuICAgICAgY29uc3QgcG9zaXRpdmVQb3J0SWQgPVxuICAgICAgICAoc2ltU291cmNlIGFzIGFueSkucG9zaXRpdmVfc291cmNlX3BvcnRfaWQgPz9cbiAgICAgICAgKHNpbVNvdXJjZSBhcyBhbnkpLnRlcm1pbmFsMV9zb3VyY2VfcG9ydF9pZFxuICAgICAgY29uc3QgbmVnYXRpdmVQb3J0SWQgPVxuICAgICAgICAoc2ltU291cmNlIGFzIGFueSkubmVnYXRpdmVfc291cmNlX3BvcnRfaWQgPz9cbiAgICAgICAgKHNpbVNvdXJjZSBhcyBhbnkpLnRlcm1pbmFsMl9zb3VyY2VfcG9ydF9pZFxuXG4gICAgICBpZiAoXG4gICAgICAgIHBvc2l0aXZlUG9ydElkICYmXG4gICAgICAgIG5lZ2F0aXZlUG9ydElkICYmXG4gICAgICAgIFwidm9sdGFnZVwiIGluIHNpbVNvdXJjZSAmJlxuICAgICAgICAoc2ltU291cmNlIGFzIGFueSkudm9sdGFnZSAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgcG9zaXRpdmVOb2RlID0gbm9kZU1hcC5nZXQocG9zaXRpdmVQb3J0SWQpIHx8IFwiMFwiXG4gICAgICAgIGNvbnN0IG5lZ2F0aXZlTm9kZSA9IG5vZGVNYXAuZ2V0KG5lZ2F0aXZlUG9ydElkKSB8fCBcIjBcIlxuXG4gICAgICAgIGNvbnN0IHZvbHRhZ2VTb3VyY2VDbWQgPSBuZXcgVm9sdGFnZVNvdXJjZUNvbW1hbmQoe1xuICAgICAgICAgIG5hbWU6IHNpbVNvdXJjZS5zaW11bGF0aW9uX3ZvbHRhZ2Vfc291cmNlX2lkLFxuICAgICAgICAgIHBvc2l0aXZlTm9kZSxcbiAgICAgICAgICBuZWdhdGl2ZU5vZGUsXG4gICAgICAgICAgdmFsdWU6IGBEQyAkeyhzaW1Tb3VyY2UgYXMgYW55KS52b2x0YWdlfWAsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3Qgc3BpY2VDb21wb25lbnQgPSBuZXcgU3BpY2VDb21wb25lbnQoXG4gICAgICAgICAgc2ltU291cmNlLnNpbXVsYXRpb25fdm9sdGFnZV9zb3VyY2VfaWQsXG4gICAgICAgICAgdm9sdGFnZVNvdXJjZUNtZCxcbiAgICAgICAgICBbcG9zaXRpdmVOb2RlLCBuZWdhdGl2ZU5vZGVdLFxuICAgICAgICApXG4gICAgICAgIG5ldGxpc3QuYWRkQ29tcG9uZW50KHNwaWNlQ29tcG9uZW50KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNpbUV4cGVyaW1lbnQgPSBjaXJjdWl0SnNvbi5maW5kKFxuICAgIChlbG0pID0+IGVsbS50eXBlID09PSBcInNpbXVsYXRpb25fZXhwZXJpbWVudFwiLFxuICApXG5cbiAgaWYgKHNpbUV4cGVyaW1lbnQpIHtcbiAgICAvLyBQcm9jZXNzIHNpbXVsYXRpb24gdm9sdGFnZSBwcm9iZXNcbiAgICBpZiAoc2ltdWxhdGlvblByb2Jlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBub2Rlc1RvUHJvYmUgPSBuZXcgU2V0PHN0cmluZz4oKVxuXG4gICAgICBmb3IgKGNvbnN0IHByb2JlIG9mIHNpbXVsYXRpb25Qcm9iZXMpIHtcbiAgICAgICAgbGV0IG5vZGVOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICAgICAgaWYgKHByb2JlLnNvdXJjZV9wb3J0X2lkKSB7XG4gICAgICAgICAgbm9kZU5hbWUgPSBub2RlTWFwLmdldChwcm9iZS5zb3VyY2VfcG9ydF9pZClcbiAgICAgICAgfSBlbHNlIGlmIChwcm9iZS5zb3VyY2VfbmV0X2lkKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2UgPSBzb3VyY2VUcmFjZXMuZmluZCgodCkgPT5cbiAgICAgICAgICAgIHQuY29ubmVjdGVkX3NvdXJjZV9uZXRfaWRzLmluY2x1ZGVzKHByb2JlLnNvdXJjZV9uZXRfaWQhKSxcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKHRyYWNlICYmIHRyYWNlLmNvbm5lY3RlZF9zb3VyY2VfcG9ydF9pZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcG9ydElkID0gdHJhY2UuY29ubmVjdGVkX3NvdXJjZV9wb3J0X2lkc1swXVxuICAgICAgICAgICAgbm9kZU5hbWUgPSBub2RlTWFwLmdldChwb3J0SWQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGVOYW1lICYmIG5vZGVOYW1lICE9PSBcIjBcIikge1xuICAgICAgICAgIG5vZGVzVG9Qcm9iZS5hZGQoYFYoJHtub2RlTmFtZX0pYClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIG5vZGVzVG9Qcm9iZS5zaXplID4gMCAmJlxuICAgICAgICAoc2ltRXhwZXJpbWVudCBhcyBhbnkpLmV4cGVyaW1lbnRfdHlwZT8uaW5jbHVkZXMoXCJ0cmFuc2llbnRcIilcbiAgICAgICkge1xuICAgICAgICBuZXRsaXN0LnByaW50U3RhdGVtZW50cy5wdXNoKFxuICAgICAgICAgIGAuUFJJTlQgVFJBTiAke1suLi5ub2Rlc1RvUHJvYmVdLmpvaW4oXCIgXCIpfWAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0aW1lUGVyU3RlcCA9IChzaW1FeHBlcmltZW50IGFzIGFueSkudGltZV9wZXJfc3RlcFxuICAgIGNvbnN0IGVuZFRpbWUgPSAoc2ltRXhwZXJpbWVudCBhcyBhbnkpLmVuZF90aW1lX21zXG4gICAgY29uc3Qgc3RhcnRUaW1lTXMgPSAoc2ltRXhwZXJpbWVudCBhcyBhbnkpLnN0YXJ0X3RpbWVfbXNcblxuICAgIGlmICh0aW1lUGVyU3RlcCAmJiBlbmRUaW1lKSB7XG4gICAgICAvLyBjaXJjdWl0LWpzb24gdmFsdWVzIGFyZSBpbiBtcywgU1BJQ0UgcmVxdWlyZXMgc2Vjb25kc1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gKHN0YXJ0VGltZU1zID8/IDApIC8gMTAwMFxuXG4gICAgICBsZXQgdHJhbkNtZCA9IGAudHJhbiAke2Zvcm1hdE51bWJlckZvclNwaWNlKFxuICAgICAgICB0aW1lUGVyU3RlcCAvIDEwMDAsXG4gICAgICApfSAke2Zvcm1hdE51bWJlckZvclNwaWNlKGVuZFRpbWUgLyAxMDAwKX1gXG4gICAgICBpZiAoc3RhcnRUaW1lID4gMCkge1xuICAgICAgICB0cmFuQ21kICs9IGAgJHtmb3JtYXROdW1iZXJGb3JTcGljZShzdGFydFRpbWUpfWBcbiAgICAgIH1cbiAgICAgIHRyYW5DbWQgKz0gXCIgVUlDXCJcbiAgICAgIG5ldGxpc3QudHJhbkNvbW1hbmQgPSB0cmFuQ21kXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldGxpc3Rcbn1cblxuZnVuY3Rpb24gZm9ybWF0UmVzaXN0YW5jZShyZXNpc3RhbmNlOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAocmVzaXN0YW5jZSA+PSAxZTYpIHJldHVybiBgJHtyZXNpc3RhbmNlIC8gMWU2fU1FR2BcbiAgaWYgKHJlc2lzdGFuY2UgPj0gMWUzKSByZXR1cm4gYCR7cmVzaXN0YW5jZSAvIDFlM31LYFxuICByZXR1cm4gcmVzaXN0YW5jZS50b1N0cmluZygpXG59XG5cbmZ1bmN0aW9uIGZvcm1hdENhcGFjaXRhbmNlKGNhcGFjaXRhbmNlOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoY2FwYWNpdGFuY2UgPj0gMWUtMykgcmV0dXJuIGAke2NhcGFjaXRhbmNlICogMWUzfU1gXG4gIGlmIChjYXBhY2l0YW5jZSA+PSAxZS02KSByZXR1cm4gYCR7Y2FwYWNpdGFuY2UgKiAxZTZ9VWBcbiAgaWYgKGNhcGFjaXRhbmNlID49IDFlLTkpIHJldHVybiBgJHtjYXBhY2l0YW5jZSAqIDFlOX1OYFxuICBpZiAoY2FwYWNpdGFuY2UgPj0gMWUtMTIpIHJldHVybiBgJHtjYXBhY2l0YW5jZSAqIDFlMTJ9UGBcbiAgcmV0dXJuIGNhcGFjaXRhbmNlLnRvU3RyaW5nKClcbn1cblxuZnVuY3Rpb24gZm9ybWF0SW5kdWN0YW5jZShpbmR1Y3RhbmNlOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoaW5kdWN0YW5jZSA+PSAxKSByZXR1cm4gaW5kdWN0YW5jZS50b1N0cmluZygpXG4gIGlmIChpbmR1Y3RhbmNlID49IDFlLTMpIHJldHVybiBgJHtpbmR1Y3RhbmNlICogMWUzfW1gXG4gIGlmIChpbmR1Y3RhbmNlID49IDFlLTYpIHJldHVybiBgJHtpbmR1Y3RhbmNlICogMWU2fXVgXG4gIGlmIChpbmR1Y3RhbmNlID49IDFlLTkpIHJldHVybiBgJHtpbmR1Y3RhbmNlICogMWU5fW5gXG4gIGlmIChpbmR1Y3RhbmNlID49IDFlLTEyKSByZXR1cm4gYCR7aW5kdWN0YW5jZSAqIDFlMTJ9cGBcbiAgcmV0dXJuIGluZHVjdGFuY2UudG9TdHJpbmcoKVxufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZUlkZW50aWZpZXIodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgcHJlZml4OiBzdHJpbmcpIHtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIHByZWZpeFxuICBjb25zdCBzYW5pdGl6ZWQgPSB2YWx1ZS5yZXBsYWNlKC9bXkEtWmEtejAtOV9dL2csIFwiX1wiKVxuICBpZiAoIXNhbml0aXplZCkgcmV0dXJuIHByZWZpeFxuICBpZiAoL15bMC05XS8udGVzdChzYW5pdGl6ZWQpKSB7XG4gICAgcmV0dXJuIGAke3ByZWZpeH1fJHtzYW5pdGl6ZWR9YFxuICB9XG4gIHJldHVybiBzYW5pdGl6ZWRcbn1cblxuZnVuY3Rpb24gYnVpbGRTaW11bGF0aW9uU3dpdGNoQ29udHJvbFZhbHVlKFxuICBzaW11bGF0aW9uU3dpdGNoOiBTaW11bGF0aW9uU3dpdGNoIHwgdW5kZWZpbmVkLFxuKSB7XG4gIGNvbnN0IGhpZ2hWb2x0YWdlID0gNVxuICBjb25zdCBsb3dWb2x0YWdlID0gMFxuICBjb25zdCByaXNlVGltZSA9IFwiMW5cIlxuICBjb25zdCBmYWxsVGltZSA9IFwiMW5cIlxuXG4gIGlmICghc2ltdWxhdGlvblN3aXRjaCkge1xuICAgIHJldHVybiBgREMgJHtsb3dWb2x0YWdlfWBcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0c0Nsb3NlZCA9IHNpbXVsYXRpb25Td2l0Y2guc3RhcnRzX2Nsb3NlZCA/PyBmYWxzZVxuICBjb25zdCBjbG9zZXNBdCA9IHNpbXVsYXRpb25Td2l0Y2guY2xvc2VzX2F0ID8/IDBcbiAgY29uc3Qgb3BlbnNBdCA9IHNpbXVsYXRpb25Td2l0Y2gub3BlbnNfYXRcbiAgY29uc3Qgc3dpdGNoaW5nRnJlcXVlbmN5ID0gc2ltdWxhdGlvblN3aXRjaC5zd2l0Y2hpbmdfZnJlcXVlbmN5XG5cbiAgY29uc3QgW2luaXRpYWxWb2x0YWdlLCBwdWxzZWRWb2x0YWdlXSA9IHN0YXJ0c0Nsb3NlZFxuICAgID8gW2hpZ2hWb2x0YWdlLCBsb3dWb2x0YWdlXVxuICAgIDogW2xvd1ZvbHRhZ2UsIGhpZ2hWb2x0YWdlXVxuXG4gIGlmIChzd2l0Y2hpbmdGcmVxdWVuY3kgJiYgc3dpdGNoaW5nRnJlcXVlbmN5ID4gMCkge1xuICAgIGNvbnN0IHBlcmlvZCA9IDEgLyBzd2l0Y2hpbmdGcmVxdWVuY3lcbiAgICBjb25zdCB3aWR0aEZyb21PcGVuQ2xvc2UgPVxuICAgICAgb3BlbnNBdCAmJiBvcGVuc0F0ID4gY2xvc2VzQXQgPyBNYXRoLm1pbihvcGVuc0F0IC0gY2xvc2VzQXQsIHBlcmlvZCkgOiAwXG4gICAgY29uc3QgcHVsc2VXaWR0aCA9XG4gICAgICB3aWR0aEZyb21PcGVuQ2xvc2UgPiAwID8gd2lkdGhGcm9tT3BlbkNsb3NlIDogTWF0aC5tYXgocGVyaW9kIC8gMiwgMWUtOSlcblxuICAgIHJldHVybiBgUFVMU0UoJHtmb3JtYXROdW1iZXJGb3JTcGljZShpbml0aWFsVm9sdGFnZSl9ICR7Zm9ybWF0TnVtYmVyRm9yU3BpY2UocHVsc2VkVm9sdGFnZSl9ICR7Zm9ybWF0TnVtYmVyRm9yU3BpY2UoY2xvc2VzQXQpfSAke3Jpc2VUaW1lfSAke2ZhbGxUaW1lfSAke2Zvcm1hdE51bWJlckZvclNwaWNlKHB1bHNlV2lkdGgpfSAke2Zvcm1hdE51bWJlckZvclNwaWNlKHBlcmlvZCl9KWBcbiAgfVxuXG4gIGlmIChvcGVuc0F0ICE9PSB1bmRlZmluZWQgJiYgb3BlbnNBdCA+IGNsb3Nlc0F0KSB7XG4gICAgY29uc3QgcHVsc2VXaWR0aCA9IE1hdGgubWF4KG9wZW5zQXQgLSBjbG9zZXNBdCwgMWUtOSlcbiAgICBjb25zdCBwZXJpb2QgPSBjbG9zZXNBdCArIHB1bHNlV2lkdGggKiAyXG5cbiAgICByZXR1cm4gYFBVTFNFKCR7Zm9ybWF0TnVtYmVyRm9yU3BpY2UoaW5pdGlhbFZvbHRhZ2UpfSAke2Zvcm1hdE51bWJlckZvclNwaWNlKHB1bHNlZFZvbHRhZ2UpfSAke2Zvcm1hdE51bWJlckZvclNwaWNlKGNsb3Nlc0F0KX0gJHtyaXNlVGltZX0gJHtmYWxsVGltZX0gJHtmb3JtYXROdW1iZXJGb3JTcGljZShwdWxzZVdpZHRoKX0gJHtmb3JtYXROdW1iZXJGb3JTcGljZShwZXJpb2QpfSlgXG4gIH1cblxuICBpZiAoY2xvc2VzQXQgPiAwKSB7XG4gICAgY29uc3QgcGVyaW9kID0gY2xvc2VzQXQgKiAyXG4gICAgY29uc3QgcHVsc2VXaWR0aCA9IE1hdGgubWF4KHBlcmlvZCAvIDIsIDFlLTkpXG4gICAgcmV0dXJuIGBQVUxTRSgke2Zvcm1hdE51bWJlckZvclNwaWNlKGluaXRpYWxWb2x0YWdlKX0gJHtmb3JtYXROdW1iZXJGb3JTcGljZShwdWxzZWRWb2x0YWdlKX0gJHtmb3JtYXROdW1iZXJGb3JTcGljZShjbG9zZXNBdCl9ICR7cmlzZVRpbWV9ICR7ZmFsbFRpbWV9ICR7Zm9ybWF0TnVtYmVyRm9yU3BpY2UocHVsc2VXaWR0aCl9ICR7Zm9ybWF0TnVtYmVyRm9yU3BpY2UocGVyaW9kKX0pYFxuICB9XG5cbiAgcmV0dXJuIGBEQyAke3N0YXJ0c0Nsb3NlZCA/IGhpZ2hWb2x0YWdlIDogbG93Vm9sdGFnZX1gXG59XG5cbmZ1bmN0aW9uIGZvcm1hdE51bWJlckZvclNwaWNlKHZhbHVlOiBudW1iZXIpIHtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSByZXR1cm4gYCR7dmFsdWV9YFxuICBpZiAodmFsdWUgPT09IDApIHJldHVybiBcIjBcIlxuXG4gIGNvbnN0IGFic1ZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGFic1ZhbHVlID49IDFlMyB8fCBhYnNWYWx1ZSA8PSAxZS0zKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZS50b0V4cG9uZW50aWFsKDYpKS50b1N0cmluZygpXG4gIH1cblxuICByZXR1cm4gTnVtYmVyKHZhbHVlLnRvUHJlY2lzaW9uKDYpKS50b1N0cmluZygpXG59XG4iLCAiZXhwb3J0IGNsYXNzIFNwaWNlU3ViY2lyY3VpdCB7XG4gIG5hbWU6IHN0cmluZ1xuICBwaW5zOiBzdHJpbmdbXVxuXG4gIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgcGluczogc3RyaW5nW10pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5waW5zID0gcGluc1xuICB9XG5cbiAgdG9TcGljZVN0cmluZygpOiBzdHJpbmcge1xuICAgIGNvbnN0IHBpblN0cmluZyA9IHRoaXMucGlucy5qb2luKFwiIFwiKVxuICAgIGNvbnN0IGhlYWRlciA9IGAuU1VCQ0tUICR7dGhpcy5uYW1lfSAke3BpblN0cmluZ31gXG4gICAgY29uc3QgZm9vdGVyID0gYC5FTkRTICR7dGhpcy5uYW1lfWBcblxuICAgIGNvbnN0IGJvZHkgPSBgKiBQbGFjZWhvbGRlciBmb3IgJHt0aGlzLm5hbWV9LiBObyBkZWZpbml0aW9uIGZvdW5kIGluIGNpcmN1aXQgSlNPTi5gXG5cbiAgICByZXR1cm4gW1wiXCIsIGhlYWRlciwgYm9keSwgZm9vdGVyXS5qb2luKFwiXFxuXCIpXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJhc2VTcGljZUNvbW1hbmQgfSBmcm9tIFwiLi9CYXNlU3BpY2VDb21tYW5kXCJcblxuZXhwb3J0IGludGVyZmFjZSBCSlRDb21tYW5kUHJvcHMge1xuICBuYW1lOiBzdHJpbmdcbiAgY29sbGVjdG9yOiBzdHJpbmdcbiAgYmFzZTogc3RyaW5nXG4gIGVtaXR0ZXI6IHN0cmluZ1xuICBzdWJzdHJhdGU/OiBzdHJpbmdcbiAgbW9kZWw6IHN0cmluZ1xuICBhcmVhPzogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBCSlRDb21tYW5kIGltcGxlbWVudHMgQmFzZVNwaWNlQ29tbWFuZCB7XG4gIGNvbW1hbmROYW1lID0gXCJianRcIiBhcyBjb25zdFxuICBwcm9wczogQkpUQ29tbWFuZFByb3BzXG5cbiAgY29uc3RydWN0b3IocHJvcHM6IEJKVENvbW1hbmRQcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSBwcm9wc1xuICB9XG5cbiAgdG9TcGljZVN0cmluZygpOiBzdHJpbmcge1xuICAgIGNvbnN0IHsgbmFtZSwgY29sbGVjdG9yLCBiYXNlLCBlbWl0dGVyLCBzdWJzdHJhdGUsIG1vZGVsLCBhcmVhIH0gPVxuICAgICAgdGhpcy5wcm9wc1xuICAgIGxldCBzcGljZVN0cmluZyA9IGBRJHtuYW1lfSAke2NvbGxlY3Rvcn0gJHtiYXNlfSAke2VtaXR0ZXJ9YFxuICAgIGlmIChzdWJzdHJhdGUpIHtcbiAgICAgIHNwaWNlU3RyaW5nICs9IGAgJHtzdWJzdHJhdGV9YFxuICAgIH1cbiAgICBzcGljZVN0cmluZyArPSBgICR7bW9kZWx9YFxuICAgIGlmIChhcmVhKSB7XG4gICAgICBzcGljZVN0cmluZyArPSBgICR7YXJlYX1gXG4gICAgfVxuICAgIHJldHVybiBzcGljZVN0cmluZ1xuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBCYXNlU3BpY2VDb21tYW5kIH0gZnJvbSBcIi4vQmFzZVNwaWNlQ29tbWFuZFwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VycmVudFNvdXJjZUNvbW1hbmRQcm9wcyB7XG4gIG5hbWU6IHN0cmluZ1xuICBwb3NpdGl2ZU5vZGU6IHN0cmluZ1xuICBuZWdhdGl2ZU5vZGU6IHN0cmluZ1xuICB2YWx1ZT86IHN0cmluZ1xuICBhY01hZ25pdHVkZT86IHN0cmluZ1xuICBhY1BoYXNlPzogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBDdXJyZW50U291cmNlQ29tbWFuZCBpbXBsZW1lbnRzIEJhc2VTcGljZUNvbW1hbmQge1xuICBjb21tYW5kTmFtZSA9IFwiY3VycmVudF9zb3VyY2VcIiBhcyBjb25zdFxuICBwcm9wczogQ3VycmVudFNvdXJjZUNvbW1hbmRQcm9wc1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBDdXJyZW50U291cmNlQ29tbWFuZFByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzXG4gIH1cblxuICB0b1NwaWNlU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBuYW1lLCBwb3NpdGl2ZU5vZGUsIG5lZ2F0aXZlTm9kZSwgdmFsdWUsIGFjTWFnbml0dWRlLCBhY1BoYXNlIH0gPVxuICAgICAgdGhpcy5wcm9wc1xuICAgIGxldCBzcGljZVN0cmluZyA9IGBJJHtuYW1lfSAke3Bvc2l0aXZlTm9kZX0gJHtuZWdhdGl2ZU5vZGV9YFxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgc3BpY2VTdHJpbmcgKz0gYCAke3ZhbHVlfWBcbiAgICB9XG4gICAgaWYgKGFjTWFnbml0dWRlKSB7XG4gICAgICBzcGljZVN0cmluZyArPSBgIEFDICR7YWNNYWduaXR1ZGV9YFxuICAgICAgaWYgKGFjUGhhc2UpIHtcbiAgICAgICAgc3BpY2VTdHJpbmcgKz0gYCAke2FjUGhhc2V9YFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3BpY2VTdHJpbmdcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgQmFzZVNwaWNlQ29tbWFuZCB9IGZyb20gXCIuL0Jhc2VTcGljZUNvbW1hbmRcIlxuXG5leHBvcnQgaW50ZXJmYWNlIEluZHVjdG9yQ291cGxpbmdDb21tYW5kUHJvcHMge1xuICBuYW1lOiBzdHJpbmdcbiAgaW5kdWN0b3JzOiBzdHJpbmdbXVxuICBjb3VwbGluZzogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBJbmR1Y3RvckNvdXBsaW5nQ29tbWFuZCBpbXBsZW1lbnRzIEJhc2VTcGljZUNvbW1hbmQge1xuICBjb21tYW5kTmFtZSA9IFwiaW5kdWN0b3JfY291cGxpbmdcIiBhcyBjb25zdFxuICBwcm9wczogSW5kdWN0b3JDb3VwbGluZ0NvbW1hbmRQcm9wc1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJbmR1Y3RvckNvdXBsaW5nQ29tbWFuZFByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzXG4gIH1cblxuICB0b1NwaWNlU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBuYW1lLCBpbmR1Y3RvcnMsIGNvdXBsaW5nIH0gPSB0aGlzLnByb3BzXG4gICAgcmV0dXJuIGBLJHtuYW1lfSAke2luZHVjdG9ycy5qb2luKFwiIFwiKX0gJHtjb3VwbGluZ31gXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJhc2VTcGljZUNvbW1hbmQgfSBmcm9tIFwiLi9CYXNlU3BpY2VDb21tYW5kXCJcblxuZXhwb3J0IGludGVyZmFjZSBKRkVUQ29tbWFuZFByb3BzIHtcbiAgbmFtZTogc3RyaW5nXG4gIGRyYWluOiBzdHJpbmdcbiAgZ2F0ZTogc3RyaW5nXG4gIHNvdXJjZTogc3RyaW5nXG4gIG1vZGVsOiBzdHJpbmdcbiAgYXJlYT86IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgSkZFVENvbW1hbmQgaW1wbGVtZW50cyBCYXNlU3BpY2VDb21tYW5kIHtcbiAgY29tbWFuZE5hbWUgPSBcImpmZXRcIiBhcyBjb25zdFxuICBwcm9wczogSkZFVENvbW1hbmRQcm9wc1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBKRkVUQ29tbWFuZFByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzXG4gIH1cblxuICB0b1NwaWNlU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBuYW1lLCBkcmFpbiwgZ2F0ZSwgc291cmNlLCBtb2RlbCwgYXJlYSB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCBzcGljZVN0cmluZyA9IGBKJHtuYW1lfSAke2RyYWlufSAke2dhdGV9ICR7c291cmNlfSAke21vZGVsfWBcbiAgICBpZiAoYXJlYSkge1xuICAgICAgc3BpY2VTdHJpbmcgKz0gYCAke2FyZWF9YFxuICAgIH1cbiAgICByZXR1cm4gc3BpY2VTdHJpbmdcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgQmFzZVNwaWNlQ29tbWFuZCB9IGZyb20gXCIuL0Jhc2VTcGljZUNvbW1hbmRcIlxuXG5leHBvcnQgaW50ZXJmYWNlIE1PU0ZFVENvbW1hbmRQcm9wcyB7XG4gIG5hbWU6IHN0cmluZ1xuICBkcmFpbjogc3RyaW5nXG4gIGdhdGU6IHN0cmluZ1xuICBzb3VyY2U6IHN0cmluZ1xuICBzdWJzdHJhdGU6IHN0cmluZ1xuICBtb2RlbDogc3RyaW5nXG4gIGxlbmd0aD86IHN0cmluZ1xuICB3aWR0aD86IHN0cmluZ1xuICBkcmFpbkFyZWE/OiBzdHJpbmdcbiAgc291cmNlQXJlYT86IHN0cmluZ1xuICBkcmFpblBlcmltZXRlcj86IHN0cmluZ1xuICBzb3VyY2VQZXJpbWV0ZXI/OiBzdHJpbmdcbiAgZHJhaW5SZXNpc3RhbmNlPzogc3RyaW5nXG4gIHNvdXJjZVJlc2lzdGFuY2U/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGNsYXNzIE1PU0ZFVENvbW1hbmQgaW1wbGVtZW50cyBCYXNlU3BpY2VDb21tYW5kIHtcbiAgY29tbWFuZE5hbWUgPSBcIm1vc2ZldFwiIGFzIGNvbnN0XG4gIHByb3BzOiBNT1NGRVRDb21tYW5kUHJvcHNcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogTU9TRkVUQ29tbWFuZFByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzXG4gIH1cblxuICB0b1NwaWNlU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGRyYWluLFxuICAgICAgZ2F0ZSxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHN1YnN0cmF0ZSxcbiAgICAgIG1vZGVsLFxuICAgICAgbGVuZ3RoLFxuICAgICAgd2lkdGgsXG4gICAgICBkcmFpbkFyZWEsXG4gICAgICBzb3VyY2VBcmVhLFxuICAgICAgZHJhaW5QZXJpbWV0ZXIsXG4gICAgICBzb3VyY2VQZXJpbWV0ZXIsXG4gICAgICBkcmFpblJlc2lzdGFuY2UsXG4gICAgICBzb3VyY2VSZXNpc3RhbmNlLFxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBsZXQgc3BpY2VTdHJpbmcgPSBgTSR7bmFtZX0gJHtkcmFpbn0gJHtnYXRlfSAke3NvdXJjZX0gJHtzdWJzdHJhdGV9ICR7bW9kZWx9YFxuXG4gICAgY29uc3QgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0ge1xuICAgICAgTDogbGVuZ3RoLFxuICAgICAgVzogd2lkdGgsXG4gICAgICBBRDogZHJhaW5BcmVhLFxuICAgICAgQVM6IHNvdXJjZUFyZWEsXG4gICAgICBQRDogZHJhaW5QZXJpbWV0ZXIsXG4gICAgICBQUzogc291cmNlUGVyaW1ldGVyLFxuICAgICAgTlJEOiBkcmFpblJlc2lzdGFuY2UsXG4gICAgICBOUlM6IHNvdXJjZVJlc2lzdGFuY2UsXG4gICAgfVxuXG4gICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBzcGljZVN0cmluZyArPSBgICR7a2V5fT0ke3ZhbHVlfWBcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHNwaWNlU3RyaW5nXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJhc2VTcGljZUNvbW1hbmQgfSBmcm9tIFwiLi9CYXNlU3BpY2VDb21tYW5kXCJcblxuZXhwb3J0IGludGVyZmFjZSBTdWJjaXJjdWl0Q2FsbENvbW1hbmRQcm9wcyB7XG4gIG5hbWU6IHN0cmluZ1xuICBub2Rlczogc3RyaW5nW11cbiAgc3ViY2lyY3VpdE5hbWU6IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgU3ViY2lyY3VpdENhbGxDb21tYW5kIGltcGxlbWVudHMgQmFzZVNwaWNlQ29tbWFuZCB7XG4gIGNvbW1hbmROYW1lID0gXCJzdWJjaXJjdWl0X2NhbGxcIiBhcyBjb25zdFxuICBwcm9wczogU3ViY2lyY3VpdENhbGxDb21tYW5kUHJvcHNcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogU3ViY2lyY3VpdENhbGxDb21tYW5kUHJvcHMpIHtcbiAgICB0aGlzLnByb3BzID0gcHJvcHNcbiAgfVxuXG4gIHRvU3BpY2VTdHJpbmcoKTogc3RyaW5nIHtcbiAgICBjb25zdCB7IG5hbWUsIG5vZGVzLCBzdWJjaXJjdWl0TmFtZSB9ID0gdGhpcy5wcm9wc1xuICAgIHJldHVybiBgWCR7bmFtZX0gJHtub2Rlcy5qb2luKFwiIFwiKX0gJHtzdWJjaXJjdWl0TmFtZX1gXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJhc2VTcGljZUNvbW1hbmQgfSBmcm9tIFwiLi9CYXNlU3BpY2VDb21tYW5kXCJcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc21pc3Npb25MaW5lQ29tbWFuZFByb3BzIHtcbiAgbmFtZTogc3RyaW5nXG4gIGFQb3NpdGl2ZTogc3RyaW5nXG4gIGFOZWdhdGl2ZTogc3RyaW5nXG4gIGJQb3NpdGl2ZTogc3RyaW5nXG4gIGJOZWdhdGl2ZTogc3RyaW5nXG4gIGltcGVkYW5jZTogc3RyaW5nXG4gIGRlbGF5Pzogc3RyaW5nXG4gIGZyZXF1ZW5jeT86IHN0cmluZ1xuICBub3JtYWxpemVkTGVuZ3RoPzogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBUcmFuc21pc3Npb25MaW5lQ29tbWFuZCBpbXBsZW1lbnRzIEJhc2VTcGljZUNvbW1hbmQge1xuICBjb21tYW5kTmFtZSA9IFwidHJhbnNtaXNzaW9uX2xpbmVcIiBhcyBjb25zdFxuICBwcm9wczogVHJhbnNtaXNzaW9uTGluZUNvbW1hbmRQcm9wc1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBUcmFuc21pc3Npb25MaW5lQ29tbWFuZFByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzXG4gIH1cblxuICB0b1NwaWNlU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGFQb3NpdGl2ZSxcbiAgICAgIGFOZWdhdGl2ZSxcbiAgICAgIGJQb3NpdGl2ZSxcbiAgICAgIGJOZWdhdGl2ZSxcbiAgICAgIGltcGVkYW5jZSxcbiAgICAgIGRlbGF5LFxuICAgICAgZnJlcXVlbmN5LFxuICAgICAgbm9ybWFsaXplZExlbmd0aCxcbiAgICB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCBzcGljZVN0cmluZyA9IGBUJHtuYW1lfSAke2FQb3NpdGl2ZX0gJHthTmVnYXRpdmV9ICR7YlBvc2l0aXZlfSAke2JOZWdhdGl2ZX0gWjA9JHtpbXBlZGFuY2V9YFxuICAgIGlmIChkZWxheSkge1xuICAgICAgc3BpY2VTdHJpbmcgKz0gYCBURD0ke2RlbGF5fWBcbiAgICB9IGVsc2UgaWYgKGZyZXF1ZW5jeSkge1xuICAgICAgc3BpY2VTdHJpbmcgKz0gYCBGPSR7ZnJlcXVlbmN5fWBcbiAgICAgIGlmIChub3JtYWxpemVkTGVuZ3RoKSB7XG4gICAgICAgIHNwaWNlU3RyaW5nICs9IGAgTkw9JHtub3JtYWxpemVkTGVuZ3RofWBcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwaWNlU3RyaW5nXG4gIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7QUFFTyxJQUFNLDhCQUE4QixDQUFDLFlBQWtDO0FBQzVFLFFBQU0sUUFBa0IsQ0FBQztBQUd6QixRQUFNLEtBQUssUUFBUSxLQUFLO0FBR3hCLE1BQUksUUFBUSxPQUFPLE9BQU8sR0FBRztBQUMzQixVQUFNLEtBQUssR0FBRyxNQUFNLEtBQUssUUFBUSxPQUFPLE9BQU8sQ0FBQyxDQUFDO0FBQUEsRUFDbkQ7QUFHQSxhQUFXLGFBQWEsUUFBUSxZQUFZO0FBQzFDLFVBQU0sS0FBSyxVQUFV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