// lib/KicadToCircuitJsonConverter.ts
import { cju } from "@tscircuit/circuit-json-util";
import { parseKicadPcb, parseKicadSch } from "kicadts";

// lib/types.ts
var ConverterStage = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  MAX_ITERATIONS = 100;
  iterationCount = 0;
  finished = false;
  /**
   * Run this stage until completion or max iterations reached.
   */
  runUntilFinished() {
    this.iterationCount = 0;
    while (!this.finished && this.iterationCount < this.MAX_ITERATIONS) {
      const hasMoreWork = this.step();
      if (!hasMoreWork) {
        this.finished = true;
      }
      this.iterationCount++;
    }
    if (this.iterationCount >= this.MAX_ITERATIONS) {
      this.ctx.warnings = this.ctx.warnings || [];
      this.ctx.warnings.push(
        `Stage ${this.constructor.name} exceeded maximum iterations (${this.MAX_ITERATIONS})`
      );
      this.finished = true;
    }
  }
};

// lib/stages/schematic/InitializeSchematicContextStage.ts
import { compose, scale, translate } from "transformation-matrix";
var InitializeSchematicContextStage = class extends ConverterStage {
  step() {
    if (!this.ctx.kicadSch) {
      this.finished = true;
      return false;
    }
    const KICAD_CENTER_X = 105;
    const KICAD_CENTER_Y = 148.5;
    const kicadCenterX = KICAD_CENTER_X;
    const kicadCenterY = KICAD_CENTER_Y;
    const cjCenterX = 0;
    const cjCenterY = 0;
    this.ctx.k2cMatSch = compose(
      translate(cjCenterX, cjCenterY),
      scale(1 / 15, -1 / 15),
      translate(-kicadCenterX, -kicadCenterY)
    );
    this.ctx.symbolUuidToComponentId = /* @__PURE__ */ new Map();
    this.ctx.warnings = this.ctx.warnings || [];
    this.ctx.stats = this.ctx.stats || {};
    this.finished = true;
    return false;
  }
};

// lib/stages/schematic/CollectLibrarySymbolsStage.ts
import { applyToPoint } from "transformation-matrix";

// lib/stages/schematic/utils/rotationToDirection.ts
function rotationToDirection(rotation) {
  const normalized = (rotation % 360 + 360) % 360;
  if (normalized >= 315 || normalized < 45) return "up";
  if (normalized >= 45 && normalized < 135) return "right";
  if (normalized >= 135 && normalized < 225) return "down";
  return "left";
}

// lib/stages/schematic/utils/inferSymbolName.ts
function inferSymbolName({
  libId,
  reference,
  rotation
}) {
  const lower = libId.toLowerCase();
  const direction = rotationToDirection(rotation);
  if (lower.includes(":r_") || lower.includes(":r") && reference.startsWith("R")) {
    return `boxresistor_${direction}`;
  }
  if (lower.includes(":c_") || lower.includes(":c") && reference.startsWith("C")) {
    if (lower.includes("polarized") || lower.includes("_pol")) {
      return `capacitor_${direction}`;
    }
    return `capacitor_${direction}`;
  }
  if (lower.includes(":l_") || lower.includes(":l") && reference.startsWith("L")) {
    return `inductor_${direction}`;
  }
  if (lower.includes(":d_") || lower.includes("diode") || reference.startsWith("D")) {
    if (lower.includes("led")) {
      return `led_${direction}`;
    }
    if (lower.includes("schottky")) {
      return `schottky_diode_${direction}`;
    }
    if (lower.includes("zener")) {
      return `zener_diode_${direction}`;
    }
    return `diode_${direction}`;
  }
  if (lower.includes(":q_") || reference.startsWith("Q")) {
    if (lower.includes("npn")) {
      return `npn_bipolar_transistor_${direction}`;
    }
    if (lower.includes("pnp")) {
      return `pnp_bipolar_transistor_${direction}`;
    }
    if (lower.includes("_n_") || lower.includes("nmos")) {
      return `n_channel_mosfet_transistor_${direction}`;
    }
    if (lower.includes("_p_") || lower.includes("pmos")) {
      return `p_channel_mosfet_transistor_${direction}`;
    }
    return `npn_bipolar_transistor_${direction}`;
  }
  if (lower.includes("gnd") || lower.includes("ground")) {
    return void 0;
  }
  if (lower.includes("vcc") || lower.includes("vdd") || lower.includes("power")) {
    return void 0;
  }
}

// lib/stages/schematic/CollectLibrarySymbolsStage.ts
var CollectLibrarySymbolsStage = class extends ConverterStage {
  processedSymbols = /* @__PURE__ */ new Set();
  step() {
    if (!this.ctx.kicadSch || !this.ctx.k2cMatSch) {
      this.finished = true;
      return false;
    }
    const symbols = this.ctx.kicadSch.symbols || [];
    for (const symbol of symbols) {
      const uuid = symbol.uuid;
      if (!uuid || this.processedSymbols.has(uuid)) continue;
      this.processSymbol(symbol);
      this.processedSymbols.add(uuid);
    }
    this.finished = true;
    return false;
  }
  processSymbol(symbol) {
    if (!this.ctx.k2cMatSch) return;
    const reference = this.getProperty(symbol, "Reference") || "U?";
    const value = this.getProperty(symbol, "Value") || "";
    const libId = symbol.libraryId || "";
    const at = symbol.at;
    const kicadPos = { x: at?.x ?? 0, y: at?.y ?? 0 };
    const cjPos = applyToPoint(this.ctx.k2cMatSch, kicadPos);
    const rotation = at?.angle ?? 0;
    const ftype = this.inferFtype(libId, reference);
    const sourceComponentId = `${libId}_source`;
    const existingSource = this.ctx.db.source_component.list().find((sc) => sc.source_component_id === sourceComponentId);
    if (!existingSource) {
      this.ctx.db.source_component.insert({
        name: libId || reference,
        ftype,
        // TODO: Fix ftype - should be mapped to valid CJ simple component types
        manufacturer_part_number: value || void 0
      });
    }
    const uuid = symbol.uuid;
    if (!uuid) return;
    const symbolName = inferSymbolName({ libId, reference, rotation });
    const inserted = this.ctx.db.schematic_component.insert({
      source_component_id: sourceComponentId,
      center: { x: cjPos.x, y: cjPos.y },
      size: this.estimateSize(symbol),
      ...symbolName ? { symbol_name: symbolName } : {}
    });
    const componentId = inserted.schematic_component_id;
    this.ctx.symbolUuidToComponentId?.set(uuid, componentId);
    this.createPorts(symbol, componentId);
    if (this.ctx.stats) {
      this.ctx.stats.components = (this.ctx.stats.components || 0) + 1;
    }
  }
  getProperty(symbol, propName) {
    const props = symbol.properties || [];
    const prop = props.find((p) => p.key === propName);
    return prop?.value;
  }
  inferFtype(libId, reference) {
    const lower = libId.toLowerCase();
    if (lower.includes(":r_") || reference.startsWith("R"))
      return "simple_resistor";
    if (lower.includes(":c_") || reference.startsWith("C"))
      return "simple_capacitor";
    if (lower.includes(":l_") || reference.startsWith("L"))
      return "simple_inductor";
    if (lower.includes(":d_") || reference.startsWith("D"))
      return "simple_diode";
    if (lower.includes(":led") || reference.startsWith("LED"))
      return "simple_led";
    if (lower.includes(":q_") || reference.startsWith("Q"))
      return "simple_transistor";
    return "simple_chip";
  }
  estimateSize(symbol) {
    return { width: 1, height: 1 };
  }
  createPorts(symbol, componentId) {
    const libId = symbol.libraryId;
    const libSymbol = this.ctx.kicadSch?.libSymbols?.symbols?.find(
      (ls) => ls.libraryId === libId
    );
    if (!libSymbol) return;
    const allPins = [];
    if (libSymbol.pins && Array.isArray(libSymbol.pins) && libSymbol.pins.length > 0) {
      allPins.push(...libSymbol.pins);
    } else if (libSymbol.pins && !Array.isArray(libSymbol.pins)) {
      allPins.push(libSymbol.pins);
    }
    if (libSymbol.subSymbols && Array.isArray(libSymbol.subSymbols)) {
      for (const subSymbol of libSymbol.subSymbols) {
        if (subSymbol.pins && Array.isArray(subSymbol.pins) && subSymbol.pins.length > 0) {
          allPins.push(...subSymbol.pins);
        } else if (subSymbol.pins && !Array.isArray(subSymbol.pins)) {
          allPins.push(subSymbol.pins);
        }
      }
    }
    if (allPins.length === 0) return;
    const componentRotation = symbol.at?.angle ?? 0;
    for (const pin of allPins) {
      const pinAt = pin._sxAt;
      if (!pinAt) continue;
      const rotRad = componentRotation * Math.PI / 180;
      const cosR = Math.cos(rotRad);
      const sinR = Math.sin(rotRad);
      const rotatedPinPos = {
        x: pinAt.x * cosR - pinAt.y * sinR,
        y: pinAt.x * sinR + pinAt.y * cosR
      };
      const scaleFactor = Math.abs(this.ctx.k2cMatSch?.a || 1 / 15);
      const relativePos = {
        x: rotatedPinPos.x * scaleFactor,
        y: -rotatedPinPos.y * scaleFactor
        // Flip Y axis
      };
      this.ctx.db.schematic_port.insert({
        schematic_component_id: componentId,
        center: relativePos,
        facing_direction: this.inferPinDirection(pin, componentRotation),
        pin_number: pin._sxNumber?.value ?? pin.pinNumber ?? void 0
      });
    }
  }
  inferPinDirection(pin, componentRotation) {
    const pinAngle = pin.at?.angle ?? 0;
    const totalAngle = pinAngle + componentRotation;
    return rotationToDirection(totalAngle);
  }
};

// lib/stages/schematic/CollectSchematicTracesStage.ts
import { applyToPoint as applyToPoint2 } from "transformation-matrix";
var CollectSchematicTracesStage = class extends ConverterStage {
  step() {
    if (!this.ctx.kicadSch || !this.ctx.k2cMatSch) {
      this.finished = true;
      return false;
    }
    const wires = this.ctx.kicadSch.wires || [];
    const wireArray = Array.isArray(wires) ? wires : [wires];
    for (const wire of wireArray) {
      this.processWire(wire);
    }
    const junctions = this.ctx.kicadSch.junctions || [];
    const junctionArray = Array.isArray(junctions) ? junctions : [junctions];
    for (const junction of junctionArray) {
      this.processJunction(junction);
    }
    this.finished = true;
    return false;
  }
  processWire(wire) {
    if (!this.ctx.k2cMatSch || !wire.pts) return;
    const pts = Array.isArray(wire.pts.xy) ? wire.pts.xy : [wire.pts.xy];
    if (pts.length < 2) return;
    const edges = [];
    for (let i = 0; i < pts.length - 1; i++) {
      const from = applyToPoint2(this.ctx.k2cMatSch, {
        x: pts[i].x,
        y: pts[i].y
      });
      const to = applyToPoint2(this.ctx.k2cMatSch, {
        x: pts[i + 1].x,
        y: pts[i + 1].y
      });
      edges.push({ from, to });
    }
    this.ctx.db.schematic_trace.insert({
      edges
    });
    if (this.ctx.stats) {
      this.ctx.stats.traces = (this.ctx.stats.traces || 0) + 1;
    }
  }
  processJunction(junction) {
    if (!this.ctx.k2cMatSch || !junction.at) return;
    const pos = applyToPoint2(this.ctx.k2cMatSch, {
      x: junction.at.x,
      y: junction.at.y
    });
    this.ctx.db.schematic_trace.insert({
      edges: [],
      junctions: [pos]
    });
  }
};

// lib/stages/pcb/InitializePcbContextStage.ts
import { compose as compose2, scale as scale2, translate as translate2 } from "transformation-matrix";
var InitializePcbContextStage = class extends ConverterStage {
  step() {
    if (!this.ctx.kicadPcb) {
      this.finished = true;
      return false;
    }
    const center = this.calculateBoardCenter();
    this.ctx.k2cMatPcb = compose2(scale2(1, -1), translate2(-center.x, -center.y));
    this.ctx.netNumToName = /* @__PURE__ */ new Map();
    this.ctx.footprintUuidToComponentId = /* @__PURE__ */ new Map();
    this.finished = true;
    return false;
  }
  calculateBoardCenter() {
    if (!this.ctx.kicadPcb) {
      return { x: 0, y: 0 };
    }
    const lines = this.ctx.kicadPcb.graphicLines || [];
    const lineArray = Array.isArray(lines) ? lines : [lines];
    const edgeCutLines = lineArray.filter((line) => {
      const layer = line.layer;
      const layerNames = typeof layer === "string" ? [layer] : layer?.names || [];
      const layerStr = layerNames.join(" ");
      return layerStr.includes("Edge.Cuts");
    });
    if (edgeCutLines.length === 0) {
      return { x: 0, y: 0 };
    }
    const xs = [];
    const ys = [];
    for (const line of edgeCutLines) {
      if (line.start) {
        xs.push(line.start.x);
        ys.push(line.start.y);
      }
      if (line.end) {
        xs.push(line.end.x);
        ys.push(line.end.y);
      }
    }
    if (xs.length === 0 || ys.length === 0) {
      return { x: 0, y: 0 };
    }
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    return {
      x: (minX + maxX) / 2,
      y: (minY + maxY) / 2
    };
  }
};

// lib/stages/pcb/CollectNetsStage.ts
var CollectNetsStage = class extends ConverterStage {
  step() {
    if (!this.ctx.kicadPcb || !this.ctx.netNumToName) {
      this.finished = true;
      return false;
    }
    const nets = this.ctx.kicadPcb.nets || [];
    const netArray = Array.isArray(nets) ? nets : [nets];
    for (const net of netArray) {
      const netNum = net._id ?? net.number ?? net.ordinal ?? 0;
      const netName = net._name ?? net.name ?? `Net-${netNum}`;
      this.ctx.netNumToName.set(netNum, netName);
    }
    if (!this.ctx.netNumToName.has(0)) {
      this.ctx.netNumToName.set(0, "");
    }
    this.finished = true;
    return false;
  }
};

// lib/stages/pcb/CollectFootprintsStage/process-footprint.ts
import { applyToPoint as applyToPoint6 } from "transformation-matrix";

// lib/stages/pcb/CollectFootprintsStage/layer-utils.ts
function getComponentLayer(footprint) {
  const layer = footprint.layer;
  const layerNames = layer?.names || [];
  if (layerNames.some((name) => name.includes("B.Cu") || name.includes("Back"))) {
    return "bottom";
  }
  return "top";
}
function determineLayerFromLayers(layers) {
  const layerArray = Array.isArray(layers) ? layers : layers?._layers || [];
  if (layerArray.includes("B.Cu") || layerArray.includes("Back")) {
    return "bottom";
  }
  return "top";
}
function mapTextLayer(kicadLayer) {
  const layerStr = typeof kicadLayer === "string" ? kicadLayer : kicadLayer?.names?.join(" ") || "";
  if (layerStr.includes("B.") || layerStr.includes("Back")) {
    return "bottom";
  }
  return "top";
}

// lib/stages/pcb/CollectFootprintsStage/text-utils.ts
function getTextValue(footprint, type) {
  const texts = footprint.fpTexts || [];
  const textArray = Array.isArray(texts) ? texts : [texts];
  const text = textArray.find((t) => t.type === type);
  return text?.text;
}
function getPropertyValue(footprint, propertyName) {
  const properties = footprint.properties || [];
  const propertyArray = Array.isArray(properties) ? properties : [properties];
  const property = propertyArray.find((p) => p.key === propertyName);
  return property?.value;
}
function substituteKicadVariables(text, footprint) {
  let result = text;
  const reference = getPropertyValue(footprint, "Reference") || getTextValue(footprint, "reference") || "?";
  const value = getPropertyValue(footprint, "Value") || getTextValue(footprint, "value") || "";
  result = result.replace(/\$\{REFERENCE\}/g, reference);
  result = result.replace(/\$\{VALUE\}/g, value);
  return result;
}

// lib/stages/pcb/CollectFootprintsStage/process-pads.ts
import { applyToPoint as applyToPoint3 } from "transformation-matrix";

// lib/stages/pcb/CollectFootprintsStage/process-ports.ts
function createPcbPort({
  ctx,
  componentId,
  padInfo
}) {
  if (!padInfo.layers || padInfo.layers.length === 0) {
    return false;
  }
  const sourcePortId = `${componentId}_port_${padInfo.padNumber}`;
  ctx.db.pcb_port.insert({
    pcb_component_id: componentId,
    source_port_id: sourcePortId,
    x: padInfo.position.x,
    y: padInfo.position.y,
    layers: padInfo.layers
  });
  return true;
}

// lib/stages/pcb/CollectFootprintsStage/process-pads.ts
function processPads(ctx, footprint, componentId, kicadComponentPos, componentRotation) {
  if (!ctx.k2cMatPcb) return;
  const pads = footprint.fpPads || [];
  const padArray = Array.isArray(pads) ? pads : [pads];
  for (const pad of padArray) {
    processPad({
      ctx,
      pad,
      componentId,
      kicadComponentPos,
      componentRotation
    });
  }
}
function processPad({
  ctx,
  pad,
  componentId,
  kicadComponentPos,
  componentRotation
}) {
  if (!ctx.k2cMatPcb) return;
  const padAt = pad.at || { x: 0, y: 0, angle: 0 };
  const padType = pad.padType || pad.type || "thru_hole";
  const padShape = pad.shape || "circle";
  const padRotation = padAt.angle || 0;
  const rotationRad = -componentRotation * Math.PI / 180;
  const rotatedPadX = padAt.x * Math.cos(rotationRad) - padAt.y * Math.sin(rotationRad);
  const rotatedPadY = padAt.x * Math.sin(rotationRad) + padAt.y * Math.cos(rotationRad);
  const padKicadPos = {
    x: kicadComponentPos.x + rotatedPadX,
    y: kicadComponentPos.y + rotatedPadY
  };
  const globalPos = applyToPoint3(ctx.k2cMatPcb, padKicadPos);
  let sizeX = 1;
  let sizeY = 1;
  if (pad.size) {
    if (Array.isArray(pad.size)) {
      sizeX = pad.size[0] || 1;
      sizeY = pad.size[1] || 1;
    } else if (typeof pad.size === "object") {
      sizeX = pad.size._width || pad.size.x || 1;
      sizeY = pad.size._height || pad.size.y || 1;
    }
  }
  const size = { x: sizeX, y: sizeY };
  const drill = pad.drill;
  const totalRotation = -componentRotation - padRotation;
  const padNumber = pad.number?.toString();
  if (padNumber) {
    const padPortInfo = {
      padNumber,
      padType,
      layers: padType === "smd" ? [determineLayerFromLayers(pad.layers || [])] : [],
      position: globalPos
    };
    createPcbPort({
      ctx,
      componentId,
      padInfo: padPortInfo
    });
  }
  if (padType === "smd") {
    createSmdPad({
      ctx,
      pad,
      componentId,
      pos: globalPos,
      size,
      shape: padShape
    });
  } else if (padType === "np_thru_hole") {
    createNpthHole(ctx, pad, componentId, globalPos, drill);
  } else {
    createPlatedHole(
      ctx,
      pad,
      componentId,
      globalPos,
      size,
      drill,
      padShape,
      totalRotation
    );
  }
}
function createSmdPad({
  ctx,
  pad,
  componentId,
  pos,
  size,
  shape
}) {
  const layers = pad.layers || [];
  const layer = determineLayerFromLayers(layers);
  if (shape === "custom") {
    const primitives = pad._sxPrimitives?._graphics || pad.primitives || [];
    const primitivesArray = Array.isArray(primitives) ? primitives : [primitives];
    for (const primitive of primitivesArray) {
      if (primitive.token === "gr_poly" || primitive.gr_poly || primitive.type === "gr_poly") {
        const grPoly = primitive.gr_poly || primitive;
        const contours = grPoly._contours || grPoly.contours || [];
        const contoursArray = Array.isArray(contours) ? contours : [contours];
        const points = [];
        for (const contour of contoursArray) {
          const pts = contour.points || contour.pts || [];
          const ptsArray = Array.isArray(pts) ? pts : [pts];
          for (const pt of ptsArray) {
            if (pt.x !== void 0 && pt.y !== void 0) {
              points.push({ x: pt.x, y: -pt.y });
            }
          }
        }
        if (points.length > 0) {
          const smtpad2 = {
            type: "pcb_smtpad",
            shape: "polygon",
            pcb_component_id: componentId,
            layer,
            port_hints: [pad.number?.toString()],
            points: points.map((pt) => ({
              x: pos.x + pt.x,
              y: pos.y + pt.y
            }))
          };
          ctx.db.pcb_smtpad.insert(smtpad2);
          if (ctx.stats) {
            ctx.stats.pads = (ctx.stats.pads || 0) + 1;
          }
          return;
        }
      }
    }
  }
  let smtpad = {
    type: "pcb_smtpad",
    pcb_component_id: componentId,
    x: pos.x,
    y: pos.y,
    width: size.x,
    height: size.y,
    layer,
    port_hints: [pad.number?.toString()]
  };
  if (shape === "circle") {
    smtpad.shape = "circle";
    smtpad.radius = Math.max(size.x, size.y) / 2;
  } else if (shape === "rect" || shape === "roundrect") {
    smtpad.shape = "rect";
    const roundrectRatio = pad._sxRoundrectRatio?.value ?? pad.roundrect_rratio;
    if (shape === "roundrect" && roundrectRatio !== void 0) {
      const minDimension = Math.min(size.x, size.y);
      const cornerRadius = minDimension * roundrectRatio / 2;
      smtpad.corner_radius = cornerRadius;
    }
  } else {
    ;
    smtpad.shape = "rect";
  }
  ctx.db.pcb_smtpad.insert(smtpad);
  if (ctx.stats) {
    ctx.stats.pads = (ctx.stats.pads || 0) + 1;
  }
}
function createPlatedHole(ctx, pad, componentId, pos, size, drill, shape, rotation = 0) {
  const holeDiameter = typeof drill === "object" ? drill?.diameter || drill?.x || 0.8 : drill || 0.8;
  let holeShape = "circle";
  const drillIsOval = typeof drill === "object" && drill.x !== void 0 && drill.y !== void 0 && drill.x !== drill.y;
  let normalizedRotation = rotation % 360;
  if (normalizedRotation < 0) normalizedRotation += 360;
  const shouldSwapDimensions = normalizedRotation >= 45 && normalizedRotation < 135 || normalizedRotation >= 225 && normalizedRotation < 315;
  let outerWidth = size.x;
  let outerHeight = size.y;
  if (shouldSwapDimensions && shape === "oval") {
    outerWidth = size.y;
    outerHeight = size.x;
  }
  const platedHole = {
    pcb_component_id: componentId,
    x: pos.x,
    y: pos.y,
    port_hints: [pad.number?.toString()]
  };
  if (shape === "circle") {
    platedHole.shape = "circle";
    platedHole.hole_diameter = holeDiameter;
    platedHole.outer_diameter = Math.max(outerWidth, outerHeight);
    platedHole.layers = ["top", "bottom"];
  } else if (shape === "oval") {
    platedHole.shape = "pill";
    platedHole.hole_width = holeDiameter;
    platedHole.hole_height = holeDiameter;
    platedHole.outer_width = outerWidth;
    platedHole.outer_height = outerHeight;
    platedHole.layers = ["top", "bottom"];
  } else if (shape === "rect" || shape === "square") {
    platedHole.shape = "pill_hole_with_rect_pad";
    platedHole.hole_shape = "circle";
    platedHole.pad_shape = "rect";
    platedHole.hole_width = holeDiameter;
    platedHole.hole_height = holeDiameter;
    platedHole.rect_pad_width = outerWidth;
    platedHole.rect_pad_height = outerHeight;
    platedHole.layers = ["top", "bottom"];
  }
  ctx.db.pcb_plated_hole.insert(platedHole);
  if (ctx.stats) {
    ctx.stats.pads = (ctx.stats.pads || 0) + 1;
  }
}
function createNpthHole(ctx, pad, componentId, pos, drill) {
  const holeDiameter = drill?.diameter || drill || 1;
  ctx.db.pcb_hole.insert({
    x: pos.x,
    y: pos.y,
    hole_diameter: holeDiameter,
    hole_shape: "circle"
  });
}

// lib/stages/pcb/CollectFootprintsStage/process-text.ts
import { applyToPoint as applyToPoint4 } from "transformation-matrix";
function processFootprintText(ctx, footprint, componentId, kicadComponentPos, componentRotation) {
  if (!ctx.k2cMatPcb) return;
  processFootprintProperties(
    ctx,
    footprint,
    componentId,
    kicadComponentPos,
    componentRotation
  );
  const texts = footprint.fpTexts || [];
  const textArray = Array.isArray(texts) ? texts : [texts];
  for (const text of textArray) {
    const layerStr = typeof text.layer === "string" ? text.layer : text.layer?.names?.join(" ") || "";
    const isSilkscreen = layerStr.includes("SilkS") || layerStr.includes("Silk");
    if (!isSilkscreen) continue;
    const textElement = {
      text: text.text,
      at: text._sxPosition || text.at,
      // Use _sxPosition for position
      layer: text.layer,
      effects: text._sxEffects || text.effects,
      _sxEffects: text._sxEffects
      // Pass _sxEffects for font size access
    };
    createSilkscreenText(
      ctx,
      textElement,
      componentId,
      kicadComponentPos,
      componentRotation,
      footprint
    );
  }
}
function processFootprintProperties(ctx, footprint, componentId, kicadComponentPos, componentRotation) {
  if (!ctx.k2cMatPcb) return;
  const properties = footprint.properties || [];
  const propertyArray = Array.isArray(properties) ? properties : [properties];
  for (const property of propertyArray) {
    if (!property.layer) continue;
    const layerStr = typeof property.layer === "string" ? property.layer : property.layer?.names?.join(" ") || "";
    const isSilkscreen = layerStr.includes("SilkS") || layerStr.includes("Silk");
    if (!isSilkscreen) continue;
    const textElement = {
      text: property.value,
      at: property._sxAt,
      // Use _sxAt instead of at
      layer: property.layer,
      effects: property._sxEffects || property.effects,
      _sxEffects: property._sxEffects
      // Pass _sxEffects for font size access
    };
    createSilkscreenText(
      ctx,
      textElement,
      componentId,
      kicadComponentPos,
      componentRotation,
      footprint
    );
  }
}
function createSilkscreenText(ctx, text, componentId, kicadComponentPos, componentRotation, footprint) {
  if (!ctx.k2cMatPcb) return;
  const at = text.at;
  const textLocalX = at?.x ?? 0;
  const textLocalY = at?.y ?? 0;
  const rotationRad = -componentRotation * Math.PI / 180;
  const rotatedTextX = textLocalX * Math.cos(rotationRad) - textLocalY * Math.sin(rotationRad);
  const rotatedTextY = textLocalX * Math.sin(rotationRad) + textLocalY * Math.cos(rotationRad);
  const textKicadPos = {
    x: kicadComponentPos.x + rotatedTextX,
    y: kicadComponentPos.y + rotatedTextY
  };
  const pos = applyToPoint4(ctx.k2cMatPcb, textKicadPos);
  const layer = mapTextLayer(text.layer);
  const processedText = substituteKicadVariables(text.text || "", footprint);
  const kicadFontSize = text._sxEffects?._sxFont?._sxSize?._height || text.effects?.font?.size?.y || 1;
  ctx.db.pcb_silkscreen_text.insert({
    pcb_component_id: componentId,
    font: "tscircuit2024",
    font_size: kicadFontSize * 1.5,
    text: processedText,
    anchor_position: pos,
    layer
  });
}

// lib/stages/pcb/CollectFootprintsStage/process-graphics.ts
import { applyToPoint as applyToPoint5 } from "transformation-matrix";
function rotatePoint(x, y, rotationDeg) {
  const rotationRad = rotationDeg * Math.PI / 180;
  return {
    x: x * Math.cos(rotationRad) - y * Math.sin(rotationRad),
    y: x * Math.sin(rotationRad) + y * Math.cos(rotationRad)
  };
}
function processFootprintGraphics(ctx, footprint, componentId, kicadComponentPos, componentRotation) {
  if (!ctx.k2cMatPcb) return;
  const lines = footprint.fpLines || [];
  const lineArray = Array.isArray(lines) ? lines : lines ? [lines] : [];
  for (const line of lineArray) {
    createFootprintLine(
      ctx,
      line,
      componentId,
      kicadComponentPos,
      componentRotation
    );
  }
  const circles = footprint.fpCircles || [];
  const circleArray = Array.isArray(circles) ? circles : circles ? [circles] : [];
  for (const circle of circleArray) {
    createFootprintCircle(
      ctx,
      circle,
      componentId,
      kicadComponentPos,
      componentRotation
    );
  }
  const arcs = footprint.fpArcs || [];
  const arcArray = Array.isArray(arcs) ? arcs : arcs ? [arcs] : [];
  for (const arc of arcArray) {
    createFootprintArc(
      ctx,
      arc,
      componentId,
      kicadComponentPos,
      componentRotation
    );
  }
}
function createFootprintLine(ctx, line, componentId, kicadComponentPos, componentRotation) {
  if (!ctx.k2cMatPcb) return;
  const start = line.start || { x: 0, y: 0 };
  const end = line.end || { x: 0, y: 0 };
  const rotatedStart = rotatePoint(start.x, start.y, -componentRotation);
  const rotatedEnd = rotatePoint(end.x, end.y, -componentRotation);
  const startKicadPos = {
    x: kicadComponentPos.x + rotatedStart.x,
    y: kicadComponentPos.y + rotatedStart.y
  };
  const endKicadPos = {
    x: kicadComponentPos.x + rotatedEnd.x,
    y: kicadComponentPos.y + rotatedEnd.y
  };
  const startPos = applyToPoint5(ctx.k2cMatPcb, startKicadPos);
  const endPos = applyToPoint5(ctx.k2cMatPcb, endKicadPos);
  const layer = mapTextLayer(line.layer);
  const strokeWidth = line.stroke?.width || line.width || 0.12;
  ctx.db.pcb_silkscreen_path.insert({
    pcb_component_id: componentId,
    layer,
    route: [startPos, endPos],
    stroke_width: strokeWidth
  });
}
function createFootprintCircle(ctx, circle, componentId, kicadComponentPos, componentRotation) {
  if (!ctx.k2cMatPcb) return;
  const center = circle.center || { x: 0, y: 0 };
  const end = circle.end || { x: 0, y: 0 };
  const radius = Math.sqrt((end.x - center.x) ** 2 + (end.y - center.y) ** 2);
  const rotatedCenter = rotatePoint(center.x, center.y, -componentRotation);
  const centerKicadPos = {
    x: kicadComponentPos.x + rotatedCenter.x,
    y: kicadComponentPos.y + rotatedCenter.y
  };
  const centerPos = applyToPoint5(ctx.k2cMatPcb, centerKicadPos);
  const layer = mapTextLayer(circle.layer);
  const strokeWidth = circle.stroke?.width || circle.width || 0.12;
  const numPoints = 16;
  const circleRoute = [];
  for (let i = 0; i <= numPoints; i++) {
    const angle = i / numPoints * 2 * Math.PI;
    const x = centerPos.x + radius * Math.cos(angle);
    const y = centerPos.y + radius * Math.sin(angle);
    circleRoute.push({ x, y });
  }
  ctx.db.pcb_silkscreen_path.insert({
    pcb_component_id: componentId,
    layer,
    route: circleRoute,
    stroke_width: strokeWidth
  });
}
function calculateArcCenter(p1, p2, p3) {
  const ax = p1.x - p2.x;
  const ay = p1.y - p2.y;
  const bx = p2.x - p3.x;
  const by = p2.y - p3.y;
  const denom = 2 * (ax * by - ay * bx);
  if (Math.abs(denom) < 1e-10) {
    return null;
  }
  const d1 = p1.x * p1.x + p1.y * p1.y - p2.x * p2.x - p2.y * p2.y;
  const d2 = p2.x * p2.x + p2.y * p2.y - p3.x * p3.x - p3.y * p3.y;
  const cx = (d1 * by - d2 * ay) / denom;
  const cy = (ax * d2 - bx * d1) / denom;
  const radius = Math.sqrt((p1.x - cx) ** 2 + (p1.y - cy) ** 2);
  return { center: { x: cx, y: cy }, radius };
}
function createFootprintArc(ctx, arc, componentId, kicadComponentPos, componentRotation) {
  if (!ctx.k2cMatPcb) return;
  const start = arc.start || { x: 0, y: 0 };
  const mid = arc.mid || { x: 0, y: 0 };
  const end = arc.end || { x: 0, y: 0 };
  const rotatedStart = rotatePoint(start.x, start.y, -componentRotation);
  const rotatedMid = rotatePoint(mid.x, mid.y, -componentRotation);
  const rotatedEnd = rotatePoint(end.x, end.y, -componentRotation);
  const startKicadPos = {
    x: kicadComponentPos.x + rotatedStart.x,
    y: kicadComponentPos.y + rotatedStart.y
  };
  const midKicadPos = {
    x: kicadComponentPos.x + rotatedMid.x,
    y: kicadComponentPos.y + rotatedMid.y
  };
  const endKicadPos = {
    x: kicadComponentPos.x + rotatedEnd.x,
    y: kicadComponentPos.y + rotatedEnd.y
  };
  const layer = mapTextLayer(arc.layer);
  const strokeWidth = arc.stroke?.width || arc.width || 0.12;
  const arcInfo = calculateArcCenter(startKicadPos, midKicadPos, endKicadPos);
  if (!arcInfo) {
    const startPos = applyToPoint5(ctx.k2cMatPcb, startKicadPos);
    const endPos = applyToPoint5(ctx.k2cMatPcb, endKicadPos);
    ctx.db.pcb_silkscreen_path.insert({
      pcb_component_id: componentId,
      layer,
      route: [startPos, endPos],
      stroke_width: strokeWidth
    });
    return;
  }
  const { center, radius } = arcInfo;
  const startAngle = Math.atan2(
    startKicadPos.y - center.y,
    startKicadPos.x - center.x
  );
  const midAngle = Math.atan2(
    midKicadPos.y - center.y,
    midKicadPos.x - center.x
  );
  const endAngle = Math.atan2(
    endKicadPos.y - center.y,
    endKicadPos.x - center.x
  );
  let sweepAngle = endAngle - startAngle;
  let midSweep = midAngle - startAngle;
  while (sweepAngle > Math.PI) sweepAngle -= 2 * Math.PI;
  while (sweepAngle < -Math.PI) sweepAngle += 2 * Math.PI;
  while (midSweep > Math.PI) midSweep -= 2 * Math.PI;
  while (midSweep < -Math.PI) midSweep += 2 * Math.PI;
  const isCCW = sweepAngle > 0;
  const midIsBetween = isCCW && midSweep > 0 && midSweep < sweepAngle || !isCCW && midSweep < 0 && midSweep > sweepAngle;
  if (!midIsBetween) {
    sweepAngle = sweepAngle > 0 ? sweepAngle - 2 * Math.PI : sweepAngle + 2 * Math.PI;
  }
  const arcLength = Math.abs(radius * sweepAngle);
  const segmentLength = 0.1;
  const numSegments = Math.max(2, Math.ceil(arcLength / segmentLength));
  const arcRoute = [];
  for (let i = 0; i <= numSegments; i++) {
    const t = i / numSegments;
    const angle = startAngle + sweepAngle * t;
    const kicadPoint = {
      x: center.x + radius * Math.cos(angle),
      y: center.y + radius * Math.sin(angle)
    };
    const cjPoint = applyToPoint5(ctx.k2cMatPcb, kicadPoint);
    arcRoute.push(cjPoint);
  }
  ctx.db.pcb_silkscreen_path.insert({
    pcb_component_id: componentId,
    layer,
    route: arcRoute,
    stroke_width: strokeWidth
  });
}

// lib/stages/pcb/CollectFootprintsStage/process-footprint.ts
function processFootprint(ctx, footprint) {
  if (!ctx.k2cMatPcb) return;
  const position = footprint.position;
  const kicadPos = { x: position?.x ?? 0, y: position?.y ?? 0 };
  const cjPos = applyToPoint6(ctx.k2cMatPcb, kicadPos);
  const rotation = position?.angle ?? 0;
  const uuid = footprint.uuid?.value || footprint.tstamp?.value;
  if (!uuid) return;
  const inserted = ctx.db.pcb_component.insert({
    center: { x: cjPos.x, y: cjPos.y },
    layer: getComponentLayer(footprint),
    rotation: -rotation,
    // Negate rotation due to Y-axis flip in coordinate transform
    width: 0,
    // Will be computed from pads if needed
    height: 0
  });
  const componentId = inserted.pcb_component_id;
  ctx.footprintUuidToComponentId?.set(uuid, componentId);
  processPads(ctx, footprint, componentId, kicadPos, rotation);
  processFootprintText(ctx, footprint, componentId, kicadPos, rotation);
  processFootprintGraphics(ctx, footprint, componentId, kicadPos, rotation);
  if (ctx.stats) {
    ctx.stats.components = (ctx.stats.components || 0) + 1;
  }
}

// lib/stages/pcb/CollectFootprintsStage/index.ts
var CollectFootprintsStage = class extends ConverterStage {
  processedFootprints = /* @__PURE__ */ new Set();
  step() {
    if (!this.ctx.kicadPcb || !this.ctx.k2cMatPcb) {
      this.finished = true;
      return false;
    }
    const footprints = this.ctx.kicadPcb.footprints || [];
    const footprintArray = Array.isArray(footprints) ? footprints : [footprints];
    for (const footprint of footprintArray) {
      const uuid = footprint.uuid?.value || footprint.tstamp?.value;
      if (!uuid) continue;
      if (this.processedFootprints.has(uuid)) continue;
      processFootprint(this.ctx, footprint);
      this.processedFootprints.add(uuid);
    }
    this.finished = true;
    return false;
  }
};

// lib/stages/pcb/CollectTracesStage.ts
import { applyToPoint as applyToPoint7 } from "transformation-matrix";
var CollectTracesStage = class extends ConverterStage {
  step() {
    if (!this.ctx.kicadPcb || !this.ctx.k2cMatPcb || !this.ctx.netNumToName) {
      this.finished = true;
      return false;
    }
    const segments = this.ctx.kicadPcb.segments || [];
    const segmentArray = Array.isArray(segments) ? segments : [segments];
    for (const segment of segmentArray) {
      this.createTraceFromSegment(segment);
    }
    this.finished = true;
    return false;
  }
  createTraceFromSegment(segment) {
    if (!this.ctx.k2cMatPcb || !this.ctx.netNumToName) return;
    const start = segment.start || { x: 0, y: 0 };
    const end = segment.end || { x: 0, y: 0 };
    const width = segment.width || 0.2;
    const layer = segment.layer;
    const layerNames = layer?.names || [];
    const layerStr = layerNames.join(" ");
    const mappedLayer = this.mapLayer(layerStr);
    const netNum = segment.net || 0;
    const netName = this.ctx.netNumToName.get(netNum) || "";
    const startPos = applyToPoint7(this.ctx.k2cMatPcb, {
      x: start.x,
      y: start.y
    });
    const endPos = applyToPoint7(this.ctx.k2cMatPcb, { x: end.x, y: end.y });
    const route = [
      {
        route_type: "wire",
        x: startPos.x,
        y: startPos.y,
        width,
        layer: mappedLayer
      },
      {
        route_type: "wire",
        x: endPos.x,
        y: endPos.y,
        width,
        layer: mappedLayer
      }
    ];
    this.ctx.db.pcb_trace.insert({
      route,
      pcb_port_id: void 0
      // Not connected to a specific port yet
    });
    if (this.ctx.stats) {
      this.ctx.stats.traces = (this.ctx.stats.traces || 0) + 1;
    }
  }
  mapLayer(kicadLayer) {
    if (kicadLayer?.includes("B.Cu") || kicadLayer?.includes("Back")) {
      return "bottom";
    }
    return "top";
  }
};

// lib/stages/pcb/CollectViasStage.ts
import { applyToPoint as applyToPoint8 } from "transformation-matrix";
var CollectViasStage = class extends ConverterStage {
  step() {
    if (!this.ctx.kicadPcb || !this.ctx.k2cMatPcb || !this.ctx.netNumToName) {
      this.finished = true;
      return false;
    }
    const vias = this.ctx.kicadPcb.vias || [];
    const viaArray = Array.isArray(vias) ? vias : [vias];
    for (const via of viaArray) {
      this.processVia(via);
    }
    this.finished = true;
    return false;
  }
  processVia(via) {
    if (!this.ctx.k2cMatPcb || !this.ctx.netNumToName) return;
    const at = via.at || { x: 0, y: 0 };
    const pos = applyToPoint8(this.ctx.k2cMatPcb, { x: at.x, y: at.y });
    const size = via.size || 0.8;
    const drill = via.drill || 0.4;
    const netNum = via.net || 0;
    const netName = this.ctx.netNumToName.get(netNum) || "";
    let fromLayer = "top";
    let toLayer = "bottom";
    if (via.layers) {
      const layersArray = Array.isArray(via.layers) ? via.layers : via.layers._layers || [];
      if (layersArray.length > 0) {
        fromLayer = this.mapLayer(layersArray[0]);
        if (layersArray.length > 1) {
          toLayer = this.mapLayer(layersArray[layersArray.length - 1]);
        }
      }
    }
    this.ctx.db.pcb_via.insert({
      x: pos.x,
      y: pos.y,
      outer_diameter: size,
      hole_diameter: drill,
      layers: [fromLayer, toLayer]
    });
    if (this.ctx.stats) {
      this.ctx.stats.vias = (this.ctx.stats.vias || 0) + 1;
    }
  }
  mapLayer(kicadLayer) {
    if (kicadLayer?.includes("B.Cu") || kicadLayer?.includes("Back") || kicadLayer?.includes("B_Cu")) {
      return "bottom";
    }
    return "top";
  }
};

// lib/stages/pcb/CollectZonesStage.ts
import { applyToPoint as applyToPoint9 } from "transformation-matrix";
var CollectZonesStage = class extends ConverterStage {
  step() {
    if (!this.ctx.kicadPcb || !this.ctx.k2cMatPcb || !this.ctx.netNumToName) {
      this.finished = true;
      return false;
    }
    const zones = this.ctx.kicadPcb.zones || [];
    const zoneArray = Array.isArray(zones) ? zones : [zones];
    for (const zone of zoneArray) {
      if (this.isZoneFilled(zone)) {
        this.createCopperPourFromZone(zone);
      }
    }
    this.finished = true;
    return false;
  }
  isZoneFilled(zone) {
    if (!zone._rawChildren || !Array.isArray(zone._rawChildren)) {
      return false;
    }
    const fillEntry = zone._rawChildren.find(
      (child) => Array.isArray(child) && child[0] === "fill"
    );
    if (fillEntry && fillEntry[1] === "yes") {
      return true;
    }
    const hasFilledPolygons = zone._rawChildren.some(
      (child) => Array.isArray(child) && child[0] === "filled_polygon"
    );
    return hasFilledPolygons;
  }
  createCopperPourFromZone(zone) {
    if (!this.ctx.k2cMatPcb || !this.ctx.netNumToName) return;
    if (!zone._rawChildren || !Array.isArray(zone._rawChildren)) {
      return;
    }
    const zoneData = this.parseZoneData(zone._rawChildren);
    const filledPolygons = this.extractFilledPolygons(zone._rawChildren);
    if (filledPolygons.length === 0) {
      const mainPolygon = this.extractMainPolygon(zone._rawChildren);
      if (mainPolygon.length > 0) {
        filledPolygons.push(mainPolygon);
      }
    }
    if (filledPolygons.length === 0) {
      if (this.ctx.warnings) {
        this.ctx.warnings.push(
          `Zone on layer ${zoneData.layer || "unknown"} has no valid polygon points`
        );
      }
      return;
    }
    const layer = this.mapLayer(zoneData.layer);
    const netNum = zoneData.net || 0;
    const netName = this.ctx.netNumToName.get(netNum) || zoneData.netName || "";
    for (const polygonPoints of filledPolygons) {
      const transformedPoints = polygonPoints.map(
        (point) => applyToPoint9(this.ctx.k2cMatPcb, { x: point.x, y: point.y })
      );
      this.ctx.db.pcb_copper_pour.insert({
        layer,
        net_name: netName,
        points: transformedPoints,
        shape: "polygon"
      });
      if (this.ctx.stats) {
        this.ctx.stats.copper_pours = (this.ctx.stats.copper_pours || 0) + 1;
      }
    }
  }
  parseZoneData(children) {
    const data = {};
    for (const child of children) {
      if (!Array.isArray(child)) continue;
      switch (child[0]) {
        case "net":
          data.net = child[1];
          break;
        case "net_name":
          data.netName = child[1];
          break;
        case "layer":
          data.layer = child[1];
          break;
      }
    }
    return data;
  }
  extractMainPolygon(children) {
    const polygonEntry = children.find(
      (child) => Array.isArray(child) && child[0] === "polygon"
    );
    if (!polygonEntry) return [];
    return this.extractPointsFromPolygonEntry(polygonEntry);
  }
  extractFilledPolygons(children) {
    const filledPolygonEntries = children.filter(
      (child) => Array.isArray(child) && child[0] === "filled_polygon"
    );
    const polygons = [];
    for (const entry of filledPolygonEntries) {
      const points = this.extractPointsFromPolygonEntry(entry);
      if (points.length > 0) {
        polygons.push(points);
      }
    }
    return polygons;
  }
  extractPointsFromPolygonEntry(polygonEntry) {
    const points = [];
    const ptsEntry = polygonEntry.find(
      (child) => Array.isArray(child) && child[0] === "pts"
    );
    if (!ptsEntry) return [];
    for (let i = 1; i < ptsEntry.length; i++) {
      const item = ptsEntry[i];
      if (Array.isArray(item) && item[0] === "xy" && item.length >= 3) {
        const x = item[1];
        const y = item[2];
        if (typeof x === "number" && typeof y === "number") {
          points.push({ x, y });
        }
      }
    }
    return points;
  }
  mapLayer(kicadLayer) {
    const layerStr = typeof kicadLayer === "string" ? kicadLayer : kicadLayer?.names?.join(" ") || kicadLayer?.name || "";
    if (layerStr.includes("B.Cu") || layerStr.includes("Back") || layerStr.includes("Bottom")) {
      return "bottom";
    }
    return "top";
  }
};

// lib/stages/pcb/CollectGraphicsStage.ts
import { applyToPoint as applyToPoint10 } from "transformation-matrix";
var CollectGraphicsStage = class extends ConverterStage {
  step() {
    if (!this.ctx.kicadPcb || !this.ctx.k2cMatPcb) {
      this.finished = true;
      return false;
    }
    const lines = this.ctx.kicadPcb.graphicLines || [];
    const lineArray = Array.isArray(lines) ? lines : [lines];
    const edgeCutLines = [];
    const silkLines = [];
    for (const line of lineArray) {
      const layer = line.layer;
      const layerNames = typeof layer === "string" ? [layer] : layer?.names || [];
      const layerStr = layerNames.join(" ");
      if (layerStr.includes("Edge.Cuts")) {
        edgeCutLines.push(line);
      } else if (layerStr.includes("SilkS")) {
        silkLines.push(line);
      }
    }
    if (edgeCutLines.length > 0) {
      this.createBoardOutline(edgeCutLines);
    }
    for (const line of silkLines) {
      this.createSilkscreenPath(line);
    }
    const grRects = this.ctx.kicadPcb.graphicRects || [];
    for (const rect of grRects) {
      this.processRectangle(rect);
    }
    const grPolys = this.ctx.kicadPcb.graphicPolys || [];
    const polyArray = Array.isArray(grPolys) ? grPolys : [grPolys];
    for (const poly of polyArray) {
      this.processPolygon(poly);
    }
    const texts = this.ctx.kicadPcb.graphicTexts || [];
    const textArray = Array.isArray(texts) ? texts : [texts];
    for (const text of textArray) {
      const layer = text.layer;
      const layerNames = typeof layer === "string" ? [layer] : layer?.names || [];
      if (layerNames.some(
        (name) => name.includes("SilkS") || name.includes(".Cu") || name.includes("Fab")
      )) {
        this.createSilkscreenText(text);
      }
    }
    this.finished = true;
    return false;
  }
  createBoardOutline(lines) {
    if (!this.ctx.k2cMatPcb) return;
    const segments = lines.map((line) => ({
      start: line.start ?? { x: 0, y: 0 },
      end: line.end ?? { x: 0, y: 0 }
    }));
    const orderedSegments = [];
    const remainingSegments = [...segments];
    if (remainingSegments.length > 0) {
      orderedSegments.push(remainingSegments.shift());
      while (remainingSegments.length > 0) {
        const lastSegment = orderedSegments[orderedSegments.length - 1];
        const lastEnd = lastSegment.end;
        let foundIndex = remainingSegments.findIndex(
          (seg) => this.pointsEqualKicad(seg.start, lastEnd)
        );
        if (foundIndex === -1) {
          foundIndex = remainingSegments.findIndex(
            (seg) => this.pointsEqualKicad(seg.end, lastEnd)
          );
          if (foundIndex !== -1) {
            const seg = remainingSegments[foundIndex];
            orderedSegments.push({
              start: seg.end,
              end: seg.start
            });
            remainingSegments.splice(foundIndex, 1);
            continue;
          }
        }
        if (foundIndex !== -1) {
          orderedSegments.push(remainingSegments.splice(foundIndex, 1)[0]);
        } else {
          orderedSegments.push(remainingSegments.shift());
        }
      }
    }
    const points = [];
    for (const segment of orderedSegments) {
      const startPos = applyToPoint10(this.ctx.k2cMatPcb, {
        x: segment.start.x,
        y: segment.start.y
      });
      const lastPoint = points[points.length - 1];
      if (!lastPoint || !this.pointsEqual(lastPoint, startPos)) {
        points.push(startPos);
      }
    }
    if (orderedSegments.length > 0) {
      const lastSegment = orderedSegments[orderedSegments.length - 1];
      const endPos = applyToPoint10(this.ctx.k2cMatPcb, {
        x: lastSegment.end.x,
        y: lastSegment.end.y
      });
      const firstPoint = points[0];
      if (firstPoint && !this.pointsEqual(firstPoint, endPos)) {
        points.push(endPos);
      }
    }
    const existingBoard = this.ctx.db.pcb_board.list()[0];
    if (existingBoard) {
      existingBoard.outline = points;
      existingBoard.width = this.calculateWidth(points);
      existingBoard.height = this.calculateHeight(points);
    } else {
      this.ctx.db.pcb_board.insert({
        outline: points,
        width: this.calculateWidth(points),
        height: this.calculateHeight(points)
      });
    }
  }
  createSilkscreenPath(line) {
    if (!this.ctx.k2cMatPcb) return;
    const start = line.start || { x: 0, y: 0 };
    const end = line.end || { x: 0, y: 0 };
    const startPos = applyToPoint10(this.ctx.k2cMatPcb, {
      x: start.x,
      y: start.y
    });
    const endPos = applyToPoint10(this.ctx.k2cMatPcb, { x: end.x, y: end.y });
    const layer = this.mapLayer(line.layer);
    const strokeWidth = line.width || 0.15;
    this.ctx.db.pcb_silkscreen_path.insert({
      pcb_component_id: "",
      // Not attached to a specific component
      layer,
      route: [startPos, endPos],
      stroke_width: strokeWidth
    });
  }
  processRectangle(rect) {
    if (!this.ctx.k2cMatPcb) return;
    const start = {
      x: rect._sxStart?._x ?? 0,
      y: rect._sxStart?._y ?? 0
    };
    const end = {
      x: rect._sxEnd?._x ?? 0,
      y: rect._sxEnd?._y ?? 0
    };
    const layerNames = rect._sxLayer?._names || [];
    const layerStr = layerNames.join(" ");
    const isFilled = rect._sxFill && (rect._sxFill.isFilled === true || String(rect._sxFill).includes("fill yes"));
    const isCopperLayer = layerStr.includes(".Cu");
    if (!isFilled || !isCopperLayer) {
      return;
    }
    const centerKicad = {
      x: (start.x + end.x) / 2,
      y: (start.y + end.y) / 2
    };
    const widthKicad = Math.abs(end.x - start.x);
    const heightKicad = Math.abs(end.y - start.y);
    const centerCJ = applyToPoint10(this.ctx.k2cMatPcb, centerKicad);
    const layer = this.mapLayer(rect._sxLayer);
    this.ctx.db.pcb_smtpad.insert({
      pcb_component_id: "",
      // Not attached to a specific component
      x: centerCJ.x,
      y: centerCJ.y,
      width: widthKicad,
      height: heightKicad,
      layer,
      shape: "rect",
      port_hints: []
    });
    if (this.ctx.stats) {
      this.ctx.stats.pads = (this.ctx.stats.pads || 0) + 1;
    }
  }
  createSilkscreenText(text) {
    if (!this.ctx.k2cMatPcb) return;
    const at = text.at || text._sxPosition;
    const pos = applyToPoint10(this.ctx.k2cMatPcb, {
      x: at?.x ?? 0,
      y: at?.y ?? 0
    });
    const layer = this.mapLayer(text.layer);
    const kicadFontSize = text._sxEffects?._sxFont?._sxSize?._height || text.effects?.font?.size?.y || 1;
    const fontSize = kicadFontSize * 1.5;
    this.ctx.db.pcb_silkscreen_text.insert({
      pcb_component_id: "",
      text: text.text || text._text || "",
      anchor_position: pos,
      layer,
      font_size: fontSize,
      font: "tscircuit2024"
    });
  }
  mapLayer(kicadLayer) {
    const layerStr = typeof kicadLayer === "string" ? kicadLayer : kicadLayer?.names?.join(" ") || "";
    if (layerStr.includes("B.") || layerStr.includes("Back")) {
      return "bottom";
    }
    return "top";
  }
  pointsEqual(p1, p2) {
    const epsilon = 1e-3;
    return Math.abs(p1.x - p2.x) < epsilon && Math.abs(p1.y - p2.y) < epsilon;
  }
  pointsEqualKicad(p1, p2) {
    const epsilon = 1e-3;
    return Math.abs(p1.x - p2.x) < epsilon && Math.abs(p1.y - p2.y) < epsilon;
  }
  calculateWidth(points) {
    if (points.length === 0) return 0;
    const xs = points.map((p) => p.x);
    return Math.max(...xs) - Math.min(...xs);
  }
  calculateHeight(points) {
    if (points.length === 0) return 0;
    const ys = points.map((p) => p.y);
    return Math.max(...ys) - Math.min(...ys);
  }
  processPolygon(poly) {
    if (!this.ctx.k2cMatPcb) return;
    const layerNames = poly._sxLayer?._names || [];
    const layerStr = layerNames.join(" ");
    const isFilled = poly._sxFill?.filled === true;
    const isCopperLayer = layerStr.includes(".Cu");
    if (!isFilled || !isCopperLayer) {
      return;
    }
    const ptsData = poly._sxPts?.points || [];
    const points = [];
    for (const pt of ptsData) {
      if (pt.token === "xy") {
        points.push({ x: pt.x, y: pt.y });
      } else if (pt.token === "arc") {
        const arcPoints = this.convertArcToPoints(
          { x: pt._sxStart?._x, y: pt._sxStart?._y },
          { x: pt._sxMid?._x, y: pt._sxMid?._y },
          { x: pt._sxEnd?._x, y: pt._sxEnd?._y }
        );
        points.push(...arcPoints);
      }
    }
    if (points.length < 3) {
      return;
    }
    const transformedPoints = points.map(
      (pt) => applyToPoint10(this.ctx.k2cMatPcb, pt)
    );
    const layer = this.mapLayer(poly._sxLayer);
    this.ctx.db.pcb_smtpad.insert({
      pcb_component_id: "",
      // Not attached to a specific component
      shape: "polygon",
      points: transformedPoints,
      layer,
      port_hints: []
    });
    if (this.ctx.stats) {
      this.ctx.stats.pads = (this.ctx.stats.pads || 0) + 1;
    }
  }
  /**
   * Converts an arc defined by start, mid, and end points to multiple line segments
   * Uses the three-point arc definition to approximate the curve
   */
  convertArcToPoints(start, mid, end, numSegments = 8) {
    const points = [];
    const { center, radius } = this.calculateArcCenter(start, mid, end);
    if (!center || radius === 0) {
      return [start, end];
    }
    const startAngle = Math.atan2(start.y - center.y, start.x - center.x);
    const endAngle = Math.atan2(end.y - center.y, end.x - center.x);
    const midAngle = Math.atan2(mid.y - center.y, mid.x - center.x);
    let angleRange = endAngle - startAngle;
    const midFromStart = midAngle - startAngle;
    const endFromStart = endAngle - startAngle;
    const normalizeMid = (midFromStart + Math.PI) % (2 * Math.PI) - Math.PI;
    const normalizeEnd = (endFromStart + Math.PI) % (2 * Math.PI) - Math.PI;
    if (normalizeEnd > 0 && (normalizeMid < 0 || normalizeMid > normalizeEnd) || normalizeEnd < 0 && (normalizeMid > 0 || normalizeMid < normalizeEnd)) {
      angleRange = angleRange - Math.sign(angleRange) * 2 * Math.PI;
    }
    for (let i = 1; i < numSegments; i++) {
      const t = i / numSegments;
      const angle = startAngle + angleRange * t;
      points.push({
        x: center.x + radius * Math.cos(angle),
        y: center.y + radius * Math.sin(angle)
      });
    }
    points.push(end);
    return points;
  }
  /**
   * Calculate the center and radius of a circle passing through three points
   */
  calculateArcCenter(p1, p2, p3) {
    const ax = p1.x;
    const ay = p1.y;
    const bx = p2.x;
    const by = p2.y;
    const cx = p3.x;
    const cy = p3.y;
    const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
    if (Math.abs(d) < 1e-10) {
      return { center: null, radius: 0 };
    }
    const ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d;
    const uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d;
    const radius = Math.sqrt((ax - ux) ** 2 + (ay - uy) ** 2);
    return { center: { x: ux, y: uy }, radius };
  }
};

// lib/stages/pcb/CollectSourceTracesStage.ts
var CollectSourceTracesStage = class extends ConverterStage {
  processedNets = /* @__PURE__ */ new Set();
  step() {
    if (!this.ctx.kicadPcb || !this.ctx.netNumToName) {
      this.finished = true;
      return false;
    }
    const netToPads = /* @__PURE__ */ new Map();
    const footprints = this.ctx.kicadPcb.footprints || [];
    const footprintArray = Array.isArray(footprints) ? footprints : [footprints];
    for (const footprint of footprintArray) {
      this.processFootprintPads(footprint, netToPads);
    }
    for (const [netNum, pads] of netToPads.entries()) {
      if (pads.length < 2 || this.processedNets.has(netNum)) {
        continue;
      }
      this.createSourceTrace(netNum, pads);
      this.processedNets.add(netNum);
    }
    this.finished = true;
    return false;
  }
  processFootprintPads(footprint, netToPads) {
    const footprintUuid = footprint.uuid?.value || footprint.tstamp?.value;
    if (!footprintUuid) return;
    const componentId = this.ctx.footprintUuidToComponentId?.get(footprintUuid);
    if (!componentId) return;
    const pads = footprint.fpPads || [];
    const padArray = Array.isArray(pads) ? pads : [pads];
    for (const pad of padArray) {
      const padNumber = pad.number?.toString();
      if (!padNumber) continue;
      const netNum = this.getPadNet(pad);
      if (netNum === null || netNum === void 0 || netNum === 0) {
        continue;
      }
      const sourcePortId = this.getOrCreateSourcePort(
        componentId,
        padNumber,
        footprint
      );
      if (!netToPads.has(netNum)) {
        netToPads.set(netNum, []);
      }
      netToPads.get(netNum).push({
        componentId,
        padNumber,
        sourcePortId
      });
    }
  }
  getPadNet(pad) {
    const net = pad._sxNet || pad.net;
    if (!net) return null;
    if (typeof net === "number") return net;
    if (typeof net === "object") {
      return net._id ?? net.number ?? net.ordinal ?? null;
    }
    return null;
  }
  getOrCreateSourcePort(componentId, padNumber, footprint) {
    const sourcePortId = `${componentId}_port_${padNumber}`;
    const existingPort = this.ctx.db.source_port.list().find((sp) => sp.source_port_id === sourcePortId);
    if (!existingPort) {
      const reference = this.getFootprintReference(footprint);
      this.ctx.db.source_port.insert({
        source_port_id: sourcePortId,
        source_component_id: componentId,
        name: `${reference || "U"}.${padNumber}`,
        pin_number: parseInt(padNumber, 10) || void 0
      });
    }
    return sourcePortId;
  }
  getFootprintReference(footprint) {
    const properties = footprint.properties || [];
    const propertyArray = Array.isArray(properties) ? properties : [properties];
    for (const property of propertyArray) {
      if (property.key === "Reference" || property.name === "Reference") {
        return property.value;
      }
    }
    const textItems = footprint.fpTexts || [];
    const textArray = Array.isArray(textItems) ? textItems : [textItems];
    for (const text of textArray) {
      if (text.type === "reference") {
        return text.text;
      }
    }
    return void 0;
  }
  createSourceTrace(netNum, pads) {
    const netName = this.ctx.netNumToName?.get(netNum) || `Net-${netNum}`;
    this.ctx.db.source_trace.insert({
      connected_source_port_ids: pads.map((p) => p.sourcePortId),
      connected_source_net_ids: [],
      // Can be populated if we track source_net elements
      display_name: netName
    });
    if (this.ctx.stats) {
      this.ctx.stats.traces = (this.ctx.stats.traces || 0) + 1;
    }
  }
};

// lib/KicadToCircuitJsonConverter.ts
var KicadToCircuitJsonConverter = class {
  fsMap = {};
  ctx;
  currentStageIndex = 0;
  pipeline;
  get currentStage() {
    return this.pipeline?.[this.currentStageIndex];
  }
  addFile(filePath, content) {
    this.fsMap[filePath] = content;
  }
  _findFileWithExtension(extension) {
    const filesWithExtension = Object.keys(this.fsMap).filter(
      (key) => key.endsWith(extension)
    );
    if (filesWithExtension.length > 1) {
      throw new Error(
        `Expected 0 or 1 file with extension ${extension}, got ${filesWithExtension.length}. Files: ${filesWithExtension.join(", ")}`
      );
    }
    return filesWithExtension[0] ?? null;
  }
  initializePipeline() {
    const pcbFile = this._findFileWithExtension(".kicad_pcb");
    const schFile = this._findFileWithExtension(".kicad_sch");
    this.ctx = {
      db: cju([]),
      kicadPcb: pcbFile ? parseKicadPcb(this.fsMap[pcbFile]) : void 0,
      kicadSch: schFile ? parseKicadSch(this.fsMap[schFile]) : void 0,
      warnings: [],
      stats: {}
    };
    this.pipeline = [];
    if (this.ctx.kicadSch) {
      this.pipeline.push(
        new InitializeSchematicContextStage(this.ctx),
        new CollectLibrarySymbolsStage(this.ctx),
        new CollectSchematicTracesStage(this.ctx)
      );
    }
    if (this.ctx.kicadPcb) {
      this.pipeline.push(
        new InitializePcbContextStage(this.ctx),
        new CollectNetsStage(this.ctx),
        new CollectFootprintsStage(this.ctx),
        new CollectTracesStage(this.ctx),
        new CollectViasStage(this.ctx),
        new CollectZonesStage(this.ctx),
        new CollectGraphicsStage(this.ctx),
        new CollectSourceTracesStage(this.ctx)
      );
    }
  }
  step() {
    if (!this.pipeline) {
      this.initializePipeline();
    }
    if (!this.currentStage) {
      return false;
    }
    const hasMoreWork = this.currentStage.step();
    if (!hasMoreWork || this.currentStage.finished) {
      this.currentStageIndex++;
    }
    return this.currentStageIndex < (this.pipeline?.length || 0);
  }
  runUntilFinished() {
    if (!this.pipeline) {
      this.initializePipeline();
    }
    for (const stage of this.pipeline || []) {
      stage.runUntilFinished();
    }
  }
  getOutput() {
    if (!this.ctx) {
      this.initializePipeline();
      this.runUntilFinished();
    }
    const elements = [];
    const tableNames = [
      "source_component",
      "source_port",
      "source_trace",
      "schematic_component",
      "schematic_port",
      "schematic_trace",
      "schematic_net_label",
      "pcb_component",
      "pcb_port",
      "pcb_smtpad",
      "pcb_plated_hole",
      "pcb_hole",
      "pcb_trace",
      "pcb_via",
      "pcb_copper_pour",
      "pcb_board",
      "pcb_silkscreen_text",
      "pcb_silkscreen_path"
    ];
    for (const tableName of tableNames) {
      const table = this.ctx.db[tableName];
      if (table && typeof table.list === "function") {
        const items = table.list();
        if (items && Array.isArray(items)) {
          elements.push(...items);
        }
      }
    }
    return elements;
  }
  getOutputString() {
    return JSON.stringify(this.getOutput(), null, 2);
  }
  getWarnings() {
    return this.ctx?.warnings || [];
  }
  getStats() {
    return this.ctx?.stats || {};
  }
};
export {
  CollectFootprintsStage,
  CollectGraphicsStage,
  CollectLibrarySymbolsStage,
  CollectNetsStage,
  CollectSchematicTracesStage,
  CollectSourceTracesStage,
  CollectTracesStage,
  CollectViasStage,
  CollectZonesStage,
  ConverterStage,
  InitializePcbContextStage,
  InitializeSchematicContextStage,
  KicadToCircuitJsonConverter
};
