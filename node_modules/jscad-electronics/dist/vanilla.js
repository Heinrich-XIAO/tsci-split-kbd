// lib/vanilla/h.ts
var Fragment = Symbol("Fragment");
function h(type, props, ...restChildren) {
  const provided = restChildren.length ? restChildren : props?.children !== void 0 ? [props.children] : [];
  const flatChildren = [];
  const stack = (Array.isArray(provided) ? provided : [provided]).flat(
    Infinity
  );
  for (const ch of stack) {
    if (ch == null || ch === false) continue;
    if (Array.isArray(ch)) flatChildren.push(...ch);
    else flatChildren.push(ch);
  }
  return {
    type,
    props: (props && props.children !== void 0 ? { ...props, children: void 0 } : props) || {},
    children: flatChildren
  };
}

// lib/Footprinter3d.tsx
import { fp } from "@tscircuit/footprinter";

// lib/vanilla/primitives.ts
var Cuboid = Symbol("Cuboid");
var Cube = Symbol("Cube");
var Cylinder = Symbol("Cylinder");
var Sphere = Symbol("Sphere");
var RoundedCuboid = Symbol("RoundedCuboid");
var Translate = Symbol("Translate");
var Rotate = Symbol("Rotate");
var Union = Symbol("Union");
var Subtract = Symbol("Subtract");
var Hull = Symbol("Hull");
var Colorize = Symbol("Colorize");
var Polygon = Symbol("Polygon");
var ExtrudeLinear = Symbol("ExtrudeLinear");

// lib/vanilla/react-shim.ts
var Fragment2 = Fragment;
var jsx = (type, props, _key) => h(type, props);
var jsxs = (type, props, _key) => h(type, props);

// lib/ChipBody.tsx
var ChipBody = ({
  center,
  width: width10,
  length,
  height: height10,
  heightAboveSurface: heightAboveSurface2 = 0.15
}) => {
  const straightHeight = height10 * 0.5;
  const taperHeight = height10 - straightHeight;
  const taperInset = Math.min(width10, length) * 0.12;
  const faceWidth = Math.max(width10 - taperInset, width10 * 0.75);
  const faceLength = Math.max(length - taperInset, length * 0.75);
  const notchRadius = Math.min(width10, length) * 0.12;
  const notchCenterZ = height10 - notchRadius * 0.6;
  const notchCenterY = length / 2 - notchRadius * 0.25;
  const notchLength = 0.5;
  const notchWidth = 0.25;
  return /* @__PURE__ */ jsx(Colorize, { color: "#555", children: /* @__PURE__ */ jsx(Translate, { offset: center, children: /* @__PURE__ */ jsx(Translate, { offset: { x: 0, y: 0, z: heightAboveSurface2 }, children: /* @__PURE__ */ jsxs(Subtract, { children: [
    /* @__PURE__ */ jsxs(Union, { children: [
      /* @__PURE__ */ jsxs(Hull, { children: [
        /* @__PURE__ */ jsx(Translate, { z: 5e-3, children: /* @__PURE__ */ jsx(Cuboid, { size: [faceWidth, faceLength, 0.01] }) }),
        /* @__PURE__ */ jsx(Translate, { z: straightHeight, children: /* @__PURE__ */ jsx(Cuboid, { size: [width10, length, 0.01] }) })
      ] }),
      /* @__PURE__ */ jsxs(Hull, { children: [
        /* @__PURE__ */ jsx(Translate, { z: straightHeight, children: /* @__PURE__ */ jsx(Cuboid, { size: [width10, length, 0.01] }) }),
        /* @__PURE__ */ jsx(Translate, { z: straightHeight + taperHeight, children: /* @__PURE__ */ jsx(Cuboid, { size: [faceWidth, faceLength, 0.01] }) })
      ] })
    ] }),
    /* @__PURE__ */ jsx(Translate, { offset: { x: 0, y: notchCenterY, z: height10 }, children: /* @__PURE__ */ jsx(Rotate, { rotation: [0, 0, 0], children: /* @__PURE__ */ jsx(Cylinder, { radius: notchLength, height: notchWidth }) }) })
  ] }) }) }) });
};

// lib/utils/range.ts
var range = (end) => Array.from({ length: end }, (_, i) => i);

// lib/utils/getExpandedStroke.ts
function getExpandedStroke(strokeInput, width10) {
  if (strokeInput.length < 2) {
    throw new Error("Stroke must have at least two points");
  }
  const stroke = Array.isArray(strokeInput[0]) ? strokeInput.map(([x, y]) => ({ x, y })) : strokeInput;
  const halfWidth = width10 / 2;
  const leftSide = [];
  const rightSide = [];
  function getNormal(p1, p2) {
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    return { x: -dy / length, y: dx / length };
  }
  function addPoint(point, normal, factor) {
    const newPoint = {
      x: point.x + normal.x * halfWidth * factor,
      y: point.y + normal.y * halfWidth * factor
    };
    if (factor > 0) {
      leftSide.push(newPoint);
    } else {
      rightSide.unshift(newPoint);
    }
  }
  const firstNormal = getNormal(stroke[0], stroke[1]);
  addPoint(stroke[0], firstNormal, 1);
  addPoint(stroke[0], firstNormal, -1);
  for (let i = 1; i < stroke.length - 1; i++) {
    const prev = stroke[i - 1];
    const current = stroke[i];
    const next = stroke[i + 1];
    const normalPrev = getNormal(prev, current);
    const normalNext = getNormal(current, next);
    const miterX = normalPrev.x + normalNext.x;
    const miterY = normalPrev.y + normalNext.y;
    const miterLength = Math.sqrt(miterX * miterX + miterY * miterY);
    const miterLimit = 2;
    if (miterLength / 2 > miterLimit * halfWidth) {
      addPoint(current, normalPrev, 1);
      addPoint(current, normalNext, 1);
      addPoint(current, normalPrev, -1);
      addPoint(current, normalNext, -1);
    } else {
      const scale = 1 / miterLength;
      addPoint(current, { x: miterX * scale, y: miterY * scale }, 1);
      addPoint(current, { x: miterX * scale, y: miterY * scale }, -1);
    }
  }
  const lastNormal = getNormal(
    stroke[stroke.length - 2],
    stroke[stroke.length - 1]
  );
  addPoint(stroke[stroke.length - 1], lastNormal, 1);
  addPoint(stroke[stroke.length - 1], lastNormal, -1);
  return [...leftSide, ...rightSide];
}

// lib/DualInlinePackage.tsx
var normalizeOnY = (points) => {
  const minX = Math.min(...points.map((p) => p.x));
  const maxX = Math.max(...points.map((p) => p.x));
  const minY = Math.min(...points.map((p) => p.y));
  const maxY = Math.max(...points.map((p) => p.y));
  const height10 = maxY - minY;
  const factor = 5.47 / height10;
  return points.map((p) => ({
    x: (p.x - minX - (maxX - minX) / 2) * factor,
    y: (p.y - minY) * factor
  }));
};
var svgPathPoints = normalizeOnY([
  { x: 20, y: 105 },
  { x: 20, y: 109 },
  { x: 20, y: 102 },
  { x: 26, y: 102 },
  { x: 26, y: 109 },
  { x: 24, y: 111 },
  { x: 24, y: 118 },
  { x: 22, y: 118 },
  { x: 22, y: 111 },
  { x: 20, y: 109 }
]);
var DIP_PIN_HEIGHT = 5.47;
var heightAboveSurface = 0.5;
var DipPinLeg = ({ x, y, z }) => {
  const isRotated = x > 0;
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(Translate, { offset: { x: x + 0.25 / 2, y, z }, children: /* @__PURE__ */ jsx(Rotate, { rotation: ["-90deg", 0, "90deg"], children: /* @__PURE__ */ jsx(ExtrudeLinear, { height: 0.25, children: /* @__PURE__ */ jsx(Polygon, { points: svgPathPoints.map((p) => [p.x, p.y]) }) }) }) }),
    /* @__PURE__ */ jsx(
      Translate,
      {
        offset: {
          x,
          y: y + (isRotated ? 1 : -1),
          z
        },
        children: /* @__PURE__ */ jsx(Rotate, { rotation: ["-90deg", "90deg", isRotated ? "180deg" : "0deg"], children: /* @__PURE__ */ jsx(ExtrudeLinear, { height: 2, children: /* @__PURE__ */ jsx(
          Polygon,
          {
            points: getExpandedStroke(
              [
                [0, 0],
                [-1, 0],
                [-1, -1]
              ],
              0.25
            ).map((p) => [p.x, p.y])
          }
        ) }) })
      }
    )
  ] });
};
var Dip = ({
  numPins = 8,
  pitch = 2.54,
  bodyWidth = 6.4
}) => {
  const numPinsOnEachSide = Math.floor(numPins / 2);
  const crossBodyPinWidth = bodyWidth + 1;
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    range(numPins).map((i) => {
      const yRow = i % numPinsOnEachSide;
      const xRow = (Math.floor(i / numPinsOnEachSide) - 0.5) * 2;
      return /* @__PURE__ */ jsx(
        DipPinLeg,
        {
          x: xRow * crossBodyPinWidth / 2,
          y: yRow * pitch - (numPinsOnEachSide - 1) / 2 * pitch,
          z: DIP_PIN_HEIGHT / 2 + heightAboveSurface
        },
        i
      );
    }),
    /* @__PURE__ */ jsx(
      ChipBody,
      {
        width: bodyWidth,
        length: numPinsOnEachSide * pitch + 0.5,
        height: DIP_PIN_HEIGHT - heightAboveSurface,
        heightAboveSurface,
        center: { x: 0, y: 0, z: heightAboveSurface }
      }
    )
  ] });
};

// lib/SmdChipLead.tsx
function calculateSCurve(x, {
  height: height10,
  padContactLength,
  curveLength,
  bodyDistance,
  steepness = 10
}) {
  if (!curveLength) curveLength = bodyDistance * 0.3;
  let flatFromBodySectionLength = bodyDistance - padContactLength - curveLength;
  if (flatFromBodySectionLength < 0) {
    curveLength += flatFromBodySectionLength;
    flatFromBodySectionLength = 0;
  }
  const curveStart = padContactLength * 0.75;
  const curveEnd = padContactLength + curveLength + (bodyDistance - padContactLength - curveLength) * 0.25;
  if (x <= curveStart) return 0;
  if (x >= curveEnd) return height10;
  const t = (x - curveStart) / (curveEnd - curveStart);
  return height10 / (1 + Math.exp(-steepness * (t - 0.5)));
}
var SmdChipLead = (props) => {
  const { thickness, width: width10, padContactLength, bodyDistance, height: height10, rotation } = props;
  const N = 15;
  const points = Array.from({ length: N }).map((_, i) => i / (N - 1) * bodyDistance).map((x) => [x, calculateSCurve(x, props)]);
  const polygon = getExpandedStroke(points, thickness);
  return /* @__PURE__ */ jsx(Colorize, { color: "#fff", children: /* @__PURE__ */ jsx(Translate, { offset: { z: 0, y: 0, x: 0, ...props.position }, children: /* @__PURE__ */ jsx(Rotate, { rotation: ["90deg", 0, rotation ?? 0], children: /* @__PURE__ */ jsx(Translate, { offset: { x: 0, y: 0, z: -width10 / 2 }, children: /* @__PURE__ */ jsx(ExtrudeLinear, { height: width10, children: /* @__PURE__ */ jsx(Polygon, { points: polygon.map((p) => [p.x, p.y]) }) }) }) }) }) });
};

// lib/Tssop.tsx
var Tssop = ({
  pinCount,
  leadLength,
  leadWidth,
  pitch,
  bodyWidth
}) => {
  const sidePinCount = Math.ceil(pinCount / 2);
  const fullLength10 = pitch * pinCount / 2 + leadWidth / 2;
  const pinOffsetToCenter = (sidePinCount - 1) * pitch / 2;
  const leadThickness = 0.25;
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    Array.from({ length: sidePinCount }).map((_, i) => /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        position: {
          x: -bodyWidth / 2 - leadLength,
          y: i * pitch - pinOffsetToCenter,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength: leadLength,
        bodyDistance: leadLength + 1,
        height: 0.8
      },
      i
    )),
    Array.from({ length: sidePinCount }).map((_, i) => /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        rotation: Math.PI,
        position: {
          x: bodyWidth / 2 + leadLength,
          y: i * pitch - pinOffsetToCenter,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength: leadLength,
        bodyDistance: leadLength + 1,
        height: 0.8
      },
      i
    )),
    /* @__PURE__ */ jsx(
      ChipBody,
      {
        center: { x: 0, y: 0, z: leadThickness / 2 },
        width: bodyWidth - leadWidth - 1,
        length: fullLength10,
        height: 1.5
      }
    )
  ] });
};

// lib/A0402.tsx
var fullLength = 1;
var width = 0.5;
var height = 0.5;
var terminatorWidth = 0.2;
var bodyLength = fullLength - terminatorWidth * 2;
var A0402 = ({ color = "#333" }) => {
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [bodyLength, width, height],
        offset: [0, 0, height / 2],
        color
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth, height, width],
        offset: [fullLength / 2 - terminatorWidth / 2, 0, height / 2],
        color: "#ccc"
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth, height, width],
        offset: [-fullLength / 2 + terminatorWidth / 2, 0, height / 2],
        color: "#ccc"
      }
    )
  ] });
};

// lib/A0603.tsx
var fullLength2 = 1.6;
var bodyLength2 = fullLength2 - 0.3 * 2;
var terminatorLength = 0.3;
var width2 = 0.85;
var height2 = 0.6;
var A0603 = ({ color = "#333" }) => {
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [bodyLength2, width2, height2],
        offset: [0, 0, height2 / 2],
        color
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorLength, width2, height2],
        offset: [fullLength2 / 2 - terminatorLength / 2, 0, height2 / 2],
        color: "#ccc"
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorLength, width2, height2],
        offset: [-fullLength2 / 2 + terminatorLength / 2, 0, height2 / 2],
        color: "#ccc"
      }
    )
  ] });
};

// lib/A0805.tsx
var fullLength3 = 2;
var width3 = 1.25;
var height3 = 0.55;
var terminatorWidth2 = 0.5;
var bodyLength3 = fullLength3 - terminatorWidth2 * 2;
var A0805 = ({ color = "#333" }) => {
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [bodyLength3, width3, height3],
        offset: [0, 0, height3 / 2],
        color
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth2, width3, height3],
        offset: [fullLength3 / 2 - terminatorWidth2 / 2, 0, height3 / 2],
        color: "#ccc"
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth2, width3, height3],
        offset: [-fullLength3 / 2 + terminatorWidth2 / 2, 0, height3 / 2],
        color: "#ccc"
      }
    )
  ] });
};

// lib/qfp.tsx
var QFP = ({
  pinCount,
  pitch,
  leadWidth,
  padContactLength,
  bodyWidth
}) => {
  const sidePinCount = pinCount / 4;
  if (!pitch) pitch = getPitch(pinCount, bodyWidth);
  if (!padContactLength) padContactLength = getPadContactLength(pinCount);
  if (!leadWidth) leadWidth = getLeadWidth(pinCount, bodyWidth);
  if (!bodyWidth) bodyWidth = pitch * (sidePinCount + 4);
  const bodyLength10 = bodyWidth;
  const pinOffsetToCenter = (sidePinCount - 1) * pitch / 2;
  const fullLength10 = bodyLength10 + 2 * padContactLength;
  const fullWidth = fullLength10;
  const leadHeight = 0.8;
  const leadThickness = 0.15;
  const bodyDistance = (fullWidth - bodyWidth) / 2 + 0.2;
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    Array.from({ length: sidePinCount }).map((_, i) => /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        position: {
          x: -fullWidth / 2,
          y: i * pitch - pinOffsetToCenter,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength,
        bodyDistance,
        height: leadHeight
      },
      `left-${i}`
    )),
    Array.from({ length: sidePinCount }).map((_, i) => /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        rotation: Math.PI,
        position: {
          x: fullWidth / 2,
          y: i * pitch - pinOffsetToCenter,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength,
        bodyDistance,
        height: leadHeight
      },
      `right-${i}`
    )),
    Array.from({ length: sidePinCount }).map((_, i) => /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        rotation: Math.PI / 2,
        position: {
          x: i * pitch - pinOffsetToCenter,
          y: -fullLength10 / 2,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength,
        bodyDistance,
        height: leadHeight
      },
      `bottom-${i}`
    )),
    Array.from({ length: sidePinCount }).map((_, i) => /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        rotation: -Math.PI / 2,
        position: {
          x: i * pitch - pinOffsetToCenter,
          y: fullLength10 / 2,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength,
        bodyDistance,
        height: leadHeight
      },
      `top-${i}`
    )),
    /* @__PURE__ */ jsx(
      ChipBody,
      {
        center: { x: 0, y: 0, z: leadThickness / 2 },
        width: bodyWidth,
        length: bodyLength10,
        height: 1.5
      }
    )
  ] });
};
var getPitch = (pinCount, width10) => {
  switch (pinCount) {
    case 44:
    case 64:
      return 0.8;
    case 52:
      return width10 === 14 ? 1 : 0.65;
    case 208:
      return 0.5;
    default:
      return 0.5;
  }
};
var getPadContactLength = (pinCount) => {
  switch (pinCount) {
    case 44:
    case 52:
    case 64:
      return 2.25;
    case 208:
      return 1.65;
    default:
      return 1;
  }
};
var getLeadWidth = (pinCount, width10) => {
  switch (pinCount) {
    case 44:
    case 64:
      return 0.5;
    case 52:
      return width10 === 14 ? 0.45 : 0.55;
    case 208:
      return 0.3;
    default:
      return 0.25;
  }
};

// lib/PinRow.tsx
var PinRow = ({
  numberOfPins,
  pitch = 2.54,
  longSidePinLength = 6
}) => {
  const pinThickness = 0.63;
  const bodyHeight = 2;
  const bodyWidth = numberOfPins * pitch;
  const shortSidePinLength = 3;
  const xoff = -((numberOfPins - 1) / 2) * pitch;
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        color: "#222",
        size: [bodyWidth, pinThickness * 3, bodyHeight],
        center: [0, 0, bodyHeight / 2]
      }
    ),
    Array.from({ length: numberOfPins }, (_, i) => /* @__PURE__ */ jsxs(Fragment2, { children: [
      /* @__PURE__ */ jsx(Colorize, { color: "gold", children: /* @__PURE__ */ jsxs(Hull, { children: [
        /* @__PURE__ */ jsx(
          Cuboid,
          {
            color: "gold",
            size: [pinThickness, pinThickness, shortSidePinLength * 0.9],
            center: [
              xoff + i * pitch,
              0,
              bodyHeight * 0.9 + bodyHeight / 2
            ]
          }
        ),
        /* @__PURE__ */ jsx(
          Cuboid,
          {
            color: "gold",
            size: [
              pinThickness / 1.8,
              pinThickness / 1.8,
              shortSidePinLength
            ],
            center: [xoff + i * pitch, 0, bodyHeight + bodyHeight / 2]
          }
        )
      ] }) }),
      /* @__PURE__ */ jsx(Colorize, { color: "gold", children: /* @__PURE__ */ jsxs(Hull, { children: [
        /* @__PURE__ */ jsx(
          Cuboid,
          {
            color: "gold",
            size: [pinThickness, pinThickness, longSidePinLength * 0.9],
            center: [xoff + i * pitch, 0, -longSidePinLength / 2 * 0.9]
          }
        ),
        /* @__PURE__ */ jsx(
          Cuboid,
          {
            color: "gold",
            size: [
              pinThickness / 1.8,
              pinThickness / 1.8,
              longSidePinLength
            ],
            center: [xoff + i * pitch, 0, -longSidePinLength / 2]
          }
        )
      ] }) })
    ] }))
  ] });
};

// lib/utils/getQuadCoords.ts
var getQuadCoords = (params) => {
  const SIDES_CCW = ["left", "bottom", "right", "top"];
  const { pin_count, pn, w, h: h2, p, pl, legsoutside } = params;
  const sidePinCount = pin_count / 4;
  const side = SIDES_CCW[Math.floor((pn - 1) / sidePinCount)];
  const pos = (pn - 1) % sidePinCount;
  const ibw = p * (sidePinCount - 1);
  const ibh = p * (sidePinCount - 1);
  const pcdfe = legsoutside ? pl / 2 : -pl / 2;
  switch (side) {
    case "left":
      return { x: -w / 2 - pcdfe, y: ibh / 2 - pos * p, o: "vert" };
    case "bottom":
      return { x: -ibw / 2 + pos * p, y: -h2 / 2 - pcdfe, o: "horz" };
    case "right":
      return { x: w / 2 + pcdfe, y: -ibh / 2 + pos * p, o: "vert" };
    case "top":
      return { x: ibw / 2 - pos * p, y: h2 / 2 + pcdfe, o: "horz" };
    default:
      throw new Error("Invalid pin number");
  }
};

// lib/utils/getQuadPinMap.ts
var getQuadPinMap = ({
  num_pins,
  cw,
  ccw,
  startingpin
}) => {
  const pin_map = [];
  const pins_per_side = num_pins / 4;
  let current_position_ccw_normal = 1;
  const sfp = {};
  for (const specifier of startingpin ?? []) {
    sfp[specifier] = true;
  }
  if (!sfp.leftside && !sfp.topside && !sfp.rightside && !sfp.bottomside) {
    sfp.leftside = true;
  }
  if (!sfp.bottompin && !sfp.leftpin && !sfp.rightpin && !sfp.toppin) {
    if (sfp.leftside) {
      sfp.toppin = true;
    } else if (sfp.topside) {
      sfp.rightpin = true;
    } else if (sfp.rightside) {
      sfp.bottompin = true;
    } else if (sfp.bottomside) {
      sfp.leftpin = true;
    }
  }
  if (sfp.leftside && sfp.toppin) {
    current_position_ccw_normal = 1;
  } else if (sfp.leftside && sfp.bottompin) {
    current_position_ccw_normal = pins_per_side;
  } else if (sfp.bottomside && sfp.leftpin) {
    current_position_ccw_normal = pins_per_side + 1;
  } else if (sfp.bottomside && sfp.rightpin) {
    current_position_ccw_normal = pins_per_side * 2;
  } else if (sfp.rightside && sfp.bottompin) {
    current_position_ccw_normal = pins_per_side * 2 + 1;
  } else if (sfp.rightside && sfp.toppin) {
    current_position_ccw_normal = pins_per_side * 3;
  } else if (sfp.topside && sfp.rightpin) {
    current_position_ccw_normal = pins_per_side * 3 + 1;
  } else if (sfp.topside && sfp.leftpin) {
    current_position_ccw_normal = pins_per_side * 4;
  }
  pin_map.push(-1);
  for (let i = 0; i < num_pins; i++) {
    pin_map[current_position_ccw_normal] = i + 1;
    if (ccw || !cw) {
      current_position_ccw_normal++;
      if (current_position_ccw_normal > num_pins) {
        current_position_ccw_normal = 1;
      }
    } else {
      current_position_ccw_normal--;
      if (current_position_ccw_normal < 1) {
        current_position_ccw_normal = num_pins;
      }
    }
  }
  return pin_map;
};

// lib/qfn.tsx
var QFN = ({
  num_pins = 16,
  bodyWidth = 9,
  bodyLength: bodyLength10 = 9,
  bodyThickness = 0.8,
  thermalPadSize,
  padWidth = 0.25,
  padLength = 0.25,
  pitch = 0.5,
  thermalPadThickness = 0.05
}) => {
  const pin_map = getQuadPinMap({
    num_pins,
    cw: true,
    ccw: true
  });
  const pinPositions = [];
  const spc = num_pins / 4;
  for (let i = 0; i < num_pins; i++) {
    const {
      x,
      y,
      o: orientation
    } = getQuadCoords({
      pin_count: num_pins,
      pn: i + 1,
      w: bodyWidth,
      h: bodyLength10,
      p: pitch,
      pl: padLength,
      legsoutside: false
    });
    let pw = padWidth;
    let pl = padLength;
    if (orientation === "vert") {
      ;
      [pw, pl] = [pl, pw];
    }
    const pn = pin_map[i + 1];
    pinPositions.push({ pn, x, y, pw, pl });
  }
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(Colorize, { color: "grey", children: /* @__PURE__ */ jsx(
      Cuboid,
      {
        center: { x: 0, y: 0, z: bodyThickness / 2 },
        size: [bodyWidth, bodyLength10, bodyThickness]
      }
    ) }),
    pinPositions.map((p, i) => /* @__PURE__ */ jsx(
      Cuboid,
      {
        center: { x: p.x, y: p.y, z: thermalPadThickness / 2 },
        size: [p.pw, p.pl, thermalPadThickness]
      },
      i
    )),
    thermalPadSize?.length !== void 0 && thermalPadSize?.width !== void 0 && /* @__PURE__ */ jsx(
      Cuboid,
      {
        center: { x: 0, y: 0, z: thermalPadThickness / 2 },
        size: [
          thermalPadSize.width,
          thermalPadSize.length,
          thermalPadThickness
        ]
      }
    )
  ] });
};
var qfn_default = QFN;

// lib/SOT-235.tsx
var SOT235 = () => {
  const fullWidth = 2.8;
  const bodyWidth = 1.6;
  const bodyLength10 = 2.9;
  const bodyHeight = 1.2;
  const leadWidth = 0.4;
  const leadThickness = 0.15;
  const leadHeight = 0.95;
  const padContactLength = 0.5;
  const padPitch = 0.95;
  const extendedBodyDistance = fullWidth - bodyWidth;
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        rotation: Math.PI,
        position: {
          x: fullWidth / 2 + extendedBodyDistance / 4,
          y: -1,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength,
        bodyDistance: extendedBodyDistance,
        height: leadHeight
      },
      1
    ),
    /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        rotation: Math.PI,
        position: {
          x: fullWidth / 2 + extendedBodyDistance / 4,
          y: 1,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength,
        bodyDistance: extendedBodyDistance,
        height: leadHeight
      },
      2
    ),
    /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        position: {
          x: -fullWidth / 2 - extendedBodyDistance / 4,
          y: 0,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength,
        bodyDistance: extendedBodyDistance,
        height: leadHeight
      },
      3
    ),
    /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        position: {
          x: -fullWidth / 2 - extendedBodyDistance / 4,
          y: -1,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength,
        bodyDistance: extendedBodyDistance,
        height: leadHeight
      },
      1
    ),
    /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        position: {
          x: -fullWidth / 2 - extendedBodyDistance / 4,
          y: 1,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength,
        bodyDistance: extendedBodyDistance,
        height: leadHeight
      },
      2
    ),
    /* @__PURE__ */ jsx(
      ChipBody,
      {
        center: { x: 0, y: 0, z: 0 },
        width: bodyWidth,
        length: bodyLength10,
        height: bodyHeight
      }
    )
  ] });
};
var SOT_235_default = SOT235;

// lib/A0201.tsx
var fullLength4 = 0.6;
var width4 = 0.3;
var height4 = 0.33;
var terminatorWidth3 = 0.1;
var bodyLength4 = fullLength4 - terminatorWidth3 * 2;
var A0201 = ({ color = "#333" }) => {
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [bodyLength4, width4, height4],
        offset: [0, 0, height4 / 2],
        color
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth3, width4, height4],
        offset: [fullLength4 / 2 - terminatorWidth3 / 2, 0, height4 / 2],
        color: "#ccc"
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth3, width4, height4],
        offset: [-fullLength4 / 2 + terminatorWidth3 / 2, 0, height4 / 2],
        color: "#ccc"
      }
    )
  ] });
};

// lib/A01005.tsx
var fullLength5 = 0.4;
var width5 = 0.2;
var height5 = 0.13;
var terminatorWidth4 = 0.07;
var bodyLength5 = fullLength5 - terminatorWidth4 * 2;
var A01005 = ({ color = "#333" }) => {
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [bodyLength5, width5, height5],
        offset: [0, 0, height5 / 2],
        color
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth4, width5, height5],
        offset: [fullLength5 / 2 - terminatorWidth4 / 2, 0, height5 / 2],
        color: "#ccc"
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth4, width5, height5],
        offset: [-fullLength5 / 2 + terminatorWidth4 / 2, 0, height5 / 2],
        color: "#ccc"
      }
    )
  ] });
};

// lib/A1206.tsx
var fullLength6 = 3.2;
var width6 = 1.6;
var height6 = 0.9;
var terminatorWidth5 = 0.5;
var bodyLength6 = fullLength6 - terminatorWidth5 * 2;
var A1206 = ({ color = "#333" }) => {
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [bodyLength6, width6, height6],
        offset: [0, 0, height6 / 2],
        color
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth5, width6, height6],
        offset: [fullLength6 / 2 - terminatorWidth5 / 2, 0, height6 / 2],
        color: "#ccc"
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth5, width6, height6],
        offset: [-fullLength6 / 2 + terminatorWidth5 / 2, 0, height6 / 2],
        color: "#ccc"
      }
    )
  ] });
};

// lib/A1210.tsx
var fullLength7 = 3.2;
var width7 = 2.5;
var height7 = 1;
var terminatorWidth6 = 0.6;
var bodyLength7 = fullLength7 - terminatorWidth6 * 2;
var A1210 = ({ color = "#333" }) => {
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [bodyLength7, width7, height7],
        offset: [0, 0, height7 / 2],
        color
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth6, width7, height7],
        offset: [fullLength7 / 2 - terminatorWidth6 / 2, 0, height7 / 2],
        color: "#ccc"
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth6, width7, height7],
        offset: [-fullLength7 / 2 + terminatorWidth6 / 2, 0, height7 / 2],
        color: "#ccc"
      }
    )
  ] });
};

// lib/A2010.tsx
var fullLength8 = 5;
var width8 = 2.5;
var height8 = 1.4;
var terminatorWidth7 = 0.6;
var bodyLength8 = fullLength8 - terminatorWidth7 * 2;
var A2010 = ({ color = "#333" }) => {
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [bodyLength8, width8, height8],
        offset: [0, 0, height8 / 2],
        color
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth7, width8, height8],
        offset: [fullLength8 / 2 - terminatorWidth7 / 2, 0, height8 / 2],
        color: "#ccc"
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth7, width8, height8],
        offset: [-fullLength8 / 2 + terminatorWidth7 / 2, 0, height8 / 2],
        color: "#ccc"
      }
    )
  ] });
};

// lib/A2512.tsx
var fullLength9 = 6.3;
var width9 = 3.2;
var height9 = 1.8;
var terminatorWidth8 = 0.8;
var bodyLength9 = fullLength9 - terminatorWidth8 * 2;
var A2512 = ({ color = "#333" }) => {
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [bodyLength9, width9, height9],
        offset: [0, 0, height9 / 2],
        color
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth8, width9, height9],
        offset: [fullLength9 / 2 - terminatorWidth8 / 2, 0, height9 / 2],
        color: "#ccc"
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        size: [terminatorWidth8, width9, height9],
        offset: [-fullLength9 / 2 + terminatorWidth8 / 2, 0, height9 / 2],
        color: "#ccc"
      }
    )
  ] });
};

// lib/FemaleHeader.tsx
var FemaleHeader = ({
  numberOfPins,
  pitch = 2.54,
  legsLength = 3,
  outerDiameter = 0.945,
  innerDiameter = 0.945
}) => {
  const pinThickness = innerDiameter / 1.5;
  const bodyDepth = pinThickness * 2 + outerDiameter;
  const bodyHeight = 5;
  const bodyWidth = (numberOfPins - 1) * pitch + outerDiameter + pitch / 2;
  const gapWidth = pinThickness * 1.6;
  const xoff = -((numberOfPins - 1) / 2) * pitch;
  const Body = /* @__PURE__ */ jsx(Colorize, { color: "#1a1a1a", children: /* @__PURE__ */ jsxs(Subtract, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        color: "#000",
        size: [bodyWidth, bodyDepth, bodyHeight],
        center: [0, 0, bodyHeight / 2]
      }
    ),
    Array.from(
      { length: numberOfPins },
      (_, i) => innerDiameter ? /* @__PURE__ */ jsx(
        Cylinder,
        {
          height: bodyHeight + 0.1,
          radius: innerDiameter / 2,
          center: [xoff + i * pitch, 0, bodyHeight / 2],
          color: "#222"
        },
        i
      ) : /* @__PURE__ */ jsx(
        Cuboid,
        {
          size: [gapWidth, gapWidth, bodyHeight],
          center: [xoff + i * pitch, 0, bodyHeight / 2]
        },
        i
      )
    )
  ] }) });
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    Body,
    Array.from({ length: numberOfPins }, (_, i) => /* @__PURE__ */ jsxs(Colorize, { color: "silver", children: [
      /* @__PURE__ */ jsxs(Hull, { children: [
        /* @__PURE__ */ jsx(
          Cuboid,
          {
            color: "silver",
            size: [pinThickness, pinThickness, legsLength * 0.9],
            center: [xoff + i * pitch, 0, -legsLength / 2 * 0.9]
          }
        ),
        /* @__PURE__ */ jsx(
          Cuboid,
          {
            color: "silver",
            size: [pinThickness / 1.8, pinThickness / 1.8, legsLength],
            center: [xoff + i * pitch, 0, -legsLength / 2]
          }
        )
      ] }),
      /* @__PURE__ */ jsx(
        Cuboid,
        {
          color: "silver",
          size: [gapWidth, gapWidth, gapWidth * 0.5],
          center: [xoff + i * pitch, 0, gapWidth / 2 * 0.5]
        }
      )
    ] }, i))
  ] });
};

// lib/PushButton.tsx
var PushButton = ({
  width: width10,
  length,
  innerDiameter = 1
}) => {
  const bodyWidth = width10;
  const bodyLength10 = length;
  const bodyHeight = width10 * 0.7;
  const legWidth = innerDiameter / 2.5;
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      RoundedCuboid,
      {
        color: "#1a1a1f",
        center: [0, 0, bodyHeight / 2],
        size: [bodyLength10, bodyLength10, bodyHeight],
        roundRadius: 0.3
      }
    ),
    /* @__PURE__ */ jsx(
      RoundedCuboid,
      {
        color: "#f2f2f2",
        center: [0, 0, bodyHeight + bodyHeight * 0.1 / 2.5],
        size: [bodyLength10, bodyLength10, bodyHeight * 0.1],
        roundRadius: 0.14
      }
    ),
    /* @__PURE__ */ jsx(
      Cylinder,
      {
        color: "#1a1a1f",
        height: bodyHeight * 0.8,
        radius: bodyWidth / 3,
        center: [0, 0, bodyHeight + bodyHeight * 0.8 / 2]
      }
    ),
    /* @__PURE__ */ jsx(
      Cylinder,
      {
        color: "#1a1a1f",
        height: bodyHeight * 0.2,
        radius: innerDiameter / 2,
        center: [
          bodyLength10 / 3,
          bodyLength10 / 3,
          bodyHeight + bodyHeight * 0.1 / 2
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      Cylinder,
      {
        color: "#1a1a1f",
        height: bodyHeight * 0.2,
        radius: innerDiameter / 2,
        center: [
          -bodyLength10 / 3,
          -bodyLength10 / 3,
          bodyHeight + bodyHeight * 0.1 / 2
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      Cylinder,
      {
        color: "#1a1a1f",
        height: bodyHeight * 0.2,
        radius: innerDiameter / 2,
        center: [
          -bodyLength10 / 3,
          bodyLength10 / 3,
          bodyHeight + bodyHeight * 0.1 / 2
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      Cylinder,
      {
        color: "#1a1a1f",
        height: bodyHeight * 0.2,
        radius: innerDiameter / 2,
        center: [
          bodyLength10 / 3,
          -bodyLength10 / 3,
          bodyHeight + bodyHeight * 0.1 / 2
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      PushButtonLeg,
      {
        thickness: innerDiameter / 3,
        width: legWidth,
        horizontalLength: bodyLength10 * 0.8,
        verticalLength: bodyHeight / 2,
        position: {
          x: -bodyWidth / 2,
          y: -bodyLength10 / 2,
          z: -bodyHeight * 1.2
        }
      }
    ),
    /* @__PURE__ */ jsx(
      PushButtonLeg,
      {
        thickness: innerDiameter / 3,
        width: legWidth,
        horizontalLength: bodyLength10 * 0.8,
        verticalLength: bodyHeight / 2,
        position: {
          x: -bodyWidth / 2,
          y: bodyLength10 / 2,
          z: -bodyHeight * 1.2
        },
        rotation: Math.PI
      }
    ),
    /* @__PURE__ */ jsx(
      PushButtonLeg,
      {
        thickness: innerDiameter / 3,
        width: legWidth,
        horizontalLength: bodyLength10 * 0.8,
        verticalLength: bodyHeight / 2,
        position: { x: bodyWidth / 2, y: bodyLength10 / 2, z: -bodyHeight * 1.2 },
        rotation: Math.PI
      }
    ),
    /* @__PURE__ */ jsx(
      PushButtonLeg,
      {
        thickness: innerDiameter / 3,
        width: legWidth,
        horizontalLength: bodyLength10 * 0.8,
        verticalLength: bodyHeight / 2,
        position: {
          x: bodyWidth / 2 + innerDiameter / 3.6,
          y: -bodyLength10 / 2,
          z: -bodyHeight * 1.2
        }
      }
    )
  ] });
};
var PushButtonLeg = (props) => {
  const {
    thickness,
    width: width10,
    horizontalLength,
    verticalLength,
    rotation = 0,
    position
  } = props;
  const points = [
    [0, horizontalLength],
    [-verticalLength / 3, horizontalLength / 3],
    [-verticalLength / 5, horizontalLength / 4],
    [0, 0]
  ];
  const polygon = getExpandedStroke(points, thickness);
  return /* @__PURE__ */ jsx(Colorize, { color: "#f2f2f2", children: /* @__PURE__ */ jsx(
    Translate,
    {
      offset: {
        x: position?.x || 0,
        y: position?.y || 0,
        z: position?.z || 0
      },
      children: /* @__PURE__ */ jsx(Rotate, { rotation: [0, 55, rotation], children: /* @__PURE__ */ jsx(ExtrudeLinear, { height: width10, children: /* @__PURE__ */ jsx(Polygon, { points: polygon.map((p) => [p.y, p.x]) }) }) })
    }
  ) });
};

// lib/SOIC.tsx
var SOIC = ({
  pinCount,
  leadLength,
  leadWidth,
  pitch,
  bodyWidth
}) => {
  const sidePinCount = Math.ceil(pinCount / 2);
  const pinOffsetToCenter = (sidePinCount - 1) * pitch / 2;
  const leadThickness = 0.25;
  const bodyHeight = 1;
  const leadHeight = 0.8;
  const leadBodyOffset = leadLength * 0;
  const fullLength10 = pitch * (sidePinCount - 1) + leadWidth + 0.2;
  const bodyWidthAdjusted = bodyWidth * 0.55;
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    Array.from({ length: sidePinCount }).map((_, i) => /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        position: {
          x: -bodyWidth / 2 - leadBodyOffset,
          y: i * pitch - pinOffsetToCenter,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength: leadLength / 2,
        bodyDistance: leadLength + 0.3,
        height: leadHeight
      },
      i
    )),
    Array.from({ length: sidePinCount }).map((_, i) => /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        rotation: Math.PI,
        position: {
          x: bodyWidth / 2 + leadBodyOffset,
          y: i * pitch - pinOffsetToCenter,
          z: leadThickness / 2
        },
        width: leadWidth,
        thickness: leadThickness,
        padContactLength: leadLength / 2,
        bodyDistance: leadLength + 0.3,
        height: leadHeight
      },
      i
    )),
    /* @__PURE__ */ jsx(
      ChipBody,
      {
        center: { x: 0, y: 0, z: leadThickness / 2 },
        width: bodyWidthAdjusted,
        length: fullLength10,
        height: bodyHeight
      }
    )
  ] });
};

// lib/VSSOP.tsx
var VSSOP = ({
  pinCount,
  pitch,
  leadWidth,
  leadLength,
  bodyWidth,
  bodyLength: bodyLength10
}) => {
  const defaults = pinCount === 8 ? {
    pitch: 0.65,
    leadWidth: 0.3,
    leadLength: 1.6
  } : {
    pitch: 0.5,
    leadWidth: 0.225,
    leadLength: 1.45
  };
  const _pitch = !isNaN(parseFloat(pitch)) ? parseFloat(pitch) : defaults.pitch;
  const _leadWidth = !isNaN(parseFloat(leadWidth)) ? parseFloat(leadWidth) * 0.8 : defaults.leadWidth;
  const _leadLength = !isNaN(parseFloat(leadLength)) ? parseFloat(leadLength) : defaults.leadLength;
  const _bodyWidth = !isNaN(parseFloat(bodyWidth)) ? parseFloat(bodyWidth) * 0.8 : 2.6;
  const _bodyLength = !isNaN(parseFloat(bodyLength10)) ? parseFloat(bodyLength10) : 2 + Number(_pitch) * 1.4;
  const sidePinCount = pinCount / 2;
  const pinOffsetToCenter = (sidePinCount - 1) * _pitch / 2;
  const leadThickness = 0.15;
  const leadHeight = 0.8;
  const componentFullWidth = 4.5;
  const leadBodyDistance = (componentFullWidth - _bodyWidth) / 2;
  const padContactLength = leadBodyDistance * 0.5;
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    Array.from({ length: sidePinCount }).map((_, i) => /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        position: {
          x: -componentFullWidth / 2,
          y: pinOffsetToCenter - i * _pitch,
          z: leadThickness / 2
        },
        width: _leadWidth,
        thickness: leadThickness,
        padContactLength: padContactLength + 0.05,
        bodyDistance: leadBodyDistance + 0.05,
        height: leadHeight
      },
      `left-${i}`
    )),
    Array.from({ length: sidePinCount }).map((_, i) => /* @__PURE__ */ jsx(
      SmdChipLead,
      {
        rotation: Math.PI,
        position: {
          x: componentFullWidth / 2,
          y: pinOffsetToCenter - i * _pitch,
          z: leadThickness / 2
        },
        width: _leadWidth,
        thickness: leadThickness,
        padContactLength: padContactLength + 0.05,
        bodyDistance: leadBodyDistance + 0.05,
        height: leadHeight
      },
      `right-${i}`
    )),
    /* @__PURE__ */ jsx(
      ChipBody,
      {
        center: { x: 0, y: 0, z: leadThickness / 2 },
        width: _bodyWidth,
        length: _bodyLength,
        height: 1
      }
    )
  ] });
};

// lib/SOD523.tsx
var SOD523 = () => {
  const fullWidth = 2.15;
  const bodyLength10 = 0.8;
  const bodyHeight = 0.6;
  const padWidth = 0.6;
  const padLength = 0.5;
  const padThickness = 0.12;
  const bodyWidth = fullWidth - padLength;
  const leftPadCenterX = -bodyWidth / 2 + padLength / 2 - 0.15;
  const rightPadCenterX = bodyWidth / 2 - padLength / 2 + 0.15;
  const taperOffset = 0.2;
  const straightHeight = bodyHeight * 0.5;
  const Body = /* @__PURE__ */ jsx(Colorize, { color: "#222", children: /* @__PURE__ */ jsxs(Union, { children: [
    /* @__PURE__ */ jsx(Translate, { z: straightHeight / 2, children: /* @__PURE__ */ jsx(Cuboid, { size: [bodyWidth, bodyLength10, straightHeight] }) }),
    /* @__PURE__ */ jsxs(Hull, { children: [
      /* @__PURE__ */ jsx(Translate, { z: straightHeight, children: /* @__PURE__ */ jsx(Cuboid, { size: [bodyWidth, bodyLength10, 0.01] }) }),
      /* @__PURE__ */ jsx(Translate, { z: bodyHeight, children: /* @__PURE__ */ jsx(
        Cuboid,
        {
          size: [bodyWidth - taperOffset, bodyLength10 - taperOffset, 0.01]
        }
      ) })
    ] })
  ] }) });
  return /* @__PURE__ */ jsxs(Fragment2, { children: [
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        color: "#ccc",
        size: [padLength, padWidth, padThickness],
        center: [leftPadCenterX, 0, padThickness / 2]
      }
    ),
    /* @__PURE__ */ jsx(
      Cuboid,
      {
        color: "#ccc",
        size: [padLength, padWidth, padThickness],
        center: [rightPadCenterX, 0, padThickness / 2]
      }
    ),
    Body
  ] });
};

// lib/Footprinter3d.tsx
var Footprinter3d = ({ footprint }) => {
  const fpJson = fp.string(footprint).json();
  switch (fpJson.fn) {
    case "dip":
      return /* @__PURE__ */ jsx(Dip, { numPins: fpJson.num_pins, pitch: fpJson.p, bodyWidth: fpJson.w });
    case "tssop":
      return /* @__PURE__ */ jsx(
        Tssop,
        {
          pinCount: fpJson.num_pins,
          leadLength: fpJson.pl,
          leadWidth: fpJson.pw,
          pitch: fpJson.p,
          bodyWidth: fpJson.w
        }
      );
    case "vssop":
      return /* @__PURE__ */ jsx(
        VSSOP,
        {
          pinCount: fpJson.num_pins,
          leadLength: fpJson.pl,
          leadWidth: fpJson.pw,
          pitch: fpJson.p,
          bodyWidth: fpJson.w,
          bodyLength: fpJson.h
        }
      );
    case "qfp":
      return /* @__PURE__ */ jsx(
        QFP,
        {
          pinCount: fpJson.num_pins,
          pitch: fpJson.p,
          leadWidth: fpJson.pw,
          padContactLength: fpJson.pl,
          bodyWidth: fpJson.w
        }
      );
    case "qfn":
      return /* @__PURE__ */ jsx(
        qfn_default,
        {
          num_pins: fpJson.num_pins,
          bodyWidth: fpJson.w,
          bodyLength: fpJson.h,
          pitch: fpJson.p,
          padLength: fpJson.pl,
          padWidth: fpJson.pw,
          thermalPadSize: {
            width: fpJson.thermalpad.x,
            length: fpJson.thermalpad.y
          }
        }
      );
    case "pinrow":
      if (fpJson.male)
        return /* @__PURE__ */ jsx(PinRow, { numberOfPins: fpJson.num_pins, pitch: fpJson.p });
      if (fpJson.female)
        return /* @__PURE__ */ jsx(FemaleHeader, { numberOfPins: fpJson.num_pins, pitch: fpJson.p });
    case "cap": {
      switch (fpJson.imperial) {
        case "0402":
          return /* @__PURE__ */ jsx(A0402, { color: "#856c4d" });
        case "0603":
          return /* @__PURE__ */ jsx(A0603, { color: "#856c4d" });
        case "0805":
          return /* @__PURE__ */ jsx(A0805, { color: "#856c4d" });
        case "0201":
          return /* @__PURE__ */ jsx(A0201, { color: "#856c4d" });
        case "01005":
          return /* @__PURE__ */ jsx(A01005, { color: "#856c4d" });
        case "1206":
          return /* @__PURE__ */ jsx(A1206, { color: "#856c4d" });
        case "1210":
          return /* @__PURE__ */ jsx(A1210, { color: "#856c4d" });
        case "2010":
          return /* @__PURE__ */ jsx(A2010, { color: "#856c4d" });
        case "2512":
          return /* @__PURE__ */ jsx(A2512, { color: "#856c4d" });
      }
    }
    case "sot235":
      return /* @__PURE__ */ jsx(SOT_235_default, {});
    case "pushbutton":
      return /* @__PURE__ */ jsx(
        PushButton,
        {
          width: fpJson.w,
          length: fpJson.h,
          innerDiameter: fpJson.id
        }
      );
    case "soic":
      return /* @__PURE__ */ jsx(
        SOIC,
        {
          pinCount: fpJson.num_pins,
          leadLength: fpJson.pl,
          leadWidth: fpJson.pw,
          pitch: fpJson.p,
          bodyWidth: fpJson.w
        }
      );
    case "sod523":
      return /* @__PURE__ */ jsx(SOD523, {});
  }
  const colorMatch = footprint.match(/_color\(([^)]+)\)/);
  const color = colorMatch ? colorMatch[1] : void 0;
  switch (fpJson.imperial) {
    case "0402":
      return /* @__PURE__ */ jsx(A0402, { color });
    case "0603":
      return /* @__PURE__ */ jsx(A0603, { color });
    case "0805":
      return /* @__PURE__ */ jsx(A0805, { color });
    case "0201":
      return /* @__PURE__ */ jsx(A0201, { color });
    case "01005":
      return /* @__PURE__ */ jsx(A01005, { color });
    case "1206":
      return /* @__PURE__ */ jsx(A1206, { color });
    case "1210":
      return /* @__PURE__ */ jsx(A1210, { color });
    case "2010":
      return /* @__PURE__ */ jsx(A2010, { color });
    case "2512":
      return /* @__PURE__ */ jsx(A2512, { color });
  }
  return null;
};

// lib/vanilla/render.ts
var isVNode = (n) => n && typeof n === "object" && "type" in n;
var degToRad = (v) => {
  if (typeof v === "number") return v;
  if (typeof v === "string") {
    const m = /^(-?\d+(?:\.\d+)?)\s*deg$/i.exec(v);
    if (m) return parseFloat(m[1]) * Math.PI / 180;
    const n = Number(v);
    if (!Number.isNaN(n)) return n;
  }
  return 0;
};
var toVec3 = (v) => {
  if (Array.isArray(v))
    return [Number(v[0]) || 0, Number(v[1]) || 0, Number(v[2]) || 0];
  if (typeof v === "object" && v)
    return [Number(v.x) || 0, Number(v.y) || 0, Number(v.z) || 0];
  return [0, 0, 0];
};
function renderNode(node, colorCtx, renderCtx) {
  const {
    jscad: { primitives, booleans, hulls, geometries, extrusions, transforms }
  } = renderCtx;
  if (node == null || node === false) return [];
  if (Array.isArray(node))
    return node.flatMap((n) => renderNode(n, colorCtx, renderCtx));
  if (!isVNode(node)) return [];
  const { type, props, children } = node;
  if (type === Fragment) {
    return (children ?? []).flatMap((c) => renderNode(c, colorCtx, renderCtx));
  }
  if (type === Colorize) {
    const newColor = props?.color;
    return (children ?? []).flatMap(
      (c) => renderNode(c, newColor ?? colorCtx, renderCtx)
    );
  }
  if (type === Translate) {
    const off = toVec3(
      props?.offset ?? { x: props?.x, y: props?.y, z: props?.z }
    );
    const geoms = (children ?? []).flatMap(
      (c) => renderNode(c, colorCtx, renderCtx)
    );
    return geoms.map(({ geom, color }) => ({
      geom: transforms.translate(off, geom),
      color: color ?? colorCtx
    }));
  }
  if (type === Rotate) {
    const rot = Array.isArray(props?.rotation) ? [
      degToRad(props.rotation[0]),
      degToRad(props.rotation[1]),
      degToRad(props.rotation[2])
    ] : [
      degToRad(props?.x ?? 0),
      degToRad(props?.y ?? 0),
      degToRad(props?.z ?? 0)
    ];
    const geoms = (children ?? []).flatMap(
      (c) => renderNode(c, colorCtx, renderCtx)
    );
    return geoms.map(({ geom, color }) => ({
      geom: transforms.rotateZ(
        rot[2],
        transforms.rotateY(rot[1], transforms.rotateX(rot[0], geom))
      ),
      color
    }));
  }
  if (type === Union || type === Subtract || type === Hull) {
    const geoms = (children ?? []).flatMap((c) => renderNode(c, colorCtx, renderCtx)).map((g) => g.geom);
    if (geoms.length === 0) return [];
    let geom;
    if (type === Union) geom = booleans.union(geoms);
    else if (type === Subtract)
      geom = booleans.subtract(geoms[0], geoms.slice(1));
    else geom = hulls.hull(geoms);
    return [{ geom }];
  }
  if (type === Polygon) {
    const points = props?.points ?? [];
    const g2 = geometries.geom2.fromPoints(points);
    return [{ geom: g2, color: colorCtx ?? props?.color }];
  }
  if (type === ExtrudeLinear) {
    const geoms2 = (children ?? []).flatMap((c) => renderNode(c, colorCtx, renderCtx)).map((g) => g.geom);
    if (geoms2.length === 0) return [];
    const base2 = geoms2.length > 1 ? booleans.union(geoms2) : geoms2[0];
    const height10 = props?.height ?? props?.h ?? 1;
    let g3 = extrusions.extrudeLinear({ height: height10 }, base2);
    if (g3.polygons) {
      for (const poly of g3.polygons) {
        if (!poly.plane || !poly.vertices || poly.vertices.length < 3) continue;
        poly.vertices.reverse();
      }
    }
    return [{ geom: g3, color: colorCtx ?? props?.color }];
  }
  if (type === Cuboid || type === Cube || type === Cylinder || type === Sphere || type === RoundedCuboid) {
    let g;
    if (type === Cuboid) {
      const size = props?.size ?? [1, 1, 1];
      const offset = props?.offset;
      const center = props?.center ?? (offset ? [offset[0], offset[1], offset[2]] : [0, 0, 0]);
      g = primitives.cuboid({ size, center });
    } else if (type === Cube) {
      const size = props?.size ?? 1;
      const offset = props?.offset;
      const center = props?.center ?? (offset ? [offset[0], offset[1], offset[2]] : [0, 0, 0]);
      g = primitives.cube({ size, center });
    } else if (type === Cylinder) {
      const height10 = props?.height ?? 1;
      const radius = props?.radius ?? 1;
      const center = props?.center ?? [0, 0, 0];
      g = primitives.cylinder({ height: height10, radius, center });
    } else if (type === Sphere) {
      const radius = props?.radius ?? 1;
      const center = props?.center ?? [0, 0, 0];
      g = primitives.sphere({ radius, center });
    } else {
      const size = props?.size ?? [1, 1, 1];
      const roundRadius = props?.roundRadius ?? 0.1;
      const center = props?.center ?? [0, 0, 0];
      g = primitives.roundedCuboid({ size, roundRadius, center });
    }
    return [{ geom: g, color: colorCtx ?? props?.color }];
  }
  if (typeof type === "function") {
    const out = type(props ?? {});
    return renderNode(out, colorCtx, renderCtx);
  }
  return (children ?? []).flatMap((c) => renderNode(c, colorCtx, renderCtx));
}
function render(root, jscad) {
  const geometries = renderNode(root, void 0, { jscad });
  return { geometries };
}

// lib/vanilla/convertCSGToThreeGeom.ts
import {
  BufferAttribute,
  BufferGeometry,
  Matrix4
} from "three";
function convertCSGToThreeGeom(csg) {
  if (csg.polygons) {
    const vertices = [];
    const indices = [];
    const colors = [];
    let idx = 0;
    for (const polygon of csg.polygons) {
      for (const vertex of polygon.vertices) {
        vertex.index = idx;
        vertices.push(vertex[0], vertex[1], vertex[2]);
        if (csg.color && csg.color.length >= 3) {
          colors.push(csg.color[0], csg.color[1], csg.color[2]);
        } else {
          colors.push(1, 1, 1);
        }
        idx++;
      }
      const first = polygon.vertices[0].index;
      for (let i = 2; i < polygon.vertices.length; i++) {
        const second = polygon.vertices[i - 1].index;
        const third = polygon.vertices[i].index;
        indices.push(first, second, third);
      }
    }
    const geo = new BufferGeometry();
    geo.setAttribute(
      "position",
      new BufferAttribute(new Float32Array(vertices), 3)
    );
    geo.setIndex(indices);
    if (colors.length > 0) {
      geo.setAttribute(
        "color",
        new BufferAttribute(new Float32Array(colors), 3)
      );
    }
    if (csg.transforms) {
      const transforms = new Matrix4();
      transforms.fromArray(csg.transforms);
      geo.applyMatrix4(transforms);
    }
    geo.computeVertexNormals();
    return geo;
  }
  if (csg.sides) {
    const vertices = [];
    const colors = [];
    for (const side of csg.sides) {
      vertices.push(side[0][0], side[0][1], 0);
      if (csg.color && csg.color.length >= 3) {
        colors.push(csg.color[0], csg.color[1], csg.color[2]);
      } else {
        colors.push(1, 1, 1);
      }
    }
    const geo = new BufferGeometry();
    geo.setAttribute(
      "position",
      new BufferAttribute(new Float32Array(vertices), 3)
    );
    if (colors.length > 0) {
      geo.setAttribute(
        "color",
        new BufferAttribute(new Float32Array(colors), 3)
      );
    }
    if (csg.transforms) {
      const transforms = new Matrix4();
      transforms.fromArray(csg.transforms);
      geo.applyMatrix4(transforms);
    }
    return geo;
  }
  console.error("Invalid CSG object: neither polygons nor sides found");
  return new BufferGeometry();
}

// lib/vanilla/index.ts
function getJscadModelForFootprint(footprint, jscad) {
  const vnode = h(Footprinter3d, { footprint });
  return render(vnode, jscad);
}
function createJSCADRenderer(jscad) {
  function createJSCADRoot(container) {
    return {
      render(element) {
        const { geometries } = render(element, jscad);
        container.splice(0, container.length, ...geometries);
      }
    };
  }
  return { createJSCADRoot };
}
export {
  Fragment,
  convertCSGToThreeGeom,
  createJSCADRenderer,
  getJscadModelForFootprint,
  h
};
//# sourceMappingURL=vanilla.js.map